<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Reex</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Reex">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Reex">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Reex" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Reex</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-我的项目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/13/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2022-05-13T12:30:20.000Z" itemprop="datePublished">2022-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/13/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/">我的项目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="开发社区首页——分页查询帖子"><a href="#开发社区首页——分页查询帖子" class="headerlink" title="开发社区首页——分页查询帖子"></a>开发社区首页——分页查询帖子</h1><h2 id="1-创建实体类对象DiscussPost"><a href="#1-创建实体类对象DiscussPost" class="headerlink" title="1.创建实体类对象DiscussPost"></a>1.创建实体类对象DiscussPost</h2><p>先创建一个DiscussPost的实体类对象，与之对应的数据库数据是discuss_post</p>
<p>分别把id, userId, title, content, type, status, createTime, commentCount, score变量及其get, set方法, toString()方法定义出来。</p>
<h2 id="2-开发DAO层——DiscussPostMapper"><a href="#2-开发DAO层——DiscussPostMapper" class="headerlink" title="2.开发DAO层——DiscussPostMapper"></a>2.开发DAO层——DiscussPostMapper</h2><p>首先定义一个<strong>查询帖子信息的方法</strong>selectDiscussPosts，形参包括userId, offset, limit，其中userId在后面个人主页的帖子才需要，offset是每一页起始行的行号，limit是每一页最多显示多少数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;DiscussPost&gt; <span class="title function_">selectDiscussPosts</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> <span class="type">int</span> userId, <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit)</span>;</span><br></pre></td></tr></table></figure>

<p>为了方便显示页码，还要定义一个方法selectDiscussPostRows来查询一共多少行帖子，只有一个形参userId，同理，也是在后面个人主页帖子的时候才需要这个userId</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">selectDiscussPostRows</span><span class="params">(<span class="type">int</span> userId)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-配置文件——discusspost-mapper-xml"><a href="#3-配置文件——discusspost-mapper-xml" class="headerlink" title="3.配置文件——discusspost-mapper.xml"></a>3.配置文件——discusspost-mapper.xml</h2><p>在mapper配置文件里定义一个discusspost-mapper.xml，在&lt;mapper 标签里的namespace参数写上配置文件<strong>为具体哪个接口服务</strong>的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.DiscussPostMapper&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体sql语句如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span></span><br><span class="line">       id, user_id, title, content, type, status, create_time, comment_count, score</span><br><span class="line">   <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDiscussPosts&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;DiscussPost&quot;</span>&gt;</span></span><br><span class="line">       select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">       from discuss_post</span><br><span class="line">       where status != 2</span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId!=0&quot;</span>&gt;</span></span><br><span class="line">           and user_id = #&#123;userId&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       order by type desc, create_time desc</span><br><span class="line">       limit #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDiscussPostRows&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">       select count(id)</span><br><span class="line">       from discuss_post</span><br><span class="line">       where status != 2</span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId!=0&quot;</span>&gt;</span></span><br><span class="line">           and user_id = #&#123;userId&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-开发Service层——DiscussPostService和UserService"><a href="#4-开发Service层——DiscussPostService和UserService" class="headerlink" title="4.开发Service层——DiscussPostService和UserService"></a>4.开发Service层——DiscussPostService和UserService</h2><p>DiscussPostService很简单，直接调用DAO层的DiscussPostMapper的两个方法即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscussPostService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostMapper discussPostMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;DiscussPost&gt; <span class="title function_">findDiscussPosts</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.selectDiscussPosts(userId, offset, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDiscussPostRows</span><span class="params">(<span class="type">int</span> userId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.selectDiscussPostRows(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserService是用来开发<strong>根据用户id来查询用户</strong>的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;<span class="comment">//用于管理User类方法的dao层Mapper组件</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-开发Controller层——HomeController"><a href="#5-开发Controller层——HomeController" class="headerlink" title="5.开发Controller层——HomeController"></a>5.开发Controller层——HomeController</h2><p>因为这一层要用到SpringMVC，方法需要用@RequestMapping()编写访问路径，因为访问的是首页，所以路径是**&#x2F;index<strong>，请求方式因为是</strong>查询<strong>，所以是RequestMethod.GET，</strong>返回的是相应的网页，所以不要加ResponseBody**，直接返回String，即视图的名字。</p>
<p>形参写入Model model，因为我们要通过model携带数据传给模板，最终返回的也是模板的路径，即Templates下的index.html</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> <span class="keyword">implements</span> <span class="title class_">CommunityConstant</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/index&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getIndexPage</span><span class="params">(Model model, Page page)</span>&#123;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//方法调用前，SpringMVC会自动实例化Model和Page，并将Page注入Model，所以在thymeleaf中可以直接访问Page对象的数据</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取帖子的总行数</span></span><br><span class="line">        page.setRows(discussPostService.findDiscussPostRows(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//页面index就可以复用这个路径了</span></span><br><span class="line">        page.setPath(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//页码offset和limit就可以根据上面的数据和Page类来获取了</span></span><br><span class="line">        List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(<span class="number">0</span>, page.getOffset(), page.getLimit());<span class="comment">//list只有id和userId，没有User的具体信息，所以我们通过定义一个map来存放每个帖子的具体信息和User对象</span></span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; discussPosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(list != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(DiscussPost post : list)&#123;<span class="comment">//要一个个遍历帖子内容</span></span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                map.put(<span class="string">&quot;post&quot;</span>, post);<span class="comment">//先存放帖子信息</span></span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(post.getUserId());</span><br><span class="line">                map.put(<span class="string">&quot;user&quot;</span>, user);<span class="comment">//再存放User信息</span></span><br><span class="line">                discussPosts.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//DispatcherServlet会自动将page装到model里面，所以不用单独添加page了</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;discussPosts&quot;</span>, discussPosts);<span class="comment">//要把数据传给model</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index&quot;</span>;<span class="comment">//返回模板路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-创建实体类Page封装分页相关操作"><a href="#5-1-创建实体类Page封装分页相关操作" class="headerlink" title="5.1 创建实体类Page封装分页相关操作"></a>5.1 创建实体类Page封装分页相关操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">    <span class="comment">//当前页码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//显示上限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//数据总数(用于计算总页数)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rows;</span><br><span class="line">    <span class="comment">//查询路径(用于复用分页链接)</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCurrent</span><span class="params">()</span> &#123;<span class="keyword">return</span> current;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurrent</span><span class="params">(<span class="type">int</span> current)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(current &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.current = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLimit</span><span class="params">()</span> &#123;<span class="keyword">return</span> limit;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLimit</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(limit &gt;= <span class="number">1</span> &amp;&amp; limit &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRows</span><span class="params">()</span> &#123;<span class="keyword">return</span> rows;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRows</span><span class="params">(<span class="type">int</span> rows)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(rows &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.rows = rows;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span> &#123;<span class="keyword">return</span> path;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPath</span><span class="params">(String path)</span> &#123;<span class="built_in">this</span>.path = path;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前页的起始行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOffset</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//current * limit - limit</span></span><br><span class="line">        <span class="keyword">return</span> (current - <span class="number">1</span>) * limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取总页数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTotal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//rows / limit [+1]</span></span><br><span class="line">        <span class="keyword">if</span>(rows % limit == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rows / limit;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rows / limit + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取起始页码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFrom</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> current - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> from &lt; <span class="number">1</span> ? <span class="number">1</span> : from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取结束页码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> current + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> getTotal();</span><br><span class="line">        <span class="keyword">return</span> to &gt; total ? total : to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要<strong>查询帖子就要访问数据库</strong>，与数据库打交道，那就是数据访问层干的活，<strong>业务层其实就是实现查询数据库的操作</strong>，所以直接调用数据访问层的查询方法，所以重点是DAO层写出查询方法，mapper.xml要写几个sql语句查询数据库的帖子详情。查询逻辑写好之后，DAO层直接调用mapper.xml的逻辑，然后业务层调DAO层，这样就来到了控制层。控制层其实就是调用业务层，<strong>把从数据库中查询到的帖子数据和用户数据传给model</strong>。因为帖子需要分页，所以我们最好专门写个实体类来实现分页功能，分页功能主要让起始行和每页帖子数量上限是一个变量，否则每次数据库变动了还得重新计算并填入到控制层方法的形参中。</p>
<h1 id="2-1开发邮件发送功能"><a href="#2-1开发邮件发送功能" class="headerlink" title="2.1开发邮件发送功能"></a>2.1开发邮件发送功能</h1><h2 id="1-设置邮箱，导入SpringBoot的Mail包"><a href="#1-设置邮箱，导入SpringBoot的Mail包" class="headerlink" title="1.设置邮箱，导入SpringBoot的Mail包"></a>1.设置邮箱，导入SpringBoot的Mail包</h2><p>新浪邮箱的设置里POP3&#x2F;SMTP功能开启，并启用授权码。</p>
<p>通过Maven导入spring-boot-starter-mail的包</p>
<h2 id="2-书写配置文件参数"><a href="#2-书写配置文件参数" class="headerlink" title="2.书写配置文件参数"></a>2.书写配置文件参数</h2><p>然后配置邮箱参数，在resources-application.properties中配置参数，具体参数如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MailProperties</span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.sina.com</span></span><br><span class="line"><span class="comment">#spring.mail.port=465</span></span><br><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">ryn2020@sina.com</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=<span class="string">21ad95cfc6c4b05e    #这里是新浪邮箱的授权码</span></span><br><span class="line"><span class="comment">#spring.mail.protocol=smtps</span></span><br><span class="line"><span class="comment">#spring.mail.properties.mail.smtp.ssl.enable=true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtl.auth</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtl.starttls.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtl.starttls.required</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h2 id="3-创建工具类MailClient"><a href="#3-创建工具类MailClient" class="headerlink" title="3.创建工具类MailClient"></a>3.创建工具类MailClient</h2><p>然后去util包下创建一个工具类MailClient，该工具类将发邮件的任务委托给新浪邮箱去完成，相当于客户端</p>
<p>该类我们要加上@Component注解，成为一个Bean。</p>
<p>先声明一个日志，后面操作要记录日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MailClient.class);</span><br></pre></td></tr></table></figure>

<p>然后<strong>注入Spring的核心组件</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JavaMailSender mailSender;</span><br></pre></td></tr></table></figure>

<p>因为每次系统邮箱，也就是发件人都是一样的，所以我们<strong>将发件人地址注入Spring中</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span><span class="comment">//这里是配置文件中参数</span></span><br><span class="line"><span class="keyword">private</span> String from;</span><br></pre></td></tr></table></figure>

<p>接下来定义发送的方法，我们只需要收件人，邮件主题和内容即可，所以形参只有它们三个。</p>
<p>发邮件的关键就是<strong>把组件JavaMailSender中的MimeMessage邮件主体构建出来</strong>，用谁构建呢？帮助类MimeMessageHelper</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMail</span><span class="params">(String to, String subject, String content)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用核心组件JavaMailSender构建邮件主体message</span></span><br><span class="line">            <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">            <span class="comment">//用帮助类构建message</span></span><br><span class="line">            <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message);</span><br><span class="line">            <span class="comment">//向帮助类传入发件人，收件人，主体和html格式的内容</span></span><br><span class="line">            helper.setFrom(from);</span><br><span class="line">            helper.setTo(to);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            helper.setText(content, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//再回到核心组件JavaMailSender执行Send方法发送邮件</span></span><br><span class="line">            mailSender.send(helper.getMimeMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;发送邮件失败：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-7开发注册功能"><a href="#2-7开发注册功能" class="headerlink" title="2.7开发注册功能"></a>2.7开发注册功能</h1><h2 id="1-开发Controller层——访问注册页面"><a href="#1-开发Controller层——访问注册页面" class="headerlink" title="1.开发Controller层——访问注册页面"></a>1.开发Controller层——访问注册页面</h2><p>直接开发控制层，设置一个跳转页面。跳转到site下的register</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518210741410.png" alt="image-20220518210741410"></p>
<h2 id="2-开发随机字符生成和加密方法——CommunityUtil工具类"><a href="#2-开发随机字符生成和加密方法——CommunityUtil工具类" class="headerlink" title="2.开发随机字符生成和加密方法——CommunityUtil工具类"></a>2.开发随机字符生成和加密方法——CommunityUtil工具类</h2><p>导入这个包，主要目的是<strong>判断一些数据、字符串、集合空值的</strong>情况，后面会用到。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518211922078.png" alt="image-20220518211922078"></p>
<p>接下来去配置文件把域名配置好，其实现在就是<strong>本机地址</strong>，因为<strong>发邮件</strong>要写上目标地址要作为链接地址</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518212611807.png" alt="image-20220518212611807"></p>
<p>因为注册要生成激活码，所以我们最好定义一个<strong>专门的方法用来生成随机字符串</strong>。而且将来上传头像，上传文件等，也要给这些资源生成随机名字，也需要这个工具。UUID.randomUUID就是<strong>Java自带的生成随机字符的方法</strong>，不过可能有“-”，所以要用空格替换。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518213026318.png" alt="image-20220518213026318"></p>
<p>另外注册的时候上传的<strong>密码是明文的，我们需要MD5加密</strong>。</p>
<p>为了防止一些<strong>简单字符串</strong>每次加密后的字符都一样，所以我们也可以看到数据库表中有盐salt，也就是<strong>每次给密码加盐</strong>，也就是<strong>加随机字符串</strong>，这样就避免密码的盗取。</p>
<p>加密是<strong>Spring自带的工具类DigestUtils</strong>的方法，加密前，我们用<strong>前面导入的lang3包对字符串先进性判空操作</strong>，非空字符串我们再加密（要求16进制的byte类型，所以要转一下）。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518213714266.png" alt="image-20220518213714266"></p>
<h2 id="3-开发Service层——UserService实现注册业务逻辑"><a href="#3-开发Service层——UserService实现注册业务逻辑" class="headerlink" title="3.开发Service层——UserService实现注册业务逻辑"></a>3.开发Service层——UserService实现注册业务逻辑</h2><p>因为注册要发邮件，所以把邮件注入进来，也注入模板引擎，后面要用。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518214006254.png" alt="image-20220518214006254"></p>
<p>然后还需要用到<strong>域名和项目名</strong>，也注入进来</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518214038726.png" alt="image-20220518214038726"></p>
<p>开始写注册业务方法，因为返回值要<strong>包括好多“报错信息”，所以我们用Map</strong>，注册需要用户传入账号，密码和邮箱，所以我们传入一个User。</p>
<p>首先对形参user进行空值判断，如果<strong>是空则报异常（注意不是报错</strong>）。然后是user的具体信息，如果哪个空了，就把哪个错误记录在map里面，返回给用户看。</p>
<p>如果都不空，还要验证邮箱和用户名是不是数据库里面已经有了，所以还要<strong>有验证操作</strong>。</p>
<p>然后才开始注册用户：</p>
<p>1）先<strong>设置盐</strong>，用随机生成字符串的方法</p>
<p>2）给密码<strong>加盐</strong></p>
<p>3）设置<strong>用户类型，激活状态</strong>，然后<strong>设置激活码</strong>（还是随机生成）</p>
<p>4）给用户<strong>设置默认头像</strong>，用牛客网默认的1000个头像中随机一个</p>
<p>5）最后给用户设置一个<strong>账号创建时间</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">register</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空值处理</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不能为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(user.getUsername()))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;账号不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(user.getPassword()))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;passwordMsg&quot;</span>, <span class="string">&quot;密码不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(user.getEmail()))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;emailMsg&quot;</span>, <span class="string">&quot;邮箱不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;<span class="comment">//这个地方第一次忘记写了，导致邮箱重复仍旧注册账户，注册后才提示邮箱重复</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证账号</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> userMapper.selectByName(user.getUsername());</span><br><span class="line">    <span class="keyword">if</span>(u != <span class="literal">null</span>)&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;该账号已存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证邮箱</span></span><br><span class="line">    u = userMapper.selectByEmail(user.getEmail());</span><br><span class="line">    <span class="keyword">if</span>(u != <span class="literal">null</span>)&#123;</span><br><span class="line">        map.put(<span class="string">&quot;emailMsg&quot;</span>, <span class="string">&quot;该邮箱已被注册&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册用户</span></span><br><span class="line">    user.setSalt(CommunityUtil.generateUUID().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">    user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt()));</span><br><span class="line">    user.setType(<span class="number">0</span>);</span><br><span class="line">    user.setStatus(<span class="number">0</span>);</span><br><span class="line">    user.setActivationCode(CommunityUtil.generateUUID());</span><br><span class="line">    user.setHeaderUrl(String.format(<span class="string">&quot;http://images.nowcoder.com/head/%dt.png&quot;</span>, <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>)));</span><br><span class="line">    user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">    userMapper.insertUser(user);<span class="comment">//这里因为我们配置文件要求mybatis自动生成id，所以不需要我们显示为id赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//激活邮件</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();<span class="comment">//这里的Context类属于org.thymeleaf.context的Context</span></span><br><span class="line">    context.setVariable(<span class="string">&quot;email&quot;</span>, user.getEmail());</span><br><span class="line">    <span class="comment">// http://localhost:8080/community/activation/101/code</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> domain + contextPath + <span class="string">&quot;/activation/&quot;</span> + user.getId() + <span class="string">&quot;/&quot;</span> + user.getActivationCode();</span><br><span class="line">    context.setVariable(<span class="string">&quot;url&quot;</span>, url);</span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> templateEngine.process(<span class="string">&quot;/mail/activation&quot;</span>, context);</span><br><span class="line">    mailClient.sendMail(user.getEmail(), <span class="string">&quot;激活账号&quot;</span>, content);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-开发Controller层——LoginController处理注册请求"><a href="#4-开发Controller层——LoginController处理注册请求" class="headerlink" title="4.开发Controller层——LoginController处理注册请求"></a>4.开发Controller层——LoginController处理注册请求</h2><p>先把前面开发的UserService业务层注入进来</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518221058302.png" alt="image-20220518221058302"></p>
<p>定义一个方法<strong>处理注册请求</strong>，浏览器要向服务器提交数据，肯定是POST请求</p>
<p>其实就是用业务层的map，如果<strong>map为空我们就可以发激活码</strong>了，表明成功，跳转到成功页面，然后过8秒跳到首页；如果map不为空，说明验证失败，就重新跳转到注册页面，并<strong>通过前端提示后端map传来的错误信息</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/register&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(Model model,User user)</span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = userService.register(user);</span><br><span class="line">    <span class="keyword">if</span>(map == <span class="literal">null</span> || map.isEmpty())&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;注册成功，我们已经向您的邮箱发送了一封激活邮件，请尽快激活！&quot;</span>);</span><br><span class="line">        <span class="comment">//倒计时之后要跳转到首页</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;target&quot;</span>, <span class="string">&quot;/index&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/operate-result&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;usernameMsg&quot;</span>, map.get(<span class="string">&quot;usernameMsg&quot;</span>));</span><br><span class="line">        model.addAttribute(<span class="string">&quot;passwordMsg&quot;</span>, map.get(<span class="string">&quot;passwordMsg&quot;</span>));</span><br><span class="line">        model.addAttribute(<span class="string">&quot;emailMsg&quot;</span>, map.get(<span class="string">&quot;emailMsg&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/register&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-定义常量接口——CommunityConstant"><a href="#5-定义常量接口——CommunityConstant" class="headerlink" title="5.定义常量接口——CommunityConstant"></a>5.定义常量接口——CommunityConstant</h2><p>该接口专门定义一些常量，后面哪个类需要用到这些常量直接实现这些接口即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommunityConstant</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 激活成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ACTIVATION_SUCCESS</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重复激活</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ACTIVATION_REPEAT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 激活失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ACTIVATION_FAILURE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-开发Service层——还是UserService处理激活账号业务"><a href="#6-开发Service层——还是UserService处理激活账号业务" class="headerlink" title="6.开发Service层——还是UserService处理激活账号业务"></a>6.开发Service层——还是UserService处理激活账号业务</h2><p>一共有三种结果：激活成功，重复激活，激活失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">activation</span><span class="params">(<span class="type">int</span> userId, String code)</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(userId);</span><br><span class="line">    <span class="keyword">if</span>(user.getStatus() == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ACTIVATION_REPEAT;<span class="comment">//如果用户状态已经为1，说明当前是重复激活</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(user.getActivationCode().equals(code))&#123;</span><br><span class="line">        userMapper.updateStatus(userId, <span class="number">1</span>);<span class="comment">//如果用户状态不为1，而且当前激活码满足条件，就把状态设为1</span></span><br><span class="line">        <span class="keyword">return</span> ACTIVATION_SUCCESS;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ACTIVATION_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-开发激活控制层Controller——还是LoginController"><a href="#7-开发激活控制层Controller——还是LoginController" class="headerlink" title="7.开发激活控制层Controller——还是LoginController"></a>7.开发激活控制层Controller——还是LoginController</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://localhost:8080/community/activation/101/code</span></span><br><span class="line">  <span class="meta">@RequestMapping(path = &quot;/activation/&#123;userId&#125;/&#123;code&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">activation</span><span class="params">(Model model, <span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="type">int</span> userId, <span class="meta">@PathVariable(&quot;code&quot;)</span> String code)</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userService.activation(userId, code);</span><br><span class="line">      <span class="comment">//激活成功了就返回登录页面</span></span><br><span class="line">      <span class="keyword">if</span>(result == ACTIVATION_SUCCESS)&#123;</span><br><span class="line">          model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;激活成功，您的账号已经可以正常使用了！&quot;</span>);</span><br><span class="line">          model.addAttribute(<span class="string">&quot;target&quot;</span>, <span class="string">&quot;/login&quot;</span>);</span><br><span class="line">      <span class="comment">//重复激活或失败了都返回主页</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result == ACTIVATION_REPEAT)&#123;</span><br><span class="line">          model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;无效操作，该账号已经激活过了！&quot;</span>);</span><br><span class="line">          model.addAttribute(<span class="string">&quot;target&quot;</span>, <span class="string">&quot;/index&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;激活失败，您提供的激活码不正确！&quot;</span>);</span><br><span class="line">          model.addAttribute(<span class="string">&quot;target&quot;</span>, <span class="string">&quot;/index&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;/site/operate-result&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>因为激活方法中返回登陆页面，我们还没写登陆页面的方法，所以下面写getLogin方法</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519161309172.png" alt="image-20220519161309172"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>注册功能的实现肯定底层逻辑是先验证当前的用户名，密码和邮箱<strong>是否合法</strong>（包括空值和是否在库的情况）。通过了这些合法性验证，我们就可以<strong>给用户的信息存储到数据库</strong>中，但是存储过程中，我们需要<strong>给用户的密码加密</strong>，否则很容易被盗。所以我们需要写个工具专门给字符串进行加密。但是加密操作如md5对简单字符串加密是对称加密，所以我们还需要在这些<strong>密码的基础上加点salt</strong>，这些salt我们用随机字符串来表示。所以还需要写个生成随机字符串的方法，我们<strong>用lang3包下的工具类</strong>对这个字符串进行<strong>判空</strong>操作。注册完成之后，就可以通过系统邮箱发邮件和激活码了，激活码我们也用随机字符串方法生成。OK，注册业务逻辑写完（伴随工具类的开发）。</p>
<p>注册业务逻辑写完了，控制层就可以调用该方法了，业务中报的错误我们都传给model，由<strong>model传给前端</strong>，然后<strong>跳转到注册页面并报错</strong>；如果没错，我们就<strong>跳到激活页面</strong>，倒计时之后<strong>转到首页</strong>。</p>
<p>激活完了有三种情况：成功，失败和重复激活。我们把这仨情况写到常量接口中，<strong>后面业务层和控制层要复用</strong>。然后写业务逻辑，说白了就是三种情况我们分别要干什么，<strong>后面控制层收到才可以进一步操作</strong>。处理完了就可以写控制层，根据激活业务<strong>返回的激活状态</strong>，将<strong>激活信息传给model</strong>，并<strong>确定每种情况要返回的页面</strong>。</p>
<h1 id="2-17-生成验证码"><a href="#2-17-生成验证码" class="headerlink" title="2.17 生成验证码"></a>2.17 生成验证码</h1><h2 id="1-导入Kaptcha包"><a href="#1-导入Kaptcha包" class="headerlink" title="1.导入Kaptcha包"></a>1.导入Kaptcha包</h2><p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519185233228.png" alt="image-20220519185233228"></p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519185721410.png" alt="image-20220519185721410"></p>
<h2 id="2-将kaptcha注入Spring容器——KaptchaConfig"><a href="#2-将kaptcha注入Spring容器——KaptchaConfig" class="headerlink" title="2.将kaptcha注入Spring容器——KaptchaConfig"></a>2.将kaptcha注入Spring容器——KaptchaConfig</h2><p>在config包下写配置类KaptchaConfig，<strong>通过配置类Properties直接写入验证码的参数</strong>：如宽度，高度，字体大小，颜色，字符范围，字符数量，干扰项。然后把配置类信息<strong>赋予kaptcha的Config类</strong>，然后<strong>传给DefaultKaptcha类</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KaptchaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Producer <span class="title function_">kaptchaProducer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.width&quot;</span>, <span class="string">&quot;100&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.height&quot;</span>, <span class="string">&quot;40&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.size&quot;</span>, <span class="string">&quot;32&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.color&quot;</span>, <span class="string">&quot;0,0,0&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.string&quot;</span>, <span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.length&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.noise.impl&quot;</span>, <span class="string">&quot;com.google.code.kaptcha.impl.NoNoise&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DefaultKaptcha</span> <span class="variable">kaptcha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultKaptcha</span>();</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>(properties);</span><br><span class="line">        kaptcha.setConfig(config);</span><br><span class="line">        <span class="keyword">return</span> kaptcha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Controller层——LoginController生成验证码的方法"><a href="#3-开发Controller层——LoginController生成验证码的方法" class="headerlink" title="3.开发Controller层——LoginController生成验证码的方法"></a>3.开发Controller层——LoginController生成验证码的方法</h2><p>接下来就要把验证码应用到登录功能中，没有业务逻辑（与数据库交互），所以直接写控制层逻辑。</p>
<p>写在哪呢，访问登录页面的方法会返回一个html页面（<u>&#x2F;site&#x2F;login</u>），<strong>此页面中有访问验证码的路径</strong>，浏览器<strong>通过该路径访问服务器</strong>，才获得验证码图片。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519201235211.png" alt="image-20220519201235211"></p>
<p>因为我们要访问一个特殊的数据——图片，所以不设置返回值，直接通过response手动地向浏览器输出，同时也要把验证码的字符串内容存入服务器端session（存在浏览器端cookie容易被盗取）。最后不要忘了<strong>注入刚刚写的配置类kaptchaProducer</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/kaptcha&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getKaptcha</span><span class="params">(HttpServletResponse response, HttpSession session)</span>&#123;</span><br><span class="line">    <span class="comment">//生成验证码</span></span><br><span class="line">    <span class="comment">//生成验证码字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> kaptchaProducer.createText();</span><br><span class="line">    <span class="comment">//生成验证码图片</span></span><br><span class="line">    <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> kaptchaProducer.createImage(text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将验证码存入session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;kaptcha&quot;</span>, text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将图片输出给浏览器</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取response输出流（字节流）向浏览器响应</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">//用javax工具类输出图片</span></span><br><span class="line">        ImageIO.write(image, <span class="string">&quot;png&quot;</span>, os);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;响应验证码失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-23-开发登录、退出功能"><a href="#2-23-开发登录、退出功能" class="headerlink" title="2.23 开发登录、退出功能"></a>2.23 开发登录、退出功能</h1><p>大纲如下：</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519204318213.png" alt="image-20220519204318213" style="zoom:50%;" />

<h2 id="1-创建实体类entity——LoginTicket"><a href="#1-创建实体类entity——LoginTicket" class="headerlink" title="1.创建实体类entity——LoginTicket"></a>1.创建实体类entity——LoginTicket</h2><p>我们把登录的用户信息单独存在一张数据库表里，字段分别有序号id, 用户序号user_id, 登陆凭证ticket, 用户登陆状态status, 用户登录过期时间expired</p>
<h2 id="2-开发DAO数据访问层——LoginTicketMapper"><a href="#2-开发DAO数据访问层——LoginTicketMapper" class="headerlink" title="2.开发DAO数据访问层——LoginTicketMapper"></a>2.开发DAO数据访问层——LoginTicketMapper</h2><p>插入一条数据，<strong>根据登陆凭证ticket查询数据</strong>，<strong>根据ticket更新登录状态</strong>（失效，有效）</p>
<p>上次用的xml的格式写的sql，本次<strong>用注解的方式</strong>写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoginTicketMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&#123;</span></span><br><span class="line"><span class="meta">            &quot;insert into login_ticket(user_id,ticket,status,expired) &quot;,</span></span><br><span class="line"><span class="meta">            &quot;values(#&#123;userId&#125;,#&#123;ticket&#125;,#&#123;status&#125;,#&#123;expired&#125;)&quot;</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span><span class="comment">//设置id是自增的</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertLoginTicket</span><span class="params">(LoginTicket loginTicket)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&#123;</span></span><br><span class="line"><span class="meta">            &quot;select id,user_id,ticket,status,expired &quot;,</span></span><br><span class="line"><span class="meta">            &quot;from login_ticket where ticket=#&#123;ticket&#125;&quot;</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    LoginTicket <span class="title function_">selectByTicket</span><span class="params">(String ticket)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&#123;</span></span><br><span class="line"><span class="meta">            &quot;update login_ticket set status=#&#123;status&#125; where ticket=#&#123;ticket&#125;&quot;</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateStatus</span><span class="params">(<span class="meta">@Param(&quot;ticket&quot;)</span> String ticket, <span class="meta">@Param(&quot;status&quot;)</span> <span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Service层——登录业务UserService"><a href="#3-开发Service层——登录业务UserService" class="headerlink" title="3.开发Service层——登录业务UserService"></a>3.开发Service层——登录业务UserService</h2><p>先把刚才的LoginTicketMapper组件注入进来，然后再开始实现登录功能。因为登录也会像注册一样，可能有很多报错，所以<strong>返回值为Map类型数据用来存储报错信息</strong>。</p>
<p>另外，登录功能可以肯定的是<strong>需要我们传入用户名和密码，还有过期时间也要传入</strong>，这个容易忘记！！！</p>
<p>具体功能和注册功能的业务逻辑很像，首先判断空值，然后验证合法性（<strong>注意密码要加salt</strong>），都通过了就生成登陆凭证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">login</span><span class="params">(String username, String password, <span class="type">int</span> expiredSeconds)</span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空值处理</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(username))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;账号不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(password))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;passwordMsg&quot;</span>, <span class="string">&quot;密码不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证账号</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectByName(username);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;该账号不存在！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证状态（注册后有没有激活）</span></span><br><span class="line">    <span class="keyword">if</span>(user.getStatus() == <span class="number">0</span>)&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;该账号未激活！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证密码</span></span><br><span class="line">    password = CommunityUtil.md5(password + user.getSalt());</span><br><span class="line">    <span class="keyword">if</span>(!user.getPassword().equals(password))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;passwordMsg&quot;</span>, <span class="string">&quot;密码不正确！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成登录凭证</span></span><br><span class="line">    <span class="type">LoginTicket</span> <span class="variable">loginTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginTicket</span>();</span><br><span class="line">    loginTicket.setUserId(user.getId());</span><br><span class="line">    loginTicket.setTicket(CommunityUtil.generateUUID());</span><br><span class="line">    loginTicket.setStatus(<span class="number">0</span>);</span><br><span class="line">    loginTicket.setExpired(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expiredSeconds * <span class="number">1000</span>));</span><br><span class="line">    loginTicketMapper.insertLoginTicket(loginTicket);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以传入loginTicket整个对象，但没必要，我们只需要登陆凭证，其他的登录信息可以用凭证去库里查</span></span><br><span class="line">    map.put(<span class="string">&quot;ticket&quot;</span>, loginTicket.getTicket());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-开发Controller——登录功能login"><a href="#4-开发Controller——登录功能login" class="headerlink" title="4.开发Controller——登录功能login"></a>4.开发Controller——登录功能login</h2><p>这里返回页面也是&#x2F;login，不会与前面的返回&#x2F;login页面的方法冲突是因为，<strong>前面是get请求，当前方法是post请求。</strong></p>
<p>传入的参数分别有用户名，密码，因为<strong>要与页面直接交互</strong>了，所以还有<strong>验证码code</strong>，因为<strong>验证码要去session中取</strong>，所以要有Session session，另外还有<strong>页面上的选框“记住我”rememberme</strong>，如果登录成功，要<strong>将ticket登陆凭证存入浏览器的cookie</strong>中，所以要用response接收，最后别忘了Model <strong>model</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/login&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password, String code, <span class="type">boolean</span> rememberme,</span></span><br><span class="line"><span class="params">                    Model model, HttpSession session, HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="comment">//检查验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">kaptcha</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;kaptcha&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code))&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;codeMsg&quot;</span>, <span class="string">&quot;验证码不正确！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/login&quot;</span>;<span class="comment">//回到登录页面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查账号，密码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expiredSeconds</span> <span class="operator">=</span> rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;</span><br><span class="line">    Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds);</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(<span class="string">&quot;ticket&quot;</span>))&#123;</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;ticket&quot;</span>, map.get(<span class="string">&quot;ticket&quot;</span>).toString());</span><br><span class="line">        <span class="comment">//生成cookie有效路径</span></span><br><span class="line">        cookie.setPath(contextPath);</span><br><span class="line">        <span class="comment">//设置cookie有效时间</span></span><br><span class="line">        cookie.setMaxAge(expiredSeconds);</span><br><span class="line">        <span class="comment">//将cookie加入到response中，响应时就会将cookie发送给浏览器</span></span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;usernameMsg&quot;</span>, map.get(<span class="string">&quot;usernameMsg&quot;</span>));</span><br><span class="line">        model.addAttribute(<span class="string">&quot;passwordMsg&quot;</span>, map.get(<span class="string">&quot;passwordMsg&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在“记住我”选框判断的时候，需要利用<strong>常量接口中</strong>的两个属性，要记得在接口中加上：</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519215357488.png" alt="image-20220519215357488" style="zoom: 67%;" />

<h2 id="5-开发Service层——退出业务logout"><a href="#5-开发Service层——退出业务logout" class="headerlink" title="5.开发Service层——退出业务logout"></a>5.开发Service层——退出业务logout</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(String ticket)</span>&#123;<span class="comment">//传入凭证即可</span></span><br><span class="line">    loginTicketMapper.updateStatus(ticket, <span class="number">1</span>);<span class="comment">//将用户状态改为1即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-开发Controller层——退出功能logout"><a href="#6-开发Controller层——退出功能logout" class="headerlink" title="6.开发Controller层——退出功能logout"></a>6.开发Controller层——退出功能logout</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/logout&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">logout</span><span class="params">(<span class="meta">@CookieValue(&quot;ticket&quot;)</span> String ticket)</span>&#123;</span><br><span class="line">    userService.logout(ticket);</span><br><span class="line">    <span class="comment">//重定向到登陆页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/login&quot;</span>;<span class="comment">//重定向默认是GET请求的/login</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-27-显示登录信息（头部信息）"><a href="#2-27-显示登录信息（头部信息）" class="headerlink" title="2.27 显示登录信息（头部信息）"></a>2.27 显示登录信息（头部信息）</h1><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220520165750148.png" alt="image-20220520165750148" style="zoom: 67%;" />

<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220520170844188.png" alt="image-20220520170844188"></p>
<p>以上的过程我们通过拦截器来实现。</p>
<h2 id="1-开发Controller——LoginTicketInterceptor拦截器"><a href="#1-开发Controller——LoginTicketInterceptor拦截器" class="headerlink" title="1.开发Controller——LoginTicketInterceptor拦截器"></a>1.开发Controller——LoginTicketInterceptor拦截器</h2><p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220521193636861.png" alt="image-20220521193636861"></p>
<p>所在包及类的位置如图所示</p>
<p>该类首先要注入Spring容器中，然后实现HandlerInterceptor接口，该接口有三个默认方法用于我们对数据的拦截操作。</p>
<p>第一步自然是在请求之前通过cookie得到ticket，所以重写preHandle()，因为接口方法的形参我们不能随便改动，preHandle有形参request，我们需要<strong>专门写一个工具类来封装从request中获取cookie的操作（1.1）</strong>。</p>
<p>除此之外，获得cookie之后，我们就可以<strong>从cookie中获得ticket（1.2）</strong>了，这也需要我们专门开发业务层<strong>查询ticket</strong>的逻辑。</p>
<p>当我们用ticket获取到用户身份后，需要根据用户来查询用户信息，并暂存在内存中的，方便我们在页面模板中使用，因为每次请求都会建立一个线程，<strong>浏览器对服务器是一对多的并发请求</strong>，所以我们要让<strong>每个当前线程持有该用户信息</strong>。所以不能简单用session来存储，我们需要单独建立一个工具类<strong>HostHolder来持有用户信息（1.3）</strong>。然后通过hostHolder来暂存用户信息。</p>
<p>接下来我们就可以开发preHandle方法了；</p>
<p>然后请求过后，<strong>模板执行之前</strong>，我们执行postHandle，此时就该从hostHandle中获取用户信息了，然后传给modelAndView。</p>
<p>最后在模板结束后，清除线程暂存的user信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginTicketInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从cookie中获取凭证</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ticket</span> <span class="operator">=</span> CookieUtil.getValue(request, <span class="string">&quot;ticket&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ticket != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//查询凭证</span></span><br><span class="line">            <span class="type">LoginTicket</span> <span class="variable">loginTicket</span> <span class="operator">=</span> userService.findLoginTicket(ticket);</span><br><span class="line">            <span class="comment">//检查凭证是否有效(凭证存在，状态为0有效，没超时)</span></span><br><span class="line">            <span class="keyword">if</span>(loginTicket != <span class="literal">null</span> &amp;&amp; loginTicket.getStatus() == <span class="number">0</span> &amp;&amp; loginTicket.getExpired().after(<span class="keyword">new</span> <span class="title class_">Date</span>()))&#123;</span><br><span class="line">                <span class="comment">//根据凭证查询用户</span></span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(loginTicket.getUserId());</span><br><span class="line">                <span class="comment">//在本次请求中持有用户信息</span></span><br><span class="line">                hostHolder.setUser(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="literal">null</span> &amp;&amp; modelAndView != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将用户信息传给modelAndView，模板即可利用user信息</span></span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;loginUser&quot;</span>, user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">        hostHolder.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-开发工具类CookieUtil"><a href="#1-1-开发工具类CookieUtil" class="headerlink" title="1.1 开发工具类CookieUtil"></a>1.1 开发工具类CookieUtil</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getValue</span><span class="params">(HttpServletRequest request, String name)</span>&#123;</span><br><span class="line">        <span class="comment">//对request和请求的cookie名字做一个判空操作</span></span><br><span class="line">        <span class="keyword">if</span>(request == <span class="literal">null</span> || name == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取request中的cookie数组</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="comment">//遍历数组元素</span></span><br><span class="line">        <span class="keyword">if</span>(cookies != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Cookie cookie : cookies)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cookie.getName().equals(name))&#123;</span><br><span class="line">                    <span class="keyword">return</span> cookie.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-开发Service层——findLoginTicket（通过ticket查询数据库的ticket）"><a href="#1-2-开发Service层——findLoginTicket（通过ticket查询数据库的ticket）" class="headerlink" title="1.2 开发Service层——findLoginTicket（通过ticket查询数据库的ticket）"></a>1.2 开发Service层——findLoginTicket（通过ticket查询数据库的ticket）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LoginTicket <span class="title function_">findLoginTicket</span><span class="params">(String ticket)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loginTicketMapper.selectByTicket(ticket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-开发工具类HostHolder"><a href="#1-3-开发工具类HostHolder" class="headerlink" title="1.3 开发工具类HostHolder"></a>1.3 开发工具类HostHolder</h3><p>为了多个线程访问服务器没有冲突，我们可以用ThreadLocal来对线程进行隔离。该方法源码显示，set方法是获取当前线程，然后在该线程中创建一个map，把信息存到map中；而get方法是通过线程获取其自身的map来获得信息。因为<strong>每个线程的map不一样，进而实现了线程隔离</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HostHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂存用户信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        users.set(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取用户信息</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> users.get();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//清楚用户信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        users.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-开发配置类WebMvcConfig"><a href="#2-开发配置类WebMvcConfig" class="headerlink" title="2.开发配置类WebMvcConfig"></a>2.开发配置类WebMvcConfig</h2><p>将刚刚开发的拦截器注入，然后通过接口WebMvcConfigurer的方法addInterceptors()来将拦截器进行注册及配置。</p>
<p>注册很简单，调用注册器registry的addInterceptor方法即可。可以为拦截路径设限 -&gt; excludePathPatterns()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginTicketInterceptor loginTicketInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//除了静态资源都需要拦截</span></span><br><span class="line">        registry.addInterceptor(loginTicketInterceptor)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/**/*.png&quot;</span>, <span class="string">&quot;/**/*.jpg&quot;</span>, <span class="string">&quot;/**/*.jpeg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="疑问与解答"><a href="#疑问与解答" class="headerlink" title="疑问与解答"></a>疑问与解答</h2><p><u><strong>问</strong>：一是如果是首次登录的时候, cookie中还没有ticket, 也就会直接跳过preHandle中的代码, 然后直接进controller中的login方法, 最后返回给客户端一个含有ticket的cookie, 没有返回user对象, 所以是不是此时页面顶部并没有渲染到数据?</u></p>
<p><u>二是点击退出的登录的时候, 请求会先过preHandle方法, 此时cookie中还带有ticket, 并且因为还没有进controller中的方法, 所以ticket的状态没有被修改为1, 所以本次请求还是会持有user, 那这样走完controller中的方法返回后还是带有user数据, 那按理说页面顶部会错误判断成user !&#x3D; null, 但是最后演示的结果是正确的, 请问这是为什么呢?</u></p>
<p><strong>答</strong>：登陆成功、退出成功时，<strong>会进行重定向</strong>。届时，浏览器和服务器之间的<strong>连接被刷新</strong>了，经过重定向之后的结果页面，状态是OK的</p>
<h1 id="2-33-账号设置——上传头像"><a href="#2-33-账号设置——上传头像" class="headerlink" title="2.33 账号设置——上传头像"></a>2.33 账号设置——上传头像</h1><h2 id="1-访问账号设置页面——UserController"><a href="#1-访问账号设置页面——UserController" class="headerlink" title="1.访问账号设置页面——UserController"></a>1.访问账号设置页面——UserController</h2><p>访问页面的功能，没有业务，直接开发Controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">	<span class="comment">//访问账号设置页面</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/setting&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSettingPage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/setting&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-上传头像"><a href="#2-上传头像" class="headerlink" title="2.上传头像"></a>2.上传头像</h2><h3 id="2-1-配置头像存放路径"><a href="#2-1-配置头像存放路径" class="headerlink" title="2.1 配置头像存放路径"></a>2.1 配置头像存放路径</h3><p><strong>先放到本机服务器</strong>（这里一定要<strong>先在这个路径下创建一个文件夹</strong>，否则后面找不到指定路径资源），后期会上传到Linux系统的云服务器</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">community.path.upload</span>=<span class="string">d:/workspace_idea/data/upload</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-开发Service层——更改头像路径updateHeader"><a href="#2-2-开发Service层——更改头像路径updateHeader" class="headerlink" title="2.2 开发Service层——更改头像路径updateHeader"></a>2.2 开发Service层——更改头像路径updateHeader</h3><p>因为我们是将图片上传到服务器中，所以没有与数据库交互的操作，自然也就没有数据访问层DAO。</p>
<p>而我们上传图片后，用户的headerUrl路径就会发生改变，所以我们要开发业务层逻辑。</p>
<p>因为我们需要用SpringMVC提供的<strong>MultipartFile类来处理上传文件</strong>，所以业务层不上传头像，只改变用户头像路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateHeader</span><span class="params">(<span class="type">int</span> userId, String headerUrl)</span>&#123;</span><br><span class="line">    <span class="comment">//直接调用之前写的Mapper接口的updateHeader方法即可</span></span><br><span class="line">    <span class="keyword">return</span> userMapper.updateHeader(userId, headerUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Controller层——上传头像uploadHeader"><a href="#3-开发Controller层——上传头像uploadHeader" class="headerlink" title="3.开发Controller层——上传头像uploadHeader"></a>3.开发Controller层——上传头像uploadHeader</h2><p>1）先判断图片<strong>是否为空</strong></p>
<p>2）获取图片文件名，并<strong>截取其后缀</strong></p>
<p>3）生成随机文件名（<strong>随机字符串+后缀</strong>），调用<u>transferTo</u>方法<strong>存储图片</strong>至服务器</p>
<p>4）<strong>更新用户头像</strong>路径</p>
<p>5）<strong>重定向</strong>到首页</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/upload&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">uploadHeader</span><span class="params">(MultipartFile headerImage, Model model)</span>&#123;</span><br><span class="line">    <span class="comment">//对图片进行判空</span></span><br><span class="line">    <span class="keyword">if</span>(headerImage == <span class="literal">null</span>)&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;您还没有选择图片！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/setting&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> headerImage.getOriginalFilename();</span><br><span class="line">    <span class="comment">//截取文件后缀名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(suffix))&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;文件的格式不正确！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/setting&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成随机文件名</span></span><br><span class="line">    fileName = CommunityUtil.generateUUID() + suffix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定文件存放的路径</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadPath + <span class="string">&quot;/&quot;</span> + fileName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//存储文件transferTo方法即是MultiPartFile类的方法</span></span><br><span class="line">        headerImage.transferTo(dest);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;上传文件失败：&quot;</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;上传文件失败，服务器发生异常！&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新当前用户的头像的路径(web访问路径) 如下：</span></span><br><span class="line">    <span class="comment">//http://localhost:8080/community/user/header/xxx.png</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line">    <span class="type">String</span> <span class="variable">headerUrl</span> <span class="operator">=</span> domain + contextPath + <span class="string">&quot;/user/header/&quot;</span> + fileName;</span><br><span class="line"></span><br><span class="line">    userService.updateHeader(user.getId(), headerUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重定向的目的是刷新连接，不刷新头像还是原来的那个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-开发Controller层——获取头像getHeader"><a href="#4-开发Controller层——获取头像getHeader" class="headerlink" title="4.开发Controller层——获取头像getHeader"></a>4.开发Controller层——获取头像getHeader</h2><p>1）先获取头像图片<strong>在服务器中的位置</strong></p>
<p>2）<strong>获得图片后缀名</strong>，response要用</p>
<p>3）response响应图片，<strong>先设置响应的图片的格式</strong>为后缀名</p>
<p>4）由response创建<strong>输出流os</strong>，然后<strong>手动创建输入流fis</strong>，fis接收文件，os输出文件</p>
<p>5）<strong>关闭流资源</strong>，利用JDK 7新特性，将finally语句写入try()内，os可自动关，<strong>fis必须写进来</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/header/&#123;fileName&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHeader</span><span class="params">(<span class="meta">@PathVariable(&quot;fileName&quot;)</span> String fileName, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//获取服务器存放路径</span></span><br><span class="line">    fileName = uploadPath + <span class="string">&quot;/&quot;</span> + fileName;</span><br><span class="line">    <span class="comment">//获取文件后缀</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">//响应图片</span></span><br><span class="line">    <span class="comment">//设置响应图片的格式</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;image/&quot;</span> + suffix);</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">//写在()自动执行finally关闭流操作</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//response由SpringMVC管理，自动关闭输出流</span></span><br><span class="line">        	<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        	<span class="comment">//fis输入流是我们自行创建的，要手动关闭</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName);</span><br><span class="line">            ) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((b = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, b);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;读取头像失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-41-检查登陆状态"><a href="#2-41-检查登陆状态" class="headerlink" title="2.41 检查登陆状态"></a>2.41 检查登陆状态</h1><p>当用户<strong>没有登录的时候</strong>，虽然功能选项没有显示出来，但是<strong>网页还是可以照常访问</strong>，所以我们必须在用户访问这些网页的时候，服务端进行判断操作。</p>
<p>我们以下操作通过注解的方式实现，所以<strong>新建annotation注解package包</strong></p>
<h2 id="1-开发注解接口——LoginRequired"><a href="#1-开发注解接口——LoginRequired" class="headerlink" title="1.开发注解接口——LoginRequired"></a>1.开发注解接口——LoginRequired</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span><span class="comment">//声明该注解作用于方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//声明该注解在运行时才有效</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LoginRequired &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-标识需要拦截的方法——UserController中的方法"><a href="#2-标识需要拦截的方法——UserController中的方法" class="headerlink" title="2.标识需要拦截的方法——UserController中的方法"></a>2.标识需要拦截的方法——UserController中的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有登录了才能访问个人设置页面，所以该方法需要拦截</span></span><br><span class="line"><span class="meta">@LoginRequired</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/setting&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSettingPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/site/setting&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有登陆了才能上传头像，所以该方法需要拦截</span></span><br><span class="line"><span class="meta">@LoginRequired</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/upload&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">uploadHeader</span><span class="params">(MultipartFile headerImage, Model model)</span>&#123;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发拦截器——LoginRequiredInterceptor"><a href="#3-开发拦截器——LoginRequiredInterceptor" class="headerlink" title="3.开发拦截器——LoginRequiredInterceptor"></a>3.开发拦截器——LoginRequiredInterceptor</h2><p>开发拦截器判断标识了注解的方法有没有登录，没有登陆是不能访问这俩方法的。所以重写preHandle方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequiredInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//确保当前拦截的目标是方法类型的</span></span><br><span class="line">        <span class="keyword">if</span>(handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</span><br><span class="line">            <span class="comment">//获取拦截的method对象</span></span><br><span class="line">            <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> handlerMethod.getMethod();</span><br><span class="line">            <span class="comment">//从method对象中取方法的注解</span></span><br><span class="line">            <span class="type">LoginRequired</span> <span class="variable">loginRequired</span> <span class="operator">=</span> method.getAnnotation(LoginRequired.class);</span><br><span class="line">            <span class="comment">//访问到标识注解的方法了，但当前用户未登录</span></span><br><span class="line">            <span class="keyword">if</span>(loginRequired != <span class="literal">null</span> &amp;&amp; hostHolder.getUser() == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//重定向到登陆界面</span></span><br><span class="line">                response.sendRedirect(request.getContextPath() + <span class="string">&quot;/login&quot;</span>);</span><br><span class="line">                <span class="comment">//拒绝后续的请求</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-配置拦截器生效路径（排除静态资源）——WebMvcConfig"><a href="#4-配置拦截器生效路径（排除静态资源）——WebMvcConfig" class="headerlink" title="4.配置拦截器生效路径（排除静态资源）——WebMvcConfig"></a>4.配置拦截器生效路径（排除静态资源）——WebMvcConfig</h2><p>其实拦截器寻找带LoginRequired注解的方法已经是一种路径，但是我们还需要将一些静态资源的访问排除掉，所以我们要去WebMvcConfig中注册该拦截器进行配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginRequiredInterceptor loginRequiredInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(loginRequiredInterceptor)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/**/*.png&quot;</span>, <span class="string">&quot;/**/*.jpg&quot;</span>, <span class="string">&quot;/**/*.jpeg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-1-过滤敏感词"><a href="#3-1-过滤敏感词" class="headerlink" title="3.1 过滤敏感词"></a>3.1 过滤敏感词</h1><h2 id="1-创建敏感词文件——sensitive-words"><a href="#1-创建敏感词文件——sensitive-words" class="headerlink" title="1.创建敏感词文件——sensitive-words"></a>1.创建敏感词文件——sensitive-words</h2><p>可以把敏感词放到数据库里，也可以放到文件中。我们在resources目录下创建一个txt文本文件——sensitive-words</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220524163219968.png" alt="image-20220524163219968" style="zoom:50%;" />

<h2 id="2-开发工具类——SensitiveFilter"><a href="#2-开发工具类——SensitiveFilter" class="headerlink" title="2.开发工具类——SensitiveFilter"></a>2.开发工具类——SensitiveFilter</h2><h3 id="1）定义前缀树"><a href="#1）定义前缀树" class="headerlink" title="1）定义前缀树"></a>1）定义前缀树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义前缀树，因为该方法比较特殊，所以就设定为private内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键词结束标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isKeyWordEnd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子节点(key是下级节点的字符，value是下级节点)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, TrieNode&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isKeyWordEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isKeyWordEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKeyWordEnd</span><span class="params">(<span class="type">boolean</span> keyWordEnd)</span> &#123;</span><br><span class="line">        isKeyWordEnd = keyWordEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加子节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSubNode</span><span class="params">(Character c, TrieNode node)</span>&#123;</span><br><span class="line">        subNodes.put(c, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取子节点</span></span><br><span class="line">    <span class="keyword">public</span> TrieNode <span class="title function_">getSubNode</span><span class="params">(Character c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subNodes.get(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）构造初始化函数——将敏感词添加到前缀树中"><a href="#2）构造初始化函数——将敏感词添加到前缀树中" class="headerlink" title="2）构造初始化函数——将敏感词添加到前缀树中"></a>2）构造初始化函数——将敏感词添加到前缀树中</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//定义日志</span><br><span class="line">private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);</span><br><span class="line"></span><br><span class="line">//将敏感词替换成常量***</span><br><span class="line">private static final String REPLACEMENT = &quot;***&quot;;</span><br><span class="line"></span><br><span class="line">//根节点</span><br><span class="line">private TrieNode rootNode = new TrieNode();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当容器实例化SensitiveFilter以后/调用SensitiveFilter构造器(服务启动时)，本方法就被调用</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里getClass()方法会让路径寻址到target目录下的classes中</span></span><br><span class="line">    <span class="comment">//txt文本格式文件属于非class文件，需要Maven先clean再compile才能在target.classes目录中显示出来</span></span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;sensitive-words.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//将字符流转换为缓冲流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>((is)));</span><br><span class="line">    ) &#123;</span><br><span class="line">        String keyword;</span><br><span class="line">        <span class="comment">//每次缓冲流读取的词都放入变量keyword中</span></span><br><span class="line">        <span class="keyword">while</span>((keyword = reader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//添加前缀树</span></span><br><span class="line">            <span class="built_in">this</span>.addKeyword(keyword);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;加载敏感词文件失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加前缀树的addKeyword()逻辑比较复杂，我们单独写一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个敏感词添加到前缀树中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addKeyword</span><span class="params">(String keyword)</span>&#123;</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> rootNode;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; keyword.length();i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> keyword.charAt(i);</span><br><span class="line">        <span class="comment">//获得当前节点的子节点</span></span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">subNode</span> <span class="operator">=</span> tempNode.getSubNode(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前节点的子节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(subNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//初始化子节点</span></span><br><span class="line">            subNode = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            tempNode.addSubNode(c, subNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指向子节点，进入下一轮循环</span></span><br><span class="line">        tempNode = subNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到字符串的最后，设置结束标识</span></span><br><span class="line">        <span class="keyword">if</span>(i == keyword.length() - <span class="number">1</span>)&#123;</span><br><span class="line">            tempNode.setKeyWordEnd(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3）过滤敏感词方法"><a href="#3）过滤敏感词方法" class="headerlink" title="3）过滤敏感词方法"></a>3）过滤敏感词方法</h3><p>最后就是重头戏——filter()。</p>
<p>总体的思想就是：让指针1指向<strong>前缀树的根节点</strong>，然后指针2作为<strong>滑动窗口的开端</strong>，指针3<strong>每次从开端向后走</strong>。如果当前根节点的下一个节点的字符<strong>不等于</strong>当前开端的字符，那么指针2和指针3都向后走；如果当前根节点的下一个节点的字符<strong>等于</strong>当前开端的字符，就让指针2停在开端处，让指针3向后走，如果碰到了前缀树<strong>一个分支的叶子节点</strong>，就说明当前指针2与指针3之间的词为敏感词，替换为”三个*“；如果没碰到叶子节点，指针3就继续向后走，直到走到叶子节点或与<strong>前缀树的节点值不等</strong>为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤敏感词</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text 待过滤文本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 过滤后的文本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(text))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针1</span></span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> rootNode;</span><br><span class="line">    <span class="comment">//指针2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//指针3</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//结果</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(position &lt; text.length())&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> text.charAt(position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳过符号</span></span><br><span class="line">        <span class="keyword">if</span>(isSymbol(c))&#123;</span><br><span class="line">            <span class="comment">//若指针1处于根节点，将此符号计入结果，让指针2向下走一步</span></span><br><span class="line">            <span class="keyword">if</span>(tempNode == rootNode)&#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//无论符号在不在根节点，指针3都向下走一步</span></span><br><span class="line">            position++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不是符号，则检查下级节点</span></span><br><span class="line">        tempNode = tempNode.getSubNode(c);</span><br><span class="line">        <span class="keyword">if</span>(tempNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//以begin开头的字符串不是敏感词</span></span><br><span class="line">            sb.append(text.charAt(begin));</span><br><span class="line">            <span class="comment">//指针2、3进入下一个位置</span></span><br><span class="line">            position = ++begin;</span><br><span class="line">            <span class="comment">//指针1重新指向根节点</span></span><br><span class="line">            tempNode = rootNode;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tempNode.isKeyWordEnd())&#123;</span><br><span class="line">            <span class="comment">//发现敏感词，将begin~position字符串替换掉</span></span><br><span class="line">            sb.append(REPLACEMENT);</span><br><span class="line">            <span class="comment">//指针2、3进入下一个位置</span></span><br><span class="line">            begin = ++position;</span><br><span class="line">            <span class="comment">//指针3重新指向根节点</span></span><br><span class="line">            tempNode = rootNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//检查下一个字符</span></span><br><span class="line">            position++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将最后一批字符计入结果</span></span><br><span class="line">    sb.append(text.substring(begin));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-6-发布帖子"><a href="#3-6-发布帖子" class="headerlink" title="3.6 发布帖子"></a>3.6 发布帖子</h1><h2 id="1-开发DAO层——DiscussPostMapper"><a href="#1-开发DAO层——DiscussPostMapper" class="headerlink" title="1.开发DAO层——DiscussPostMapper"></a>1.开发DAO层——DiscussPostMapper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertDiscussPost</span><span class="params">(DiscussPost discussPost)</span>;</span><br></pre></td></tr></table></figure>

<p>然后在discusspost-mapper.xml把插入帖子的sql语句写出来</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.DiscussPostMapper&quot;</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span></span><br><span class="line">    user_id, title, content, type, status, create_time, comment_count, score</span><br><span class="line">	<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertDiscussPost&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;DiscussPost&quot;</span>&gt;</span></span><br><span class="line">        insert into discuss_post(<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>)</span><br><span class="line">        values(#&#123;userId&#125;,#&#123;title&#125;,#&#123;content&#125;,#&#123;type&#125;,#&#123;status&#125;,#&#123;createTime&#125;,#&#123;commentCount&#125;,#&#123;score&#125;)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-开发Service层——DiscussPostService"><a href="#2-开发Service层——DiscussPostService" class="headerlink" title="2.开发Service层——DiscussPostService"></a>2.开发Service层——DiscussPostService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscussPostService</span> &#123;    </span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SensitiveFilter sensitiveFilter;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addDiscussPost</span><span class="params">(DiscussPost post)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(post == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不能为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转义HTML标记符号</span></span><br><span class="line">        post.setTitle(HtmlUtils.htmlEscape(post.getTitle()));</span><br><span class="line">        post.setContent(HtmlUtils.htmlEscape(post.getContent()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//过滤敏感词</span></span><br><span class="line">        post.setTitle(sensitiveFilter.filter(post.getTitle()));</span><br><span class="line">        post.setTitle(sensitiveFilter.filter(post.getContent()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现插入帖子数据</span></span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.insertDiscussPost(post);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发CommunityUtil工具类——字符串转换为JSON格式"><a href="#3-开发CommunityUtil工具类——字符串转换为JSON格式" class="headerlink" title="3.开发CommunityUtil工具类——字符串转换为JSON格式"></a>3.开发CommunityUtil工具类——字符串转换为JSON格式</h2><p>因为我们的帖子内容都是字符串文本存入数据库的，但是在网页端显示的都是JSON格式的字符串，所以我们需要提供一个工具类，来实现字符串向JSON格式字符串的转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJSONString</span><span class="params">(<span class="type">int</span> code, String msg, Map&lt;String, Object&gt; map)</span>&#123;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    json.put(<span class="string">&quot;code&quot;</span>, code);<span class="comment">//向前端页面响应状态码</span></span><br><span class="line">    json.put(<span class="string">&quot;msg&quot;</span>, msg);<span class="comment">//向前端页面响应提示信息</span></span><br><span class="line">    <span class="keyword">if</span>(map != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            json.put(key, map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> json.toJSONString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJSONString</span><span class="params">(<span class="type">int</span> code, String msg)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSONString(code, msg, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJSONString</span><span class="params">(<span class="type">int</span> code)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSONString(code, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-开发Controller层——DiscussPostController"><a href="#4-开发Controller层——DiscussPostController" class="headerlink" title="4.开发Controller层——DiscussPostController"></a>4.开发Controller层——DiscussPostController</h2><p>控制层开发的时候要注意：我们返回给页面的是字符串，所以要<strong>使用@ResponseBody注解</strong>；先检查用户<strong>是否登录</strong>；登陆了就向数据库添加帖子。不要忘了<strong>给页面一个提示信息</strong>，提示成功。</p>
<p>如果报错的话，后面会统一处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/discuss&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscussPostController</span> <span class="keyword">implements</span> <span class="title class_">CommunityConstant</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/add&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addDiscussPost</span><span class="params">(String title, String content)</span>&#123;</span><br><span class="line">        <span class="comment">//先检查用户有没有登录</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">403</span>,<span class="string">&quot;你还没有登录哦！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加帖子</span></span><br><span class="line">        <span class="type">DiscussPost</span> <span class="variable">post</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiscussPost</span>();</span><br><span class="line">        post.setUserId(user.getId());</span><br><span class="line">        post.setTitle(title);</span><br><span class="line">        post.setContent(content);</span><br><span class="line">        post.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        discussPostService.addDiscussPost(post);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//报错的情况，将来统一处理</span></span><br><span class="line">        <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">0</span>,<span class="string">&quot;发布成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-11-帖子详情"><a href="#3-11-帖子详情" class="headerlink" title="3.11 帖子详情"></a>3.11 帖子详情</h1><h2 id="1-开发DAO层——DiscussPostMapper-1"><a href="#1-开发DAO层——DiscussPostMapper-1" class="headerlink" title="1.开发DAO层——DiscussPostMapper"></a>1.开发DAO层——DiscussPostMapper</h2><p>首先在数据访问层开发查询帖子（ById）的功能，然后在discusspost-mapper.xml写查询sql语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiscussPost <span class="title function_">selectDiscussPostById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDiscussPostById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;DiscussPost&quot;</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from discuss_post</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-开发Service层——DiscussPostService-1"><a href="#2-开发Service层——DiscussPostService-1" class="headerlink" title="2.开发Service层——DiscussPostService"></a>2.开发Service层——DiscussPostService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DiscussPost <span class="title function_">findDiscussPostById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> discussPostMapper.selectDiscussPostById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Controller层——DiscussPostController"><a href="#3-开发Controller层——DiscussPostController" class="headerlink" title="3.开发Controller层——DiscussPostController"></a>3.开发Controller层——DiscussPostController</h2><p>现在查询帖子详情其实只查询帖子对象本身和帖子对应的发布者。帖子真正的详情如评论，评论的评论，点赞，我们都放到后面去处理。所以本节<strong>只是查询帖子对象</strong>，以及根据对象去<strong>查询发布帖子的id对应的user</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/discuss&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscussPostController</span> <span class="keyword">implements</span> <span class="title class_">CommunityConstant</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/detail/&#123;discussPostId&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDiscussPost</span><span class="params">(<span class="meta">@PathVariable(&quot;discussPostId&quot;)</span> <span class="type">int</span> discussPostId, Model model)</span>&#123;</span><br><span class="line">        <span class="comment">//查询帖子</span></span><br><span class="line">        <span class="type">DiscussPost</span> <span class="variable">post</span> <span class="operator">=</span> discussPostService.findDiscussPostById(discussPostId);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;post&quot;</span>,post);</span><br><span class="line">        <span class="comment">//查询帖子的作者</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(post.getUserId());</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        </span><br><span class="line"> 		<span class="keyword">return</span> <span class="string">&quot;/site/discuss-detail&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-20-显示评论"><a href="#3-20-显示评论" class="headerlink" title="3.20 显示评论"></a>3.20 显示评论</h1><h2 id="1-认识comment数据库"><a href="#1-认识comment数据库" class="headerlink" title="1.认识comment数据库"></a>1.认识comment数据库</h2><p>comment数据库中含有id和user_id，这俩好理解，前者是序号，后者代表当前评论是谁发布的。</p>
<p>entity_type是评论类型，比如1代表对帖子的评论，2代表对评论的评论；</p>
<p><strong>entity_id就是帖子或者评论或者某个课程的id</strong>；</p>
<p>target_id是被评论的某个用户的id，content是帖子内容，status表示这个这个评论被禁用了，不可用了。creat_time是帖子发表时间。</p>
<h2 id="2-开发实体类——Comment"><a href="#2-开发实体类——Comment" class="headerlink" title="2.开发实体类——Comment"></a>2.开发实体类——Comment</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comment</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> userId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> entityType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> entityId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> targetId;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserId</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEntityType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> entityType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEntityType</span><span class="params">(<span class="type">int</span> entityType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.entityType = entityType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEntityId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> entityId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEntityId</span><span class="params">(<span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.entityId = entityId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTargetId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> targetId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTargetId</span><span class="params">(<span class="type">int</span> targetId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.targetId = targetId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreateTime</span><span class="params">(Date createTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Comment&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, userId=&quot;</span> + userId +</span><br><span class="line">                <span class="string">&quot;, entityType=&quot;</span> + entityType +</span><br><span class="line">                <span class="string">&quot;, entityId=&quot;</span> + entityId +</span><br><span class="line">                <span class="string">&quot;, targetId=&quot;</span> + targetId +</span><br><span class="line">                <span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, status=&quot;</span> + status +</span><br><span class="line">                <span class="string">&quot;, createTime=&quot;</span> + createTime +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发DAO层——CommentMapper"><a href="#3-开发DAO层——CommentMapper" class="headerlink" title="3.开发DAO层——CommentMapper"></a>3.开发DAO层——CommentMapper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommentMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据实体来查询评论：分为帖子的评论，评论的评论，课程的评论等....</span></span><br><span class="line">    List&lt;Comment&gt; <span class="title function_">selectCommentsByEntity</span><span class="params">(<span class="meta">@Param(&quot;entityType&quot;)</span> <span class="type">int</span> entityType, <span class="meta">@Param(&quot;entityId&quot;)</span> <span class="type">int</span> entityId, <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询具体某个实体的评论的总数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">selectCountByEntity</span><span class="params">(<span class="meta">@Param(&quot;entityType&quot;)</span> <span class="type">int</span> entityType, <span class="meta">@Param(&quot;entityId&quot;)</span> <span class="type">int</span> entityId)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在comment-mapper.xml中写对应的sql语句</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.CommentMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span></span><br><span class="line">        id, user_id, entity_type, entity_id, target_id, content, status, create_time</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectCommentsByEntity&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        from comment</span><br><span class="line">        where status = 0</span><br><span class="line">        and entity_type = #&#123;entityType&#125;</span><br><span class="line">        and entity_id = #&#123;entityId&#125;</span><br><span class="line">        order by create_time asc</span><br><span class="line">        limit #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectCountByEntity&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select count(id)</span><br><span class="line">        from comment</span><br><span class="line">        where status = 0</span><br><span class="line">        and entity_type = #&#123;entityType&#125;</span><br><span class="line">        and entity_id = #&#123;entityId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-开发Service层——CommentService"><a href="#4-开发Service层——CommentService" class="headerlink" title="4.开发Service层——CommentService"></a>4.开发Service层——CommentService</h2><p>将刚开发的CommentMapper注入进来，直接写出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentService</span> <span class="keyword">implements</span> <span class="title class_">CommunityConstant</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CommentMapper commentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Comment&gt; <span class="title function_">findCommentsByEntity</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commentMapper.selectCommentsByEntity(entityType, entityId, offset, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCommentCount</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commentMapper.selectCountByEntity(entityType, entityId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-开发Controller层——DiscussPostController"><a href="#5-开发Controller层——DiscussPostController" class="headerlink" title="5.开发Controller层——DiscussPostController"></a>5.开发Controller层——DiscussPostController</h2><p>因为评论就是在帖子内容的下方，所以我们的控制层不需要单独写一个方法，直接<strong>沿用帖子详情的方法</strong>即可。</p>
<p>因为数据库里有entity_type字段，指明了实体的类型，为了代码的阅读性，我们<strong>在常量接口创建以下两个常量</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommunityConstant</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实体类型：帖子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ENTITY_TYPE_POST</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实体类型：评论</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ENTITY_TYPE_COMMENT</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着向帖子详情功能的方法中添加内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping(path = &quot;/detail/&#123;discussPostId&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDiscussPost</span><span class="params">(<span class="meta">@PathVariable(&quot;discussPostId&quot;)</span> <span class="type">int</span> discussPostId, Model model, Page page)</span>&#123;</span><br><span class="line">        <span class="comment">//查询某个具体的帖子</span></span><br><span class="line">        <span class="type">DiscussPost</span> <span class="variable">post</span> <span class="operator">=</span> discussPostService.findDiscussPostById(discussPostId);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;post&quot;</span>,post);</span><br><span class="line">        <span class="comment">//查询该帖子的作者</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(post.getUserId());</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="comment">//为评论设置分页信息</span></span><br><span class="line">        page.setLimit(<span class="number">5</span>);</span><br><span class="line">        page.setPath(<span class="string">&quot;/discuss/detail/&quot;</span> + discussPostId);</span><br><span class="line">        page.setRows(post.getCommentCount());<span class="comment">//这里为了方便查询评论数量，我们在discuss_post数据库中存了commentCount变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//评论：给帖子的评论</span></span><br><span class="line">        <span class="comment">//回复：给评论的评论</span></span><br><span class="line">        <span class="comment">//获取相关评论信息(评论列表)</span></span><br><span class="line">        List&lt;Comment&gt; commentList = commentService.findCommentsByEntity(</span><br><span class="line">                ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建评论信息的显示对象(View object)的集合</span></span><br><span class="line">        <span class="comment">//泛型中的Comment和Map&lt;String, Object&gt;一一对应</span></span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; commentVoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(commentList != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Comment comment : commentList) &#123;</span><br><span class="line">                <span class="comment">//每个comment都用一个map来存储用于呈现给页面的数据</span></span><br><span class="line">                Map&lt;String, Object&gt; commentVo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                <span class="comment">//向评论VO添加评论和作者</span></span><br><span class="line">                commentVo.put(<span class="string">&quot;comment&quot;</span>, comment);</span><br><span class="line">                commentVo.put(<span class="string">&quot;user&quot;</span>, userService.findUserById(comment.getUserId()));</span><br><span class="line">                <span class="comment">//每个评论下面的回复列表（该列表就不分页了，有多少显示多少）</span></span><br><span class="line">                List&lt;Comment&gt; replyList = commentService.findCommentsByEntity(</span><br><span class="line">                        ENTITY_TYPE_COMMENT, comment.getId(), <span class="number">0</span>, Integer.MAX_VALUE);</span><br><span class="line">                <span class="comment">//创建回复信息的显示对象(View object)的集合</span></span><br><span class="line">                <span class="comment">//泛型中的Comment和Map&lt;String, Object&gt;一一对应</span></span><br><span class="line">                List&lt;Map&lt;String, Object&gt;&gt; replyVoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span>(replyList != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(Comment reply : replyList)&#123;</span><br><span class="line">                        <span class="comment">//一个回复的显示对象(View object)</span></span><br><span class="line">                        Map&lt;String, Object&gt; replyVo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                        <span class="comment">//向回复VO添加评论和作者</span></span><br><span class="line">                        replyVo.put(<span class="string">&quot;reply&quot;</span>, reply);</span><br><span class="line">                        replyVo.put(<span class="string">&quot;user&quot;</span>, userService.findUserById(reply.getUserId()));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//回复的目标</span></span><br><span class="line">                        <span class="type">User</span> <span class="variable">target</span> <span class="operator">=</span> reply.getTargetId() == <span class="number">0</span> ? <span class="literal">null</span> : userService.findUserById(reply.getTargetId());</span><br><span class="line">                        replyVo.put(<span class="string">&quot;target&quot;</span>, target);</span><br><span class="line">                        </span><br><span class="line">                        replyVoList.add(replyVo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//一定要把每个评论的replyVoList装进commentVo中</span></span><br><span class="line">                commentVo.put(<span class="string">&quot;replys&quot;</span>, replyVoList);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//记录每条评论下面回复的数量</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">replyCount</span> <span class="operator">=</span> commentService.findCommentCount(ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">                commentVo.put(<span class="string">&quot;replyCount&quot;</span>, replyCount);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//每一次遍历，都要将Map添加进集合中</span></span><br><span class="line">                commentVoList.add(commentVo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">&quot;comments&quot;</span>, commentVoList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/discuss-detail&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-22-添加评论"><a href="#3-22-添加评论" class="headerlink" title="3.22 添加评论"></a>3.22 添加评论</h1><h2 id="1-开发DAO层——CommentMapper"><a href="#1-开发DAO层——CommentMapper" class="headerlink" title="1.开发DAO层——CommentMapper"></a>1.开发DAO层——CommentMapper</h2><p>前两个方法是上一节的，<strong>第三个插入方法是本节的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommentMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据实体来查询评论：分为帖子的评论，评论的评论，课程的评论等....</span></span><br><span class="line">    List&lt;Comment&gt; <span class="title function_">selectCommentsByEntity</span><span class="params">(<span class="meta">@Param(&quot;entityType&quot;)</span> <span class="type">int</span> entityType, <span class="meta">@Param(&quot;entityId&quot;)</span> <span class="type">int</span> entityId, <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询具体某个实体的评论的总数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">selectCountByEntity</span><span class="params">(<span class="meta">@Param(&quot;entityType&quot;)</span> <span class="type">int</span> entityType, <span class="meta">@Param(&quot;entityId&quot;)</span> <span class="type">int</span> entityId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertComment</span><span class="params">(Comment comment)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在comment-mapper.xml中写sql</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.CommentMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span></span><br><span class="line">        user_id, entity_type, entity_id, target_id, content, status, create_time</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertComment&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="line">        insert into comment(<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>)</span><br><span class="line">        values(#&#123;userId&#125;,#&#123;entityType&#125;,#&#123;entityId&#125;,#&#123;targetId&#125;,#&#123;content&#125;,#&#123;status&#125;,#&#123;createTime&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-开发DAO层——DiscussPostMapper-1"><a href="#2-开发DAO层——DiscussPostMapper-1" class="headerlink" title="2.开发DAO层——DiscussPostMapper"></a>2.开发DAO层——DiscussPostMapper</h2><p>不要忘了discusspost数据库存了一个“相对冗余”的变量，即每个帖子的评论数量。所以要更新该库里每个帖子的评论数量（最后一个方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscussPostMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;DiscussPost&gt; <span class="title function_">selectDiscussPosts</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> <span class="type">int</span> userId, <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">selectDiscussPostRows</span><span class="params">(<span class="type">int</span> userId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertDiscussPost</span><span class="params">(DiscussPost discussPost)</span>;</span><br><span class="line"></span><br><span class="line">    DiscussPost <span class="title function_">selectDiscussPostById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">	<span class="comment">//更新帖子的评论数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateCommentCount</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id, <span class="meta">@Param(&quot;commentCount&quot;)</span> <span class="type">int</span> commentCount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在discusspost-mapper.xml写更新语句的sql：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.DiscussPostMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateCommentCount&quot;</span>&gt;</span></span><br><span class="line">        update discuss_post set comment_count = #&#123;commentCount&#125; where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-开发Service层——DiscussPostService"><a href="#3-开发Service层——DiscussPostService" class="headerlink" title="3.开发Service层——DiscussPostService"></a>3.开发Service层——DiscussPostService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscussPostService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把刚刚写的DAO层导进来就行了</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostMapper discussPostMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateCommentCount</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> commentCount)</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> discussPostMapper.updateCommentCount(id, commentCount);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-开发Service层——CommentService-1"><a href="#4-开发Service层——CommentService-1" class="headerlink" title="4.开发Service层——CommentService"></a>4.开发Service层——CommentService</h2><p>这个业务我们要明白：<strong>添加评论的同时，我们要在数据库更新一条评论</strong>。我们必须保证上述操作具有事务的一致性，原子性，所以我们要用Spring来声明该方法需要<strong>事务管理</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentService</span> <span class="keyword">implements</span> <span class="title class_">CommunityConstant</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CommentMapper commentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SensitiveFilter sensitiveFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostService discussPostService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addComment</span><span class="params">(Comment comment)</span>&#123;</span><br><span class="line">        <span class="comment">//评论是空的就抛异常</span></span><br><span class="line">        <span class="keyword">if</span>(comment == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不能为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先对评论comment进行符号和敏感词的过滤</span></span><br><span class="line">        comment.setContent(HtmlUtils.htmlEscape(comment.getContent()));</span><br><span class="line">        comment.setContent(sensitiveFilter.filter(comment.getContent()));</span><br><span class="line">        <span class="comment">//返回插入的行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> commentMapper.insertComment(comment);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新帖子的评论数量（评论的评论不算）</span></span><br><span class="line">        <span class="keyword">if</span>(comment.getEntityType() == ENTITY_TYPE_POST)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> commentMapper.selectCountByEntity(comment.getEntityType(), comment.getEntityId());</span><br><span class="line">            <span class="comment">//调用刚才写的业务逻辑，更新库里的帖子数量</span></span><br><span class="line">            discussPostService.updateCommentCount(comment.getEntityId(), count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-开发Controller层——CommentController"><a href="#5-开发Controller层——CommentController" class="headerlink" title="5.开发Controller层——CommentController"></a>5.开发Controller层——CommentController</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/comment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CommentService commentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/add/&#123;discussPostId&#125;&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addComment</span><span class="params">(<span class="meta">@PathVariable(&quot;discussPostId&quot;)</span> <span class="type">int</span> discussPostId, Comment comment)</span>&#123;</span><br><span class="line">        <span class="comment">//后面会有统一的异常处理，可以保证这里肯定是用户登陆的</span></span><br><span class="line">        comment.setUserId(hostHolder.getUser().getId());</span><br><span class="line">        <span class="comment">//保证评论是有效的</span></span><br><span class="line">        comment.setStatus(<span class="number">0</span>);</span><br><span class="line">        comment.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        commentService.addComment(comment);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//评论以后，要跳回当前具体的帖子详情页面，每个帖子都有一个discussPostId来对应</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/discuss/detail/&quot;</span> + discussPostId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-24-私信列表和私信详情"><a href="#3-24-私信列表和私信详情" class="headerlink" title="3.24 私信列表和私信详情"></a>3.24 私信列表和私信详情</h1><h2 id="1-创建实体类——Message"><a href="#1-创建实体类——Message" class="headerlink" title="1.创建实体类——Message"></a>1.创建实体类——Message</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> fromId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> toId;</span><br><span class="line">    <span class="keyword">private</span> String conversationId;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFromId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fromId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFromId</span><span class="params">(<span class="type">int</span> fromId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fromId = fromId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getToId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setToId</span><span class="params">(<span class="type">int</span> toId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.toId = toId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConversationId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> conversationId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConversationId</span><span class="params">(String conversationId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conversationId = conversationId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreateTime</span><span class="params">(Date createTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, fromId=&quot;</span> + fromId +</span><br><span class="line">                <span class="string">&quot;, toId=&quot;</span> + toId +</span><br><span class="line">                <span class="string">&quot;, conversationId=&#x27;&quot;</span> + conversationId + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, status=&quot;</span> + status +</span><br><span class="line">                <span class="string">&quot;, createTime=&quot;</span> + createTime +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-开发DAO层——MessageMapper"><a href="#2-开发DAO层——MessageMapper" class="headerlink" title="2.开发DAO层——MessageMapper"></a>2.开发DAO层——MessageMapper</h2><p>包括查询<strong>当前用户</strong>的会话列表和会话数量，<strong>某个会话</strong>的会话列表和会话数量，还有<strong>未读会话</strong>（包括<strong>所有未读</strong>和<strong>某条会话</strong>的未读）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前用户的会话列表，针对每个会话只返回最新的一条私信（根据userId查询）</span></span><br><span class="line">    List&lt;Message&gt; <span class="title function_">selectConversations</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> <span class="type">int</span> userId, <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前用户的会话数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">selectConversationCount</span><span class="params">(<span class="type">int</span> userId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个会话所包含的私信列表（根据conversationId查询）</span></span><br><span class="line">    List&lt;Message&gt; <span class="title function_">selectLetters</span><span class="params">(<span class="meta">@Param(&quot;conversationId&quot;)</span> String conversationId, <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个会话所包含的私信数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">selectLetterCount</span><span class="params">(String conversationId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询未读私信的数量（包括当前用户所有未读数量 和 某个会话的未读数量）</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">selectLetterUnreadCount</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> <span class="type">int</span> userId, <span class="meta">@Param(&quot;conversationId&quot;)</span> String conversationId)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写配置文件<strong>message-mapper.xml</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.MessageMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span></span><br><span class="line">        id, from_id, to_id, conversation_id, content, status, create_time</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span></span><br><span class="line">        from_id, to_id, conversation_id, content, status, create_time</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectConversations&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Message&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        from message</span><br><span class="line">        where id in (</span><br><span class="line">            select max(id) from message</span><br><span class="line">            where status != 2</span><br><span class="line">            and from_id != 1</span><br><span class="line">            and (from_id = #&#123;userId&#125; or to_id = #&#123;userId&#125;)</span><br><span class="line">            group by conversation_id</span><br><span class="line">        )</span><br><span class="line">        order by id desc</span><br><span class="line">        limit #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectConversationCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select count(m.maxid) from (</span><br><span class="line">            select max(id) as maxid from message</span><br><span class="line">            where status != 2</span><br><span class="line">            and from_id != 1</span><br><span class="line">            and (from_id = #&#123;userId&#125; or to_id = #&#123;userId&#125;)</span><br><span class="line">            group by conversation_id</span><br><span class="line">        ) as m</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectLetters&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Message&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        from message</span><br><span class="line">        where status != 2</span><br><span class="line">        and from_id != 1</span><br><span class="line">        and conversation_id = #&#123;conversationId&#125;</span><br><span class="line">        order by id desc</span><br><span class="line">        limit #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectLetterCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select count(id)</span><br><span class="line">        from message</span><br><span class="line">        where status != 2</span><br><span class="line">        and from_id != 1</span><br><span class="line">        and conversation_id = #&#123;conversationId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectLetterUnreadCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select count(id)</span><br><span class="line">        from message</span><br><span class="line">        where status = 0</span><br><span class="line">        and from_id != 1</span><br><span class="line">        and to_id = #&#123;userId&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;conversationId!=null&quot;</span>&gt;</span></span><br><span class="line">            and conversation_id = #&#123;conversationId&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-开发Service层——MessageService"><a href="#3-开发Service层——MessageService" class="headerlink" title="3.开发Service层——MessageService"></a>3.开发Service层——MessageService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageMapper messageMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Message&gt; <span class="title function_">findConversations</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageMapper.selectConversations(userId, offset, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findConversationCount</span><span class="params">(<span class="type">int</span> userId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageMapper.selectConversationCount(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Message&gt; <span class="title function_">findLetters</span><span class="params">(String conversationId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageMapper.selectLetters(conversationId, offset, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLetterCount</span><span class="params">(String conversationId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageMapper.selectLetterCount(conversationId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLetterUnreadCount</span><span class="params">(<span class="type">int</span> userId, String conversationId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageMapper.selectLetterUnreadCount(userId, conversationId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-开发Controller层——MessageController"><a href="#4-开发Controller层——MessageController" class="headerlink" title="4.开发Controller层——MessageController"></a>4.开发Controller层——MessageController</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私信列表</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/letter/list&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLetterList</span><span class="params">(Model model, Page page)</span>&#123;</span><br><span class="line">        <span class="comment">//后面形参需要获取当前用户user的id</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line">        <span class="comment">//分页信息</span></span><br><span class="line">        page.setLimit(<span class="number">5</span>);</span><br><span class="line">        page.setPath(<span class="string">&quot;/letter/list&quot;</span>);</span><br><span class="line">        page.setRows(messageService.findConversationCount(user.getId()));<span class="comment">//这里通过当前的用户user来获取当前user的id</span></span><br><span class="line">        <span class="comment">//会话列表</span></span><br><span class="line">        List&lt;Message&gt; conversationList = messageService.findConversations(</span><br><span class="line">                user.getId(), page.getOffset(), page.getLimit());</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; conversations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(conversationList != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Message message : conversationList)&#123;</span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                <span class="comment">//先把整个私信传入map</span></span><br><span class="line">                map.put(<span class="string">&quot;conversation&quot;</span>, message);</span><br><span class="line">                <span class="comment">//把私信数量传入map</span></span><br><span class="line">                map.put(<span class="string">&quot;letterCount&quot;</span>, messageService.findLetterCount(message.getConversationId()));</span><br><span class="line">                <span class="comment">//把未读私信数量传入map</span></span><br><span class="line">                map.put(<span class="string">&quot;unreadCount&quot;</span>, messageService.findLetterUnreadCount(user.getId(), message.getConversationId()));</span><br><span class="line">                <span class="comment">//要显示当前私信发起者的头像，所以要找到该对象的id</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">targetId</span> <span class="operator">=</span> user.getId() == message.getFromId() ? message.getToId() : message.getFromId();</span><br><span class="line">                map.put(<span class="string">&quot;target&quot;</span>, userService.findUserById(targetId));</span><br><span class="line"></span><br><span class="line">                conversations.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;conversations&quot;</span>, conversations);</span><br><span class="line">        <span class="comment">//查询当前用户的所有的未读消息数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">letterUnreadCount</span> <span class="operator">=</span> messageService.findLetterUnreadCount(user.getId(), <span class="literal">null</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;letterUnreadCount&quot;</span>, letterUnreadCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/letter&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//具体私信内容</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;letter/detail/&#123;conversationId&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLetterDetail</span><span class="params">(<span class="meta">@PathVariable(&quot;conversationId&quot;)</span> String conversationId, Page page, Model model)</span>&#123;</span><br><span class="line">        <span class="comment">//分页信息</span></span><br><span class="line">        page.setLimit(<span class="number">5</span>);</span><br><span class="line">        page.setPath(<span class="string">&quot;/letter/detail/&quot;</span> + conversationId);</span><br><span class="line">        page.setRows(messageService.findLetterCount(conversationId));</span><br><span class="line">        <span class="comment">//当前某个会话的私信列表</span></span><br><span class="line">        List&lt;Message&gt; letterList = messageService.findLetters(conversationId, page.getOffset(), page.getLimit());</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; letters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(letterList != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Message message : letterList)&#123;</span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                <span class="comment">//把该私信详情的所有内容存起来</span></span><br><span class="line">                map.put(<span class="string">&quot;letter&quot;</span>, message);</span><br><span class="line">                <span class="comment">//因为私信详情里总要显示发私信的人的头像，所以我们要获取fromUser</span></span><br><span class="line">                map.put(<span class="string">&quot;fromUser&quot;</span>, userService.findUserById(message.getFromId()));</span><br><span class="line">                letters.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;letters&quot;</span>, letters);</span><br><span class="line">        <span class="comment">//查询与当前用户私信的人是谁</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;target&quot;</span>, getLetterTarget(conversationId));</span><br><span class="line">        <span class="comment">//将所有未读消息设置已读（下一节3.27）</span></span><br><span class="line">        List&lt;Integer&gt; ids = getLetterIds(letterList);</span><br><span class="line">        <span class="keyword">if</span>(!ids.isEmpty())&#123;</span><br><span class="line">            messageService.readMessage(ids);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/letter-detail&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询target的具体方法</span></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">getLetterTarget</span><span class="params">(String conversationId)</span>&#123;</span><br><span class="line">        String[] ids = conversationId.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">id0</span> <span class="operator">=</span> Integer.parseInt(ids[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">id1</span> <span class="operator">=</span> Integer.parseInt(ids[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(hostHolder.getUser().getId() == id0)&#123;</span><br><span class="line">            <span class="keyword">return</span> userService.findUserById(id1);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> userService.findUserById(id0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里是下一节更新私信需要用到的——得到未读消息（多条消息组成的集合）</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">getLetterIds</span><span class="params">(List&lt;Message&gt; letterList)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(letterList != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Message message : letterList)&#123;</span><br><span class="line">                <span class="comment">//检查当前用户是不是一个接收者的身份并且信息是不是处于未读的状态</span></span><br><span class="line">                <span class="keyword">if</span>(hostHolder.getUser().getId() == message.getToId() &amp;&amp; message.getStatus() == <span class="number">0</span>)&#123;</span><br><span class="line">                    ids.add(message.getId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ids;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-27-发送私信"><a href="#3-27-发送私信" class="headerlink" title="3.27 发送私信"></a>3.27 发送私信</h1><h2 id="1-开发DAO层——MessageMapper"><a href="#1-开发DAO层——MessageMapper" class="headerlink" title="1.开发DAO层——MessageMapper"></a>1.开发DAO层——MessageMapper</h2><p>上一节3.24已经写了五个方法，这节再加俩方法，分别是<strong>新增一条</strong>私信和<strong>修改消息的状态</strong>（已读，未读）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增一个消息</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertMessage</span><span class="params">(Message message)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改消息状态</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateStatus</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> List&lt;Integer&gt; ids, <span class="meta">@Param(&quot;status&quot;)</span> <span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在xml配置文件写sql语句。注意！更新语句<strong>要涉及多个id的更新操作</strong>，用MyBatis的foreach遍历集合：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.MessageMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span></span><br><span class="line">        from_id, to_id, conversation_id, content, status, create_time</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertMessage&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Message&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into message (<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>)</span><br><span class="line">        values(#&#123;fromId&#125;,#&#123;toId&#125;,#&#123;conversationId&#125;,#&#123;content&#125;,#&#123;status&#125;,#&#123;createTime&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStatus&quot;</span>&gt;</span></span><br><span class="line">        update message set status = #&#123;status&#125;</span><br><span class="line">        where id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-开发Service层——MessageService"><a href="#2-开发Service层——MessageService" class="headerlink" title="2.开发Service层——MessageService"></a>2.开发Service层——MessageService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageMapper messageMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SensitiveFilter sensitiveFilter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//增加私信只需要对内容进行标记符号和敏感词的过滤</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addMessage</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        message.setContent(HtmlUtils.htmlEscape(message.getContent()));</span><br><span class="line">        message.setContent(sensitiveFilter.filter(message.getContent()));</span><br><span class="line">        <span class="keyword">return</span> messageMapper.insertMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//将集合ids中的多个id对应的status设为1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">readMessage</span><span class="params">(List&lt;Integer&gt; ids)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageMapper.updateStatus(ids, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Controller层——MessageController"><a href="#3-开发Controller层——MessageController" class="headerlink" title="3.开发Controller层——MessageController"></a>3.开发Controller层——MessageController</h2><p>因为我们要异步更新私信内容，所以<strong>需要返回字符串而不是指定页面</strong>，所以<strong>用@ResponseBody</strong></p>
<p>因为我们传入的是用户名，而实际要对用户进行操作。所以要先在UserService里声明一个<strong>根据用户名查询用户的功能</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">findUserByName</span><span class="params">(String username)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userMapper.selectByName(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以在MessageController中声明发送私信的功能了，其实就是查询用户存不存在，存在就创建一个message对象，存入响应的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/letter/send&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sendLetter</span><span class="params">(String toName, String content)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过用户名查询被私信人</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">target</span> <span class="operator">=</span> userService.findUserByName(toName);</span><br><span class="line">    <span class="comment">//先判断被私信人存不存在</span></span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">1</span>,<span class="string">&quot;目标用户不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建message对象并赋值</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">    message.setFromId(hostHolder.getUser().getId());</span><br><span class="line">    message.setToId(target.getId());</span><br><span class="line">    <span class="comment">//私信人和被私信人谁的id小，就放前面</span></span><br><span class="line">    <span class="keyword">if</span>(message.getFromId() &lt; message.getToId())&#123;</span><br><span class="line">        message.setConversationId(message.getFromId() + <span class="string">&quot;_&quot;</span> + message.getToId());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        message.setConversationId(message.getToId() + <span class="string">&quot;_&quot;</span> + message.getFromId());</span><br><span class="line">    &#125;</span><br><span class="line">    message.setContent(content);</span><br><span class="line">    message.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    messageService.addMessage(message);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-将未读消息设置为已读"><a href="#4-将未读消息设置为已读" class="headerlink" title="4.将未读消息设置为已读"></a>4.将未读消息设置为已读</h2><p>其实本功能在上一节（3.24）中已经写了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ids = getLetterIds(letterList);</span><br><span class="line"><span class="keyword">if</span>(!ids.isEmpty())&#123;</span><br><span class="line">	messageService.readMessage(ids);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;/site/letter-detail&quot;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="3-31-统一异常处理"><a href="#3-31-统一异常处理" class="headerlink" title="3.31 统一异常处理"></a>3.31 统一异常处理</h1><p>因为DAO层和Service层的异常都要向上传给Controller层，所以我们直接在Controller层统一处理异常即可。</p>
<p><strong>基于SpringBoot</strong>的异常处理方式，我们只需要<strong>在templates目录下放入error目录</strong>，在error目录下创建404.html和500.html常见页面，这样在出现异常的时候，系统会<strong>自动跳转</strong>到404或500页面。</p>
<p>对于404用这种方式没问题，但是500属于服务端报错，<strong>需要记录日志</strong>方便于以后分析错误，另外，如果请求是<strong>异步</strong>的，我们最好不是跳转页面而是直接在当前页面<strong>返回JSON格式的字符串</strong>。</p>
<p>所以我们用Spring的@ControllerAdvice注解来解决。</p>
<h2 id="1-开发Controller层——getErrorPage"><a href="#1-开发Controller层——getErrorPage" class="headerlink" title="1.开发Controller层——getErrorPage"></a>1.开发Controller层——getErrorPage</h2><p><strong>因为我们要手动处理服务端异常</strong>，所以需要在主页HomeController中定义一个方法，用于异常时<strong>定位（重定向）到templates&#x2F;error&#x2F;500.html</strong>，（重定向）的意思是我们不把重定向的操作写在当前方法中，而<strong>交给异常处理方法来亲自重定向</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/error&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getErrorPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/error/500&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-开发Controller层——advice通知层——ExceptionAdvice"><a href="#2-开发Controller层——advice通知层——ExceptionAdvice" class="headerlink" title="2.开发Controller层——advice通知层——ExceptionAdvice"></a>2.开发Controller层——advice通知层——ExceptionAdvice</h2><p>1）用Spring的注解@ControllerAdvice去<strong>扫描带有Controller注解的组件</strong></p>
<p>2）一旦哪个Controller层组件出现异常，就会调用当前类ExceptionAdvice类中<strong>注明@ExceptionHandler注解的handleException方法</strong>，进而完成了异常处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该注解只去扫描带有Controller注解的组件</span></span><br><span class="line"><span class="meta">@ControllerAdvice(annotations = Controller.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ExceptionAdvice.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本注解用于修饰方法，表明Controller出现异常后调用本方法，Exception.class说明要处理所有异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;Exception.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleException</span><span class="params">(Exception e, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//这只是一个异常的概括</span></span><br><span class="line">        logger.error(<span class="string">&quot;服务器发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">        <span class="comment">//遍历异常数组的所有信息，并逐条记录下来</span></span><br><span class="line">        <span class="keyword">for</span>(StackTraceElement element : e.getStackTrace())&#123;</span><br><span class="line">            logger.error(element.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从请求头参数判断当前是否为异步请求(key:x-requested-with)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xRequestedWith</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;x-requested-with&quot;</span>);</span><br><span class="line">        <span class="comment">//XML是异步请求</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;XMLHttpRequest&quot;</span>.equals(xRequestedWith))&#123;</span><br><span class="line">            <span class="comment">//返回给页面JSON格式的普通字符串，页面主动将其转换为Js对象</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/plain;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//获取输出流</span></span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">            <span class="comment">//输出一个字符串</span></span><br><span class="line">            writer.write(CommunityUtil.getJSONString(<span class="number">1</span>,<span class="string">&quot;服务器异常！&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//普通请求就直接重定向到错误页面（HomeController层会通过该路径访问getErrorPage方法）</span></span><br><span class="line">            response.sendRedirect(request.getContextPath() + <span class="string">&quot;/error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-33-统一记录日志"><a href="#3-33-统一记录日志" class="headerlink" title="3.33 统一记录日志"></a>3.33 统一记录日志</h1><p>这一节主要是为了记录业务层的日志，我们自然可以想到<u>在每个处理业务的时候加上记录日志的逻辑</u>，但是这就增加了代码的<strong>耦合度</strong>，<strong>一旦想改变记录日志的位置</strong>，会代码巨大的工作量。因为每个业务都需要记录日志，这些代码就可以称为是<strong>系统需求</strong>，我们可以进行统一封装——SpringAOP。</p>
<h2 id="1-开发aspect切面层——ServiceLogAspect"><a href="#1-开发aspect切面层——ServiceLogAspect" class="headerlink" title="1.开发aspect切面层——ServiceLogAspect"></a>1.开发aspect切面层——ServiceLogAspect</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nowcoder.community.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ryn2020</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-04-30 20:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceLogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ServiceLogAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置切点及其切入的位置——处理所有业务组件及其方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.nowcoder.community.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表明本通知为前置通知——在切点之前通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line"><span class="comment">//日志的格式：用户[1.2.3.4]，在[xxx]时间，访问了[com.nowcoder.community.service.xxx()]某个功能.</span></span><br><span class="line">        <span class="comment">//用工具类RequestContextHolder获得请求的attributes</span></span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="comment">//通过attributes获得请求对象request</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">        <span class="comment">//通过request获得ip地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> request.getRemoteHost();</span><br><span class="line">        <span class="comment">//获得当前时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//下面代码前者获得类名com.nowcoder.community，后者获得方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> joinPoint.getSignature().getDeclaringTypeName() + <span class="string">&quot;.&quot;</span> + joinPoint.getSignature().getName();</span><br><span class="line">        <span class="comment">//定义记录日志的格式</span></span><br><span class="line">        logger.info(String.format(<span class="string">&quot;用户[%s],在[%s],访问了[%s].&quot;</span>, ip, now, target));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-7-Spring整合Redis"><a href="#4-7-Spring整合Redis" class="headerlink" title="4.7 Spring整合Redis"></a>4.7 Spring整合Redis</h1><h2 id="1-导入Redis包"><a href="#1-导入Redis包" class="headerlink" title="1.导入Redis包"></a>1.导入Redis包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#RedisProperties</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">11</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>

<h2 id="3-开发配置类——RedisConfig"><a href="#3-开发配置类——RedisConfig" class="headerlink" title="3.开发配置类——RedisConfig"></a>3.开发配置类——RedisConfig</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//将连接Redis数据库的工厂赋给template，template有了工厂就有了访问数据库的能力</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置key的序列化方式</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">//设置value的序列化方式</span></span><br><span class="line">        template.setValueSerializer(RedisSerializer.json());</span><br><span class="line">        <span class="comment">//设置hash的key的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">//设置hash的value的序列化方式</span></span><br><span class="line">        template.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让template生效</span></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-10-4-13-点赞与我收到的赞"><a href="#4-10-4-13-点赞与我收到的赞" class="headerlink" title="4.10-4.13 点赞与我收到的赞"></a>4.10-4.13 点赞与我收到的赞</h1><h2 id="1-开发工具类——RedisKeyUtil"><a href="#1-开发工具类——RedisKeyUtil" class="headerlink" title="1.开发工具类——RedisKeyUtil"></a>1.开发工具类——RedisKeyUtil</h2><p>因为Redis是面向key-value编程的，为了后续代码对key可以反复复用，所以我们专门写一个生成<strong>与点赞相关的key的生成工具</strong>——RedisKeyUtil</p>
<p>关于被点赞的实体（帖子、评论、评论的评论等），我们定义该实体<strong>与点赞行为相关的key</strong>的前缀为like:entity，然后<strong>拼接上entityType和entityId</strong>，共同构成了like:entity:entityType:entityId格式的RedisKey</p>
<p>另外，个人主页也有显示某个用户获得多少赞的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisKeyUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key在拼接的过程中，:用来分割单词</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLIT</span> <span class="operator">=</span> <span class="string">&quot;:&quot;</span>;</span><br><span class="line">    <span class="comment">//声明前缀：以实体为key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_ENTITY_LIKE</span> <span class="operator">=</span> <span class="string">&quot;like:entity&quot;</span>;</span><br><span class="line">    <span class="comment">//声明前缀：以用户为key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_USER_LIKE</span> <span class="operator">=</span> <span class="string">&quot;like:user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//某个实体的赞</span></span><br><span class="line">    <span class="comment">//之后会将value存入set集合中(谁给这个实体点了赞，就把谁的userId存到set集合中，这样不仅可以累计点赞数量，也可以知道是谁给该实体点过赞)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getEntityLikeKey</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId)</span>&#123;</span><br><span class="line">        <span class="comment">//格式：like:entity:entityType:entityId</span></span><br><span class="line">        <span class="keyword">return</span> PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//某个用户获得的赞（在个人主页显示）</span></span><br><span class="line">    <span class="comment">//value存int值就可以</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getUserLikeKey</span><span class="params">(<span class="type">int</span> userId)</span>&#123;</span><br><span class="line">        <span class="comment">//格式：like:user:userId</span></span><br><span class="line">        <span class="keyword">return</span> PREFIX_USER_LIKE + SPLIT + userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-开发Service层——LikeService"><a href="#2-开发Service层——LikeService" class="headerlink" title="2.开发Service层——LikeService"></a>2.开发Service层——LikeService</h2><p>开发完生成与点赞相关的key的工具类之后，我们就可以开发业务层了，因为Redis本身就是数据库，我们<strong>不需要开发DAO层</strong>，而是直接<strong>通过业务层</strong>来实现与Redis库的交互。</p>
<p>因为每次点赞既要更新当前对某个实体的赞，又要更新某个用户获得的赞的数量（用于个人主页查询）。所以要保证事务性，需要事务管理。</p>
<p>1）首先利用刚刚的工具类生成<strong>与点赞相关的key</strong>和<strong>与用户相关的key</strong>；</p>
<p>2）判断当前实体有没有被点过赞。</p>
<p>3）<u><strong>事务管理</strong></u>：如果点过赞就删掉key对应的value，同时让个人获得赞的数量-1；如果没点过赞，就<strong>把点赞的用户的userId</strong>传入value中，同时让个人获得赞的数量+1。</p>
<p>因为对于帖子这种实体，需要显示一共被点了多少赞，所以需要单独<strong>统计点赞数量</strong>——findEntityLikeCount</p>
<p>如果某个用户在<strong>登陆的状态</strong>下访问某个帖子，帖子会显示<strong>当前帖子或某个评论有没有被用户点过赞</strong>，如果点过，要显示已赞，当再次点击时就取消赞。所以需要单独查询<strong>某个用户对某个实体的点赞状态</strong>——findEntityLikeStatus</p>
<p>最后不要忘了查询某个<strong>用户获得的赞</strong>的数量（用于个人主页显示）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LikeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点赞</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">like</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType, <span class="type">int</span> entityId, <span class="type">int</span> entityUserId)</span>&#123;</span><br><span class="line">        <span class="comment">//因为点赞操作要涉及两次更新操作，所以要保证事务性</span></span><br><span class="line">        redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">SessionCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">                <span class="comment">//生成与点赞某个实体相关的key</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">entityLikeKey</span> <span class="operator">=</span> RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">                <span class="comment">//生成与某个用户获得点赞相关的key</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">userLikeKey</span> <span class="operator">=</span> RedisKeyUtil.getUserLikeKey(entityUserId);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//查看当前用户有没有对该实体点过赞</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> operations.opsForSet().isMember(entityLikeKey, userId);</span><br><span class="line">				<span class="comment">//此时才可以开启事务，因为Redis是把事务放到队列中等待事务提交后统一执行</span></span><br><span class="line">                operations.multi();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(isMember)&#123;</span><br><span class="line">                    operations.opsForSet().remove(entityLikeKey, userId);</span><br><span class="line">                    operations.opsForValue().decrement(userLikeKey);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果没有点过赞，就向key中添加userId作为value</span></span><br><span class="line">                    operations.opsForSet().add(entityLikeKey, userId);</span><br><span class="line">                    operations.opsForValue().increment(userLikeKey);</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//提交事务</span></span><br><span class="line">                <span class="keyword">return</span> operations.exec();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个实体被点赞的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">findEntityLikeCount</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">entityLikeKey</span> <span class="operator">=</span> RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().size(entityLikeKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某人对某实体的点赞状态（已赞还是赞）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findEntityLikeStatus</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType, <span class="type">int</span> entityId)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">entityLikeKey</span> <span class="operator">=</span> RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">        <span class="comment">//因为后续可能还有点踩的功能，所以我们当前返回0，1，将来点踩就返回-1</span></span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个用户获得的赞的数量（用于个人主页显示）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findUserLikeCount</span><span class="params">(<span class="type">int</span> userId)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userLikeKey</span> <span class="operator">=</span> RedisKeyUtil.getUserLikeKey(userId);</span><br><span class="line">        <span class="comment">//这里默认返回值是Object，需要手动强转为Integer类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> (Integer) redisTemplate.opsForValue().get(userLikeKey);</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="literal">null</span> ? <span class="number">0</span> : count.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Controller层——LikeController"><a href="#3-开发Controller层——LikeController" class="headerlink" title="3.开发Controller层——LikeController"></a>3.开发Controller层——LikeController</h2><p>首先我们不可能每次点赞都刷新网页，所以我们<strong>采用异步请求</strong>，返回JSON格式的字符串，所以用@ResponseBody注解。</p>
<p>首先获取当前登录的用户，执行点赞操作必然是<strong>当前的用户来执行</strong>，然后就可以<u>执行点赞操作</u>，获取<u>某个实体被点赞的数量</u>，还有<u>当前用户对某个实体的点赞状态</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LikeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LikeService likeService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/like&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>  <span class="comment">//因为是异步请求，所以是ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">like</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId, <span class="type">int</span> entityUserId)</span>&#123;</span><br><span class="line">        <span class="comment">//获取当前用户user</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line">        <span class="comment">//执行点赞操作</span></span><br><span class="line">        likeService.like(user.getId(), entityType, entityId, entityUserId);</span><br><span class="line">        <span class="comment">//获取某个实体中点赞的数量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">likeCount</span> <span class="operator">=</span> likeService.findEntityLikeCount(entityType, entityId);</span><br><span class="line">        <span class="comment">//当前用户对某个实体的点赞状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">likeStatus</span> <span class="operator">=</span> likeService.findEntityLikeStatus(user.getId(), entityType, entityId);</span><br><span class="line">        <span class="comment">//返回结果放到Map中</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;likeCount&quot;</span>, likeCount);</span><br><span class="line">        map.put(<span class="string">&quot;likeStatus&quot;</span>, likeStatus);</span><br><span class="line">        <span class="comment">//因为是异步请求，返回JSON格式数据</span></span><br><span class="line">        <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">0</span>, <span class="literal">null</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-在主页的查询帖子功能中增加查询点赞数量操作"><a href="#4-在主页的查询帖子功能中增加查询点赞数量操作" class="headerlink" title="4.在主页的查询帖子功能中增加查询点赞数量操作"></a>4.在主页的查询帖子功能中增加查询点赞数量操作</h2><p>只需要在HomeController类中的getIndexPage()方法中，添加累计点赞数量的操作即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主页只需要查询每个帖子的点赞数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">likeCount</span> <span class="operator">=</span> likeService.findEntityLikeCount(ENTITY_TYPE_POST, post.getId());</span><br><span class="line">map.put(<span class="string">&quot;likeCount&quot;</span>, likeCount);</span><br></pre></td></tr></table></figure>

<h2 id="5-在帖子详情页面中增加点赞的相关功能"><a href="#5-在帖子详情页面中增加点赞的相关功能" class="headerlink" title="5.在帖子详情页面中增加点赞的相关功能"></a>5.在帖子详情页面中增加点赞的相关功能</h2><p>只需要在DiscussPostController类的getDiscussPost()方法中，分别在帖子，评论，和评论的评论中增加点赞的操作即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//帖子</span></span><br><span class="line"><span class="comment">//点赞数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">likeCount</span> <span class="operator">=</span> likeService.findEntityLikeCount(ENTITY_TYPE_POST, discussPostId);</span><br><span class="line">model.addAttribute(<span class="string">&quot;likeCount&quot;</span>, likeCount);</span><br><span class="line"><span class="comment">//查询当前用户是否为当前帖子点过赞</span></span><br><span class="line"><span class="type">int</span> <span class="variable">likeStatus</span> <span class="operator">=</span> hostHolder.getUser() == <span class="literal">null</span> ? <span class="number">0</span> : likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_POST, discussPostId);</span><br><span class="line">model.addAttribute(<span class="string">&quot;likeStatus&quot;</span>, likeStatus);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//评论</span></span><br><span class="line"><span class="comment">//点赞数量</span></span><br><span class="line">likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">commentVo.put(<span class="string">&quot;likeCount&quot;</span>, likeCount);</span><br><span class="line"><span class="comment">//查询当前用户是否为当前评论点过赞</span></span><br><span class="line">likeStatus = hostHolder.getUser() == <span class="literal">null</span> ? <span class="number">0</span> : likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">commentVo.put(<span class="string">&quot;likeStatus&quot;</span>, likeStatus);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//评论的回复</span></span><br><span class="line"><span class="comment">//点赞数量</span></span><br><span class="line">likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, reply.getId());</span><br><span class="line">replyVo.put(<span class="string">&quot;likeCount&quot;</span>, likeCount);</span><br><span class="line"><span class="comment">//查询当前用户是否为当前评论点过赞</span></span><br><span class="line">likeStatus = hostHolder.getUser() == <span class="literal">null</span> ? <span class="number">0</span> : likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, reply.getId());</span><br><span class="line">replyVo.put(<span class="string">&quot;likeStatus&quot;</span>, likeStatus);</span><br></pre></td></tr></table></figure>

<h2 id="6-开发个人主页功能——UserController类的getProfilePage"><a href="#6-开发个人主页功能——UserController类的getProfilePage" class="headerlink" title="6.开发个人主页功能——UserController类的getProfilePage()"></a>6.开发个人主页功能——UserController类的getProfilePage()</h2><p>因为我们不仅可以查询当前登录的user的主页，也可以<strong>点击任何一个用户的头像就可以进入他的主页</strong>，所以我们在控制层要<strong>传入userId</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//个人主页</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/profile/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getProfilePage</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="type">int</span> userId, Model model)</span>&#123;</span><br><span class="line">    <span class="comment">//根据用户id获取用户user</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(userId);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该用户不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将用户user传给模板</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="comment">//查询当前用户user获得的点赞数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">likeCount</span> <span class="operator">=</span> likeService.findUserLikeCount(userId);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;likeCount&quot;</span>, likeCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/site/profile&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-16-关注、取消关注"><a href="#4-16-关注、取消关注" class="headerlink" title="4.16 关注、取消关注"></a>4.16 关注、取消关注</h1><h2 id="1-更新工具类——RedisKeyUtil"><a href="#1-更新工具类——RedisKeyUtil" class="headerlink" title="1.更新工具类——RedisKeyUtil"></a>1.更新工具类——RedisKeyUtil</h2><p>在生成key的工具类中更新两个方法，分别是生成<strong>关注者的key</strong>和<strong>粉丝的key</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisKeyUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key在拼接的过程中，:用来分割单词</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLIT</span> <span class="operator">=</span> <span class="string">&quot;:&quot;</span>;</span><br><span class="line">    <span class="comment">//声明前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_ENTITY_LIKE</span> <span class="operator">=</span> <span class="string">&quot;like:entity&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_USER_LIKE</span> <span class="operator">=</span> <span class="string">&quot;like:user&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_FOLLOWEE</span> <span class="operator">=</span> <span class="string">&quot;followee&quot;</span>;<span class="comment">//被关注的实体</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_FOLLOWER</span> <span class="operator">=</span> <span class="string">&quot;follower&quot;</span>;<span class="comment">//粉丝</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//某个用户关注的实体（谁userId关注的哪个实体entityType）</span></span><br><span class="line">    <span class="comment">//格式为：followee:userId:entityType  存储到zset有序集合中，存放的value是entityId，按照时间now先后排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFolloweeKey</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_FOLLOWEE + SPLIT + userId + SPLIT + entityType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//某个实体拥有的粉丝(entityType, entityId唯一标识某个实体)</span></span><br><span class="line">    <span class="comment">//格式为：follower:entityType:entityId  存储到zset有序集合中，存放的value是userId，按照时间now先后排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFollowerKey</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_FOLLOWER + SPLIT + entityType + SPLIT + entityId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-开发Service层——FollowService"><a href="#2-开发Service层——FollowService" class="headerlink" title="2.开发Service层——FollowService"></a>2.开发Service层——FollowService</h2><p>业务层主要有以下逻辑：对某个实体（用户、帖子等）的<strong>关注操作和取消关注的操作</strong>，因为我们只开发了关注用户的操作，所以<strong>这里的实体就是用户</strong>。因为关注的时候，既要<u><strong>增加被关注者的粉丝</strong></u>，又要<u><strong>增加当前用户的关注者</strong></u>，所以要保证这个事物的事务性。</p>
<p>另外个人主页还要显示某个用户的<strong>关注人数和粉丝人数</strong>，所以要分别声明这两个方法</p>
<p>最后是<strong>关注的状态</strong>，因为我们点击关注之后，再点击就会取消关注，所以这个<strong>当前登录的用户是否关注了本用户</strong>，需要将这个状态查询出来，向前端页面传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FollowService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关注操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="comment">//因为follow的业务要同时存储被关注的目标和目标的粉丝，所以要保证事务性</span></span><br><span class="line">        redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">SessionCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">                <span class="comment">//先分别创建关注和粉丝的key</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">followeeKey</span> <span class="operator">=</span> RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">                <span class="type">String</span> <span class="variable">followerKey</span> <span class="operator">=</span> RedisKeyUtil.getFollowerKey(entityType, entityId);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//开启事务</span></span><br><span class="line">                operations.multi();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//分别添加关注者key的value和粉丝key的value</span></span><br><span class="line">                operations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());</span><br><span class="line">                operations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> operations.exec();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消关注</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="comment">//因为unfollow的业务要同时删除被关注的目标和目标的粉丝，所以要保证事务性</span></span><br><span class="line">        redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">SessionCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">                <span class="comment">//先分别创建关注和粉丝的key</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">followeeKey</span> <span class="operator">=</span> RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">                <span class="type">String</span> <span class="variable">followerKey</span> <span class="operator">=</span> RedisKeyUtil.getFollowerKey(entityType, entityId);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//开启事务</span></span><br><span class="line">                operations.multi();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//分别删除关注者key的value和粉丝key的value</span></span><br><span class="line">                operations.opsForZSet().remove(followeeKey, entityId);</span><br><span class="line">                operations.opsForZSet().remove(followerKey, userId);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> operations.exec();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个用户关注实体的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">findFolloweeCount</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">followeeKey</span> <span class="operator">=</span> RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().zCard(followeeKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个实体（用户）的粉丝数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">findFollowerCount</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">followerKey</span> <span class="operator">=</span> RedisKeyUtil.getFollowerKey(entityType, entityId);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().zCard(followerKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前用户是否已关注该实体（用户）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasFollowed</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">followeeKey</span> <span class="operator">=</span> RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">        <span class="comment">//查看对应的key值是否有score</span></span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().score(followeeKey, entityId) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Controller层——FollowController"><a href="#3-开发Controller层——FollowController" class="headerlink" title="3.开发Controller层——FollowController"></a>3.开发Controller层——FollowController</h2><p>本步骤就是简单的视图层开发，添加两个操作，分别是<strong>关注和取关</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FollowController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FollowService followService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关注</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/follow&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">follow</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="comment">//这里其实需要用拦截器判断是否登录</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">        followService.follow(user.getId(), entityType, entityId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">0</span>, <span class="string">&quot;已关注！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取消关注</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/unfollow&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">        followService.unfollow(user.getId(), entityType, entityId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">0</span>, <span class="string">&quot;已取消关注！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-更新Controller层——UserController"><a href="#4-更新Controller层——UserController" class="headerlink" title="4.更新Controller层——UserController"></a>4.更新Controller层——UserController</h2><p>之前个人主页只有收集点赞数量的功能，本次加上收集**<u>关注数量</u><strong>，</strong><u>粉丝数量</u><strong>以及</strong><u>关注状态</u>**三个功能。</p>
<p>注意关注状态必须要求用户登录，如果用户没有登录，因为<strong>无法点击关注</strong>，所以就谈不上用户状态了，始终**<u>返回给前端页面一个“未关注”的状态</u>**即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//个人主页</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/profile/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getProfilePage</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="type">int</span> userId, Model model)</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(userId);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该用户不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="comment">//点赞数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">likeCount</span> <span class="operator">=</span> likeService.findUserLikeCount(userId);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;likeCount&quot;</span>, likeCount);</span><br><span class="line">    <span class="comment">//关注数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">followeeCount</span> <span class="operator">=</span> followService.findFolloweeCount(userId, ENTITY_TYPE_USER);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;followeeCount&quot;</span>, followeeCount);</span><br><span class="line">    <span class="comment">//粉丝数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">followerCount</span> <span class="operator">=</span> followService.findFollowerCount(ENTITY_TYPE_USER, userId);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;followerCount&quot;</span>, followerCount);</span><br><span class="line">    <span class="comment">//是否已关注，如果没登录默认显示关注</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasFollowed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//当前用户登陆了才可以点击关注</span></span><br><span class="line">    <span class="keyword">if</span>(hostHolder.getUser() != <span class="literal">null</span>) &#123;</span><br><span class="line">        hasFollowed = followService.hasFollowed(hostHolder.getUser().getId(), ENTITY_TYPE_USER, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;hasFollowed&quot;</span>, hasFollowed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/site/profile&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-19-关注列表、粉丝列表"><a href="#4-19-关注列表、粉丝列表" class="headerlink" title="4.19 关注列表、粉丝列表"></a>4.19 关注列表、粉丝列表</h1><h2 id="1-更新Service层——FollowService"><a href="#1-更新Service层——FollowService" class="headerlink" title="1.更新Service层——FollowService"></a>1.更新Service层——FollowService</h2><p>主要增加了查询<strong>某个用户的关注的所有人</strong>和<strong>粉丝所有人</strong>逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询某用户关注的人</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">findFollowees</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    <span class="comment">//创建关注者key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">followeeKey</span> <span class="operator">=</span> RedisKeyUtil.getFolloweeKey(userId, ENTITY_TYPE_USER);</span><br><span class="line">    <span class="comment">//获取followeeKey对应的value按照时间从大到小排列的集合，集合里边是value，也就是用户id</span></span><br><span class="line">    <span class="comment">//注意这里的Set被重写了，是有序的集合</span></span><br><span class="line">    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followeeKey, offset, offset + limit - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(targetIds == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Integer targetId : targetIds) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//根据targetId查询对应的用户user</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(targetId);</span><br><span class="line">        map.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="comment">//获取当前targetId用户的关注时间</span></span><br><span class="line">        <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> redisTemplate.opsForZSet().score(followeeKey, targetId);</span><br><span class="line">        <span class="comment">//将score转换为具体时间</span></span><br><span class="line">        map.put(<span class="string">&quot;followTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(score.longValue()));</span><br><span class="line">        list.add(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询某用户的粉丝</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">findFollowers</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">followerKey</span> <span class="operator">=</span> RedisKeyUtil.getFollowerKey(ENTITY_TYPE_USER, userId);</span><br><span class="line">    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followerKey, offset, offset + limit - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(targetIds == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Integer targetId : targetIds) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//根据targetId查询对应的用户user</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(targetId);</span><br><span class="line">        map.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="comment">//获取当前targetId用户的关注时间</span></span><br><span class="line">        <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> redisTemplate.opsForZSet().score(followerKey, targetId);</span><br><span class="line">        <span class="comment">//将score转换为具体时间</span></span><br><span class="line">        map.put(<span class="string">&quot;followTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(score.longValue()));</span><br><span class="line">        list.add(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-更新Controller层——FollowController"><a href="#2-更新Controller层——FollowController" class="headerlink" title="2.更新Controller层——FollowController"></a>2.更新Controller层——FollowController</h2><p>1）查看某个用户的<strong>关注列表</strong><u>getFollowees()</u></p>
<p>2）查看某个用户的<strong>粉丝列表</strong><u>getFollowers()</u></p>
<p>3）查看当前登陆的用户<strong>有没有关注</strong>列表中的某个用户userId——<u>hasFollowed()</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看某个用户(userId)的关注列表</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/followees/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getFollowees</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="type">int</span> userId, Page page, Model model)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(userId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该用户不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为关注列表的最上方需要显示当前关注列表是谁的列表，所以需要向前端页面传入user</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置分页信息</span></span><br><span class="line">    page.setLimit(<span class="number">5</span>);</span><br><span class="line">    page.setPath(<span class="string">&quot;/followees/&quot;</span> + userId);</span><br><span class="line">    <span class="comment">//调用查询关注者数量的方法，返回是long型，要进行强制转换</span></span><br><span class="line">    page.setRows((<span class="type">int</span>) followService.findFolloweeCount(userId, ENTITY_TYPE_USER));</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; userList = followService.findFollowees(userId, page.getOffset(), page.getLimit());</span><br><span class="line">    <span class="keyword">if</span>(userList != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Map&lt;String, Object&gt; map : userList) &#123;</span><br><span class="line">            <span class="comment">//关注列表中的每一个用户u</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User) map.get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            <span class="comment">//查询当前登录的用户user有没有关注列表中的某个指定的用户u</span></span><br><span class="line">            map.put(<span class="string">&quot;hasFollowed&quot;</span>, hasFollowed(u.getId()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;users&quot;</span>, userList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/site/followee&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看某个用户(userId)的粉丝列表</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/followers/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getFollowers</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="type">int</span> userId, Page page, Model model)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(userId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该用户不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为关注列表的最上方需要显示当前关注列表是谁的列表，所以需要向前端页面传入user</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置分页信息</span></span><br><span class="line">    page.setLimit(<span class="number">5</span>);</span><br><span class="line">    page.setPath(<span class="string">&quot;/followers/&quot;</span> + userId);</span><br><span class="line">    page.setRows((<span class="type">int</span>) followService.findFollowerCount(ENTITY_TYPE_USER, userId));</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; userList = followService.findFollowers(userId, page.getOffset(), page.getLimit());</span><br><span class="line">    <span class="keyword">if</span>(userList != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Map&lt;String, Object&gt; map : userList) &#123;</span><br><span class="line">            <span class="comment">//关注列表中的每一个用户u</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User) map.get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            <span class="comment">//查询当前登录的用户user有没有关注列表中的某个指定的用户u</span></span><br><span class="line">            map.put(<span class="string">&quot;hasFollowed&quot;</span>, hasFollowed(u.getId()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;users&quot;</span>, userList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/site/follower&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为列表中要显示登录用户(hostHolder.getUser)有没有关注过列表中的某个用户(userId)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasFollowed</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(hostHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果登陆了，就直接查询登录用户对userId的关注状态</span></span><br><span class="line">    <span class="keyword">return</span> followService.hasFollowed(hostHolder.getUser().getId(), ENTITY_TYPE_USER, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-23-优化登录模块-验证码、登陆凭证、用户信息"><a href="#4-23-优化登录模块-验证码、登陆凭证、用户信息" class="headerlink" title="4.23 优化登录模块(验证码、登陆凭证、用户信息)"></a>4.23 优化登录模块(验证码、登陆凭证、用户信息)</h1><h2 id="1-更新工具类——RedisKeyUtil-验证码"><a href="#1-更新工具类——RedisKeyUtil-验证码" class="headerlink" title="1.更新工具类——RedisKeyUtil(验证码)"></a>1.更新工具类——RedisKeyUtil(验证码)</h2><p>加一个验证码的key生成方法，因为验证码无法与某一个<strong>还未登录的用户</strong>绑定，所以要专门<strong>生成一个随机字符串</strong>来与验证码进行绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisKeyUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key在拼接的过程中，:用来分割单词</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLIT</span> <span class="operator">=</span> <span class="string">&quot;:&quot;</span>;</span><br><span class="line">    <span class="comment">//声明前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_KAPTCHA</span> <span class="operator">=</span> <span class="string">&quot;kaptcha&quot;</span>;<span class="comment">//验证码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//登录验证码(owner是用户的临时凭证)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getKaptchaKey</span><span class="params">(String owner)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_KAPTCHA + SPLIT + owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-重写Controller层——LoginController-验证码"><a href="#2-重写Controller层——LoginController-验证码" class="headerlink" title="2.重写Controller层——LoginController(验证码)"></a>2.重写Controller层——LoginController(验证码)</h2><p>之前是<strong>从session中</strong>获取验证码，但是这<strong>不利于后期分布式部署</strong>，所以我们本次通过将验证码存入Redis中，并设置<strong>生存时间</strong>，来提高验证码的访问效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取验证码功能</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/kaptcha&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getKaptcha</span><span class="params">(HttpServletResponse response<span class="comment">/*, HttpSession session*/</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//生成验证码</span></span><br><span class="line">    <span class="comment">//生成验证码字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> kaptchaProducer.createText();</span><br><span class="line">    <span class="comment">//生成验证码图片</span></span><br><span class="line">    <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> kaptchaProducer.createImage(text);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将验证码存入session</span></span><br><span class="line">        <span class="comment">//session.setAttribute(&quot;kaptcha&quot;, text);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证码的归属（属于哪个用户）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">kaptchaOwner</span> <span class="operator">=</span> CommunityUtil.generateUUID();</span><br><span class="line">    <span class="comment">//将临时凭证存入cookie中</span></span><br><span class="line">    <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;kaptchaOwner&quot;</span>, kaptchaOwner);</span><br><span class="line">    <span class="comment">//为该cookie设置生存时间：60s</span></span><br><span class="line">    cookie.setMaxAge(<span class="number">60</span>);</span><br><span class="line">    <span class="comment">//cookie在整个项目路径下都有效</span></span><br><span class="line">    cookie.setPath(contextPath);</span><br><span class="line">    <span class="comment">//将cookie发送给客户端</span></span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将验证码存入Redis中，设置生存时间为60s</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getKaptchaKey(kaptchaOwner);</span><br><span class="line">    redisTemplate.opsForValue().set(redisKey, text, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将图片输出给浏览器</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取response输出流（字节流）向浏览器响应</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">//用javax工具类输出图片</span></span><br><span class="line">        ImageIO.write(image, <span class="string">&quot;png&quot;</span>, os);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;响应验证码失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//登录功能</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/login&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password, String code, <span class="type">boolean</span> rememberme,</span></span><br><span class="line"><span class="params">                    Model model<span class="comment">/*, HttpSession session*/</span>, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                    <span class="meta">@CookieValue(&quot;kaptchaOwner&quot;)</span> String kaptchaOwner)</span>&#123;</span><br><span class="line">    <span class="comment">//检查验证码</span></span><br><span class="line">        <span class="comment">//String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;);</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">kaptcha</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//从cookie中取到临时凭证，若非空，则根据凭证创建key，并获得验证码</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotBlank(kaptchaOwner)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getKaptchaKey(kaptchaOwner);</span><br><span class="line">        kaptcha = (String) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code))&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;codeMsg&quot;</span>, <span class="string">&quot;验证码不正确！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/login&quot;</span>;<span class="comment">//回到登录页面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查账号，密码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expiredSeconds</span> <span class="operator">=</span> rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;</span><br><span class="line">    Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds);</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(<span class="string">&quot;ticket&quot;</span>))&#123;</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;ticket&quot;</span>, map.get(<span class="string">&quot;ticket&quot;</span>).toString());</span><br><span class="line">        <span class="comment">//生成cookie有效路径</span></span><br><span class="line">        cookie.setPath(contextPath);</span><br><span class="line">        <span class="comment">//设置cookie有效时间</span></span><br><span class="line">        cookie.setMaxAge(expiredSeconds);</span><br><span class="line">        <span class="comment">//将cookie加入到response中，响应时就会将cookie发送给浏览器</span></span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;usernameMsg&quot;</span>, map.get(<span class="string">&quot;usernameMsg&quot;</span>));</span><br><span class="line">        model.addAttribute(<span class="string">&quot;passwordMsg&quot;</span>, map.get(<span class="string">&quot;passwordMsg&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-更新工具类——RedisKeyUtil-登陆凭证"><a href="#3-更新工具类——RedisKeyUtil-登陆凭证" class="headerlink" title="3.更新工具类——RedisKeyUtil(登陆凭证)"></a>3.更新工具类——RedisKeyUtil(登陆凭证)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisKeyUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key在拼接的过程中，:用来分割单词</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLIT</span> <span class="operator">=</span> <span class="string">&quot;:&quot;</span>;</span><br><span class="line">    <span class="comment">//声明前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_TICKET</span> <span class="operator">=</span> <span class="string">&quot;ticket&quot;</span>;<span class="comment">//登陆凭证</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//登录凭证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getTicketKey</span><span class="params">(String ticket)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_TICKET + SPLIT + ticket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-废弃DAO层——LoginTicketMapper-登陆凭证"><a href="#4-废弃DAO层——LoginTicketMapper-登陆凭证" class="headerlink" title="4.废弃DAO层——LoginTicketMapper(登陆凭证)"></a>4.废弃DAO层——LoginTicketMapper(登陆凭证)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Deprecated</span><span class="comment">//声明本方法不推荐使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoginTicketMapper</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-重写Service层——UserService-登录凭证"><a href="#5-重写Service层——UserService-登录凭证" class="headerlink" title="5.重写Service层——UserService(登录凭证)"></a>5.重写Service层——UserService(登录凭证)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">login</span><span class="params">(String username, String password, <span class="type">int</span> expiredSeconds)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//空值处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证账号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证状态（注册后有没有激活）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证密码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成登录凭证</span></span><br><span class="line">        <span class="type">LoginTicket</span> <span class="variable">loginTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginTicket</span>();</span><br><span class="line">        loginTicket.setUserId(user.getId());</span><br><span class="line">        loginTicket.setTicket(CommunityUtil.generateUUID());</span><br><span class="line">        loginTicket.setStatus(<span class="number">0</span>);</span><br><span class="line">        loginTicket.setExpired(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expiredSeconds * <span class="number">1000</span>));</span><br><span class="line"><span class="comment">//        loginTicketMapper.insertLoginTicket(loginTicket);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getTicketKey(loginTicket.getTicket());</span><br><span class="line">        <span class="comment">//Redis自动将loginTicket对象转换为JSON格式的字符串</span></span><br><span class="line">        redisTemplate.opsForValue().set(redisKey, loginTicket);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//也可以传入loginTicket整个对象，但没必要，我们只需要登陆凭证，其他的登录信息可以用凭证去库里查</span></span><br><span class="line">        map.put(<span class="string">&quot;ticket&quot;</span>, loginTicket.getTicket());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(String ticket)</span>&#123;</span><br><span class="line"><span class="comment">//      废弃loginTicketMapper.updateStatus(ticket, 1);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先把ticket从redis中取出来，然后再更新状态为1，最后再存回去</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getTicketKey(ticket);</span><br><span class="line">        <span class="type">LoginTicket</span> <span class="variable">loginTicket</span> <span class="operator">=</span> (LoginTicket)redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">        loginTicket.setStatus(<span class="number">1</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(redisKey, loginTicket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LoginTicket <span class="title function_">findLoginTicket</span><span class="params">(String ticket)</span>&#123;</span><br><span class="line"><span class="comment">//      废弃return loginTicketMapper.selectByTicket(ticket);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//直接从Redis中获取凭证ticket</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getTicketKey(ticket);</span><br><span class="line">        <span class="keyword">return</span> (LoginTicket) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-更新工具类——RedisKeyUtil-用户信息"><a href="#6-更新工具类——RedisKeyUtil-用户信息" class="headerlink" title="6.更新工具类——RedisKeyUtil(用户信息)"></a>6.更新工具类——RedisKeyUtil(用户信息)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisKeyUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key在拼接的过程中，:用来分割单词</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLIT</span> <span class="operator">=</span> <span class="string">&quot;:&quot;</span>;</span><br><span class="line">    <span class="comment">//声明前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_USER</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;<span class="comment">//用户信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getUserKey</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_USER + SPLIT + userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-更新Service层——UserService-用户信息"><a href="#7-更新Service层——UserService-用户信息" class="headerlink" title="7.更新Service层——UserService(用户信息)"></a>7.更新Service层——UserService(用户信息)</h2><p>三个<u>添加</u>：</p>
<p>1）在userService类中构造getCache()，表明所有查询user的业务<strong>先从Redis中查询</strong></p>
<p>2）Redis查询不到user，就<strong>从MySQL中查询</strong>，然后<strong>放到Redis库中</strong></p>
<p>3）涉及到<strong>user信息变更</strong>的业务，需要<strong>清除</strong>Redis中存储的user</p>
<p>三个<u>更新</u>：</p>
<ul>
<li>更改findUserById()，之前是从数据库中查询user，<strong>效率低</strong>，改为直接从Redis中查询</li>
<li>更改activation()，激活步骤中可能会<strong>更新用户的激活状态</strong>，更新后要清除Redis关于该user的缓存</li>
<li>更改updateHeader()，本方法<strong>更改了用户头像</strong>，要清除Redis关于该user的缓存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.优先从缓存中取值</span></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">getCache</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getUserKey(userId);</span><br><span class="line">        <span class="keyword">return</span> (User) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.取不到数据就初始化缓存数据(从mysql中取数据存到redis中)</span></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">initCache</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(userId);</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getUserKey(userId);</span><br><span class="line">        redisTemplate.opsForValue().set(redisKey, user, <span class="number">3600</span>, TimeUnit.SECONDS);<span class="comment">//设置1h过期时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.数据变更时清除缓存数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clearCache</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getUserKey(userId);</span><br><span class="line">        redisTemplate.delete(redisKey);</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过用户id查找用户信息user</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line"><span class="comment">//      废弃return userMapper.selectById(id);</span></span><br><span class="line">        <span class="comment">//改从Redis中取user，取不到就去数据库找到并init-Redis库，然后返回user</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getCache(id);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">            user = initCache(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//激活</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">activation</span><span class="params">(<span class="type">int</span> userId, String code)</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(userId);</span><br><span class="line">        <span class="keyword">if</span>(user.getStatus() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ACTIVATION_REPEAT;<span class="comment">//如果用户状态已经为1，说明当前是重复激活</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(user.getActivationCode().equals(code))&#123;</span><br><span class="line">            userMapper.updateStatus(userId, <span class="number">1</span>);<span class="comment">//如果用户状态不为1，而且当前激活码满足条件，就把状态设为1</span></span><br><span class="line">            <span class="comment">//因为更新了用户信息，所以清除缓存中用户的信息</span></span><br><span class="line">            clearCache(userId);</span><br><span class="line">            <span class="keyword">return</span> ACTIVATION_SUCCESS;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ACTIVATION_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新用户头像</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateHeader</span><span class="params">(<span class="type">int</span> userId, String headerUrl)</span>&#123;</span><br><span class="line"><span class="comment">//      废弃return userMapper.updateHeader(userId, headerUrl);</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.updateHeader(userId, headerUrl);</span><br><span class="line">        <span class="comment">//因为更新了用户信息，所以清除缓存中用户的信息</span></span><br><span class="line">        clearCache(userId);</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/13/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/" data-id="cl34jfrpo0000agv65zyw0788" data-title="我的项目" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-05-13T06:38:33.000Z" itemprop="datePublished">2022-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/">计算机网络笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="路由器相关知识"><a href="#路由器相关知识" class="headerlink" title="路由器相关知识"></a>路由器相关知识</h2><ol>
<li>MAC头部的作用就是<strong>将包传送到路由器</strong>，其中的接收方MAC地址，就是路由器端口的MAC地址。所以，当包到达了路由器，MAC头部任务就完成了，<strong>MAC头部即被丢弃</strong>。</li>
<li>在网络包的传输过程中，<strong>源IP和目标IP始终不变</strong>，而为了两两设备在以太网中传输，必须<strong>实时变化MAC地址</strong>。</li>
<li>在发送数据包的时候，<strong>如果目标主机不是本地局域网内的主机，那MAC地址填入的是路由器地址</strong>，通过路由器的层层转发，<strong>一直转发到目标主机的路由器</strong>，发现IP地址是自己局域网内的主机，就会通过ARP请求<strong>获取目标主机的MAC地址</strong>，进而转发到这个服务器主机。</li>
</ol>
<h2 id="GET和POST区别？"><a href="#GET和POST区别？" class="headerlink" title="GET和POST区别？"></a>GET和POST区别？</h2><p>GET请求的参数一般<strong>写在URL中</strong>，URL规定<strong>只能支持ASCII</strong>，虽然HTTP协议并没有限制URL长度，但是<strong>浏览器自身会对URL长度有限制</strong>。</p>
<p>POST请求的参数一般<strong>放在请求报文（body）中</strong>，body参数<strong>没有格式限制</strong>，只要浏览器和服务器都可接受就行，而且body参数的<strong>长度没有限制</strong>。</p>
<h2 id="HTTPS和HTTP"><a href="#HTTPS和HTTP" class="headerlink" title="HTTPS和HTTP"></a>HTTPS和HTTP</h2><p>前者就是在HTTP的基础上，在TCP和HTTP之间添加了一层SSL&#x2F;TLS安全协议，使得报文能够加密传输。</p>
<p>所以HTTPS不仅要进行TCP的三次握手，还要接着进行SSL&#x2F;TLS握手判断，才可以加密传输报文。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png" alt="HTTP 与 HTTPS 网络层"  />

<h2 id="HTTP对应OSI模型哪几层？"><a href="#HTTP对应OSI模型哪几层？" class="headerlink" title="HTTP对应OSI模型哪几层？"></a>HTTP对应OSI模型哪几层？</h2><p>用来管理通信连接的<strong>会话层</strong>，转换数据格式的<strong>表示层</strong>，与对端主机交互的<strong>应用层</strong>。</p>
<h2 id="应用层各大常见协议"><a href="#应用层各大常见协议" class="headerlink" title="应用层各大常见协议"></a>应用层各大常见协议</h2><h3 id="1-TELNET：远程登陆协议"><a href="#1-TELNET：远程登陆协议" class="headerlink" title="1. TELNET：远程登陆协议"></a>1. TELNET：远程登陆协议</h3><p>建立在TCP协议之上，通过一个终端登录到其他远端的服务器。<strong>最大缺点：明文传输</strong>，所以有了SSH</p>
<h3 id="2-SSH（Secure-Shell）：安全的网络传输协议"><a href="#2-SSH（Secure-Shell）：安全的网络传输协议" class="headerlink" title="2. SSH（Secure Shell）：安全的网络传输协议"></a>2. SSH（Secure Shell）：安全的网络传输协议</h3><p>有效防止远程管理过程中的信息泄露，加密传输，也是建立在TCP协议之上的。</p>
<h3 id="3-FTP：文件传输协议"><a href="#3-FTP：文件传输协议" class="headerlink" title="3. FTP：文件传输协议"></a>3. FTP：文件传输协议</h3><p>FTP是在两个“相连”的计算机之间进行文件传输的协议</p>
<p>最大特点：<strong>两条TCP连接</strong>，一条用于<strong>传送控制信息</strong>，比如：登录验证，发送文件的名称，发送方式部署等；另一条用于<strong>专门传输数据</strong>。</p>
<h3 id="4-SMTP（Simple-Mail-Transfer-Protocol）：简单邮件传输-发送-协议"><a href="#4-SMTP（Simple-Mail-Transfer-Protocol）：简单邮件传输-发送-协议" class="headerlink" title="4. SMTP（Simple Mail Transfer Protocol）：简单邮件传输(发送)协议"></a>4. SMTP（Simple Mail Transfer Protocol）：简单邮件传输(发送)协议</h3><p><strong>用来发送</strong>邮件的协议，<strong>只支持发送端主机行为</strong>，所以不会根据接收端的请求发送，而是根据发送端请求进行发送。</p>
<p>虽然建立在TCP协议上保证了传输的可靠性，但内容不能保证可靠，因为没有身份验证功能。所以现在规定“POP before SMTP”或者“SMTP认证”。</p>
<p>以前的邮件发送需要两端都要保持插电，很不友好，现在是<strong>一端发给服务器A，A发给服务器B，另一端从B接收</strong>。</p>
<h3 id="5-POP（Post-Office-Protocol）：邮局协议"><a href="#5-POP（Post-Office-Protocol）：邮局协议" class="headerlink" title="5. POP（Post Office Protocol）：邮局协议"></a>5. POP（Post Office Protocol）：邮局协议</h3><p><strong>用来接收</strong>邮件的协议，前面发送端的邮件通过SMTP<strong>发送给一直插电的POP服务器</strong>，接收端再根据POP从POP服务器把邮件“拿过来”。</p>
<p>注意：POP就有<strong>用户验证</strong>喽！</p>
<h3 id="6-IMAP（Internet-Message-Access-Protocol）：交互邮件访问协议"><a href="#6-IMAP（Internet-Message-Access-Protocol）：交互邮件访问协议" class="headerlink" title="6. IMAP（Internet Message Access Protocol）：交互邮件访问协议"></a>6. IMAP（Internet Message Access Protocol）：交互邮件访问协议</h3><p>与POP区别就是，POP是客户端管理邮件，而IMAP是<strong>服务器管理邮件</strong>。</p>
<p>这带来了极大的方便：比如我电脑已读某个邮件，那么手机也显示我读了，因为我是<strong>在一致的服务器处理</strong>了MIME信息。所以可以<strong>实现多终端同步的效果</strong>。</p>
<h2 id="电子邮箱发送过程？"><a href="#电子邮箱发送过程？" class="headerlink" title="电子邮箱发送过程？"></a>电子邮箱发送过程？</h2><p>比如一个163邮箱向一个QQ邮箱发邮件：</p>
<p>1）通过SMTP，163邮箱将邮件发给163邮箱服务器</p>
<p>2）163服务器发给QQ服务器</p>
<p>3）QQ服务器通知该QQ邮箱来取邮件，要通过POP&#x2F;IMAP取</p>
<h2 id="如何判断邮箱真正存在？"><a href="#如何判断邮箱真正存在？" class="headerlink" title="如何判断邮箱真正存在？"></a>如何判断邮箱真正存在？</h2><p>1）通过邮箱域名查找到对应的SMTP服务器地址（你家在哪？）</p>
<p>2）尝试与该服务器建立连接（找到你家）</p>
<p>3）服务器尝试向该邮箱发送邮件（你家给你打电话）</p>
<p>4）根据该邮箱返回结果判断真假（听听是自己儿子声音不）</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>首先，<strong>IP是面向无连接的</strong>，它尽管去传输，面向连接要交给它的上层TCP。</p>
<p>一开始分为ABCDE五类，都具有两个部分：网络号和主机号。其中D类用于多播（广播无法穿透路由，所以有了多播），E还没用</p>
<p>缺点：ABC所包含的主机数相差太大，不符合实际应用。</p>
<h3 id="无类别域间路由CIDR-Classless-Inter-Domain-Routing"><a href="#无类别域间路由CIDR-Classless-Inter-Domain-Routing" class="headerlink" title="无类别域间路由CIDR(Classless Inter-Domain Routing)"></a>无类别域间路由CIDR(Classless Inter-Domain Routing)</h3><p>所以有了无分类地址的CIDR：灵活分配网络号和主机号（32拆成两大部分）。这里有子网掩码的概念，<strong>掩码的意思是掩盖掉主机号。将子网掩码和IP地址按位计算AND，就可以得到网络号</strong>。</p>
<p>分离网络号和主机号的目的就是：同一个网络就<strong>直接本地传输</strong>了，不同网络我们再去通过路由向外传输。</p>
<p>下面是子网划分的示意图（<u>还没搞懂它的意义</u>）：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/18.jpg" alt="img"></p>
<h3 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h3><p>其实就是主机向另一个主机传输，如果需要跨网，就要通过路由器来路由。</p>
<p>注意：<strong>环回地址</strong>是特殊的IP地址，为127.0.0.1。localhost和它意义一样，使用这俩时，<strong>数据包不会流向网络</strong>。</p>
<h3 id="IP分片与重组"><a href="#IP分片与重组" class="headerlink" title="IP分片与重组"></a>IP分片与重组</h3><p>因为IP传输过程中，数据包要通过数据链路传输，所以要根据数据链路的最大传输单元MTU来对IP分片。</p>
<p>需要注意的时：<strong>IP在路由器上不会重组，只会在目标主机才重组</strong>。</p>
<h3 id="IPv6与IPv4"><a href="#IPv6与IPv4" class="headerlink" title="IPv6与IPv4"></a>IPv6与IPv4</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/30.jpg" alt=" IPv6 中的单播通信" style="zoom:50%;" />

<p>6比4多加了个<strong>链路本地单播地址</strong>，用于不走路由器的本数据链路传播。其他的像v6的<strong>唯一本地地址</strong>相当于v4的私有IP，v6的<strong>全局单播地址</strong>相当于v4的共有IP。</p>
<h4 id="IPv6相比IPv4的首部改进："><a href="#IPv6相比IPv4的首部改进：" class="headerlink" title="IPv6相比IPv4的首部改进："></a>IPv6相比IPv4的首部改进：</h4><p>1）<strong>取消首部校验和字段</strong>：因为数据链路层和传输层都要校验，所以v6直接取消了IP校验</p>
<p>2）<strong>取消分片&#x2F;重新组装相关字段</strong>：中间路由器不准分片和重组了</p>
<p>3）<strong>取消选项字段</strong></p>
<h2 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>解析域名的</p>
<h3 id="ARP（有缓存）"><a href="#ARP（有缓存）" class="headerlink" title="ARP（有缓存）"></a>ARP（有缓存）</h3><p>根据IP地址查询MAC地址的，主机A想找主机B的IP对应的MAC地址，就要先<strong>在同一数据链路下进行广播</strong>发送一个ARP请求包，包内<strong>包含了主机B的IP地址</strong>。</p>
<p>RARP就是通过MAC获取IP，一般在无法通过DHCP获取IP的情况下应用到。</p>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>1）DHCP客户端也就是没有IP地址的客户端<strong>发送DHCP发现报文</strong>（DHCP DISCOVER），在数据链路中以<strong>广播</strong>形式发送；</p>
<p>2）DHCP服务器收到后向客户端响应（还是广播），发送的是<strong>DHCP提供报文</strong>（DHCP OFFER），报文包括：可租约的IP地址，子网掩码，默认网关，DNS服务器以及<strong>IP地址租用期</strong>。</p>
<p>3）客户端可能收到多个DHCP发来的报文，选一个并向该服务器发送<strong>DHCP请求报文</strong>（DHCP REQUEST）</p>
<p>4）服务器发送DHCP响应报文（<strong>DHCP ACK</strong>），应答所要求的参数。</p>
<p>5）如果<strong>IP快到期</strong>了，客户端继续向服务器发送DHCP请求报文来申请。</p>
<p>DHCP交互中，<strong>全程都是UDP广播通信</strong>，为了解决不在同一个局域网的通信，出现了<strong>DHCP中继代理</strong>，相当于以前政府直接交涉，现在交给小区居委会代理，居委会负责找政府要IP。（链路广播，中继单播）</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/37.jpg" alt=" DHCP 中继代理" style="zoom:50%;" />

<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>把私有IP转换为公有IP，如果不加点什么这个好像没啥用，所以有了NAPT</p>
<p>NAPT就是<strong>将私有IP转换为IP地址＋端口号</strong>，这正是利用了网络传输需要使用传输层协议的特点。</p>
<p>每次转换都是在NAPT路由器上生成一张转换表，TCP首次握手发出SYN包的时候就<strong>生成了这个表</strong>，关闭连接时候FIN包发送的时候<strong>表就删掉了</strong>。</p>
<p>NAT&#x2F;NAPT依赖自己的转换表，带来的以下不足：</p>
<p>1）外部无法与NAT内部服务器建立连接（不懂）</p>
<p>2）转换表的生成和转换操作有性能开销</p>
<p>3）NAT路由器一旦重启，所有TCP连接都要重置</p>
<p>如何解决：</p>
<p>1）改用IPv6。</p>
<p>2）NAT穿透技术：就是客户端<strong>主动从NAT设备获取共有IP地址</strong>，然后<strong>自己建立端口映射条目</strong>，不用NAT来建立了。</p>
<h2 id="ICMP（Internet-Control-Message-Protocol）"><a href="#ICMP（Internet-Control-Message-Protocol）" class="headerlink" title="ICMP（Internet Control Message Protocol）"></a>ICMP（Internet Control Message Protocol）</h2><p>用来确认IP包是否成功发送到目标地址，报告IP被遗弃的原因，报告改善网络设置等。包括两类（橘色和黄色），如下：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/41.jpg" alt="常见的 ICMP 类型" style="zoom:33%;" />

<h3 id="IGMP（不懂）"><a href="#IGMP（不懂）" class="headerlink" title="IGMP（不懂）"></a>IGMP（不懂）</h3><p>组播地址不是IP地址，一般用于UDP协议</p>
<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzYuanBn?x-oss-process=image/format,png" alt="TCP 头格式" style="zoom: 40%;" />

<p>TCP四元组（源地址、源端口、目标地址、目标端口）可以<strong>唯一确定一个连接</strong>。</p>
<p>最大的<strong>TCP连接数</strong> &#x3D; 客户端**<u>IP数</u>** × 客户端<u><strong>端口数</strong></u>。实际远没有这么多，连接数还受<strong>文件描述符和内存</strong>的制约。</p>
<h3 id="为什么UDP头部没有首部长度字段，而TCP头部有？"><a href="#为什么UDP头部没有首部长度字段，而TCP头部有？" class="headerlink" title="为什么UDP头部没有首部长度字段，而TCP头部有？"></a>为什么UDP头部没有首部长度字段，而TCP头部有？</h3><p>因为TCP头部存在<strong>可变长的选项字段</strong>，而UDP头部长度始终不变。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEyLmpwZw?x-oss-process=image/format,png" alt="UDP 头部格式" style="zoom:50%;" />

<h3 id="为什么TCP头部没有包长度字段，而UDP头部有？"><a href="#为什么TCP头部没有包长度字段，而UDP头部有？" class="headerlink" title="为什么TCP头部没有包长度字段，而UDP头部有？"></a>为什么TCP头部没有包长度字段，而UDP头部有？</h3><p>UDP头部虽然只有四部分，但它<strong>比TCP多一个包长度</strong>（头部+数据的总长度），<strong>TCP的包长可由IP层获知</strong>。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEzLmpwZw?x-oss-process=image/format,png" alt="img" style="zoom:50%;" />

<h3 id="TCP和UDP各自的应用场景？"><a href="#TCP和UDP各自的应用场景？" class="headerlink" title="TCP和UDP各自的应用场景？"></a>TCP和UDP各自的应用场景？</h3><p>TCP可靠，所以多应用于FTP文件传输，HTTP&#x2F;HTTPS</p>
<p>UDP可以随时发送，高效。所以多应用于包较少的通信，如DNS、SNMP(Simple Network Management Protocol)等；视频，音频等；广播通信</p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>第三次握手<strong>可以携带数据</strong>，前两次握手不可携带数据。</p>
<p><u>三次握手意义</u>：阻止重复历史连接的初始化（<strong>主要意义</strong>），同步双方初始序列号，避免资源浪费。</p>
<p>每次<u>初始化序列号不一样的意义</u>：很大程度避免<strong>历史报文被下一个相同四元组的连接接收</strong>。</p>
<p>TCP头部字段的<strong>序列号</strong>和TCP建立连接的<strong>初始序列号都不是无限递增</strong>的，会发生<strong>回绕为初始值</strong>的情况，所以无法通过序列号来<strong>判断新老数据</strong>。</p>
<p>MTU和MSS的区别如下：</p>
<p>MTU(Maximum Transmission Unit)</p>
<p>MSS(Maximum Segment size)</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzIzLmpwZw?x-oss-process=image/format,png" alt="MTU 与 MSS"></p>
<h4 id="为什么TCP的整个报文（头部-数据）不交给IP分片？"><a href="#为什么TCP的整个报文（头部-数据）不交给IP分片？" class="headerlink" title="为什么TCP的整个报文（头部+数据）不交给IP分片？"></a>为什么TCP的整个报文（头部+数据）不交给IP分片？</h4><p>因为IP分片丢失，整个IP报文的<strong>所有分片都需要重传</strong>（IP层无响应，无超时重传机制）。</p>
<p>而TCP以MSS为单位分片后，某个TCP分片丢失，也是<strong>以MSS为单位重发</strong>的，重传效率大大增加。</p>
<h4 id="三次握手分别丢失的情况"><a href="#三次握手分别丢失的情况" class="headerlink" title="三次握手分别丢失的情况"></a>三次握手分别丢失的情况</h4><p><u>第一次握手丢失</u>：<strong>超时重传</strong>（默认逐次等1s, 2s, 4s, 16s, 32s），32s后仍没回应，不传了，直接断开TCP连接</p>
<p><u>第二次握手丢失</u>：客户端没收到ACK，触发超时重传，<strong>重传SYN报文</strong>；服务端没收到客户端的ACK（第三次握手），触发超时重传，<strong>重传SYN-ACK报文</strong>。</p>
<p><u>第三次握手丢失</u>：服务端<strong>重传SYN-ACK报文</strong>。</p>
<p>Linux半连接队列（SYN队列）和全连接队列（Accept队列）：</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzI2LmpwZw?x-oss-process=image/format,png" alt="正常流程" style="zoom:50%;" />

<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzMwLmpwZw?x-oss-process=image/format,png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom:50%;" />

<p><strong>主动关闭连接的一端</strong>才有TIME_WAIT状态。</p>
<h4 id="四次挥手分别丢失的情况"><a href="#四次挥手分别丢失的情况" class="headerlink" title="四次挥手分别丢失的情况"></a>四次挥手分别丢失的情况</h4><p><u>第一次挥手丢失</u>：客户端重传FIN报文，超过一定次数，直接进入close状态；</p>
<p><u>第二次挥手丢失</u>：因为<strong>ACK报文不会重传</strong>，所以还是客户端重传FIN报文，直到超过最大重传次数；</p>
<p><u>第三次挥手丢失</u>：<strong>服务端</strong>重发FIN报文，与客户端机制一样；</p>
<p><u>第四次挥手丢失</u>：<strong>服务端</strong>重发FIN报文。</p>
<h4 id="为什么TIME-WAIT等待时间是2MSL？"><a href="#为什么TIME-WAIT等待时间是2MSL？" class="headerlink" title="为什么TIME_WAIT等待时间是2MSL？"></a>为什么TIME_WAIT等待时间是2MSL？</h4><p>MSL（Maximum Segment Lifetime）报文最大生存时间，单位是时间，超时即丢弃。因为TCP基于IP协议，IP头部有TTL字段，是IP数据包可经过的最大路由数。TTL一般是64，Linux的MSL默认为30s，意味着<strong>Linux认为报文经过64个路由器的时间不超过30s</strong>。</p>
<p>其实2MSL时长是<strong>至少允许报文丢失一次</strong>。比如ACK在一个MSL内丢失，被动方重发的FIN会在第二个MSL内到达，TIME_WAIT就可以应对。如果一次ACK或一次FIN走不了一个MSL，那就很可能可以允许丢失两次、三次……所以2MSL时长至少允许一次报文丢失。</p>
<h4 id="为什么需要TIME-WAIT状态？"><a href="#为什么需要TIME-WAIT状态？" class="headerlink" title="为什么需要TIME_WAIT状态？"></a>为什么需要TIME_WAIT状态？</h4><p>①防止<strong>历史连接中的数据</strong>，被后面相同四元组的连接错误的接收；</p>
<p>②保证<strong>被动关闭连接的一方</strong>，能被正确的关闭。</p>
<h4 id="TIME-WAIT过多的危害？"><a href="#TIME-WAIT过多的危害？" class="headerlink" title="TIME_WAIT过多的危害？"></a>TIME_WAIT过多的危害？</h4><p>①客户端（发起连接方）<strong>端口资源</strong>被过多地占用；</p>
<p>②服务端（被动连接方）受<strong>系统资源</strong>限制。</p>
<h4 id="建立连接后，客户端突然出故障怎么办？"><a href="#建立连接后，客户端突然出故障怎么办？" class="headerlink" title="建立连接后，客户端突然出故障怎么办？"></a>建立连接后，客户端突然出故障怎么办？</h4><p>TCP存在保活机制，一段时间内没有任何连接活动，就每隔一个时间间隔发送一个探测报文。</p>
<h4 id="建立连接后，服务端突然出故障怎么办？"><a href="#建立连接后，服务端突然出故障怎么办？" class="headerlink" title="建立连接后，服务端突然出故障怎么办？"></a>建立连接后，服务端突然出故障怎么办？</h4><p>服务端发送FIN报文，与客户端进行四次挥手。</p>
<h2 id="TCP重传机制、滑动窗口、流量控制、拥塞控制"><a href="#TCP重传机制、滑动窗口、流量控制、拥塞控制" class="headerlink" title="TCP重传机制、滑动窗口、流量控制、拥塞控制"></a>TCP重传机制、滑动窗口、流量控制、拥塞控制</h2><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>RTT（Round-Trip Time往返时延）就是数据发送时刻到接收到确认时刻的差值，是动态变化的。</p>
<p>RTO（Retransmission Timeout超时重传时间），RTO要略大于RTT</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/8.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="RTO 应略大于 RTT" style="zoom: 67%;" />

<p>每当遇到一次超时重传，TCP都会将下一次超时重传时间间隔<strong>设为先前值的两倍</strong>。</p>
<h4 id="Linux如何计算RTO？"><a href="#Linux如何计算RTO？" class="headerlink" title="Linux如何计算RTO？"></a>Linux如何计算RTO？</h4><p>1）采样RTT时间，作<strong>加权平均</strong>，这个值不断变化</p>
<p>2）采样RTT<strong>波动范围</strong></p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>这种机制是<strong>数据驱动</strong>，而不是时间驱动。如下图，没收到就会<strong>一直传没收到2的ACK</strong>，连续收到<strong>3个</strong>就重传。</p>
<p>但是这种机制的弊端是：不知道重传2还是重传2、3、4、5，发送端不知道连续的3个ACK是谁传回来的。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传机制" style="zoom: 67%;" />

<h3 id="SACK方法（Selectice-ACK选择性确认）"><a href="#SACK方法（Selectice-ACK选择性确认）" class="headerlink" title="SACK方法（Selectice ACK选择性确认）"></a>SACK方法（Selectice ACK选择性确认）</h3><p>这种方式需要TCP头部的选项字段加一个SACK，它可以将缓存的地图发给发送方，这样发送方就知道哪些被收到了，哪些没被收到。然后就可以只重传丢失的数据了。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/11.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="选择性确认" style="zoom: 40%;" />

<p>Duplicate SACK（D-SACK）主要**使用了SACK来告诉[发送方]**有哪些数据被重复接收了。</p>
<p>D-SACK优点：</p>
<p>1）可以让[发送方]知道是<strong>包丢了</strong>还是对面的应答<strong>ACK丢了</strong>；</p>
<p>2）可以知道[发送方]的包是不是<strong>被网络延时</strong>了；</p>
<p>3）可以知道[发送方]的包是不是被<strong>网络复制</strong>了。（不懂）</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><u>窗口大小</u>：<strong>无需等待ACK</strong>而可以<strong>连续发送数据</strong>的最大值。</p>
<p><u>累计确认&#x2F;累计应答</u>：如下图：ACK 600没到<strong>但是ACK 700到了</strong>，也能说明前面的数据都收到了。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="用滑动窗口方式并行处理" style="zoom:50%;" />

<h3 id="窗口大小由哪一方决定？"><a href="#窗口大小由哪一方决定？" class="headerlink" title="窗口大小由哪一方决定？"></a>窗口大小由哪一方决定？</h3><p>窗口大小对应着TCP的<strong>Window</strong>字段。该字段是**[接收端]告诉[发送端]**自己还有多少缓冲区可以接收数据。</p>
<p>所以<strong>由[接收方]的窗口大小决定</strong>。</p>
<h3 id="发送方的滑动窗口"><a href="#发送方的滑动窗口" class="headerlink" title="发送方的滑动窗口"></a>发送方的滑动窗口</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/19.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="SND.WND、SND.UN、SND.NXT" style="zoom:45%;" />

<p>SND.WND：发送窗口的大小（<strong>接收方指定</strong>）</p>
<p>SND.UNA：<strong>绝对指针</strong>，指向<u>已发送但未收到ACK</u>的第一个字节的序列号</p>
<p>SND.NXT：<strong>绝对指针</strong>，指向<u>未发送但可发送范围</u>的第一个字节的序列号</p>
<p>指向<u>未发送且超出范围</u>（#4）的第一个字节的序列号是个<strong>相对指针</strong>。</p>
<p><strong>可用窗口大小</strong>由图可知是计算得来的。</p>
<h3 id="接收方的滑动窗口"><a href="#接收方的滑动窗口" class="headerlink" title="接收方的滑动窗口"></a>接收方的滑动窗口</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="接收窗口" style="zoom:45%;" />

<p>RCV.WND：接收窗口大小（通告<strong>给发送方的</strong>）</p>
<p>RCV.NXT：<strong>绝对指针</strong>，指向期望从发送方发来的下一个字节的序列号（#3的第一个字节）。</p>
<p>还有一个<strong>相对指针</strong>指向#4的第一个字节，是RCV.NXT+RCV.WND控制的。</p>
<p>因为接收方告诉发送方窗口大小有一定的<strong>时延</strong>，所以<strong>接收窗口约等于发送窗口</strong>。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="操作系统缓冲区与滑动窗口的关系"><a href="#操作系统缓冲区与滑动窗口的关系" class="headerlink" title="操作系统缓冲区与滑动窗口的关系"></a>操作系统缓冲区与滑动窗口的关系</h3><p>实际上，发送窗口和接收窗口中存放的字节数，都放在了操作系统缓冲区中。而应用进程就负责读取这一部分内容。</p>
<p>1）情况1</p>
<p>有的时候，应用进程非常忙碌，<strong>没有时间读取缓存区的内容</strong>，这样就会导致发送方发送来的一部分数据没办法及时被接收方的应用进程读取，滑动窗口的<strong>可用窗口越来越小，接收窗口也越来越小</strong>。（就像你吃饱了，另一个人还不停向你扔包子，虽然你告诉他一次最多仍5个，但是你现在肚子一点都装不下，所以就先放篮子里，放篮子里的早晚也要吃的，所以篮子有多少包子，你就要让你的接收窗口减少多少个包子，直到我们篮子里装了5个包子，那么就认为对方不能再扔了。）</p>
<p>所以从上边我们可以知道：缓冲区存了多少未读的数据，那么接收窗口缩小多少。接收窗口始终随缓冲区动态变化，就像消息队列一样，所以<strong>缓冲区未读数据M+接收窗口当前值N&#x3D;初始接收窗口的大小T</strong></p>
<p>上述情况就是：<strong>M一直增大，N一直减小，所以发送窗口逐渐减小</strong>。</p>
<p>2）情况2</p>
<p>有的时候，应用资源非常繁忙，操作系统会主动减少接收缓存（这就相当于操作系统自己给<strong>自己放了几个拿不走的包子——M永久性增大</strong>），这就直接导致我们现在窗口也要减少。但是窗口减少<strong>需要通知给发送方，这就需要一定的时间</strong>，在这时间内，很有可能有很大的包传过来，那么就会<strong>导致丢包</strong>（因为接收方的缓存收不下了）。</p>
<p>导致丢包的原因是：M增大的<strong>同时</strong>，N减小，但N传给发送方<strong>需要时间</strong>，这个时候发送方传来的包，接收方很可能接不住。</p>
<p>解决的方式就是：N<strong>先减小</strong>，过段时间（为了让N减小的消息通知给发送方）再让M增大（放入几个拿不走的包子）。</p>
<h3 id="窗口关闭（风险与解决）"><a href="#窗口关闭（风险与解决）" class="headerlink" title="窗口关闭（风险与解决）"></a>窗口关闭（风险与解决）</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/24.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口关闭潜在的危险" style="zoom:40%;" />

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/25.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口探测" style="zoom:35%;" />

<p>其实就是收到零窗口通知的一端会默认启用计时器，<strong>到点了就发送探测报文</strong>。</p>
<h3 id="糊涂窗口综合征（小接收与小发送问题）"><a href="#糊涂窗口综合征（小接收与小发送问题）" class="headerlink" title="糊涂窗口综合征（小接收与小发送问题）"></a>糊涂窗口综合征（小接收与小发送问题）</h3><p>有的时候，接收方通知给发送方的窗口大小越来越小，这就会带来一个问题，<strong>数据量很小的话，不值得传输一次</strong>，可以攒一攒，或者说等一等接收方接收一部分数据再传。（一个一个仍包子比较亏，等我一口能吃仨了，你一口气仍仨过来）</p>
<p>解决该问题有两种思路，一种是让接收方不通告小窗口给发送方；另一种是让发送方避免发送小数据。</p>
<h4 id="接收方不通告小窗口"><a href="#接收方不通告小窗口" class="headerlink" title="接收方不通告小窗口"></a>接收方不通告小窗口</h4><p>当 <strong>Window &lt; Math.min（MSS与缓存的一半）时</strong>，接收方就会向发送方<strong>通告Window为0</strong>。直到Window大于那俩值的时候，再通知Window值。</p>
<h4 id="发送方不发送小数据"><a href="#发送方不发送小数据" class="headerlink" title="发送方不发送小数据"></a>发送方不发送小数据</h4><p>Nagle算法，思路是延时处理。满足以下两条件之一才可以发送数据：</p>
<p>1）Window &gt;&#x3D; MSS 或 数据大小 &gt;&#x3D; MSS</p>
<p>2）收到之前发送数据的ACK回包</p>
<p>对于需要小数据包交互的场景如telnet或ssh，需要关闭Nagle算法。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>TCP不能一直按照流量控制传输，有的时候<strong>网络拥堵，就要减少传输量</strong>。</p>
<p><strong>发送窗口swnd</strong> &#x3D; min(拥塞窗口cwnd,接收窗口rwnd)</p>
<p>而拥塞窗口cwnd在网络中<strong>没有拥塞的时候，就会增大</strong>，出现拥塞，就会减少。</p>
<p><u>如何知道拥塞？</u>发送方没在规定时间收到ACK，也就是<strong>发生了超时重传</strong>，认为网络出现拥塞。</p>
<h3 id="拥塞控制的控制算法"><a href="#拥塞控制的控制算法" class="headerlink" title="拥塞控制的控制算法"></a>拥塞控制的控制算法</h3><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>慢启动算法规则：发送方每收到一个ACK，拥塞窗口cwnd就+1。（<strong>指数级增长</strong>）</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/27.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="慢启动算法" style="zoom: 40%;" />

<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>cwnd<strong>超过慢启动门限ssthresh</strong>就会进入拥塞避免算法。</p>
<p>规则：每收到一个ACK，cwnd增加1&#x2F;cwnd。（<strong>线性增长</strong>）</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/28.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="拥塞避免" style="zoom:40%;" />

<h4 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h4><p>上面两种都是cwnd逐渐增加，一旦网络拥塞，也就是拥塞发生，就会触发重传机制。</p>
<p><u><strong>超时重传</strong></u>：门限ssthresh设为cwnd&#x2F;2;cwnd置为1（<strong>急刹车并重新慢启动，一般不可取</strong>）</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="拥塞发送 —— 超时重传" style="zoom:30%;" />

<p><u><strong>快速重传</strong></u>：cwnd减半，门限ssthresh&#x3D;cwnd，然后<strong>进入快速恢复算法</strong>。</p>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>与<strong>快速重传</strong>一起“食用”。</p>
<p>规则：</p>
<ul>
<li>cwnd &#x3D; ssthresh + 3（3是指收到3个数据包）</li>
<li>重传丢失的数据包，收到一个重复ACK，cwnd就+1（线性增长）</li>
<li>一旦收到新数据ACK，就令cwnd &#x3D; ssthresh，说明恢复过程结束，<strong>再次进入拥塞避免状态</strong>（线性增长）</li>
</ul>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传和快速恢复" style="zoom:40%;" />

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" data-id="cl34efpty00001cv6d0asee9e" data-title="计算机网络笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作字符串题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/13/%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-13T03:26:25.000Z" itemprop="datePublished">2022-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/13/%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E8%A7%A3/">操作字符串题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcode-541-反转字符串II"><a href="#leetcode-541-反转字符串II" class="headerlink" title="leetcode 541.反转字符串II"></a>leetcode 541.反转字符串II</h1><p>给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p>
<p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<p>示例:</p>
<p>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “bacdfeg”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(i + k - <span class="number">1</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ch[start];</span><br><span class="line">                ch[start] = ch[end];</span><br><span class="line">                ch[end] = temp;</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环中的i，就相当于一个指针，每次走2*k个单位，走完一次，就定义当前反转字符串的起始位和终点位。</p>
<p>注意：<strong>终点位的要取i + k - 1和s.length() - 1的最小值</strong>，因为最后一次如果反转个数不够k个的时候，就直接将当前字符串从start到s.length() - 1的所有字符串翻转即可。</p>
<p>因为反转操作涉及字符串中每个字符的换位，所以最好将字符串转换为数组进行操作。最后记得再将数组转换为字符串。</p>
<h1 id="leetcode-28-实现strStr"><a href="#leetcode-28-实现strStr" class="headerlink" title="leetcode 28.实现strStr()"></a>leetcode 28.实现strStr()</h1><p><u><strong>题目</strong>：实现 strStr() 函数。</u></p>
<p><u>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</u></p>
<p><u>示例 1: 输入: haystack &#x3D; “hello”, needle &#x3D; “ll” 输出: 2</u></p>
<p><u>示例 2: 输入: haystack &#x3D; “aaaaa”, needle &#x3D; “bba” 输出: -1</u></p>
<p><u>说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i + m &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(haystack.charAt(i + j) != needle.charAt(j))&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题我暂时只会暴力解法，后续学会了KMP算法会进行更新。</p>
<p>暴力解法其实思路比较简单，让haystack数组指针依次向后递进，每递进一次，我们就从当前位置开始判断，该指针及其后面的元素是不是和needle的每个元素相同，如果都相同，那么我们就找到了needle出现的第一个位置。一旦有一个不同，那么就可以继续让haystack指针向后走了。</p>
<p>这里我们需要定义一个boolean类型的变量flag，初始值是true，一定要注意其定义的位置：<strong>每次haystack递进一位就定义一个全新的flag</strong>，而<strong>不要定义为全局变量</strong>。因为这个flag是为每次寻找needle字符串服务的，所以<strong>每次比较都要用全新的flag</strong>。</p>
<p><strong>每次寻找needle字符串的操作结束之后，都要看看flag还是不是true</strong>，如果还是true，说明找到了needle；如果是false，就说明上面的寻找过程中，出现了某个字符没匹配上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/13/%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E8%A7%A3/" data-id="cl33vz9vp0000qwv64bvmbn7e" data-title="操作字符串题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-哈希算法题目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/13/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2022-05-13T02:21:16.000Z" itemprop="datePublished">2022-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/13/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/">哈希算法题目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcode-202-快乐数"><a href="#leetcode-202-快乐数" class="headerlink" title="leetcode 202.快乐数"></a>leetcode 202.快乐数</h1><p><u><strong>题目</strong>：编写一个算法来判断一个数 n 是不是快乐数。</u></p>
<p><u>「快乐数」 定义为：</u></p>
<p><u>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</u><br><u>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</u><br><u>如果这个过程 结果为 1，那么这个数就是快乐数。</u><br><u>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</u></p>
<p><u>示例如下：</u></p>
<p><u>输入：n &#x3D; 19</u><br><u>输出：true</u><br><u>解释：</u><br><u>12 + 92 &#x3D; 82</u><br><u>82 + 22 &#x3D; 68</u><br><u>62 + 82 &#x3D; 100</u><br><u>12 + 02 + 02 &#x3D; 1</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//必须同时满足n != 1和set里面没有n，才进入循环：n == 1就是快乐数，set有n就是死循环</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !set.contains(n))&#123;</span><br><span class="line">            <span class="comment">//注意这里要先添加n到set中，再改变n的值。</span></span><br><span class="line">            set.add(n);</span><br><span class="line">            n = getNextNum(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">n</span> <span class="operator">=</span>= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            res += temp * temp;</span><br><span class="line">            n = n / <span class="number">10</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的思路有那么一点绕，一次写对不是很容易。</p>
<p>首先我们最好单独定义一个方法，<strong>用来计算每次不断更新的n，计算的过程就是不停的记录n % 10</strong>，然后让该位乘方值记录到res中，直到n &#x3D;&#x3D; 0，也就是把n的每一位的乘方都累加到res中。</p>
<p>然后将上面记录的更新之后的n，更新到主方法的n中。</p>
<p>在<strong>更新之前我们要记得用set保存n</strong>，防止后续的循环计算。</p>
<p>循环条件要想清楚，<strong>既然你进入这个循环了，那么你肯定不等于1</strong>，因为等于1就没要计算了，所以有n !&#x3D; 1这个条件。</p>
<p><strong>另一个条件自然是为了避免重复计算</strong>，所以n更新之后必须更新为之前没有计算过的n，如果计算过，那么就直接跳出循环吧。</p>
<p>所以循环条件有两个，一定不要丢了。</p>
<h1 id="leetcode-349-两个数组的交集"><a href="#leetcode-349-两个数组的交集" class="headerlink" title="leetcode 349.两个数组的交集"></a>leetcode 349.两个数组的交集</h1><p><u><strong>题目</strong>：给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。举例：</u></p>
<p><u>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</u><br><u>输出：[2]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; resSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums1)&#123;</span><br><span class="line">            set1.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(x))&#123;</span><br><span class="line">                resSet.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[resSet.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : resSet)&#123;</span><br><span class="line">            ans[index++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路比较简单，注意审题，相同的元素我们只记录一次，所以用HashSet是一种很简单的方式。</p>
<p>注意最后用数组记录即可。</p>
<h1 id="☆leetcode-350-两个数组的交集II"><a href="#☆leetcode-350-两个数组的交集II" class="headerlink" title="☆leetcode 350.两个数组的交集II"></a>☆leetcode 350.两个数组的交集II</h1><p><u><strong>题目</strong>：给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。举例：</u></p>
<p><u>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</u><br><u>输出：[2,2]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length &gt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums1)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            map.put(x, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(x))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.get(x);</span><br><span class="line">                ans[index++] = x;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    map.put(x, count);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.remove(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//注意这里是左闭右开区间</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(ans, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题与上面一题的区别就是重复元素要全部记录了，所以HashSet显得力不从心了。我们选用能记录每个重复元素出现次数的HashMap，利用value来记录每个key值出现的次数。</p>
<p><strong>为了节省哈希表得空间</strong>，我们用较小得数组存储到哈希表中。</p>
<p>每次存储的时候需要注意，为了书写和判断方便，我们利用map的getOrDefault方法，这可以让我们轻松的写出统一的count值，然后执行map.put(x, count)。</p>
<p>因为<strong>交集元素个数肯定 &lt;&#x3D; 较短的数组长度</strong>，所以我们记录交集元素只需要较短的长度即可。</p>
<p>在判断长数组存不存在map元素的时候，要注意：一旦存在，<strong>我们添加后一定要判断当前的count值，并且更新count值</strong>，更重要的是，count &#x3D;&#x3D; 0了要及时<strong>删除其所对应的key值</strong>，如果还没等于0，也要<strong>及时更新map中的count值</strong>，即map.put(x, count)。</p>
<h1 id="leetcode-1-两数之和"><a href="#leetcode-1-两数之和" class="headerlink" title="leetcode 1.两数之和"></a>leetcode 1.两数之和</h1><p><u><strong>题目</strong>：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</u></p>
<p><u>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</u></p>
<p><u>你可以按任意顺序返回答案。</u></p>
<p><u>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</u><br><u>输出：[0,1]</u><br><u>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tar</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(tar) &amp;&amp; map.get(tar) != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, map.get(tar)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里不能先添加，否则上面返回的数组</span></span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一步到位：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="☆leetcode-454-四数相加-II"><a href="#☆leetcode-454-四数相加-II" class="headerlink" title="☆leetcode 454.四数相加 II"></a>☆leetcode 454.四数相加 II</h1><p><u><strong>题目</strong>：给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</u></p>
<p><u>0 &lt;&#x3D; i, j, k, l &lt; n</u><br><u>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0</u></p>
<p><u>举例</u>：</p>
<p><u>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]</u><br><u>输出：2</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(temp)) &#123;</span><br><span class="line">                    map.put(temp, map.get(temp) + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(temp, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(<span class="number">0</span> - temp)) &#123;</span><br><span class="line">                    res += map.get(<span class="number">0</span> - temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-15-三数之和"><a href="#leetcode-15-三数之和" class="headerlink" title="leetcode 15.三数之和"></a>leetcode 15.三数之和</h1><p><u><strong>题目</strong>：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</u></p>
<p><u>注意：答案中不可以包含重复的三元组。</u></p>
<p><u>输入：nums &#x3D; [-1,0,1,2,-1,-4]</u><br><u>输出：[[-1,-1,2],[-1,0,1]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));</span><br><span class="line">                    left++; </span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-18-四数之和"><a href="#leetcode-18-四数之和" class="headerlink" title="leetcode 18.四数之和"></a>leetcode 18.四数之和</h1><p><u>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</u></p>
<p><u>0 &lt;&#x3D; a, b, c, d &lt; n</u><br><u>a、b、c 和 d 互不相同</u><br><u>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target</u><br><u>你可以按 任意顺序 返回答案 。</u></p>
<p><u>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0</u><br><u>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                    <span class="comment">//因为测试用例增加了一个相加会发生溢出的数组，所以用long型</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>)nums[i] + (<span class="type">long</span>)nums[j] + (<span class="type">long</span>)nums[left] + (<span class="type">long</span>)nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">                        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i], nums[j], nums[left], nums[right])));</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-242-有效的字母异位词"><a href="#leetcode-242-有效的字母异位词" class="headerlink" title="leetcode 242.有效的字母异位词"></a>leetcode 242.有效的字母异位词</h1><p><u><strong>题目</strong>：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</u></p>
<p><u>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</u></p>
<p><u>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”</u><br><u>输出: true</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            nums[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            nums[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-383-赎金信"><a href="#leetcode-383-赎金信" class="headerlink" title="leetcode 383.赎金信"></a>leetcode 383.赎金信</h1><p><u><strong>题目</strong>：给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</u></p>
<p><u>如果可以，返回 true ；否则返回 false 。</u></p>
<p><u>magazine 中的每个字符只能在 ransomNote 中使用一次。</u></p>
<p><u>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”</u><br><u>输出：false</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : magazine.toCharArray()) &#123;</span><br><span class="line">            nums[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : ransomNote.toCharArray()) &#123;</span><br><span class="line">            nums[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="comment">//这里直接判断，可以省去一次循环</span></span><br><span class="line">            <span class="keyword">if</span>(nums[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="☆leetcode-49-字母异位词分组"><a href="#☆leetcode-49-字母异位词分组" class="headerlink" title="☆leetcode 49.字母异位词分组"></a>☆leetcode 49.字母异位词分组</h1><p><u><strong>题目</strong>：给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。</u></p>
<p><u>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</u></p>
<p><u>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]</u><br><u>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str : strs) &#123;</span><br><span class="line">            <span class="comment">//1.注意：为每个字符串单独创建数组</span></span><br><span class="line">            <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">                nums[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.用sb存储每个字符串的标识符，如hello:h1e1ll2o1</span></span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append((<span class="type">char</span>) i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                    sb.append(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.注意：将StringBuilder转换为String</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="comment">//4.构建map的value，如果之前有key对应的value，就继续向list中添加新的字符串，然后将list统一放入map中。</span></span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.map.values()本身就是List&lt;String&gt;类型的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="☆leetcode-438-找到字符串中所有字母异位词"><a href="#☆leetcode-438-找到字符串中所有字母异位词" class="headerlink" title="☆leetcode 438.找到字符串中所有字母异位词"></a>☆leetcode 438.找到字符串中所有字母异位词</h1><p><u><strong>题目</strong>：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</u></p>
<p><u>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</u></p>
<p><u>输入: s &#x3D; “cbaebabacd”, p &#x3D; “abc”</u><br><u>输出: [0,6]</u><br><u>解释:</u><br><u>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。</u><br><u>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</u></p>
<p><u>输入: s &#x3D; “abab”, p &#x3D; “ab”</u><br><u>输出: [0,1,2]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滑动窗口+哈希法存储</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sLength</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pLength</span> <span class="operator">=</span> p.length();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(sLength &lt; pLength) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] sNums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] pNums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; pLength;i++) &#123;</span><br><span class="line">            sNums[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            pNums[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(sNums, pNums)) &#123;</span><br><span class="line">            ans.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保证窗口长度为pLength不变，逐个删除左边界i，添加右边界i + pLen</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; sLength - pLength;i++) &#123;</span><br><span class="line">            sNums[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            sNums[s.charAt(i + pLength) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(Arrays.equals(sNums, pNums)) &#123;</span><br><span class="line">                ans.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/13/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/" data-id="cl33tx2240000fkv6agf0ho2c" data-title="哈希算法题目" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-个人对JVM的理解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E4%B8%AA%E4%BA%BA%E5%AF%B9JVM%E7%9A%84%E7%90%86%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T12:04:43.000Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E4%B8%AA%E4%BA%BA%E5%AF%B9JVM%E7%9A%84%E7%90%86%E8%A7%A3/">个人对JVM的理解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="☆JVM内存结构："><a href="#☆JVM内存结构：" class="headerlink" title="☆JVM内存结构："></a>☆JVM内存结构：</h2><p><img src="D:\Picgo\img\image-20220511200810603.png" alt="image-20220511200810603"></p>
<p>首先给出JVM的结构图，包括了类装载器子系统、运行时数据区、执行引擎、本地方法接口、垃圾回收（<strong>这里不确定</strong>）</p>
<p>而内存结构呢，就是运行时数据区部分，也就包括了：程序计数器、虚拟机栈、本地方法栈、堆、方法区。其中方法区在jdk8以后就变成元数据区了。</p>
<p><u>程序计数器</u>：</p>
<p>是内存中很小的一个存储空间，可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。在程序运行过程中，线程是非常多的，但是CPU的核心数却是有限的，所以我们必须要通过不断切换线程来来为处理器分配时间，进而完成程序的执行。程序计数器就是为了实现线程切换用的，<strong>每个线程都用独立的程序计数器</strong>，两两互不干扰，其生命周期也与线程保持一致。</p>
<p>垃圾回收和内存溢出都与程序计数器无关。</p>
<h2 id="☆类加载机制整个过程是怎么样的"><a href="#☆类加载机制整个过程是怎么样的" class="headerlink" title="☆类加载机制整个过程是怎么样的"></a>☆类加载机制整个过程是怎么样的</h2><p><img src="D:\Picgo\img\image-20220512150709656.png" alt="image-20220512150709656"></p>
<p>类加载机制的过程：首先Java虚拟机将描述类的数据从Class文件中<strong>加载到内存</strong>，然后对数据进行<strong>连接以及初始化</strong>的过程，最终形成了可以被JVM可以直接使用的类型。</p>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><p>加载只是整个“类加载”过程的第一步。这个过程Java虚拟机完成了三件事：</p>
<p>1）通过一个类的全限定名来<strong>获取定义此类的二进制字节流</strong>。</p>
<p>2）将这个字节流代表的静态存储结构<strong>转化</strong>为方法区的运行时数据结构（注意：这里仅仅是转化）。</p>
<p>3）在内存中生成一个代表这个类的java.lang.Class对象，<strong>作为方法区这个类的各种数据访问入口</strong>。</p>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><p>作为连接的第一步，验证的目的主要是确保加载的Class字节流<strong>不会危害</strong>到虚拟机自身安全（本步骤对应的代码如果已经在之前执行过程中反复验证过了，就可以关掉该步骤，以缩短虚拟机类加载时间）：</p>
<p>1）文件格式验证：验证字节流<strong>是否符合Class文件格式规范</strong></p>
<p>2）元数据验证：对字节码进行<strong>语义分析</strong>，比如某个类有无父类，是否继承了不允许继承的类等一些违规的语义</p>
<p>3）字节码验证：确定程序语义的<strong>合法性、逻辑性</strong>，较复杂，具体见《深入理解JVM》P270</p>
<p>4）符号引用验证：这个验证要在后面的解析阶段发生，通俗来讲，就是<strong>检验该类是否缺少或者被禁止访问它依赖的某些资源</strong>。</p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h3><p>本阶段开始正式为类中定义的<strong>静态变量分配内存</strong>并<strong>设置初始零值</strong>。注意：JDK 7之前，这部分变量分配在方法区中，而<strong>JDK 8之后，则分配到堆中</strong>。以下两点需要注意：</p>
<p>1）这里分配内存和设置零值都<strong>仅限于类变量</strong>（静态变量），实例变量将在<strong>对象实例化时随着对象一起分配到Java堆中</strong>。</p>
<p>2）注意是设置零值，<strong>一般情况不是初始化</strong>。</p>
<p>3）特殊情况就是<strong>static final定义的变量</strong>，Javac<strong>编译时</strong>就已经为该变量生成ConstantValue属性（可以理解为<strong>设置初始零值</strong>），类加载的准备阶段，就<strong>直接为其赋值</strong>了。</p>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><p>将字节码中常量池内的符号引用替换为直接引用。</p>
<p>1）符号引用：是任何形式的字面量，只要使用时能无歧义的“精准定位”即可。</p>
<p>2）直接引用：可以是<strong>直接指向</strong>目标的<strong>指针</strong>、<strong>相对偏移量</strong>或能<strong>间接定位</strong>到目标的<strong>句柄</strong>。一旦有直接引用，那么相对应的<strong>目标必定在虚拟机内存中存在</strong>。</p>
<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><p>该阶段，虚拟机才正式开始执行类中编写的Java程序代码，将主导权移交给应用程序。在前面的”准备“阶段中，我们已经为类变量进行分配内存和设置零值的操作，接下来就<strong>轮到初始化阶段真正为这些变量赋值</strong>了。</p>
<p>1）直接来讲，<strong>初始化就是执行类构造器clinit&gt;()方法的过程</strong>，clinit&gt;()是Javac编译器的自动生成物。</p>
<p>2）clinit&gt;()是编译器自动收集类中<strong>所有的静态变量的赋值动作和静态语句块中的语句</strong>合并而成的，收集顺序就是源代码书写顺序。</p>
<p>3）在子类执行clinit&gt;()方法前，<strong>先要执行其父类clinit&gt;()<strong>，这也是为什么父类静态语句块要先执行的原因。与类的构造函数（虚拟机视角的实例构造器init&gt;()方法）不同，</strong>不需要显示调用父类构造器</strong>。</p>
<h2 id="☆类加载器"><a href="#☆类加载器" class="headerlink" title="☆类加载器"></a>☆类加载器</h2><p><img src="D:\Picgo\img\image-20220512194439270.png" alt="image-20220512194439270"></p>
<p>前面提到，类加载机制的第一步就是加载，我们用到的工具自然是类加载器。其实类加载器分类很简单，就是C&#x2F;C++写的启动类加载器和Java写的类加载器，具体分类如下：</p>
<p><img src="D:\Picgo\img\image-20220512194934161.png" alt="image-20220512194934161"></p>
<h3 id="1-启动类加载器（引导类加载器-Bootstrap-ClassLoader）"><a href="#1-启动类加载器（引导类加载器-Bootstrap-ClassLoader）" class="headerlink" title="1.启动类加载器（引导类加载器, Bootstrap ClassLoader）"></a>1.启动类加载器（引导类加载器, Bootstrap ClassLoader）</h3><p>1）<strong>虚拟机自带</strong>，C++编写</p>
<p>2）用来<strong>加载Java核心库</strong></p>
<p>3）<strong>没有父加载器，也没有父类</strong></p>
<p>4）<strong>加载其下面的</strong>扩展类加载器和系统类加载器</p>
<h3 id="2-扩展类加载器（Extension-ClassLoader）"><a href="#2-扩展类加载器（Extension-ClassLoader）" class="headerlink" title="2.扩展类加载器（Extension ClassLoader）"></a>2.扩展类加载器（Extension ClassLoader）</h3><p>1）Java编写，**<u>独立存在于虚拟机外部</u>**</p>
<p>2）<strong>继承自抽象类</strong>java.lang.ClassLoader</p>
<p>3）父类加载器就是上边的Bootstrap ClassLoader</p>
<h3 id="3-系统类加载器（应用程序类加载器，System-ClassLoader）"><a href="#3-系统类加载器（应用程序类加载器，System-ClassLoader）" class="headerlink" title="3.系统类加载器（应用程序类加载器，System ClassLoader）"></a>3.系统类加载器（应用程序类加载器，System ClassLoader）</h3><p>1）Java编写，**<u>独立存在于虚拟机外部</u>**</p>
<p>2）<strong>继承自抽象类</strong>java.lang.ClassLoader</p>
<p>3）父类加载器就是上边的Extension ClassLoader</p>
<p>4）负责加载环境变量和系统属性指定路径下的类库</p>
<p>5）程序的默认类加载器，<strong>一般Java应用类都是它加载的</strong>。</p>
<h3 id="4-用户自定义类加载器"><a href="#4-用户自定义类加载器" class="headerlink" title="4.用户自定义类加载器"></a>4.用户自定义类加载器</h3><h2 id="☆双亲委派模型"><a href="#☆双亲委派模型" class="headerlink" title="☆双亲委派模型"></a>☆双亲委派模型</h2><p>首先我们要知道，虚拟机对class文件是<strong>按需加载</strong>的，也就是只有在需要使用该类的时候，才将其class文件加载到内存中生成class对象。</p>
<p>那么加载某个class文件的时候，具体的过程是怎么样的呢？这时候就要引入我们的一种特殊模式：双亲委派模式。工作原理如下：</p>
<p>1）一个类加载器收到类加载请求，<strong>先把请求依次委托其父类加载器去执行</strong>，请求<strong>最终到达顶层</strong>的启动类加载器。</p>
<p>2）如果父类加载器<strong>可以完成类加载的任务，就成功返回</strong>。若不能完成，<strong>才交给子加载器</strong>进行加载。</p>
<h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>其实就是利用了双亲委派模型的特点，假如我们定义一个String类，那么加载这个自定义String类的时候，<strong>会先委派到顶部的引导类加载器加载</strong>，引导类发现自己可以加载，就<strong>接着加载JDK自带的文件java.lang.String</strong>，这样就可以避免我们自定义String类对核心源代码的破坏。</p>
<h3 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h3><p>1）避免类的重复加载</p>
<p>2）保护程序安全，避免核心API被随意篡改</p>
<h2 id="☆判断两个class对象是否相同，我们需要看什么？"><a href="#☆判断两个class对象是否相同，我们需要看什么？" class="headerlink" title="☆判断两个class对象是否相同，我们需要看什么？"></a>☆判断两个class对象是否相同，我们需要看什么？</h2><p>1）类的名字首先得相同，包名也得一致</p>
<p>2）加载这个class的类加载器（<strong>ClassLoader实例对象</strong>）必须相同。</p>
<h2 id="☆Java什么时候对类进行主动引用？"><a href="#☆Java什么时候对类进行主动引用？" class="headerlink" title="☆Java什么时候对类进行主动引用？"></a>☆Java什么时候对类进行主动引用？</h2><p>1）使用new关键字实例化对象的时候</p>
<p>2）访问某个<strong>类（或接口）的静态变量</strong>，或者对该静态变量<strong>赋值</strong></p>
<p>3）调用某个类的<strong>静态方法</strong></p>
<p>4）使用java.lang.reflect包的方法对某个类进行<strong>反射调用</strong></p>
<p>5）初始化某个类，<strong>优先触发其父类初始化</strong></p>
<p>6）虚拟机启动时，用户需要<strong>指定一个要执行的主类</strong>（包括main()方法的那个类），虚拟机先初始化该类</p>
<p>7）JDK 7开始提供<strong>动态语言支持</strong>（不懂）</p>
<p>8）JDK 8在**接口中定义了默认方法(**default标识)，如果这个接口的实现类发生了初始化，那么该接口要率先初始化。</p>
<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>程序计数器（pc寄存器）存放的是该方法要执行的下一条指令的值（存疑）。</p>
<h1 id="☆虚拟机栈的作用是什么？"><a href="#☆虚拟机栈的作用是什么？" class="headerlink" title="☆虚拟机栈的作用是什么？"></a>☆虚拟机栈的作用是什么？</h1><p>栈是<strong>运行时</strong>的单位，而堆是<strong>存储的</strong>单位。栈解决的是程序如何执行，如何处理数据的问题；而堆是解决数据存储的问题。当然一些数据也会存在栈中，只能说栈的主要功能是处理数据，它<strong>是线程私有的</strong>。内部存储着一个个栈帧，<strong>每一个栈帧对应一个Java方法</strong>。</p>
<p>上面是比较泛泛的总结，虚拟机栈具体是什么作用呢？它主管程序的运行，<strong>在每个栈帧的局部变量表中保存相应方法的局部变量</strong>（8种<strong>基本数据</strong>类型、引用类型变量的<strong>引用地址</strong>），一<strong>部分结果</strong>，并参与方法的<strong>调用和返回</strong>。</p>
<p>栈操作只有两个：</p>
<p>1）执行方法的时候，<strong>进栈</strong>（入栈、压栈）</p>
<p>2）方法执行结束的时候，<strong>出栈</strong></p>
<p>所以栈<strong>没有垃圾回收机制</strong>，只<strong>存在栈溢出</strong>的现象。</p>
<h1 id="☆虚拟机栈的常见异常？如何设置栈的大小？"><a href="#☆虚拟机栈的常见异常？如何设置栈的大小？" class="headerlink" title="☆虚拟机栈的常见异常？如何设置栈的大小？"></a>☆虚拟机栈的常见异常？如何设置栈的大小？</h1><p>当<strong>某个线程请求分配的栈容量超过</strong>了Java虚拟机栈允许的最大容量，虚拟机会报<strong>StackOverflowError</strong>，即栈溢出。</p>
<p>我们可以通过-Xxx设置虚拟机栈的大小。在Idea的Run中，找到Edit Configurations，在当前程序的VM options中写入-Xxx256k即可。</p>
<p>如果Java虚拟机栈可以动态扩展，但<strong>扩展的时候无法申请到足够的内存</strong>，或者创建新线程的时候<strong>没有足够内存去创建对应的虚拟机栈</strong>，则虚拟机会报OutOfMemoryError异常，也就是我们所说的OOM。</p>
<h1 id="☆栈帧的内部结构"><a href="#☆栈帧的内部结构" class="headerlink" title="☆栈帧的内部结构"></a>☆栈帧的内部结构</h1><p>栈帧内部包括：局部变量表、操作数栈、动态链接、方法返回地址、一些附加信息。其中，<strong>局部变量表和操作数栈占的内存最大</strong>，主要影响栈帧的大小，而栈帧的大小决定了每个线程的虚拟机栈能存放多少个栈帧。</p>
<p>1）局部变量表：就是<strong>数字数组</strong>，主要用于<strong>存储方法参数和定义在方法体内的局部变量</strong>，包括基本数据类型、对象引用、returnAddress类型。<strong>slot(变量槽)<strong>是最基本的存储单元，对于byte、short、char在存储前，被</strong>转换为int</strong>,而boolean也被<strong>转换为int</strong>，false对应0，true对应非0。他们都<strong>占用一个slot</strong>。long和double类型的变量<strong>占两个slot</strong>。</p>
<p>栈帧的<strong>局部变量表与性能调优关系最为密切</strong>，因为在垃圾回收过程中，表中的变量是重要的<strong>垃圾回收根节点</strong>，只要<strong>被表中直接或间接引用的对象</strong>都不会被回收。</p>
<p>2）操作数栈(其<strong>大小在编译时就确定</strong>了)：在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，例如执行<strong>复制、交换、求和</strong>等操作。主要用于<strong>保存计算过程中的中间结果</strong>，同时作为计算过程中的<strong>变量临时存储空间</strong>。</p>
<p>注意：操作数栈<strong>并非通过访问索引</strong>来进行数据访问的，它只是入栈出栈的一个实现工具。</p>
<p>3）动态链接：<strong>指向运行时常量池</strong>中的该栈帧所属<strong>方法的引用</strong>。在类加载之前，符号引用都在class文件的常量池中，类加载后，这些符号引用就被<strong>类加载阶段的“解析”过程</strong>转换为调用方法的直接引用。动态链接就是<strong>来实现这个“解析”过程的</strong>。</p>
<p>4）方法返回地址：存放调用该方法的<strong>pc寄存器的值</strong>（存疑）。本质上就是：比如当前方法退出了，意为当前方法出栈，<strong>那么就要恢复上层方法的栈帧</strong>，这时我们就需要程序计数器的值，所以方法返回地址就存放了这个值（类比接力赛传棒）。</p>
<p>动态链接，方法返回地址和其他附加信息被称为<strong>帧数据区</strong>。</p>
<p>总的来说，每一个栈帧对应一个方法，但是方法要运行就必须有一个专门的数据结构来对数据进行操作，这个数据结构就是操作数栈，数据就是局部变量表中的数据，方法执行过程中，各种字节码指令负责操作数栈的入栈出栈操作。</p>
<h1 id="☆局部变量和静态变量的对比"><a href="#☆局部变量和静态变量的对比" class="headerlink" title="☆局部变量和静态变量的对比"></a>☆局部变量和静态变量的对比</h1><p>我们知道静态变量就是类变量，是在累加载阶段就有初始化操作的，其一是<strong>“准备”阶段的初始化零值</strong>，另一阶段是<strong>”初始化“阶段为类变量赋初始值</strong>。</p>
<p>对于局部变量，<strong>因为要放在局部变量表中，表没有初始化过程</strong>，所以我们必须在写代码的时候，人为初始化。</p>
<h1 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h1><p>静态绑定&#x2F;链接（对应早期绑定）就是（被调用的方法）<strong>符号引用转换为直接引用在编译期</strong>就可以确定下来，比如定义一个<strong>final的常量或方法</strong>，此时这个符号在编译期就可以确定，没有多态的特性。</p>
<p>动态绑定&#x2F;链接（对应晚期绑定）就是（被调用的方法）符号引用转换为直接引用是<strong>在运行期间</strong>才可以确定下来，正是因为Java具有<strong>多态</strong>的特性，所以才有了动态链接。</p>
<h1 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h1><p>简单来说就是father类继承了Object类，然后写了两个新方法，然后Son类继承了father类，然后重写了father类的两个新方法，那么在Son调用这两个新方法的时候就会去father中找，但是调用object类的时候，就可以直接从虚方法表中找到，不用先上father中找，然后再去Object中找了。</p>
<p>这样就实现了，调用方法的时候，根据虚方法表直接确定压入操作数栈的直接引用，不用再一层层向上判断。</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220622200249524.png" alt="image-20220622200249524" style="zoom:50%;" />

<h1 id="本地方法接口和本地方法栈"><a href="#本地方法接口和本地方法栈" class="headerlink" title="本地方法接口和本地方法栈"></a>本地方法接口和本地方法栈</h1><p>本地方法接口就是一个java<strong>调用非java代码</strong>（C代码）的接口。</p>
<p>本地方法栈在运行时数据区内部，用于<strong>管理本地方法的调用</strong>。</p>
<h1 id="JVM实例-进程-运行时数据区的关系"><a href="#JVM实例-进程-运行时数据区的关系" class="headerlink" title="JVM实例-进程-运行时数据区的关系"></a>JVM实例-进程-运行时数据区的关系</h1><p>一个jvm实例对应着一个进程，一个进程只有一个运行时数据区。因为一个进程拥有多个线程，所以多线程共享一个堆和方法区，而他们各自拥有自己的程序计数器、虚拟机栈和本地方法栈。</p>
<h1 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h1><p>JVM一启动，引导类加载器就把JVM实例加载出来了，<strong>JVM实例创建出来了，运行时数据区就确定了</strong>，所以堆区的大小也就确定了。堆上的物理空间不是连续的，但逻辑上应该视为连续的。</p>
<p>栈、堆、方法区之间的关系如图所示：</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220623163626173.png" alt="image-20220623163626173" style="zoom: 50%;" />

<h1 id="对象在堆中的分配过程"><a href="#对象在堆中的分配过程" class="headerlink" title="对象在堆中的分配过程"></a>对象在堆中的分配过程</h1><p>new出来的对象先放在Eden区，当Eden区满了，触发YGC&#x2F;Minor GC即垃圾回收，剩余的对象放入servivor的to区，survivor的<strong>from区和to区必须有一个是空的，谁空谁是to区</strong>。</p>
<p>所以<strong>触发YGC之后，Eden区必为空</strong>，多出来的放入survivor的to区，放不下就放老年代。</p>
<p>如果survivor区满了，会触发GC吗？不会，只有Eden区满了才会触发YGC，其实YGC不仅回收Eden区，也回收两个survivor区，也就是说<strong>YGC回收的是整个新生代区的垃圾，但是只有Eden区满了才会触发YGC</strong>。</p>
<p>什么时候survivor满了？我们要知道：**<u>只有YGC的时候，才会从Eden和from区向to区转移对象</u>**，survivor满了的意思就是当前需要转移到to区的对象所占内存大于to区的内存，那么多出来的就会晋升至老年代（这时候就无视对象年龄）</p>
<p><strong>-Xx:MaxTenuringThreshold</strong>&#x3D; N是新生代到老年代的<strong>阈值</strong>，超过这个值就会晋升到老年代，当老年代满了，就会触发Major GC。</p>
<h1 id="为什么要有TLAB"><a href="#为什么要有TLAB" class="headerlink" title="为什么要有TLAB?"></a>为什么要有TLAB?</h1><p>TLAB(Thread Local Allocation Buffer)本地线程分配缓冲，说白了就是，一个运行数据区（只有一个堆）对应着一个进程，一个进程有多个线程，<strong>多个线程共享一个堆内的数据</strong>，高并发环境下会带来<strong>线程不安全问题</strong>。</p>
<p>下图画的有点大，其实TLAB内存非常小，仅占整个**Eden区的1%**（这里好像是每个线程占1%，不确定）。</p>
<p>注意：TLAB<strong>不能完全说是线程私有的</strong>，因为其他线程也<strong>可以访问</strong>这部分空间，但在这部分空间分<strong>配内存的权力</strong>只有当前线程拥有。</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220623171737389.png" alt="image-20220623171737389" style="zoom:60%;" />

<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><p>逃逸分析就是分析<strong>对象的动态作用域</strong>：</p>
<p>当一个对象只<strong>在当前方法中被定义并调用</strong>，就是没有逃逸，就可以将当前对象放入栈中，即<strong>栈上分配</strong>。</p>
<p>当一个对象在当前方法定义之后，不仅在当前方法调用，还在<strong>外部方法调用</strong>，则发生了逃逸。</p>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>将堆分配转换为栈分配</p>
<h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><p>一个对象<strong>只被一个线程访问</strong>（未逃逸），那么可以把对该对象的同步操作去掉（<strong>删除同步锁</strong>）。</p>
<h3 id="分离对象或标量替换"><a href="#分离对象或标量替换" class="headerlink" title="分离对象或标量替换"></a>分离对象或标量替换</h3><p>一个对象其实就是<strong>多个元素的聚合量</strong>，如果逃逸分析后发现当前对象只被一个线程调用，那么这个聚合量就可以被打散，放入栈中。比如对象Tom有name, age, sex，那么就可以将之前存放在堆中的Tom变量转换为标量name,age,sex分配到栈的局部变量表中。</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>方法区相当于JVM的“接口”，而永久代、元空间相当于JVM具体实现的类</p>
<p>jdk7及之前方法区在hotspot虚拟机<strong>具体实现</strong>是永久代；</p>
<p>jdk8以后方法区的<strong>具体实现</strong>是元空间（不占用虚拟机设置的内存，而是<strong>使用本地内存</strong>）。</p>
<p>JVM中方法区不能等价为元空间，只是hotspot虚拟机（默认虚拟机）的方法区等价为元空间</p>
<p><strong>方法区主要存放的是Class类</strong>，而堆主要存放的是实例化的对象。</p>
<p>下图可以看到，Person类在加载过程中是存到方法区的，而对象person如果是在方法中定义的，那么就是局部变量，存放在栈帧的局部变量表中，只不过存放的是地址，真正的对象是存放在堆中的。</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220623193754551.png" alt="image-20220623193754551" style="zoom:50%;" />

<h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p>方法区存放着[<strong>类型信息</strong>（域&#x2F;属性信息和方法信息）]、[<strong>运行时常量池</strong>（常量、静态变量）]、[JIT代码缓存]。</p>
<p>类型信息：这个类型的完整有效名（<strong>包名</strong>.类名）、直接父类有效名、修饰符、<strong>直接接口的有序表</strong></p>
<p>域&#x2F;属性信息：属性名称、类型、修饰符以及声明顺序</p>
<p>方法信息：方法名称、返回类型、参数的数量和类型、修饰符、字节码、操作数栈、局部变量表及大小、异常表</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220623201600578.png" alt="image-20220623201600578" style="zoom: 40%;" />

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E4%B8%AA%E4%BA%BA%E5%AF%B9JVM%E7%9A%84%E7%90%86%E8%A7%A3/" data-id="cl31jc9hq00000cv6gfxp6myd" data-title="个人对JVM的理解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-双指针题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T09:01:55.000Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E8%A7%A3/">双指针题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcode-27-移除元素"><a href="#leetcode-27-移除元素" class="headerlink" title="leetcode 27.移除元素"></a>leetcode 27.移除元素</h1><p>**<u>题目</u>**：<u>给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。</u></p>
<p><u>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题因为要原地修改数组，所以必须要<strong>让元素之间换位</strong>来实现更改数组的操作。</p>
<p>所以我们采用双指针解法，既降低了空间复杂度，又实现了原位置换的好处。</p>
<p>具体操作就是让一个fast指针不停向后移动，而slow指针则必须“听从”fast指针安排，当fast没碰到val的时候，fast指针把当前位置的元素赋值给slow位置的元素，因为这些等于val的元素我们就不要了，所以不需要换位，只需要替代即可。</p>
<p>如果fast碰到val了，就让它继续向后走，这时一定不要对数组进行换位操作，因为只有碰到上面的情况，才实现换位，fast碰到的val让slow碰到了再解决。</p>
<p>可能会有以下问题：fast这样赋值，会不会打乱数组原有顺序？肯定不会。因为slow和fast是共起点的，只有当fast碰到val的那一刻，二者分开，而<strong>fast的作用就是要把不等于val的元素赋给slow</strong>，所以fast一定会依次将这些值赋给slow的，也就不会出现乱序的现象。</p>
<h1 id="leetcode-26-删除有序数组中的重复项"><a href="#leetcode-26-删除有序数组中的重复项" class="headerlink" title="leetcode 26.删除有序数组中的重复项"></a>leetcode 26.删除有序数组中的重复项</h1><p><u><strong>题目</strong>：给你一个<strong>升序排列</strong>的数组 <code>nums</code> ，请你原地删除重复出现的元素，使每个元素<strong>只出现一次</strong>，返回删除后数组的新长度。元素的<strong>相对顺序</strong>应该保持<strong>一致</strong>。不要使用额外的空间，你必须在并在使用 O(1) 额外空间的条件下完成</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>, fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[fast - <span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种解法我们可以发现：**比较的是nums[fast]和nums[fast - 1]**，也就是fast指针指向的元素和其指过的元素，直接想难度比较大，我们举例：[0,0,1,1,1,2,2,3,3,4]</p>
<p>因为我们要让fast和前面一位比，自然<strong>初始位置要从1开始</strong>，slow为1，这样可以让两者同步向后走。那么问题来了，slow为0行不行？</p>
<p>我们来看一下，如果slow为0，那么fast第一次比较的时候，发现0 &#x3D;&#x3D; 0会跳过当前位置，走到1的时候，发现1 !&#x3D; 0，这个时候，才把1赋给slow位置的0，<strong>那么slow一开始就丢掉了一个0，整个数组都会丢掉0</strong>。比如[1,1,2]答案是[2]，自己可以试一下。</p>
<p>所以slow和fast初始位置均为1，这样可以避免初始值被吞没的现象。</p>
<p>我们知道，<strong>比较重复值还可以让fast和其后面一个值比较</strong>，官方题解没有给出这种解法，但是确实是可以的，分析如下：</p>
<p>我们来比较nums[fast]和nums[fast + 1]，自然就要让fast从最初的的位置开始走起，所以初始值fast &#x3D; 0。那么slow也从0开始走吗？</p>
<p>我们假设slow也从0开始走，还是以简单的[1,1,2]为例，fast发现1和1相等，跳过，走到第二个1，发现1和2不等，肯定要把2给slow，给前面fast的就给乱了，所以要**把nums[fast + 1]赋给nums[slow]**。这个时候，我们发现slow在一开始就被赋予2，1压根不存在了。所以slow不能从最开始走，而要保留第一个值，从第二位走，也就是初始化slow &#x3D; 1。这只是我自己想到的一种向后比较的解法，纯粹是多思考一下，解法还是按照前面的思路比较简单。向后比较的题解代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[fast + <span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow] = nums[fast + <span class="number">1</span>];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-283-移动零"><a href="#leetcode-283-移动零" class="headerlink" title="leetcode 283.移动零"></a>leetcode 283.移动零</h1><p><u><strong>题目：</strong>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</u></p>
<p><u><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[slow];</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                nums[fast] = temp;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题要<strong>注意是移动0到末尾，而不是删除0</strong>，所以不能仅仅在nums[fast] !&#x3D; 0的时候进行覆盖操作，而要进行替换操作，<strong>将fast指向的非0数字赋给slow，把0转移给fast</strong>。</p>
<h1 id="leetcode-844-比较含退格的字符串"><a href="#leetcode-844-比较含退格的字符串" class="headerlink" title="leetcode 844.比较含退格的字符串"></a>leetcode 844.比较含退格的字符串</h1><p><u><strong>题目：</strong>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</u></p>
<p><u>注意：如果对空文本输入退格字符，文本继续为空。示例如下：</u></p>
<p><u>输入：s &#x3D; “ab#c”, t &#x3D; “ad#c”</u><br><u>输出：true</u><br><u>解释：s 和 t 都会变成 “ac”。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, j = t.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">skipA</span> <span class="operator">=</span> <span class="number">0</span>, skipB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    skipA++;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipA &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipA--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(j) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    skipB++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipB &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipB--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != t.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题虽然为简单题，但是想一次做对有些困难。</p>
<p>因为”#”是删除前一个字符，所以我们从后向前遍历比较好。整体的思路就是，先遍历s，如果碰到#，就计数，直到当前遍历无#，就跳出循环，然后同样的方式遍历t。</p>
<p>两个字符串的遍历走完之后，如果当前i或者j没有走完，就判断当前i和j位置对应的字符是否相等，如果不相等，那么肯定就返回false，为什么呢？因为我们<strong>同时从后向前遍历，一旦进行比较，就说明此时i和j后面的元素已经确定好了</strong>，没有一一对应的话，就没必要向前遍历了。如果有一个字符串走完了呢？一样的道理，还是没有一一对应上，因为<strong>此时连长度都对不上了</strong>，俩字符串更不可能相同了。</p>
<p>如果上述两个判断都没有问题，那么我就让两个指针都向前移动一位，继续判断。</p>
<p>什么时候跳出循环呢？一定要让两个指针都走完才可以，如果只有一个指针走完，我们就return true了。那么<u>absfds##asd##和a</u>就会误判了。</p>
<h1 id="leetcode-977-有序数组的平方"><a href="#leetcode-977-有序数组的平方" class="headerlink" title="leetcode 977.有序数组的平方"></a>leetcode 977.有序数组的平方</h1><p><u><strong>题目：</strong></u><u>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。举例如下：</u></p>
<p><u>输入：nums &#x3D; [-4,-1,0,3,10]</u><br><u>输出：[0,1,9,16,100]</u><br><u>解释：平方后，数组变为 [16,1,0,9,100]</u><br><u>排序后，数组变为 [0,1,9,16,100]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>, index = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] * nums[i] &lt; nums[j] * nums[j])&#123;</span><br><span class="line">                ans[index--] = nums[j] * nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[index--] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="img"></p>
<p>题解来自Carl大佬，这个图足够说明解题思路了。要注意的就是while的循环条件。</p>
<h1 id="☆leetcode-209-长度最小的子数组"><a href="#☆leetcode-209-长度最小的子数组" class="headerlink" title="☆leetcode 209.长度最小的子数组"></a>☆leetcode 209.长度最小的子数组</h1><p><u><strong>题目</strong>：给定一个含有 n 个正整数的数组和一个正整数 target 。</u></p>
<p><u>找出该数组中满足其和 ≥ target 的长度最小的<strong>连续子数组</strong> [numsl, numsl+1, …, numsr-1, numsr]，并返回其长度。如果不存在符合条件的子数组，返回0。</u></p>
<p><u><strong>示例 1：</strong></u></p>
<p><u>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</u><br><u>输出：2</u><br><u>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>, res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right &lt; nums.length;right++)&#123;</span><br><span class="line">            sum += nums[right];<span class="comment">//每次移动right指针都要将其所指元素添加进sum中</span></span><br><span class="line">            <span class="comment">//这里容易写成if，要用while循环判断，直至窗口内的sum &lt; target</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;<span class="comment">//一旦总和大于目标值，就开始记录当前最短数组，并右移left指针</span></span><br><span class="line">                res = Math.min(res, right - left + <span class="number">1</span>)</span><br><span class="line">                sum -= nums[left++];<span class="comment">//记得删除left指针指向的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">res</span> <span class="operator">=</span>= Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题一定要看清楚题意，是<strong>连续子数组！</strong></p>
<p>这样我们才可以<strong>利用双指针来模拟滑动窗口</strong>，左指针就是滑动窗口的左边界，右指针对应着右边界。</p>
<p>每当我们移动一次right指针，我们就把right所指的元素添加进sum中，一旦sum &gt;&#x3D; target，我们就要<strong>开始记录当前数组长度和之前记录的res的最小值</strong>。记录之后，为了继续移动right指针，我们<strong>必须删除左指针指向的元素</strong>，同时<strong>一定不要忘了右移左指针</strong>。这样一个滑动窗口就形成了。</p>
<p>最后要<strong>记住判断res是否存在</strong>，不存在的话就是初始值Integer.MAX_VALUE。</p>
<h1 id="leetcode-904-水果成篮"><a href="#leetcode-904-水果成篮" class="headerlink" title="leetcode 904.水果成篮"></a>leetcode 904.水果成篮</h1><p><u><strong>题目</strong>：你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</u></p>
<p><u>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</u></p>
<p><u>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。</u><br><u>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</u><br><u>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</u><br><u>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</u></p>
<p><u>举例如下：</u></p>
<p><u>输入：fruits &#x3D; [0,1,2,2]</u><br><u>输出：3</u><br><u>解释：可以采摘 [1,2,2] 这三棵树。</u><br><u>如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; fruits.length;j++)&#123;</span><br><span class="line">            count.add(fruits[j], <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//一旦个数超过2个，就开始删除左指针指向的元素</span></span><br><span class="line">            <span class="keyword">while</span>(count.size() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                count.add(fruits[i], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(count.get(fruits[i]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    count.remove(fruits[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(k) ? <span class="built_in">super</span>.get(k) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">        put(k, get(k) + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题理解题意是难度比较大的，总的来说就是在一个<strong>含有重复元素的数组</strong>中，找到<strong>含有两种不同元素的最长连续子数组</strong>。这道题和前面的题的区别，就像背包问题，一个求背包重量，一个求方案数一样。这道题就是后者的情况，因为<strong>重复元素只算一种元素</strong>，所以我们必须要用HashMap来记录这个元素在数组中出现了多少次。而<strong>连续子数组的长度则由HashMap的size()来控制</strong>。</p>
<p>我们依旧是利用双指针模拟滑动窗口，让右指针j不停向右移动，移动一次就记录当前j指向的元素及其出现的次数，一旦我们的HashMap的size() &gt;&#x3D; 3了，说明当前HashMap存了3组不同种元素，要删一个，这时候，我们开始从左删，因为HashMap中记录的是重复元素的个数，<strong>所以先删key值fruits[i]对应的value，删一个就一次左指针i</strong>。直到这个value &#x3D;&#x3D; 0了，说明这个重复元素删干净了，就可以把当前fruits[i]删掉了。</p>
<p><strong>不管是删fruits[i]还是删其value值，都要进行i++，所以这个i++的位置一定要放对</strong>。</p>
<p>上述的操作因为与HashMap的原始方法有一些出入，所以我们可以看到官方题解又<strong>另写了一个继承HashMap的类来重写HashMap的方法</strong>，方便我们主方法进行重复元素的增删改查。</p>
<p>最后需要注意的是，每次向右移动一次指针j，不仅要记录当前的fruits[j]和其出现次数，还要累计当前的长度ans,别忘了，我们需要返回的最终结果，就是这个每次累计的ans值。如果当前HashMap的size() &gt;&#x3D; 3，那就先进入while循环，直到size() &lt; 3了，我们再更新ans的值。<strong>所以ans和while循环的顺序一定要写对</strong>。</p>
<p>总的来说，<strong>容易出现问题的地方</strong>，首先是：</p>
<p>​		①左指针i向右移动的时机</p>
<p>​		②更新ans的时机。</p>
<h1 id="leetcode-76-最小覆盖字串（未完成）"><a href="#leetcode-76-最小覆盖字串（未完成）" class="headerlink" title="leetcode 76.最小覆盖字串（未完成）"></a>leetcode 76.最小覆盖字串（未完成）</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E8%A7%A3/" data-id="cl31ednen0000bgv69yxwh7fl" data-title="双指针题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-二分法题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E4%BA%8C%E5%88%86%E6%B3%95%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T06:01:09.000Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E4%BA%8C%E5%88%86%E6%B3%95%E9%A2%98%E8%A7%A3/">二分法题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="leetcode-704-二分查找"><a href="#leetcode-704-二分查找" class="headerlink" title="leetcode 704.二分查找"></a>leetcode 704.二分查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种二分查找的题，我们首先要看数组是不是<strong>有序的</strong>，因为我们要逐步缩小查找区间，如果数组不是有序的，那么就无法用二分法。</p>
<p>其次数组<strong>不能有重复元素</strong>，如果有重复元素我们只能找到符合条件的某一个元素，必须用一些其他手段才能找到所有符合条件的元素。</p>
<p>好了，本题自然是很简单的数组，满足有序且不重复的条件。</p>
<p>难点就是：边界条件比较难确定，即中点值大于target的时候，左边界和右边界如何收缩。</p>
<p>根据Carl大佬给的思路，我们将l和r的范围区间确定为左闭右闭的闭区间[l,r]，这样我们在while循环的时候，循环条件自然是l &lt;&#x3D; r了，<strong>因为l &#x3D;&#x3D; r也是符合闭区间的范围的</strong>。</p>
<p>进入循环后，如果nums[mid] &lt; target，说明当前mid位置的元素不符合条件，而且在target的左边，我们自然要将左边界l收缩，l &#x3D; mid还是l &#x3D; mid + 1呢？我们<strong>一定要看区间</strong>，我们确定的是闭区间，所以[mid, r]这个mid不是我们想要的范围为，[mid + 1, r]才是。</p>
<p>同理，nums[mid] &gt; target时，我们要收缩右边界r，所以[l, mid - 1]才是我们想要的范围。</p>
<p>其实，还可以将区间定义为左闭右开的区间[l, r)，这样循环体则是l &lt; r，if判断的边界条件也有区别。具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-35-搜索插入位置"><a href="#leetcode-35-搜索插入位置" class="headerlink" title="leetcode 35.搜索插入位置"></a>leetcode 35.搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。数组中无重复元素，请必须使用时间复杂度为 <code>O(log n)</code> 的算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题具体思路和上一题一样，但是难点是插入位置，也就是数组中<strong>可能不存在目标值</strong>，我们要将这个值插入到哪里是有讲究的。</p>
<p>通过二分法闭区间的思路，我们可以看出：<strong>只有跳出while循环之后return的值才是最终插入的位置</strong>，也就是没查找到目标值的情况。这个时候自然满足l &gt; r，也就是<strong>l &#x3D; r + 1</strong>。</p>
<p>既然确定了插入位置是return语句的返回值，我们就得考虑什么时候跳出循环的：走完最后一个if或者else if语句。</p>
<p>如果最后走的if语句，那么当前的l &#x3D; mid + 1，nums[mid]比target要小，我们肯定要把target插入到mid之后，也就是mid + 1，那么自然我们返回l即可。</p>
<p>如果最后走的是else if语句呢？当前r &#x3D; mid - 1，当前nums[mid]比target大，我们肯定要把target插入到mid的位置，进而把当前的mid位置的元素向后挤一位，为什么不插到mid - 1，因为**<u>mid - 1位置的元素肯定比target小</u>**，假设nums[mid - 1] &#x3D;&#x3D; 3, target &#x3D;&#x3D; 4, nums[mid] &#x3D;&#x3D; 5，就成了[4,3,5]了。所以必须要插在5的位置，形成[3, 4, 5]。因为r &#x3D; mid - 1，所以最后返回r + 1。因为跳出循环后，肯定满足前面说的l &#x3D; r + 1这个等式，所以上述分析的两种情况，即返回l或r + 1是一样的。</p>
<h2 id="leetcode-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#leetcode-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="leetcode 34.在排序数组中查找元素的第一个和最后一个位置"></a>leetcode 34.在排序数组中查找元素的第一个和最后一个位置</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBoard</span> <span class="operator">=</span> findLeftBoard(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBoard</span> <span class="operator">=</span> findRightBoard(nums, target);</span><br><span class="line">        <span class="keyword">if</span>(leftBoard == -<span class="number">2</span> || rightBoard == - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(rightBoard - leftBoard &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftBoard + <span class="number">1</span>, rightBoard - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLeftBoard</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBoard</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                leftBoard = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBoard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRightBoard</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBoard</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                rightBoard = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightBoard;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题明显有重复元素，用二分法难度陡增。</p>
<p>代码很长，所以思路一定要清晰。</p>
<p>可以看到代码分别找了左边界和右边界，两个寻找边界的方法都是采用的二分法，我们**<u>以findLeftBoard()为例</u>**。</p>
<p>我们首先定义了leftBoard的初始值，为什么是-2，这个得留到最后解释。</p>
<p>可以看到代码的if分了两部分，一部分是nums[mid] &lt; target这一部分，如果满足这个条件，那么我们让左边界</p>
<p>右移，这个没什么疑问。</p>
<p>但是else if这部分，为什么既包括了nums[mid] &gt; target的部分，又包括了nums[mid] &#x3D;&#x3D; target部分。</p>
<p>我们需要举个例子，比如当前数组是[1,2,3,3,3,3,3,3,3,3,3,3,3,3,4,5,5,6,6,7]，target是3，一上来二分法就能定位到3，但是我们要确定左边界，所以必须要通过循环体不断让mid逼近左边界，我们可以看到当确定闭区间[l, r]的时候，right是不断由mid - 1确定的，也就是<strong>真正不断向左移动的是right</strong>，所以我们的左边界一定要<strong>利用好区间[l, r]的右边界不断向左移动的这一个特点</strong>。</p>
<p>这样一来，我们就可以理解为什么每次right &#x3D; mid - 1的时候，还要更新leftBoard。right什么时候停止左移呢，答案是找到最后一个满足target &#x3D;&#x3D; 3的位置，跳出循环，返回leftBoard，这个左边界值我们可以用上一题的插入位置来考虑，因为<strong>最后的leftBoard &#x3D;&#x3D; right，而right &#x3D; mid - 1，mid这个位置是最后一个满足target的点，所以mid - 1自然是左边界的前一个值了</strong>。那么它就自然有等于-1的风险，所以我们初始化leftBoard为-2。</p>
<p>对于寻找右边界，我们的思路是一样的，只不过rightBoard最后没有等于-1的风险，所以我们可以为其初始化为-1或-2都可。</p>
<h2 id="☆leetcode-69-x的平方根"><a href="#☆leetcode-69-x的平方根" class="headerlink" title="☆leetcode 69.x的平方根"></a>☆leetcode 69.x的平方根</h2><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根。</p>
<p>由于返回类型是整数，结果只保留 整数部分，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = x, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &lt;= x)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案很简单，但是要注意用long型变量，因为mid + 1之后，其自身的平方很可能比Integer的最大范围还大，容易溢出报错，所以要用long型。</p>
<h2 id="leetcode-367-有效的完全平方数"><a href="#leetcode-367-有效的完全平方数" class="headerlink" title="leetcode 367.有效的完全平方数"></a>leetcode 367.有效的完全平方数</h2><p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法1：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = num;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &gt; num)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &lt; num)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法2：</span></span><br><span class="line"><span class="comment">//只需与69题最后返回值不同即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = num, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>) mid * mid &lt;= num) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans * ans == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与上一题需要注意的地方一样。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E4%BA%8C%E5%88%86%E6%B3%95%E9%A2%98%E8%A7%A3/" data-id="cl319inhr0000jgv6anb7cgxu" data-title="二分法题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-动态规划序列问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T04:37:29.101Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/">动态规划之序列问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-单数组找子序列问题"><a href="#1-单数组找子序列问题" class="headerlink" title="1.单数组找子序列问题"></a>1.单数组找子序列问题</h3><h4 id="lt-300-最长递增子序列"><a href="#lt-300-最长递增子序列" class="headerlink" title="lt 300.最长递增子序列"></a>lt 300.最长递增子序列</h4><p>在一个整数数组nums中，找到最长的严格<strong>递增的子序列的长度</strong>，返回其<strong>长度</strong>。如[10,9,2,5,3,7,101,18]中的[2,3,7,101]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                    max = Math.max(dp[i], max);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dp[i]是<strong>以nums[i]为结尾</strong>组成的最长递增子序列的<em><strong>长度</strong></em>。这是每个动态规划题目需要最先确定的。</p>
<p>1.首先我们知道，每一个数字都是一个长度为1的递增序列，所以<strong>每个dp[i]我们一定要初始化为1</strong>，后面具体等于多少是后面的事。</p>
<p>2.这里两层循环是重点，外层循环i(i &lt; nums.length)负责dp[i]的推进，每次推进dp[i]都<strong>需要比较nums[i]以前所有的数字</strong>，也就是内层循环j(i &lt; j)，一旦发现比nums[i]小的num[j]了，我们就要让dp[i]与当前的dp[j] + 1进行比较，取大者存入dp[i]。这才能保证<em><strong>每个dp[i]都比较过前面所有的数字，并留住了最大值</strong></em>。</p>
<p>3.我们要注意：[1,3,6,7,9,4,10,5]这个序列，如果我们没有一个随时记录的max，<em>而是直接最后返回dp[nums.length - 1]<em>，会出现这么一种情况：10这里对应的dp[6]是6，但是5这里的dp[7]只能记录比5小的dp[i]的最大值，也就是到4这里就停了，那么4呢，4会在它的循环中记录到3就停了，所以4这里的dp[5]是3，5这里的dp[7]也就是dp[nums.length]是4。最大值不是6反而成4了，这就是不随时记录max的后果，而</em></em>“罪魁祸首”是每次的dp[i]只有在nums[i] &gt; nums[j]的时候才记录**。</p>
<p><u>难点：①.初始化不是默认值0，而是1；②定义一个随时记录最大值的max</u></p>
<h4 id="lt-674-最长连续递增序列"><a href="#lt-674-最长连续递增序列" class="headerlink" title="lt 674.最长连续递增序列"></a>lt 674.最长连续递增序列</h4><p>一个没有排序的整数数组nums，找到<strong>最长的连续递增子序列</strong>，返回其<strong>长度</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                max = Math.max(dp[i], max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.一定要和300进行区分，这次是连续了，也就是增着增着突然断了是要从头（1）开始的，但是之前的长度也要记下，说不定就有最大值呢？所以还是要定义一个max来随时记录最大值；</p>
<p>2.此外，真的需要我们从头开始吗？其实不用，因为这个所谓的“头”，就是每个值得初始化——dp[i] &#x3D; 1。</p>
<p>3.最重要的是这次还用叠层循环吗？不用了，我们只需要每次让当前元素和前面的元素比较，比前面大就在前面的dp[i - 1]加上1即可，<strong>如果前面的这个dp[i - 1]“断了”，那么他自然就是1</strong>，所以也不需要我们从头开始了。</p>
<p><u>难点：1.每次断了要从1开始，容易思路变乱；2.持续记录最大值max</u></p>
<h3 id="2-两数组求子序列问题"><a href="#2-两数组求子序列问题" class="headerlink" title="2.两数组求子序列问题"></a>2.两数组求子序列问题</h3><h4 id="lt-718-最长重复子数组"><a href="#lt-718-最长重复子数组" class="headerlink" title="lt 718.最长重复子数组"></a>lt 718.最长重复子数组</h4><p>两个整数数组nums1和nums2，返回最长的<strong>公共子数组的长度</strong>。如nums1 &#x3D; [1,2,3,2,1], nums2 &#x3D; [3,2,1,4,7]，返回[3,2,1]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.二维数组解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.一维数组解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums2.length;j &gt;= <span class="number">1</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max, dp[j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.这道题叫重复子数组不如<strong>叫公共子序列</strong>，我们定义的dp[i][j)自然是以i - 1为结尾的nums1和j - 1为结尾的nums2的<strong>最长子序列长度</strong>。</p>
<p>2.就拿nums1 &#x3D; [1,2,3,2,1], nums2 &#x3D; [3,2,1,4,7]为例，外层循环一层层推进nums1中的元素，每推进一步，就执行内层循环遍历nums2所有元素，如果当前的nums1[i - 1] &#x3D;&#x3D; nums2[j - 1]，那么就让当前的dp等于不考虑这俩值的那个dp再加上考虑这俩值的1，也就是dp[i - 1][j - 1) + 1。效果如下图：</p>
<img src="https://img-blog.csdnimg.cn/2021011215282060.jpg" alt="718.最长重复子数组" style="zoom: 45%;" />

<p>3.我们看图中的最后三行，<strong>必须是45°角累加才能得到最大长度</strong>，这说明了只有当前的nums1[i - 1] &#x3D;&#x3D; nums2[j - 1]满足之后，又继续满足nums1[i - 2] &#x3D; nums2[j - 2]，以此类推，才可以实现45°累加，而这种程度的累加就说明了两个数组这些满足累加的元素<strong>必须紧挨着不能断开</strong>，才能实现累加，这就是连续的含义。<em>下面一题我们给出不连续的解法</em>。</p>
<p><u>难点：1.一维数组解法要注意<strong>每次不满足等值判断时</strong>要为当前dp赋值为0；2.一维数组解法每列要倒叙遍历；3.要随时记录最大值；4.dp的角标和nums角标很容易出错</u></p>
<h4 id="lt-1143-最长公共子序列"><a href="#lt-1143-最长公共子序列" class="headerlink" title="lt 1143.最长公共子序列"></a>lt 1143.最长公共子序列</h4><p>两个字符串text1和text2，返回两字符串最长公共子序列<strong>长度</strong>。如text1 &#x3D; “abcde”, text2 &#x3D; “ace”，返回3。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length() + <span class="number">1</span>][text2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= text1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= text2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.length()][text2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次是<strong>非连续</strong>的了，那么当前<strong>text1(i) !&#x3D; text2(j)<strong>该怎么办呢？肯定不能从头(0)来了，因为我们要查非连续的子序列，</strong>有多少算多少</strong>。以<strong>下右图</strong>的倒数第二行倒数第二列的2为例，这个时候d !&#x3D; c，那么我们看看分别<strong>让各自序列不含d或c</strong>的时候dp是多少：1.不含d，是[a,b,c]和[a,c]，有2；2.不含c，是[a,b,c,d]和[a]，只有1。所以我们取两者的最大值，来构建当前i,j下的dp(i)(j)。也就是<strong>下左图的左箭头和上箭头</strong>取最大值的方法。</p>
<p><img src="https://img-blog.csdnimg.cn/20210204115139616.jpg" alt="1143.最长公共子序列" style="zoom:45%;" /><img src="https://img-blog.csdnimg.cn/20210210150215918.jpg" alt="1143.最长公共子序列1" style="zoom: 50%;" /></p>
<p><u>难点：在text1(i) !&#x3D; text2(j)的时候，如何计算当前dp(i)(j)</u></p>
<h4 id="lt-1035-不相交的线"><a href="#lt-1035-不相交的线" class="headerlink" title="lt 1035.不相交的线"></a>lt 1035.不相交的线</h4><p>我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。</p>
<p>现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] &#x3D;&#x3D; B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p>
<p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。<img src="https://assets.leetcode.com/uploads/2019/04/26/142.png" alt="img" style="zoom:10%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= nums2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums1.length][nums2.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是求最长的公共子序列，与上面题解法一模一样</p>
<p><u>难点：将题目理解为最长公共子序列</u></p>
<h3 id="3-子序列求和"><a href="#3-子序列求和" class="headerlink" title="3.子序列求和"></a>3.子序列求和</h3><h4 id="lt-53-最大子序和"><a href="#lt-53-最大子序和" class="headerlink" title="lt 53.最大子序和"></a>lt 53.最大子序和</h4><p>在一个整数数组nums中，找到一个具有<strong>最大和</strong>的<strong>连续子数组</strong>，返回<strong>最大和</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.我们定义当前dp[i]为i之前的<strong>最大连续子序列和</strong>，那么这个和要不就是当前的nums[i] + dp[i - 1]，要么就是nums[i]，谁大是谁。</p>
<p>2.随时记录一个最大值max，以防数组中有一个很小的负数，使得最大子序和出现在中间。</p>
<p><u>难点：1.不能因为当前nums[i]太小就不加进来；2.随时记录最大值max</u></p>
<h3 id="4-一数组是另一数组的子序列问题"><a href="#4-一数组是另一数组的子序列问题" class="headerlink" title="4.一数组是另一数组的子序列问题"></a>4.一数组是另一数组的子序列问题</h3><h4 id="lt-392-判断子序列"><a href="#lt-392-判断子序列" class="headerlink" title="lt 392.判断子序列"></a>lt 392.判断子序列</h4><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。例如，”ace”是”abcde”的一个子序列，而”aec”不是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.双指针解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; j &lt; t.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == t.charAt(j))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">i</span> <span class="operator">=</span>= s.length() ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.二维数组解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> s.length(); <span class="type">int</span> <span class="variable">length2</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= length1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= length2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[length1][length2] == length1)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210303172354155.jpg" alt="392.判断子序列1" style="zoom:33%;" /><img src="https://img-blog.csdnimg.cn/2021030317364166.jpg" alt="392.判断子序列2" style="zoom:33%;" /></p>
<p><u>难点：不满足等值条件时，要让<strong>长数组</strong>不考虑当前值</u></p>
<h4 id="☆lt-115-不同的子序列-子序列个数"><a href="#☆lt-115-不同的子序列-子序列个数" class="headerlink" title="☆lt 115.不同的子序列(子序列个数)"></a>☆lt 115.不同的子序列(子序列个数)</h4><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。比如”baegg”和”bag”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= s.length();i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= t.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.这道题难度比较大，当满足等值条件的时候，dp(i)(j)要考虑两种情况，一种就是去掉这两个相等的元素，取dp(i - 1)(j - 1)；另一种很难想，就是取dp(i - 1)(j)。以”baegg”和”bag”为例，当最后一个”g” &#x3D;&#x3D; “g”的时候，可以考虑”baeg”包含“ba”的dp，<strong>也要考虑”baeg”包含”bag”的dp</strong>；如果两个g不相等，那么就只考虑”baeg”包含”ba?”的dp.</p>
<img src="https://code-thinking.cdn.bcebos.com/pics/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.jpg" alt="115.不同的子序列" style="zoom: 50%;" />

<p><u>难点：1.满足等值条件的时候，容易漏条件；2.dp(i)(0) &#x3D; 1的初始化很容易丢掉</u></p>
<h3 id="5-编辑字符串问题"><a href="#5-编辑字符串问题" class="headerlink" title="5.编辑字符串问题"></a>5.编辑字符串问题</h3><h4 id="lt-583-两个字符串的删除操作"><a href="#lt-583-两个字符串的删除操作" class="headerlink" title="lt 583.两个字符串的删除操作"></a>lt 583.两个字符串的删除操作</h4><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。例如: “sea”, “eat”，返回2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= word1.length();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt;= word2.length();j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= word1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= word2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j-<span class="number">1</span>] + <span class="number">1</span>), dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>);<span class="comment">//其实dp[i-1][j-1] + 2不用写</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题代码长，但是难度不大，只要记住初始化，含义是i或j表示字符长度，而0是空串，这样初始化就没难度了。然后就是等值的时候，因为不用删，所以dp(i)(j) &#x3D; dp(i - 1)(j - 1)；不等值就要取三种情况的最大值，<strong>其实dp(i - 1)(j - 1) + 2这个不用写</strong>。</p>
<p><u>难点：1.初始化容易忘；2.条件细节容易丢</u></p>
<h4 id="lt-72-编辑距离"><a href="#lt-72-编辑距离" class="headerlink" title="lt 72.编辑距离"></a>lt 72.编辑距离</h4><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p>
<p>你可以对一个单词进行如下三种操作：插入，删除或替换一个字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; word1.length() + <span class="number">1</span>;i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; word2.length() + <span class="number">1</span>;j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; word1.length() + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; word2.length() + <span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i -<span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>), dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实和上面的583非常相似，记住增加就是删除的逆推，所以合二为一，替换可以让两个分别的删除操作合二为一</p>
<p><u>难点：1.初始化容易忘；2.条件细节容易丢</u></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/" data-id="cl3cvqp5y0000ssv6fjn3a0kv" data-title="动态规划之序列问题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL个人总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/MySQL%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T03:37:29.914Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/MySQL%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">MySQL个人总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="01讲-基础架构：一条SQL查询语句是如何执行的？"><a href="#01讲-基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="01讲 | 基础架构：一条SQL查询语句是如何执行的？"></a>01讲 | 基础架构：一条SQL查询语句是如何执行的？</h2><p>下图是MySQL的逻辑架构图</p>
<img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img" style="zoom:30%;" />

<p>大体来说，MySQL可以分为Server层和存储引擎层两部分</p>
<p>Server层包括：连接器、查询缓存、分析器、优化器和执行器等。而<strong>不同的存储引擎共用</strong>一个Server层。</p>
<h3 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1.连接器"></a>1.连接器</h3><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</p>
<h3 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a>2.查询缓存</h3><p>MySQL拿到一个查询请求之后，会先到查询缓存中看看，之前查没查过，如果查过，之前执行过的语句和结果，会以key-value的形式，直接缓存在内存中。不过，只要有<strong>对一个表的更新操作，这个表上的所有查询缓存都会被清空</strong>，所以命中率较低，在MySQL 8.0以后已经<strong>被淘汰</strong>了。</p>
<h3 id="3-分析器（要做什么）"><a href="#3-分析器（要做什么）" class="headerlink" title="3.分析器（要做什么）"></a>3.分析器（要做什么）</h3><p>查询缓存未命中，则先走分析器，做<strong>“词法分析”</strong>，识别里面的字符串都是什么，代表什么。同时也会<strong>判断所查询的字段是否存在</strong>。然后做“<strong>语法分析</strong>”，判断这个SQL语句是否符合MySQL语法。</p>
<h3 id="4-优化器（该怎么做）"><a href="#4-优化器（该怎么做）" class="headerlink" title="4.优化器（该怎么做）"></a>4.优化器（该怎么做）</h3><p>优化器是在表里面有多个索引的时候，决定使用哪个索引，或者多表关联(join)的时候，决定各表连接顺序。</p>
<h3 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5.执行器"></a>5.执行器</h3><p>要先判断当前用户<strong>是否对表有查询权限</strong>。为什么到这里才查权限，其实一共有三层查询权限的过程，引用极客的评论：“连接器是账号权限校验   分析器是库权限验证   执行器是语句在表中权限验证。”</p>
<p>假如当前查询的字段<strong>没有索引</strong>，那么就是走全表扫描，具体操作<strong>不是存储引擎单独完成的，而是执行器每次调用InnoDB引擎的接口来走全表扫描的</strong>。</p>
<p><u>记住！！！存储引擎是<strong>基于表</strong>的，而不是基于数据库的。</u></p>
<p>如果<strong>有索引</strong>，那么执行器就<strong>直接调用InnoDB“满足条件的这一行”这个接口</strong>。</p>
<p>我们在使用慢查询日志的时候看到的<strong>rows_examined</strong>的字段，表示<strong>语句执行过程中扫描了多少行</strong>，这个值其实就是<strong>执行器每次调用引擎</strong>获取数据行的时候<strong>累加</strong>的。<!--这里不确定执行器的这个累加值到底是怎么算的--></p>
<p>不过需要注意的是，<strong>执行器调用一次，引擎可能扫描多行</strong>，所以引擎扫描行数和rows_examined<strong>并不完全相同</strong>。</p>
<h2 id="08讲-事务到底是隔离的还是不隔离的？"><a href="#08讲-事务到底是隔离的还是不隔离的？" class="headerlink" title="08讲 | 事务到底是隔离的还是不隔离的？"></a>08讲 | 事务到底是隔离的还是不隔离的？</h2><h3 id="1-可重复读隔离级别"><a href="#1-可重复读隔离级别" class="headerlink" title="1.可重复读隔离级别"></a>1.可重复读隔离级别</h3><p>先创建下面的表，只含有id和k两列，id为主键，插入了两行数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `k` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into t(id, k) values(1,1),(2,2);</span><br></pre></td></tr></table></figure>

<p>在<strong>可重复读的隔离级别</strong>下执行下面的三个事务：</p>
<img src="https://static001.geekbang.org/resource/image/82/d6/823acf76e53c0bdba7beab45e72e90d6.png" alt="img" style="zoom:50%;" />

<p>注意start&#x2F;begin transaction不是事务的起点，起点是其后面的<strong>第一个操作InnoDB的语句</strong>；</p>
<p>而start transaction with consistent snapshot顾名思义<strong>创建一致性视图</strong>，才是事务的<strong>起点</strong>。</p>
<p>图中例子默认<strong>autocommit&#x3D;1</strong>，即<strong>除非显示声明事务开始</strong>，否则默认一个语句执行完就提交</p>
<p>首先，因为是RR隔离级别，所以我们开启了事务以后，其他在当前事务之后的更新都不会被读取到，但是这只涉及查询语句。因为<strong>查询语句是快照读</strong>：</p>
<p>比如事务A我们定义其事务Id为99，那么事务B就是100，事务C就是101，<strong>事务B和C的Id都比A要大</strong>，他们的快照不会被事务A中的查询语句读取到，所以最后事务A**读取的还是(1,1)**，即实现了可重复读。快照读有下面三种判断方式：</p>
<p>​	1.事务已提交，但是在视图创建之后提交的，该视图不可见；（比如事务C对于A）</p>
<p>​	2.事务已提交，而且在视图创建之前提交的，该视图就可见；（比如一个比A还早的事务提交过）</p>
<p>​	3.事务未提交，那肯定不可见。（比如事务B对于A）</p>
<p>以上是快照读，那么当前读是什么呢？</p>
<p>对于增删改操作，数据都是<strong>先读后写</strong>的，这个读，就是<strong>读取当前最新的快照</strong>。对于查询语句，我们可以在select语句中加上lock in share mode（读锁，共享锁）或for update（写锁，排他锁），所以事务B更新的数据是在事务C更新结束后再更新的，即(1,2) -&gt; (1,3)。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">S 锁（读锁）</th>
<th>X 锁（写锁）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S 锁</td>
<td align="left">不冲突</td>
<td>冲突</td>
</tr>
<tr>
<td align="left">X 锁</td>
<td align="left">冲突</td>
<td>冲突</td>
</tr>
</tbody></table>
<p>下面把事务发生流程稍微改动一下，即<strong>事务C</strong>在事务B更新、查询之前<strong>没有立刻提交</strong>（改成C’）：</p>
<img src="https://static001.geekbang.org/resource/image/cd/6e/cda2a0d7decb61e59dddc83ac51efb6e.png" alt="img" style="zoom:50%;" />

<p>这里C’因为没有及时提交，所以更新完变成(1,2)之后，正拿着这个快照版本的写锁还没释放，事务B是当前读，必须要读最新的版本，还必须得给最新版本加锁，这些步骤缺一不可，所以事务B的这个当前读操作就被C’的写锁给锁住了，<strong>必须等C’释放写锁</strong>，才可以继续进行当前读。</p>
<h3 id="2-读提交隔离级别"><a href="#2-读提交隔离级别" class="headerlink" title="2.读提交隔离级别"></a>2.读提交隔离级别</h3><p>这个级别其实就<strong>不存在持续整个事务的一致性快照</strong>了，即start transaction with consistent snapshot和start&#x2F;begin transaction是<strong>没差别</strong>的。也就是说，<strong>每一个语句执行前都会重新计算出一个新的视图</strong>。</p>
<img src="https://static001.geekbang.org/resource/image/18/be/18fd5179b38c8c3804b313c3582cd1be.jpg" alt="img" style="zoom:33%;" />

<p>所以再来看上面A事务，我们就可以确定，C这次要比A事务发生的早，而且也提交了，所以读取(1,2)是没问题的。而B虽然也比A事务早，但是A事务执行的时候，<strong>B还没提交</strong>，所以A读取不到(1,3)，所以最终A读取的就是(1,2)。</p>
<h2 id="16讲-“order-by”是怎么工作的？"><a href="#16讲-“order-by”是怎么工作的？" class="headerlink" title="16讲 | “order by”是怎么工作的？"></a>16讲 | “order by”是怎么工作的？</h2><h2 id="17讲-如何正确地显示随机消息"><a href="#17讲-如何正确地显示随机消息" class="headerlink" title="17讲 | 如何正确地显示随机消息"></a>17讲 | 如何正确地显示随机消息</h2><p>本文是沿着上一篇order by语句来进行展开的。本篇文章讲述一种排序的需求，即从大量数据（words）中随机查找若干个数据（word）。</p>
<h3 id="1-order-by-rand"><a href="#1-order-by-rand" class="headerlink" title="1. order by rand()"></a>1. order by rand()</h3><p>如果用MySQL自带的随机语句order by rand()来进行查找，流程如下：</p>
<p>1.先在<strong>内存中</strong>建立一个临时表，用来储存随机小数(R字段)以及word，此处需要扫描10000行</p>
<p>2.然后将临时表的内容一个一个存储到sort_buffer中，这里储存的是随机小数R字段和位置信息。这又需要扫描10000行</p>
<p>3.这时再将sort_buffer中的内容根据随机小数进行排序，这里不需要表操作，所以不需要扫描行数、</p>
<p>4.最后从排列好的sort_buffer中根据位置信息选出前三个，然后去内存临时表中取出三个对应的word</p>
<h3 id="2-随机排序方法"><a href="#2-随机排序方法" class="headerlink" title="2. 随机排序方法"></a>2. 随机排序方法</h3><p>然后为了优化上述方法，作者提出<strong>随机排序方法</strong>：</p>
<p>1.取得words表的主键id的最大值和最小值</p>
<p>2.用随机函数根据上面这俩值生成一个随机数X</p>
<p>3.取不小于X的第一个id的行</p>
<p>这种方法不严谨，因为X可能周围有可能含有好多空洞，也可能X本身的位置有空洞，所以每个数据被取到的概率是不一样的。</p>
<p>然后上述方法<strong>进行优化</strong>：</p>
<p>1.首先取得整个word表的行数，C</p>
<p>2.对这个行数C进行rand()函数运算，然后取整，Y</p>
<p>3.用limit Y,1取得一行（这里的意思是丢掉前Y个值，取第一个，如果是空洞则跳过）。</p>
<p>这种算法总共需要扫描C+Y+1行，代价其实比优化前要高，但是保证了空洞不会被取到，且每个数据能被公平取到。如果随机取三个数，那么扫描的行数就是C+(Y1+1)+(Y2+1)+(Y3+1)</p>
<p>本篇文章的核心思想就是：<strong>尽量将业务逻辑写在业务代码中，让数据库仅仅去做“读写数据”的事情</strong>。</p>
<h2 id="18讲-为什么这些SQL语句逻辑相同，性能却差异巨大？"><a href="#18讲-为什么这些SQL语句逻辑相同，性能却差异巨大？" class="headerlink" title="18讲 | 为什么这些SQL语句逻辑相同，性能却差异巨大？"></a>18讲 | 为什么这些SQL语句逻辑相同，性能却差异巨大？</h2><p>本篇文章讲述的是条件查询时，一些SQL语句执行过慢的现象以及原因。</p>
<h3 id="1-条件字段函数操作"><a href="#1-条件字段函数操作" class="headerlink" title="1.条件字段函数操作"></a>1.条件字段函数操作</h3><p>一个关于日期（datetime）的索引如下，这个索引的名字是t_modified，如果我们想查询索引中七月的数据，可以用函数month()，即where month(t_modified)&#x3D;7，但是这个时候，SQL语句执行的特别慢，原因就在于：我们对索引字段做了函数计算，人家字段明明是有年有月有日的字段，你只取其中的月来进行查询，必然需要month函数，但是MySQL规定<strong>对字段使用了函数计算，就不能使用索引了</strong>，这个时候就会<strong>执行全表扫描</strong>，执行速度非常慢。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from tradelog where month(t_modified)=7;</span><br></pre></td></tr></table></figure>

<p>为什么走全索引搜索？因为对索引字段进行函数操作，<strong>可能会对索引值的有序性造成破坏</strong>，所以优化器<strong>默认会放弃走树搜索功能</strong>。</p>
<p>这里<strong>要注意</strong>：<strong>不是放弃了使用这个索引</strong>，而是放弃在这个索引上面走树搜索，转而执行全索引扫描。</p>
<img src="https://static001.geekbang.org/resource/image/3e/86/3e30d9a5e67f711f5af2e2599e800286.png" alt="img" style="zoom: 50%;" />

<p>优化方法：执行如下代码，即优化器可以判断在t_modified索引上走树搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from tradelog where</span><br><span class="line">    -&gt; (t_modified &gt;= &#x27;2016-7-1&#x27; and t_modified&lt;&#x27;2016-8-1&#x27;) or</span><br><span class="line">    -&gt; (t_modified &gt;= &#x27;2017-7-1&#x27; and t_modified&lt;&#x27;2017-8-1&#x27;) or </span><br><span class="line">    -&gt; (t_modified &gt;= &#x27;2018-7-1&#x27; and t_modified&lt;&#x27;2018-8-1&#x27;);</span><br></pre></td></tr></table></figure>

<p>所以这里提到了优化器“偷懒”的行为：即使你认为你的SQL语句对索引字段的有序性不造成破坏，它还是默认会破坏的。比如如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where id + 1 = 10000</span><br></pre></td></tr></table></figure>

<p>我们在执行前必须手动改成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where id = 10000 - 1</span><br></pre></td></tr></table></figure>

<h3 id="2-隐式类型转换"><a href="#2-隐式类型转换" class="headerlink" title="2.隐式类型转换"></a>2.隐式类型转换</h3><p>这里<strong>需要记住：MySQL会自动将字符串转成数字</strong>，比如如下代码（假如tradeid是int类型变量）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where tradeid=&quot;110717&quot;;</span><br></pre></td></tr></table></figure>

<p>但是如果tradeid是varchar(32)类型，即字符串，那么如下的代码就需要隐式地将数字转换为字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where tradeid=110717;</span><br></pre></td></tr></table></figure>

<p>所以上面这个代码对于优化器来说，实际的执行语句是（即对索引字段执行了函数，优化器放弃走树搜索）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where CAST(tradid AS signed int) = 110717;</span><br></pre></td></tr></table></figure>

<h3 id="3-隐式字符编码转换"><a href="#3-隐式字符编码转换" class="headerlink" title="3.隐式字符编码转换"></a>3.隐式字符编码转换</h3><p>在如下代码中，执行了连表查询，即先在l表中找到id&#x3D;2的行，然后去d表中查找满足d.tradeid&#x3D;l.tradeid的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2;</span><br></pre></td></tr></table></figure>

<p>在这里，l是驱动表，d是被驱动表，tradeid是关联字段。</p>
<p>这个时候，如果驱动表和被驱动表的字符集不同，比如驱动表是utf8mb4，被驱动表是utf8，那么被驱动表的索引字段<strong>在查询的时候会被执行函数，这个函数隐式地将utf8向上转型为更大的字符集utf8mb4</strong>；如果反过来，即被驱动表的字符集比较大，则不会出现隐式地执行函数这一问题。</p>
<p>与前面两种情况相同，<strong>被驱动表的索引字段被执行了函数，优化器默认不走索引的树搜索</strong>。</p>
<p>优化的方式有二：</p>
<p>其一是将被驱动表的字符集直接转换为utf8mb4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null;</span><br></pre></td></tr></table></figure>

<p>但是数据量比较大或者业务不允许的话，可以主动地将驱动表的字符集下调至utf8，从而避免被驱动表在被隐式执行函数的操作，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2; </span><br></pre></td></tr></table></figure>

<h3 id="4-思考题补充情况"><a href="#4-思考题补充情况" class="headerlink" title="4.思考题补充情况"></a>4.思考题补充情况</h3><p>一个可变的字符串在定义的时候，长度只有10，即b varchar(10)：</p>
<p>如果执行如下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from table_a where b=&#x27;1234567890abcd&#x27;;</span><br></pre></td></tr></table></figure>

<p>按理说，表中肯定没有这个字段，返回null就行了，但是<strong>MySQL实际上对上述结果进行了截断</strong>，截断成长度为10的字符串，所以交给引擎层的数据实际是’1234567890’，假如满足这个查询条件的数据有数万行，那么<strong>一共需要做数万次回表操作</strong>，每次回表查出的整行数据<strong>再给server层判断</strong>，判断其是否与’1234567890abcd’相等，最后查询不到该数据就返回空值。</p>
<h2 id="19讲-为什么我只查一行的语句，也执行这么慢？"><a href="#19讲-为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="19讲 | 为什么我只查一行的语句，也执行这么慢？"></a>19讲 | 为什么我只查一行的语句，也执行这么慢？</h2><h3 id="1-第一类：查询长时间不返回"><a href="#1-第一类：查询长时间不返回" class="headerlink" title="1.第一类：查询长时间不返回"></a>1.第一类：查询长时间不返回</h3><p>有如下代码，查询结果长时间不返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1;</span><br></pre></td></tr></table></figure>

<p>可能的原因有如下几种：</p>
<h4 id="1-等MDL（metadata-lock）锁"><a href="#1-等MDL（metadata-lock）锁" class="headerlink" title="1.等MDL（metadata lock）锁"></a>1.等MDL（metadata lock）锁</h4><p>这种原因可以通过执行show processlist命令来查看Waiting for table metadata lock</p>
<img src="https://static001.geekbang.org/resource/image/50/28/5008d7e9e22be88a9c80916df4f4b328.png" alt="img" style="zoom: 50%;" />

<p>出现这种状态就表示：现在有一个线程<strong>正在表t上请求或者持有MDL写锁</strong>，把select语句堵住了。</p>
<p>复现如下：</p>
<img src="https://static001.geekbang.org/resource/image/74/ca/742249a31b83f4858c51bfe106a5daca.png" alt="img" style="zoom:50%;" />

<p>处理方式是：<strong>找到谁持有MDL写锁，把它kill掉</strong>。</p>
<p>但是上面图片中，这个线程对应的Command是Sleep，导致查找不便。我们可以在MySQL启动时设置performance_schema&#x3D;on，然后通过下面的命令找到该线程（然后kill它）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select blocking_pid from sys.schema_table_lock_waits;</span><br></pre></td></tr></table></figure>

<h4 id="2-等flush（刷盘）"><a href="#2-等flush（刷盘）" class="headerlink" title="2.等flush（刷盘）"></a>2.等flush（刷盘）</h4><p>这种堵塞，我们在执行show processlist命令时，可以看到Waiting for table flush</p>
<img src="https://static001.geekbang.org/resource/image/2d/24/2d8250398bc7f8f7dce8b6b1923c3724.png" alt="img" style="zoom:50%;" />

<p>出现这种状态就表示：<strong>现在有一个线程正在对表t做flush操作</strong>。</p>
<p>但是实际上，这个操作非常快，所以真正的原因应该是flush操作被其他线程堵住了，进而flush堵住了我们的select操作。</p>
<p>复现如下：</p>
<img src="https://static001.geekbang.org/resource/image/2b/9c/2bbc77cfdb118b0d9ef3fdd679d0a69c.png" alt="img" style="zoom:50%;" />

<h4 id="3-等行锁"><a href="#3-等行锁" class="headerlink" title="3.等行锁"></a>3.等行锁</h4><p>前面两个情况都是表级锁导致的阻塞，<strong>select语句并没有进入引擎中</strong>。</p>
<p>而等行锁的情况，用下面这种复现就一目了然了：</p>
<img src="https://static001.geekbang.org/resource/image/3e/75/3e68326b967701c59770612183277475.png" alt="img" style="zoom:50%;" />

<p>事务A并没有提交，所以事务A在id&#x3D;1上拥有持有写锁，而当前事务B执行的是当前读（lock in share mode是共享锁，for update是排他锁），所以事务B访问id&#x3D;1要加读锁，那么事务A占有的写锁自然会堵住事务B。</p>
<p>与MDL写锁的查询方式一样，可以通过 sys.innodb_lock_waits 表查到元凶。</p>
<img src="https://static001.geekbang.org/resource/image/d8/18/d8603aeb4eaad3326699c13c46379118.png" alt="img" style="zoom: 50%;" />

<p>但需要注意的是，这个表同时提到了KILL QUERY 4和KILL 4，实际上<strong>前者是停止4号线程当前正在执行的语句</strong>，这其实<strong>没用</strong>，因为update早已执行完，停止语句并不能让id&#x3D;1上的行锁去掉；只有执行KILL 4，即<strong>断开这个事务的连接，这时该线程会自动回滚</strong>，进而<strong>释放了id&#x3D;1上的行锁</strong>。</p>
<h3 id="2-第二类：查询慢"><a href="#2-第二类：查询慢" class="headerlink" title="2.第二类：查询慢"></a>2.第二类：查询慢</h3><p>来看看这个例子：</p>
<p>执行下面语句，但执行时间要800ms：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1;</span><br></pre></td></tr></table></figure>

<p>但给这个查询加共享锁（当前读），则只需要0.2ms：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1 lock in share mode;</span><br></pre></td></tr></table></figure>

<p>按理说，加锁比不加锁还多一个步骤，应该更慢才对，实际上看下面的复现就懂了：</p>
<img src="https://static001.geekbang.org/resource/image/84/ff/84667a3449dc846e393142600ee7a2ff.png" alt="img" style="zoom:50%;" />

<p>当前隔离级别是innoDB默认的repeatable read，所以不加行锁的查询语句执行的<strong>是一致读</strong>，需要<strong>将执行100万次的更新回滚至更新之前</strong>；而加共享锁的查询语句执行的<strong>是当前读</strong>，<strong>不需要回滚操作</strong>，直接返回当前快照的结果，步骤如下：</p>
<img src="https://static001.geekbang.org/resource/image/46/8c/46bb9f5e27854678bfcaeaf0c3b8a98c.png" alt="img" style="zoom: 33%;" />

<h2 id="第20讲-幻读是什么，幻读有什么问题？"><a href="#第20讲-幻读是什么，幻读有什么问题？" class="headerlink" title="第20讲 | 幻读是什么，幻读有什么问题？"></a>第20讲 | 幻读是什么，幻读有什么问题？</h2><p>这篇文章难度较大，作者通过假设与反证法证明了间隙锁存在的意义。</p>
<p>首先我们给出一个例子，在例子的基础上理解这节课的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure>

<p>可以看出，这个表有两个索引，一个是主键索引，另一个是普通索引c。</p>
<h3 id="1-所查询字段没有索引（走主键索引）"><a href="#1-所查询字段没有索引（走主键索引）" class="headerlink" title="1.所查询字段没有索引（走主键索引）"></a>1.所查询字段没有索引（走主键索引）</h3><p>下面我们执行如下语句，<strong>是怎么加锁的，这些锁是什么时候释放的呢</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where d=5 for update;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>结果是：因为数据d没有建立索引，所以在查询过程中<strong>需要走全表索引</strong>，也就是主键id的索引，这个时候<strong>不会锁单独的某行，而是对全表上锁</strong>，即上表锁。如果在该事务提交前，有其他事物进行CRUD操作，都会被表锁阻塞，即发生上一讲的“等MDL锁”现象。</p>
<h3 id="2-所查询字段有普通索引（走普通索引）"><a href="#2-所查询字段有普通索引（走普通索引）" class="headerlink" title="2.所查询字段有普通索引（走普通索引）"></a>2.所查询字段有普通索引（走普通索引）</h3><p>如果执行如下语句，<strong>又是怎么加锁的，这些锁是什么时候释放的呢</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where c=5 for update;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>注意这里c有索引，所以该查询语句走普通索引，这个时候会对c&#x3D;5上行锁，同时在(0,5)以及(5,10)上间隙锁。</p>
<p>表t的普通索引c和主键索引的行锁和间隙锁如下图所示（注意这里的数值之所以一样，是因为插入的时候id和c的值是一样的，比如(0,0,0),(5,5,5)等）：</p>
<img src="https://static001.geekbang.org/resource/image/e7/61/e7f7ca0d3dab2f48c588d714ee3ac861.png" alt="img" style="zoom: 50%;" />

<p>按照B+树搜索规则，找到满足c&#x3D;5的位置，然后对c&#x3D;5上行锁，同时在(0,5)与(5,10)这两个区间上间隙锁，这还没完，我们<strong>还要找到第一个不满足c&#x3D;5的位置才可以结束</strong>，显然该行为c&#x3D;10，所以c&#x3D;10这一行也被上了行锁，所以整个c的索引上，在区间(0,5] &amp;&amp; (5,10]也就是(0,10]上了锁，然后因为c&#x3D;10不满足条件，c&#x3D;10的行锁会去掉（下一章会讲到），所以<strong>最后为两个间隙锁(0,5), (5,10)和一个c&#x3D;5的行锁</strong>。此时如果在该事物提交之前有其他事物在这个区间执行CRUD操作会被阻塞，<strong>这种阻塞是行锁性质的阻塞</strong>。</p>
<h3 id="3-间隙锁的引入对并发度的影响"><a href="#3-间隙锁的引入对并发度的影响" class="headerlink" title="3.间隙锁的引入对并发度的影响"></a>3.间隙锁的引入对并发度的影响</h3><p>有如下操作：</p>
<img src="https://static001.geekbang.org/resource/image/df/be/df37bf0bb9f85ea59f0540e24eb6bcbe.png" alt="img" style="zoom:50%;" />

<p>首先A事物执行查询语句，此时因为表t中没有id&#x3D;9的行，所以会在(5,10)区间上间隙锁，下一时刻B同样执行查询语句，我们知道，<strong>如果查的不是不存在的id&#x3D;9而是id&#x3D;5</strong>，那么<strong>A事物拥有id&#x3D;5的写锁，会阻塞B事物访问id&#x3D;5</strong>。但是现在A事物查询的是不存在的id&#x3D;9，上的是区间的间隙锁，那么此时B事物的查询语句不会被该间隙锁阻塞，同样也会对(5,10)区间上间隙锁。这也就说明：<strong>间隙锁之间不会像读写锁一样发生冲突</strong>。所以B在执行下一条插入语句时，会被A事物的间隙锁阻塞，同样A执行插入语句也会被B事物的间隙锁阻塞，进而产生了死锁现象。</p>
<h2 id="第21讲-为什么我只改一行的语句，锁这么多？"><a href="#第21讲-为什么我只改一行的语句，锁这么多？" class="headerlink" title="第21讲 | 为什么我只改一行的语句，锁这么多？"></a>第21讲 | 为什么我只改一行的语句，锁这么多？</h2><h3 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h3><p>本集作者根据MySQL源码总结出了两个原则，两个优化和一个bug</p>
<p>1.原则1：加锁的基本单位是next-key lock，这其实是<strong>先加间隙锁再加行锁的产物</strong>，所以区间为前开后闭。</p>
<p>2.原则2：查找过程中访问到的对象才会加锁，<strong>没有访问到不会加锁</strong>。</p>
<p>3.优化1：索引上的<strong>等值查询</strong>，给<strong>唯一索引</strong>加锁的时候，next-key lock<strong>退化为行锁</strong>。</p>
<p>4.优化2：索引上的<strong>等值查询</strong>，直到最后向右遍历到不满足等值条件时，next-key lock退化为间隙锁。</p>
<p>5.一个bug：<strong>唯一索引</strong>的<strong>范围查询</strong>，也会访问到最后一个不满足条件的值。</p>
<p>首先拿出上节课的表数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure>

<p>可以看出，这个表有两个索引，一个是主键索引，另一个是普通索引c。</p>
<h3 id="案例一：等值查询间隙锁"><a href="#案例一：等值查询间隙锁" class="headerlink" title="案例一：等值查询间隙锁"></a>案例一：等值查询间隙锁</h3><img src="https://static001.geekbang.org/resource/image/58/6c/585dfa8d0dd71171a6fa16bed4ba816c.png" alt="img" style="zoom:50%;" />

<p>这个案例其实和上一讲的select * from t where c &#x3D; 5差不多。</p>
<p>因为是等值查询，根据原则1，先上锁(5,10]。然后根据优化2，等值查询，c&#x3D;10不满足条件，(5,10]退化为间隙锁(5,10)。</p>
<h3 id="☆案例二：非唯一索引等值锁（覆盖索引）"><a href="#☆案例二：非唯一索引等值锁（覆盖索引）" class="headerlink" title="☆案例二：非唯一索引等值锁（覆盖索引）"></a>☆案例二：非唯一索引等值锁（覆盖索引）</h3><img src="https://static001.geekbang.org/resource/image/46/65/465990fe8f6b418ca3f9992bd1bb5465.png" alt="img" style="zoom: 33%;" />

<p>首先根据原则1，先上锁(0,5]，<strong>如果c是唯一索引，那么我们就可以停止了，而且会退化为行锁c&#x3D;5</strong>，但是这里c是非唯一索引，所以还会向右遍历到第一个不满足条件的c&#x3D;10。<strong>根据原则2，c&#x3D;10被访问到了</strong>，所以继续给(5,10]上锁。然后根据优化2，c&#x3D;10不满足条件，所以退化为间隙锁(5,10)。</p>
<p>所以最终的锁为(0,5)和(5,10)的间隙锁还有c&#x3D;5的行锁。从中我们可以看出C事物必然被锁，那为什么B事物没有被锁呢，因为这个例子用的是<strong>共享锁，只锁覆盖索引</strong>，如果用<strong>排他锁</strong>(for update)，系统会默认你要更新数据，就会顺便<strong>把主键索引满足条件的行上行锁</strong>。</p>
<p>如果我们<strong>要查询的字段在覆盖索引中找不到，那么系统就会走主键索引</strong>，那么自然就会把主键索引中满足条件的行上行锁了。比如将A事物改为select d from t where c&#x3D;5 lock in share mode;</p>
<h3 id="案例三：主键索引的范围锁（唯一索引）"><a href="#案例三：主键索引的范围锁（唯一索引）" class="headerlink" title="案例三：主键索引的范围锁（唯一索引）"></a>案例三：主键索引的范围锁（唯一索引）</h3><img src="https://static001.geekbang.org/resource/image/30/80/30b839bf941f109b04f1a36c302aea80.png" alt="img" style="zoom: 33%;" />

<p>首先根据原则1，找到id&#x3D;10，next-key lock为(5,10]，根据优化1（<strong>这里id&#x3D;10按等值索引规则走</strong>），唯一索引的锁退化为行锁，即c&#x3D;10。因为是范围查询，我们还需要继续向后找到不满足的第一个条件，即c&#x3D;15，这个时候根据原则1，next-key lock为(10,15]，<strong>但是这里一定要注意，范围查询没有优化，只有所谓的bug，所以范围查询不会退化间隙锁</strong>。</p>
<p>所以最后有两个行锁c&#x3D;10和c&#x3D;15，还有间隙锁(5,10)。（根据评论，已经有版本修复了这个”bug”，即没有c&#x3D;15这个没必要的行锁了）</p>
<h3 id="案例四：非唯一索引范围锁"><a href="#案例四：非唯一索引范围锁" class="headerlink" title="案例四：非唯一索引范围锁"></a>案例四：非唯一索引范围锁</h3><img src="https://static001.geekbang.org/resource/image/73/7a/7381475e9e951628c9fc907f5a57697a.png" alt="img" style="zoom:33%;" />

<p>与案例三不同的是，这个索引是普通索引c。</p>
<p>首先根据原则1，找到c&#x3D;10的行，对(5,10]上锁。然后范围查询，找到第一个不满足条件的c&#x3D;15，对(10,15]上锁，<strong>同样因为范围查询没有优化，所以(10,15]不会退化为间隙锁</strong>。</p>
<p>所以最后为两个next-key lock，分别是(5,10]和(10,15]。（也可以说是两个间隙锁加两个行锁）</p>
<h3 id="案例五：唯一索引范围锁bug"><a href="#案例五：唯一索引范围锁bug" class="headerlink" title="案例五：唯一索引范围锁bug"></a>案例五：唯一索引范围锁bug</h3><img src="https://static001.geekbang.org/resource/image/b1/6d/b105f8c4633e8d3a84e6422b1b1a316d.png" alt="img" style="zoom:33%;" />

<p>这里要看清楚，是id&gt;10不是id&#x3D;10，所以没有案例三中的id&#x3D;10这个等值查询了（案例三id &gt;&#x3D; 10是等值查询），所以<strong>直接走范围查询找到id&#x3D;15</strong>，根据原则1，对(10,15]上next-key lock锁，这里因为是<strong>范围查询，没有优化</strong>，不会发生退化。按理说找到id &#x3D; 15就可以停止了，<strong>但是MySQL必须找到第一个不满足条件的数据才能停止</strong>，所以会继续找到id&#x3D;20，然后根据原则1，对(15,20]上next-key lock锁，这也就证明为什么事物B和事物C被锁上了。（后面的版本已经修复，貌似是8.0.18）</p>
<p>所以最终有两个next-key lock锁，分别是(10,15]和(15,20]。</p>
<h3 id="案例六：非唯一索引存在“等值”的例子"><a href="#案例六：非唯一索引存在“等值”的例子" class="headerlink" title="案例六：非唯一索引存在“等值”的例子"></a>案例六：非唯一索引存在“等值”的例子</h3><p>对本来就含有c&#x3D;10的索引中，再插入一个c&#x3D;10，会发生什么呢，执行语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t values(30,10,30);</span><br></pre></td></tr></table></figure>

<p>其实我们会发现索引c中c&#x3D;10会有两个数据，分别是(c&#x3D;10,id&#x3D;10)和(c&#x3D;10,id&#x3D;30)，如下图所示：</p>
<img src="https://static001.geekbang.org/resource/image/c1/59/c1fda36c1502606eb5be3908011ba159.png" alt="img" style="zoom: 33%;" />

<p>自然我们就可以发现，c&#x3D;10自身一会产生间隙的。</p>
<img src="https://static001.geekbang.org/resource/image/b5/78/b55fb0a1cac3500b60e1cf9779d2da78.png" alt="img" style="zoom:33%;" />

<p>首先声明：delete语句和select…for update语句加锁的逻辑类似，所以上面的枷锁规则依旧适用。</p>
<p>根据原则1，首先找到(c&#x3D;10,id&#x3D;10)而不是(c&#x3D;10,id&#x3D;30)，所以这里的next-key lock为(c&#x3D;5,id&#x3D;5)到(c&#x3D;5,id&#x3D;10)的左开右闭区间，然后直到找到不满足条件的行(c&#x3D;15,id&#x3D;15)，继续根据原则1，next-key lock为(c&#x3D;10,id&#x3D;10)到(c&#x3D;15,id&#x3D;15)的左开右闭区间，根据优化2，退化为间隙锁，即(c&#x3D;10,id&#x3D;10)到(c&#x3D;15,id&#x3D;15)的左开右开区间。</p>
<p>所以最终的区间是图中的开区间：</p>
<img src="https://static001.geekbang.org/resource/image/bb/24/bb0ad92483d71f0dcaeeef278f89cb24.png" alt="img" style="zoom:33%;" />

<h3 id="案例七：limit语句加锁"><a href="#案例七：limit语句加锁" class="headerlink" title="案例七：limit语句加锁"></a>案例七：limit语句加锁</h3><img src="https://static001.geekbang.org/resource/image/af/2e/afc3a08ae7a254b3251e41b2a6dae02e.png" alt="img" style="zoom: 50%;" />

<p>这次加了个limit，发现B事物通过了。其实这是因为索引遍历到(c&#x3D;10,id&#x3D;30)的时候，limit 2条件已经满足了，所以不会向后走了。</p>
<p>所以加锁范围如下所示(左开右闭)：</p>
<img src="https://static001.geekbang.org/resource/image/e5/d5/e5408ed94b3d44985073255db63bd0d5.png" alt="img" style="zoom: 33%;" />

<h3 id="案例八：一个死锁的例子"><a href="#案例八：一个死锁的例子" class="headerlink" title="案例八：一个死锁的例子"></a>案例八：一个死锁的例子</h3><img src="https://static001.geekbang.org/resource/image/7b/06/7b911a4c995706e8aa2dd96ff0f36506.png" alt="img" style="zoom: 33%;" />

<p>首先c&#x3D;10，我们可以根据案例1确定了上锁区间为(5,15)。然后事物B按道理被事物A锁住了，但是我们发现事物A在插入c&#x3D;8的操作时竟然被阻塞了，其实原因就是<strong>事物B上了间隙锁(5,10)，而行锁c&#x3D;10进入锁等待</strong>，所以在A执行插入操作的时候发生了死锁现象，InnoDB让事物B回滚，插入最终才成功。</p>
<p>这个案例证明了next-key lock其实是分步执行的，先上间隙锁，再上行锁。间隙锁之间无互斥现象，而行锁之间会互斥。</p>
<h2 id="第22讲-MySQL有哪些“饮鸩止渴”提高性能的方法？"><a href="#第22讲-MySQL有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="第22讲 | MySQL有哪些“饮鸩止渴”提高性能的方法？"></a>第22讲 | MySQL有哪些“饮鸩止渴”提高性能的方法？</h2><h3 id="1-短连接风暴"><a href="#1-短连接风暴" class="headerlink" title="1.短连接风暴"></a>1.短连接风暴</h3><p>业务高峰，MySQL会存在很多连接，连接数量过多会导致数据库压力较大，处理方法有以下几种：</p>
<p>1.调高max_connections，增加可容纳的连接数（风险很大）</p>
<p>2.先处理掉<strong>占着连接但长时间不工作（事务外空闲太久）</strong>的线程，如果还不够，再考虑断开<strong>事务内空闲太久</strong>的线程</p>
<p>3.减少连接过程的消耗（跳过权限验证），有极大的安全隐患。</p>
<h3 id="2-慢查询性能问题"><a href="#2-慢查询性能问题" class="headerlink" title="2.慢查询性能问题"></a>2.慢查询性能问题</h3><p>在 MySQL 中，会引发性能问题的慢查询，大体有以下三种可能：</p>
<p>1.索引没有设计好；</p>
<p>2.SQL 语句没写好；</p>
<p>3.MySQL 选错了索引。</p>
<h4 id="1-索引设计问题"><a href="#1-索引设计问题" class="headerlink" title="1.索引设计问题"></a>1.索引设计问题</h4><p>对于索引没有设计好，我们可以直接执行alter table语句来创建新的索引。具体方式是：</p>
<p>1.备库B执行set sql_log_bin&#x3D;off，即关掉binlog，然后执行alter table加上索引；</p>
<p>2.主备库切换；</p>
<p>3.目前备库是A，对A执行上面的1操作。</p>
<h4 id="2-SQL语句问题"><a href="#2-SQL语句问题" class="headerlink" title="2.SQL语句问题"></a>2.SQL语句问题</h4><p>使用query_rewrite语句对原SQL语句执行“查询重写”。</p>
<h4 id="3-MySQL选错索引问题"><a href="#3-MySQL选错索引问题" class="headerlink" title="3.MySQL选错索引问题"></a>3.MySQL选错索引问题</h4><p>同样使用查询重写，给原来的语句加上force index。</p>
<p>上述问题可以在一开始业务上线前避免，具体操作就是测试环境，进行预演。这里细节看原文，<strong>面试不考，工作要用</strong>。</p>
<h3 id="3-QPS突增问题"><a href="#3-QPS突增问题" class="headerlink" title="3.QPS突增问题"></a>3.QPS突增问题</h3><p>QPS是每秒查询率的意思，通常出现QPS高峰是新功能bug，解决QPS突增<strong>具体要看业务是否可以下掉这个新功能</strong>，具体也去看原文，原文写的很简洁明了。</p>
<h2 id="第23讲-MySQL是怎么保证数据不丢的？"><a href="#第23讲-MySQL是怎么保证数据不丢的？" class="headerlink" title="第23讲 | MySQL是怎么保证数据不丢的？"></a>第23讲 | MySQL是怎么保证数据不丢的？</h2><h3 id="1-binlog的写入机制"><a href="#1-binlog的写入机制" class="headerlink" title="1.binlog的写入机制"></a>1.binlog的写入机制</h3><img src="https://static001.geekbang.org/resource/image/9e/3e/9ed86644d5f39efb0efec595abb92e3e.png" alt="img" style="zoom: 50%;" />

<p>直接上图，我们可以清楚的看到，一个事务执行的时候：</p>
<p>1.先把日志写入binlog cache里（<strong>每个线程或事务独占一个binlog cache</strong>）；</p>
<p>2.事务提交时，执行器把binlog cache里的日志写入binlog中，并清空binlog cache（<strong>所有线程共用一个binlog</strong>）</p>
<p>​			(1).执行write，把日志写入文件系统的page cache中（这里<strong>操作系统分配的内存</strong>）</p>
<p>​			(2).执行fsync，将日志持久化到磁盘中</p>
<p>可以看到，写入binlog，分为write和fsync两个操作，<strong>只有fsync才发生IO</strong></p>
<p>两个操作的时机由sync_binlog参数控制：</p>
<p>1.参数为0，每次提交事务只write不fsync</p>
<p>2.参数为1，每次提交事务都fsync</p>
<p>3.参数为N（N&gt;1），每次提交事务都write，但累计N个事务才fsync</p>
<p>N设置比较可以<strong>缓解IO瓶颈</strong>问题，但是<strong>主机异常重启，或断电</strong>啥的，就会<strong>丢失最近N个事务的binlog日志</strong>。</p>
<h3 id="2-redo-log写入机制"><a href="#2-redo-log写入机制" class="headerlink" title="2.redo log写入机制"></a>2.redo log写入机制</h3><img src="https://static001.geekbang.org/resource/image/9d/d4/9d057f61d3962407f413deebc80526d4.png" alt="img" style="zoom: 67%;" />

<p>也是直接上图，我们会发现redo log与binlog最大的不同就是“图小了”，小哪了？所有线程（事务）共用一个redo log buffer。这就说明：<strong>一个事务提交并写到page cache或持久化到磁盘中</strong>（写入到黄色或者绿色区域），<strong>会把当前buffer里所有其他未提交事务全“带走”</strong>。</p>
<p>同样redo log的写入也由一个参数控制，就是InnoDB提供的innodb_flush_log_at-trx_commit：</p>
<p>1.参数为0，每次事务提交只把redo log留在redo log buffer中（<strong>留在缓冲区</strong>）</p>
<p>2.参数为1，每次事务提交都将redo log直接持久化(<strong>fsync</strong>)到磁盘（<strong>执行IO</strong>）</p>
<p>3.参数为2，每次事务提交都只把redo log写(<strong>write</strong>)到page cache（<strong>操作系统分配的内存</strong>）</p>
<h4 id="1-未提交事务的redo-log写盘的三种可能情况："><a href="#1-未提交事务的redo-log写盘的三种可能情况：" class="headerlink" title="1).未提交事务的redo log写盘的三种可能情况："></a>1).未提交事务的redo log写盘的三种可能情况：</h4><p>写入page cache或磁盘，统称为写盘</p>
<p>1.InnoDB有一个<strong>后台线程</strong>，<strong>每隔一秒</strong>，就会<strong>把buffer中日志write到page cache里</strong>，然后<strong>fsync到磁盘里</strong>。</p>
<p>2.redo log buffer<strong>占用空间即将达到innodb_log_buffer_size的一半时</strong>，后台线程主动写盘，因为事务还没提交，所以<strong>只write不fsync</strong>。</p>
<p>3.最后就是最开始提到的，<strong>一个并行事务的提交</strong>，会顺带把buffer里的内容全“带走”。</p>
<h4 id="2-MySQL的双“1”配置保证数据一致性（crash-safe）："><a href="#2-MySQL的双“1”配置保证数据一致性（crash-safe）：" class="headerlink" title="2).MySQL的双“1”配置保证数据一致性（crash-safe）："></a>2).MySQL的双“1”配置保证数据一致性（crash-safe）：</h4><p>双“1”就是把sync_binlog和innodb_flush_log_at-trx_commit都设置为1，那么<strong>redo log在prepare的时候就已经持久化到磁盘了</strong>，所以会分为以下四种情况：</p>
<p>​		情况1：redo log prepare阶段fsync失败</p>
<p>​		情况2：binlog的fsync失败</p>
<p>​		情况3：redo log commit失败</p>
<p>​		情况4：俩都成功</p>
<p>​				情况1，redo log和binlog均检查出未写入磁盘，事务回滚，内存数据丢失，不影响数据一致性；</p>
<p>​				情况2，redo log在prepare阶段持久化磁盘成功，但binlog持久化失败，那么MySQL如果异常重启，发现只有redo log没有binlog，而且redo log还未commit，事务回滚；（<!--这里有个疑问-->，redo log已经持久化到磁盘了，还能回滚吗？）</p>
<p>​				情况3，俩都持久化了，直接提交，数据一致；</p>
<p>​				情况4，俩都持久化了，并且事务commit了，数据一致。</p>
<p>最后作者讲到了<strong>组提交</strong>，一句话，MySQL尽可能拖时间，为的就是<strong>组员尽可能地多，进而减少磁盘IO</strong>。</p>
<h2 id="第24讲-MySQL是怎么保证主备一致的？"><a href="#第24讲-MySQL是怎么保证主备一致的？" class="headerlink" title="第24讲 | MySQL是怎么保证主备一致的？"></a>第24讲 | MySQL是怎么保证主备一致的？</h2><p>本讲主要讲了一下之前答疑的时候binlog的三种格式：statement, row, mixed</p>
<h3 id="1-MySQL主备的基本原理（M-S结构）："><a href="#1-MySQL主备的基本原理（M-S结构）：" class="headerlink" title="1.MySQL主备的基本原理（M-S结构）："></a>1.MySQL主备的基本原理（M-S结构）：</h3><img src="https://static001.geekbang.org/resource/image/fd/10/fd75a2b37ae6ca709b7f16fe060c2c10.png" alt="img" style="zoom: 33%;" />

<p>状态1：<strong>客户端读写都访问节点A</strong>，此时B是A的备库，<strong>B只是将A的更新同步过来</strong>；</p>
<p>当需要<strong>主备切换</strong>的时候，就切换成状态2，仍然与上面状态1的流程一样。</p>
<p>这时我们最好将备库设置为<strong>只读(readonly)模式</strong>，主要考虑了以下三点：</p>
<p>​		1.<strong>运营类的查询语句会被放到备库查询</strong>，备库只读可以防止误操作；</p>
<p>​		2.防止切换的一瞬间出现<strong>双写问题</strong>；</p>
<p>​		3.用只读状态<strong>判断主备库（节点）的身份</strong>。</p>
<p>以下是节点A同步到节点B的内部流程图：</p>
<img src="https://static001.geekbang.org/resource/image/a6/a3/a66c154c1bc51e071dd2cc8c1d6ca6a3.png" alt="img" style="zoom: 50%;" />

<p>主库A的第一行就是<strong>接收到客户端的请求后</strong>，执行内部事务的逻辑，<strong>同时写binlog</strong>；</p>
<p>备库B和主库A之间一直<strong>维持着一个长连接</strong>，主库A内有一个线程专门服务这个长连接，主备库的事务日志同步流程如下：</p>
<p>​		1.<strong>备库B设置A的各种参数</strong>，包含了A的IP，端口，用户名密码，从哪个位置（文件名和日志偏移量）开始请求binlog。</p>
<p>​		2.备库B启动两个线程：io_thread和sql_thread，<strong>前者负责与主库建立连接</strong>。</p>
<p>​		3.主库A校验用户名密码后，开始按照B要求的位置，<strong>从本地（page cache或磁盘）取</strong>binlog发给B；</p>
<p>​		4.B拿到binlog，写到本地文件，称为<strong>中转文件(relay log)</strong></p>
<p>​		5.sql_thread线程读取这个中转日志，<strong>解析命令并执行</strong>。</p>
<h3 id="2-binlog的三种格式对比："><a href="#2-binlog的三种格式对比：" class="headerlink" title="2.binlog的三种格式对比："></a>2.binlog的三种格式对比：</h3><p>binlog一共有三种格式，分别为statement, row, mixed，第三种就是前两种的混合格式。</p>
<h4 id="1-binlog-format-x3D-statement"><a href="#1-binlog-format-x3D-statement" class="headerlink" title="1)binlog_format&#x3D;statement"></a>1)binlog_format&#x3D;statement</h4><p>如果binlog设置为statement，那么binlog记录的就是SQL语句的原文，比如下面这条SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from t /*comment*/  where a&gt;=4 and t_modified&lt;=&#x27;2018-11-10&#x27; limit 1;</span><br></pre></td></tr></table></figure>

<p>那么binlog记录的内容如下：</p>
<img src="https://static001.geekbang.org/resource/image/b9/31/b9818f73cd7d38a96ddcb75350b52931.png" alt="img"  />

<p>但实际上这条语句在执行的时候是会报警的：</p>
<img src="https://static001.geekbang.org/resource/image/96/2b/96c2be9c0fcbff66883118526b26652b.png" alt="img"  />

<p>原因是该语句<strong>用了limit</strong>，<strong>主备库</strong>可能会<strong>走不同的索引</strong>。所以MySQL这样写有风险。</p>
<h4 id="2-binlog-format-x3D-row"><a href="#2-binlog-format-x3D-row" class="headerlink" title="2)binlog_format&#x3D;row"></a>2)binlog_format&#x3D;row</h4><p>如果binlog设置为row格式，那么binlog内容如下：</p>
<img src="https://static001.geekbang.org/resource/image/d6/26/d67a38db154afff610ae3bb64e266826.png" alt="img"  />

<p>这一次SQL原文变成了Table_map和Delete_rows：</p>
<p>​		Table_map用于说明<strong>接下来操作的表是谁</strong></p>
<p>​		Delete_rows用于<strong>定义删除的行为</strong></p>
<p>实际上设置为row格式，binlog里面记录了真实删除行的主键id，也就是具体删除的参数，这就避免了<strong>主从库走不同索引</strong>导致的主从不一致的隐患。</p>
<h4 id="3-binlog-format-x3D-mixed"><a href="#3-binlog-format-x3D-mixed" class="headerlink" title="3)binlog_format&#x3D;mixed"></a>3)binlog_format&#x3D;mixed</h4><p>mixed格式就是statement和row格式的混合，MySQL会<strong>根据SQL语句是否可能引起主从不一致</strong>而选择row或者statement。这看起来很好，但其实row还有一大优势就是<strong>恢复数据</strong>！</p>
<p>设置成row，delete语句回滚可以直接被转成insert，反之亦然。而update语句回滚只需要对调更新前后的两个数据即可。</p>
<p>以上的操作，statement都不行，所以row格式主键称为主流。</p>
<h3 id="3-双M结构"><a href="#3-双M结构" class="headerlink" title="3.双M结构"></a>3.双M结构</h3><img src="https://static001.geekbang.org/resource/image/20/56/20ad4e163115198dc6cf372d5116c956.png" alt="img" style="zoom: 33%;" />

<p>以上为<strong>双M结构</strong>，也是<strong>实际生产中使用较多</strong>的结构。这种结构其实就是<strong>AB互为主备库</strong>的方式，这样在切换的时候就<strong>不用修改主备关系</strong>了。（注意：主备库<strong>同时只能有一个库接受更新</strong>）</p>
<p>具体流程就是：</p>
<p>A更新了一条语句，把生成的binlog给B，B执行完这条语句也生成一个binlog，再给A。（这里建议log_slave_updates设置为on，表示<strong>备库执行relay log后生成binlog</strong>）</p>
<h4 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h4><p>这样会有循环复制binlog的问题，所以MySQL会给<strong>两个库设置不同的server id</strong>，所以A生成的binlog里记录的都是A的server id，而B生成的binlog的server id也是A的server id，这样再传回给A的时候，A发现这个binlog的server id是自己的，就不再处理这个日志了。</p>
<h2 id="第25讲-MySQL是怎么保证高可用的？"><a href="#第25讲-MySQL是怎么保证高可用的？" class="headerlink" title="第25讲 | MySQL是怎么保证高可用的？"></a>第25讲 | MySQL是怎么保证高可用的？</h2><p>这节就着上一节讲的主备切换，我们继续以双M为例，因为这个在生产中用的最多。</p>
<h3 id="1-主备延迟"><a href="#1-主备延迟" class="headerlink" title="1.主备延迟"></a>1.主备延迟</h3><p>主备切换<strong>一般发生在</strong>软件升级、主库所在机器按计划下线或者机器掉电了。</p>
<p>主备切换时<strong>数据同步的三个关键时间点</strong>：</p>
<p>​		1.主库A完成一个事务，<strong>写入binlog</strong>，这个时刻记为T1；</p>
<p>​		2.备库B<strong>接收完A库传来的binlog</strong>，记为T2；</p>
<p>​		3.备库B也<strong>执行完此事务</strong>，记为T3.</p>
<p><strong>主备延迟</strong>：备库执行完事务与主库执行完事务的时间差(***<!--这里有疑问-->***，为什么不是A写完binlog的时刻)，即T3-T1（网络正常下，T2-T1非常小）</p>
<p>这个时间差不会因为主备库机器的系统时间不一样而出现数据不准的现象，因为备库连接主库的时候<strong>会获得当前主库的系统时间</strong>，在后续做主备延迟的时间计算时，<strong>自动扣掉两系统时间的差值</strong>。</p>
<h4 id="主备延迟的来源"><a href="#主备延迟的来源" class="headerlink" title="主备延迟的来源"></a>主备延迟的来源</h4><h5 id="1-备库机器性能比主库的差"><a href="#1-备库机器性能比主库的差" class="headerlink" title="1.备库机器性能比主库的差"></a>1.备库机器性能比主库的差</h5><p>所以一般<strong>要求做对称部署</strong>，即主备库选用相同规格的机器。</p>
<h5 id="2-备库压力大"><a href="#2-备库压力大" class="headerlink" title="2.备库压力大"></a>2.备库压力大</h5><p>例如备库查询耗费大量CPU，严重影响数据同步速度，造成主备延迟。一般情况下，会采取以下两种方式：</p>
<p>​		1).<strong>一主多从</strong>。一个主库对应一个备库和多个从库。</p>
<p>​		2).<strong>binlog输出到外部系统</strong>，如Hadoop，让外部系统<strong>提供统计类查询</strong>的能力。</p>
<h5 id="3-大事务"><a href="#3-大事务" class="headerlink" title="3.大事务"></a>3.大事务</h5><p>因为<strong>主库必须等待事务执行完成才会写入binlog，再传给备库B</strong>。如果主库有个大事务需要长时间执行，那么主备切换的延迟自然就很大了。比如<strong>一次性delete太多数据</strong>或<strong>大表的DDL</strong>。</p>
<h5 id="4-备库并行复制（下一讲）"><a href="#4-备库并行复制（下一讲）" class="headerlink" title="4.备库并行复制（下一讲）"></a>4.备库并行复制（下一讲）</h5><h3 id="2-可靠性优先策略"><a href="#2-可靠性优先策略" class="headerlink" title="2.可靠性优先策略"></a>2.可靠性优先策略</h3><p><img src="D:\Picgo\img\image-20220424142142508.png" alt="image-20220424142142508"></p>
<p>图是双M结构，SBM指的是seconds_behind_master，也就是前面提到的T3-T1，以上的主备切换流程如下：</p>
<p>1.首先需要等到SBM小于某个值（这里是5s）才能进入下一步，否则持续等待</p>
<p>2.把主库A改为只读(readonly&#x3D;true)</p>
<p>3.判断备库B的SBM值是否为0，等到了0才能进入下一步</p>
<p>4.把备库B改为可读写状态(readonly&#x3D;false)</p>
<p>5.把业务请求切到备库B</p>
<p>可以看到在状态<strong>处于步骤2和3的时候，AB库都是只读的</strong>，说明这个时候两个库都不可写，所以SBM太长会严重影响业务，但是<strong>数据一致性</strong>得到了保障。</p>
<h3 id="3-可用性优先策略"><a href="#3-可用性优先策略" class="headerlink" title="3.可用性优先策略"></a>3.可用性优先策略</h3><p>该策略就是强行让上面的<strong>步骤4和5放到步骤1的前面</strong>。这个时候就会出现数据不一致的现象。</p>
<p>举例：</p>
<img src="https://static001.geekbang.org/resource/image/37/3a/3786bd6ad37faa34aca25bf1a1d8af3a.png" alt="img" style="zoom: 60%;" />

<p>表中只有id和c两个数据，插入c&#x3D;4的时候主库还是A，插入c&#x3D;5的时候主库突然变成B了，由于<strong>插入操作比relay log的解析要快</strong>，又因为插入一个c，主键<strong>id只需要自增</strong>即可，所以会插入一个错误的(4,5)，如果<strong>binlog_format&#x3D;mixed</strong>，那么此时A库会根据B传来的binlog增加一个(5,5)的数据，B库也会根据A库的binlog增加一个(5,4)的数据，此时出现了<strong>两行数据不一致</strong>的现象。</p>
<p>如果<strong>binlog_format&#x3D;row</strong>呢?</p>
<img src="https://static001.geekbang.org/resource/image/b8/43/b8d2229b2b40dd087fd3b111d1bdda43.png" alt="img" style="zoom:60%;" />

<p>由于row格式的binlog<strong>会记录新插入的行的所有字段值</strong>，所以只会在B突然切换成主库的时候，插入了一条(4,5)，而不会出现上面的binlog导致的不一致的情况，所以<strong>最终只会出现一行不一致的数据</strong>。</p>
<p>所以<strong>可用性优先策略会出现数据不一致的现象</strong>。</p>
<h3 id="4-结论"><a href="#4-结论" class="headerlink" title="4.结论"></a>4.结论</h3><p>最后结论：“在满足数据可靠性的前提下，MySQL 高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。”</p>
<h2 id="第26讲-备库为什么会延迟好几个小时？"><a href="#第26讲-备库为什么会延迟好几个小时？" class="headerlink" title="第26讲 | 备库为什么会延迟好几个小时？"></a>第26讲 | 备库为什么会延迟好几个小时？</h2><img src="https://static001.geekbang.org/resource/image/1a/ef/1a85a3bac30a32438bfd8862e5a34eef.png" alt="img" style="zoom: 40%;" />

<p>再贴上主备流程图，这次多了两个箭头，分别是<strong>客户端写入主库的粗箭头</strong>，和<strong>备库上sql_thread执行中转日志(relay log)的细箭头</strong>。箭头越粗，代表并发度越高。</p>
<p>主库上，影响客户端写入主库的并发度自然就是各种锁，除了<strong>某个单行的高并发极端状况</strong>，<strong>InnoDB行锁</strong>对业务的支持还是很友好的。</p>
<p>但是备库上的这个这个细箭头，虽然不粗，但是在<strong>官方MySQL5.6版本之前，是不支持多线程复制的</strong>。</p>
<p>因此<strong>主库并发度高的时候</strong>，传来的binlog单线程复制会带来<strong>严重的主备延迟现象</strong>。</p>
<h3 id="1-多线程模型"><a href="#1-多线程模型" class="headerlink" title="1.多线程模型"></a>1.多线程模型</h3><img src="https://static001.geekbang.org/resource/image/bc/45/bcf75aa3b0f496699fd7885426bc6245.png" alt="img" style="zoom:40%;" />

<p><strong>coordinator</strong>就是原来的sql_thread，现在它不再直接更新数据，而<strong>只负责读取中转日志和分发事务</strong>。</p>
<p>真正<strong>更新日志</strong>的工作，交给worker。</p>
<p>coordinator的基本要求：</p>
<p>​		1.不能造成更新覆盖：更新同一行的两个事务，必须被分发到同一个worker中</p>
<p>​		2.同一个事物不能被拆开，必须放到同一个worker中</p>
<h3 id="2-按表分发策略"><a href="#2-按表分发策略" class="headerlink" title="2.按表分发策略"></a>2.按表分发策略</h3><p>基本思路是：两个事务<strong>更新不同的表</strong>，就可以并行。这样可以<strong>保证两个worker不会更新同一行</strong>。</p>
<img src="https://static001.geekbang.org/resource/image/8b/76/8b6976fedd6e644022d4026581fb8d76.png" alt="img" style="zoom: 40%;" />

<p>每个worker对应一个hash表，用于保存所涉及的表，<strong>key是“库名.表名”，value是“队列中有多少个事务修改这个表”</strong>。</p>
<p>每个事务在分发的时候，<strong>跟所有worker的冲突关系</strong>包括以下三种情况：</p>
<p>​		1.如果和所有worker<strong>都不冲突</strong>，coordinator会把这个事务<strong>分配给最闲的</strong>worker</p>
<p>​		2.如果<strong>只和一个</strong>worker冲突，那就把事务<strong>分配给这个worker</strong></p>
<p>​		3.如果<strong>和多个</strong>worker冲突，coordinator<strong>进入等待状态</strong>，直到冲突的worker只剩下一个</p>
<p>多个表负载均衡的时候，按表分发的效果比较好，但是对于热点表，就变成单线程复制了。</p>
<h3 id="3-按行分发策略"><a href="#3-按行分发策略" class="headerlink" title="3.按行分发策略"></a>3.按行分发策略</h3><p>基本思路是，两个事务<strong>更新不同的行</strong>，就可以并行。这个模式必须要求binlog的格式是row，因为statement格式不能记录具体更新的某行。</p>
<p>这个时候key对应的就是“库名+表名+索引名字+值”（<strong>不能有外键</strong>）。这就表明<strong>按行分发会消耗更多的计算资源</strong>。</p>
<h3 id="4-MySQL-5-6版本的并行复制策略"><a href="#4-MySQL-5-6版本的并行复制策略" class="headerlink" title="4.MySQL 5.6版本的并行复制策略"></a>4.MySQL 5.6版本的并行复制策略</h3><p>该版本第一次支持并行复制，只不过支持的粒度是<strong>按库并行</strong>。碰到事务都在一个库里进行，就gg了，该策略用的不多。</p>
<h3 id="5-MariaDB的并行策略"><a href="#5-MariaDB的并行策略" class="headerlink" title="5.MariaDB的并行策略"></a>5.MariaDB的并行策略</h3><p>MariaDB的实现方式（采用了redo log组提交的特性）：</p>
<p>​		1.在一组里面一起提交的事务，有相同的commit_id，下一组就是commit_id+1;</p>
<p>​		2.commit_id直接写在binlog中</p>
<p>​		3.传到备库的时候，相同的commit_id的事务分发到多个worker执行</p>
<p>​		4.这一组全执行完，coordinator再去取下一批</p>
<p>其实就是<strong>模拟了主库的并行模式</strong>，但是并没有真正实现模拟主库，因为主库（追求效率）中，一组事务commit的同时，下一组已经在执行中了。而MariaDB则必须一组一组来，这样如果某一组有大事务，那么某一时间可能只有一个worker在工作，是严重浪费资源的。</p>
<h3 id="6-MySQL-5-7的并行复制策略（不太理解）"><a href="#6-MySQL-5-7的并行复制策略（不太理解）" class="headerlink" title="6.MySQL 5.7的并行复制策略（不太理解）"></a>6.MySQL 5.7的并行复制策略（不太理解）</h3><p>其实就是在MariaDB的基础上进行优化，利用前面章节学到的两阶段提交的特点，不用等到commit阶段，只要能够到达redo log prepare阶段，就表示事务已经通过锁冲突检验了。所以：</p>
<p>​		1.同时处于prepare的事务，在备库可以并行执行</p>
<p>​		2.处于prepare与commit之间的事务，在备库也可以并行执行。</p>
<p>所以延长prepare到commit之间的时间，制造更多“同时处于prepare的事务”，可以增加备库复制的并行度。</p>
<h3 id="7-MySQL-5-7-22的并行复制策略（不太理解）"><a href="#7-MySQL-5-7-22的并行复制策略（不太理解）" class="headerlink" title="7.MySQL 5.7.22的并行复制策略（不太理解）"></a>7.MySQL 5.7.22的并行复制策略（不太理解）</h3><h2 id="第27讲-主库出问题了，从库怎么办？"><a href="#第27讲-主库出问题了，从库怎么办？" class="headerlink" title="第27讲 | 主库出问题了，从库怎么办？"></a>第27讲 | 主库出问题了，从库怎么办？</h2><img src="https://static001.geekbang.org/resource/image/00/53/0014f97423bd75235a9187f492fb2453.png" alt="img" style="zoom:40%;" />

<p>如图，是一主多从结构发生主备切换的示意图。可以看出，在切换之前，所有从库都指向A，现在转向A’，必然需要A‘的“身份信息”。</p>
<h3 id="1-基于位点的主备切换"><a href="#1-基于位点的主备切换" class="headerlink" title="1.基于位点的主备切换"></a>1.基于位点的主备切换</h3><p>以B为例，当把B切换为A’从库的时候，需要执行change master命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$password </span><br><span class="line">MASTER_LOG_FILE=$master_log_name </span><br><span class="line">MASTER_LOG_POS=$master_log_pos  </span><br></pre></td></tr></table></figure>

<p>前四个参数自然是A’库的IP、端口、用户名和密码。后俩则是<strong>同步位点</strong>，也就是<strong>主库对应的文件名和日志偏移量</strong>。</p>
<p>这个同步位点容易出现偏差，是不精确的。比如主库A执行完一条语句，并把binlog传给A’和其他从库（包括B），A’和B也都同步了这个binlog，但是<strong>主库A还没接收到回执ack就挂了</strong>，那么此时同步位点肯定是这个位置，这就会<strong>导致A’和B即使同步了此数据，但是同步位点“不知情”</strong>。</p>
<p>一般有两种方式处理这种错误，一种是<strong>碰到这种错误就跳过</strong>，另一种是<strong>设置跳过指定的错误类型</strong>。</p>
<h3 id="2-GTID（全局事务ID）"><a href="#2-GTID（全局事务ID）" class="headerlink" title="2.GTID（全局事务ID）"></a>2.GTID（全局事务ID）</h3><p>全称是Global Transaction Identifier</p>
<p>GTID是<strong>事务提交的时候才生成</strong>的，要与事务id区分开来，事务id是<strong>执行过程中就分配</strong>了，如果事务回滚，后面的事务仍旧id递增。所以<strong>最终表现为GTID是连续的，而事务id经常不是连续的</strong>。</p>
<p>基于GTID的主备切换语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$password </span><br><span class="line">master_auto_position=1 </span><br></pre></td></tr></table></figure>

<p>这时就不需要主库对应的文件名和偏移量了，直接<strong>设置主备关系使用GTID协议</strong>即可。</p>
<p>取binlog的逻辑如下：</p>
<p>然后A’和B（**<!--文中说的实例，不太懂--><strong>）分别有自己的GTID集合，B把自己的发给A’，A‘核对两个集合，并判断此时A’有但B没有的这一部分GTID，然后看A’有没有这些的GTID对应的binlog(</strong><!--这里可能说明有误，但是整体意思是对的-->**)，没有的话，直接返回错误，如果有的话，就找出第一个不再B集合里的事务开始发给B。</p>
<p>上述思想有个<strong>前提</strong>，就是原先的主备库的<strong>日志是完整且一致的</strong>。</p>
<p>严谨的说：主备切换不是不需要找位点了，而是<strong>找位点的这个工作在A’内部就自动完成了</strong>，对开发人员非常友好。</p>
<h2 id="第28讲-读写分离有哪些坑？（处理主备延迟带来的问题）"><a href="#第28讲-读写分离有哪些坑？（处理主备延迟带来的问题）" class="headerlink" title="第28讲 | 读写分离有哪些坑？（处理主备延迟带来的问题）"></a>第28讲 | 读写分离有哪些坑？（处理主备延迟带来的问题）</h2><p>由于主从可能存在延迟现象，<strong>客户端更新后立刻发起查询</strong>，如果查询的是从库，很可能<strong>读到更新之前的状态</strong>，这就是“过期读”（非术语，只是方便理解）。</p>
<h3 id="1-强制走主库方案"><a href="#1-强制走主库方案" class="headerlink" title="1.强制走主库方案"></a>1.强制走主库方案</h3><p>对于必须要拿到最新结果的请求，我们必须强制让查询请求直接走主库查询，但主库的压力不言而喻</p>
<h3 id="2-Sleep方案"><a href="#2-Sleep方案" class="headerlink" title="2.Sleep方案"></a>2.Sleep方案</h3><p>主库更新后，<strong>读从库之前先sleep一会</strong>，但是很可能出现睡多了，或者睡得太短的现象。</p>
<h3 id="3-判断主备无延迟方案"><a href="#3-判断主备无延迟方案" class="headerlink" title="3.判断主备无延迟方案"></a>3.判断主备无延迟方案</h3><p>有三种做法：</p>
<p>​		1.查询前判断<strong>seconds_behind_master</strong>（第25讲提到的）是否为0，但是<strong>精度不太够</strong></p>
<p>​		2.查询前判断<strong>主库的最新位点与备库的最新位点</strong>是不是完全相同</p>
<p>​		3.查询前判断备库<strong>收到的所有日志</strong>的GTID集合与备库所有<strong>已经执行完成</strong>的GTID集合是否相同</p>
<p>但是还是有问题：因为主库<strong>写入binlog之后就反馈客户端</strong>了，所以有一部分binlog处于<strong>客户端已经收到提交确认，而备库还没有收到binlog的状态</strong>。</p>
<h3 id="4-配合semi-sync"><a href="#4-配合semi-sync" class="headerlink" title="4.配合semi-sync"></a>4.配合semi-sync</h3><p>这个时候就需要引入半同步复制，即semi-sync replication</p>
<p>设计如下：</p>
<p>​		1.事务提交，主库把binlog发给从库；</p>
<p>​		2.从库收到binlog，发回给主库一个ack，表示收到</p>
<p>​		3.主库收到ack，才给客户端返回”事务完成”的确认。</p>
<p>也就是说，<strong>等从库确认收到了传来的binlog，主库才返回客户端“确认”。</strong></p>
<p>但是又带来了新的问题：</p>
<p>​		1.semi-sync对于一主一备没问题，一主多从就很可能出现<strong>当前读取的从表并没有返回ack，而返回ack的从表却没有被读到</strong>。这仍旧会导致过期读的现象存在。</p>
<p>​		2.<strong>业务更新高峰期，主库位点或GTID更新极快</strong>，位点和GTID的<strong>等值判断</strong>可能长时间不成立，就会出现持续等待的现象。</p>
<h3 id="5-等主库位点方案"><a href="#5-等主库位点方案" class="headerlink" title="5.等主库位点方案"></a>5.等主库位点方案</h3><p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure>

<p>逻辑如下：</p>
<p>​		1.主库一个事务更新之后，立刻<strong>去主库找位点</strong>，得到主库执行到的file和pos；</p>
<p>​		2.<strong>选一个从库</strong>执行当前的查询语句；</p>
<p>​		3.在从库执行上述语句，如果<strong>在timeout规定时间内查到了，就返回一个&gt;&#x3D;0的正整数</strong>，并决定在这个从库执行查询语句</p>
<p>​		4.<strong>否则，去主库</strong>执行查询语句</p>
<p>以上的思路就是<strong>给从库查询一个限时，找不到位点，就直接去主库</strong>，不过这就回到了第一个方法强制走主库可能会碰到所有查询都超过timeout了，这就需要业务开发人员来权衡了。</p>
<h3 id="6-GTID方案"><a href="#6-GTID方案" class="headerlink" title="6.GTID方案"></a>6.GTID方案</h3><p>与主库位点很相似，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select wait_for_executed_gtid_set(gtid_set, 1);</span><br></pre></td></tr></table></figure>

<p>不同的是第一步，不找位点了，改成<strong>获取事物的GTID</strong>，如果<strong>超时了就返回1，找到了就返回0</strong>。</p>
<h2 id="第29讲-如何判断一个数据库是不是出问题了？"><a href="#第29讲-如何判断一个数据库是不是出问题了？" class="headerlink" title="第29讲 | 如何判断一个数据库是不是出问题了？"></a>第29讲 | 如何判断一个数据库是不是出问题了？</h2><h3 id="1-select-1判断"><a href="#1-select-1判断" class="headerlink" title="1.select 1判断"></a>1.select 1判断</h3><p>select 1成功返回，只能说明<strong>这个库的进程还在</strong>，不能说明<strong>这个库可能发生堵塞了</strong>，因为select 1<strong>没有深入innoDB</strong>层。</p>
<p>这里作者提到了一个innodb_thread_concurrency的参数，目的是<strong>控制innoDB的并发线程上限</strong>。这里要记住，这里的<strong>并发量指的不是并发连接数，而是并发查询</strong>。大量的并发查询才会占CPU，大量的连接只是占内存</p>
<p>当线程<strong>进入锁等待</strong>的时候，并发线程的<strong>计数会-1</strong>。</p>
<h3 id="2-查表判断"><a href="#2-查表判断" class="headerlink" title="2.查表判断"></a>2.查表判断</h3><p>在数据库里面特意定义一个心跳表health_check，里面只放一行数据进行查询操作。</p>
<p>想判断数据库有没有问题就查这个库里的数据，这种方法<strong>可以检测由于并发线程过多导致数据库不可用</strong>的情况。</p>
<p>但是一旦binlog所在磁盘利用率达到100%，<strong>事务的更新和提交都堵住了，但是查询依旧可行</strong>。所以还需要进一步完善。</p>
<h3 id="3-更新判断"><a href="#3-更新判断" class="headerlink" title="3.更新判断"></a>3.更新判断</h3><p>在上述心跳表里放一个随时可以更新的字段，比如更新时间&#x3D;now()</p>
<p>但是节点可用性检测既要检测主库，也要检测备库，这个时候<strong>我们要给备库以写的能力</strong>。</p>
<p>那么就会<strong>发生主备库都写同一条更新命令的情况</strong>。</p>
<p>所以要在心跳表中存入多行数据，并用<strong>A、B表一定不同的server_id来作为主键</strong>。这就不会发生“更新冲突”了。</p>
<p>但是，假如当前日志盘的IO利用率是100%，那么<strong>执行更新操作会非常的慢</strong>，这个时候也说明主库出问题了，需要主备切换，但是<strong>当前update操作需要的资源很小</strong>，所以可能表现为：更新速度很快。这就<strong>误让我们认为</strong>主库还是可用的。</p>
<h3 id="4-内部统计"><a href="#4-内部统计" class="headerlink" title="4.内部统计"></a>4.内部统计</h3><p>MySQL 5.6版本以后提供了performance_schema库，可以查询<strong>统计每次IO请求的时间</strong>，也就是对MySQL库实时监控。</p>
<p>综上，作者建议<strong>优先update系统表</strong>，然后<strong>配合增加检测performance_schema</strong>的信息。</p>
<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><p><strong>第一范式</strong>：列（属性）不可分割，下面左边的表格中，进货和销售两大列要分开成右边的表格</p>
<p><img src="https://img-blog.csdnimg.cn/20201010150116971.png#pic_center" alt="在这里插入图片描述" style="zoom: 45%;" />改成:<img src="https://img-blog.csdnimg.cn/20201010150415789.png#pic_center" alt="在这里插入图片描述" style="zoom: 60%;" /></p>
<p><strong>第二范式</strong>：非主键的属性必须<strong>完全依赖主键</strong>属性。（不能只<strong>依赖主键的一部分</strong>）</p>
<p>比如下面的表格，订单编号和商品号联合组成了主键，除了订单金额，其他元素都只与这个主键相关；而订单金额只与订单编号相关，而与商品号不相关，所以需要单独建立订单编号和订单金额的表，消除非主属性对主键的**<u>部分函数依赖</u>**。</p>
<img src="https://img-blog.csdnimg.cn/20201117100620286.png#pic_center" alt="不符合第二范式" style="zoom:60%;" />

<p>改成下面的两张表即可：</p>
<p><img src="https://img-blog.csdnimg.cn/20201117101002301.png" alt="表一" style="zoom:60%;" /><img src="https://img-blog.csdnimg.cn/2020111710115694.png" alt="表二" style="zoom: 50%;" /></p>
<p><strong>第三范式</strong>：任何非主属性不依赖于其他非主属性，即在2NF上，消除了**<u>传递依赖</u><strong>（</strong>非主属性之间**不能有依赖）</p>
<p>图中的老师性别与年龄只与老师姓名有关，所以<strong>非主键之间</strong>出现了依赖，需要单独建立一张表</p>
<img src="https://img-blog.csdnimg.cn/20201117105815991.png#pic_center" alt="不符合第三范式" style="zoom:70%;" />

<p>改成下面的两张表即可：</p>
<p><img src="https://img-blog.csdnimg.cn/20201117110334814.png" alt="表一" style="zoom:70%;" /><img src="https://img-blog.csdnimg.cn/20201117110353157.png" alt="表二" style="zoom:70%;" /></p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="1-哈希表存储的弊端"><a href="#1-哈希表存储的弊端" class="headerlink" title="1.哈希表存储的弊端"></a>1.哈希表存储的弊端</h3><ul>
<li><strong>哈希冲突</strong>问题，不过这个<strong>问题不大</strong>，可以通过拉链法、扩容数组甚至链表转换为红黑树去解决</li>
<li>最大的问题是哈希表<strong>不支持顺序和范围查询</strong>。</li>
</ul>
<h3 id="2-B树和B-树的区别"><a href="#2-B树和B-树的区别" class="headerlink" title="2.B树和B+树的区别"></a>2.B树和B+树的区别</h3><ul>
<li><strong>B树</strong>的所有节点<strong>既存放键key又存放数据data</strong>，而B+树只有<strong>叶子节点</strong>存放key和data，上层节点都<strong>只存放key</strong></li>
<li>B树的叶子节点相互独立，B+树的叶子节点之间是<strong>双向链</strong></li>
<li>B树的检索过程是对整棵树的每个节点做二分查找，可能到不了叶子节点就查到了；而B+树每次都是<strong>从根节点遍历到叶子节点</strong>，检索效率<strong>更稳定</strong>。</li>
</ul>
<h3 id="3-MyISAM引擎和InnoDB引擎的索引结构区别"><a href="#3-MyISAM引擎和InnoDB引擎的索引结构区别" class="headerlink" title="3.MyISAM引擎和InnoDB引擎的索引结构区别"></a>3.MyISAM引擎和InnoDB引擎的索引结构区别</h3><p>都使用B+树，但是实现方式不太一样：</p>
<p>MyISAM引擎的B+树叶子节点的data域存放的是<strong>数据记录的地址</strong>。搜索索引的时候，如果某个key存在，就取出data域的地址值，然后读取该地址值位置的数据，也可以叫做“非聚簇索引”。</p>
<p>InnoDB引擎的B+树叶子节点存放的<strong>本身就是数据文件</strong>，与MyISAM的<strong>索引文件和数据文件分离</strong>是不同的，所以InnoDB的索引存储了完整的数据文件，无论是聚簇索引还是非聚簇索引存放的<strong>主键key都是值本身</strong>，而不是地址。</p>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>主键索引不用多说：</p>
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/cluster-index.png" alt="img" style="zoom:25%;" />

<p>二级索引注意一下，唯一索引、普通索引、前缀索引<strong>都是二级索引</strong>。</p>
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/no-cluster-index.png" alt="img" style="zoom:25%;" />

<p><strong>唯一索引</strong>是为了属性数据的唯一性，而<strong>不是为了查询效率</strong></p>
<p><strong>普通索引</strong>是为了快速查询数据，<strong>允许数据重复和NULL</strong>。</p>
<p><strong>前缀索引</strong>只适用于字符串类型的数据，即对字符串<strong>前几个字符</strong>创建索引。</p>
<p><strong>全文索引</strong>：<strong>MySQL 5.6</strong>之前只有MyISAM支持，<strong>5.6</strong>之后InnoDB也支持全文索引。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="多事务并发带来的问题"><a href="#多事务并发带来的问题" class="headerlink" title="多事务并发带来的问题"></a>多事务并发带来的问题</h2><p>脏写：一个事务<strong>修改</strong>了另一个<strong>未提交事务</strong>修改的数据，会发生脏写。</p>
<p>脏读：一个事务<strong>读取</strong>了另一个<strong>未提交事务</strong>修改的数据，会发生脏读。</p>
<p>不可重复读：一个事务<strong>修改</strong>了另一个<strong>未提交事务</strong>正在读取的数据，导致事务前后读取数据不一致。</p>
<p>幻读：一个事务对另一个<strong>未提交的事务</strong>正在查询的某些数据进行修改（<strong>增删</strong>）操作，会发生幻读。</p>
<p>这里<u>幻读和不可重复读</u>的主要区别是：前者是新增或删除几条数据，引发<strong>记录的条数前后不一致</strong>；而后者是读取的数据被修改，引发<strong>读取的数据前后不一致</strong>。</p>
<p>（<strong>个人理解</strong>）<u>脏读和不可重复读</u>的区别：前者是先修改再被读，后者是先读取，<strong>被修改后再读</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/MySQL%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" data-id="cl3117rey0000tcv60nf2d3td" data-title="MySQL个人总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/26/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Linux学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/06/24/%E9%93%BE%E8%A1%A8%E9%A2%98%E8%A7%A3/">链表题解</a>
          </li>
        
          <li>
            <a href="/2022/06/20/acm%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/">acm输入输出练习</a>
          </li>
        
          <li>
            <a href="/2022/06/04/%E8%B4%AA%E5%BF%83%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/">贪心系列题解</a>
          </li>
        
          <li>
            <a href="/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/">Redis知识点</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>