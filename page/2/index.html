<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Reex</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Reex">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Reex">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Reex" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Reex</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-个人对JVM的理解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E4%B8%AA%E4%BA%BA%E5%AF%B9JVM%E7%9A%84%E7%90%86%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T12:04:43.000Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E4%B8%AA%E4%BA%BA%E5%AF%B9JVM%E7%9A%84%E7%90%86%E8%A7%A3/">个人对JVM的理解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="☆JVM内存结构："><a href="#☆JVM内存结构：" class="headerlink" title="☆JVM内存结构："></a>☆JVM内存结构：</h2><p><img src="D:\Picgo\img\image-20220511200810603.png" alt="image-20220511200810603"></p>
<p>首先给出JVM的结构图，包括了类装载器子系统、运行时数据区、执行引擎、本地方法接口、垃圾回收（<strong>这里不确定</strong>）</p>
<p>而内存结构呢，就是运行时数据区部分，也就包括了：程序计数器、虚拟机栈、本地方法栈、堆、方法区。其中方法区在jdk8以后就变成元数据区了。</p>
<p><u>程序计数器</u>：</p>
<p>是内存中很小的一个存储空间，可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。在程序运行过程中，线程是非常多的，但是CPU的核心数却是有限的，所以我们必须要通过不断切换线程来来为处理器分配时间，进而完成程序的执行。程序计数器就是为了实现线程切换用的，<strong>每个线程都用独立的程序计数器</strong>，两两互不干扰，其生命周期也与线程保持一致。</p>
<p>垃圾回收和内存溢出都与程序计数器无关。</p>
<h2 id="☆类加载机制整个过程是怎么样的"><a href="#☆类加载机制整个过程是怎么样的" class="headerlink" title="☆类加载机制整个过程是怎么样的"></a>☆类加载机制整个过程是怎么样的</h2><p><img src="D:\Picgo\img\image-20220512150709656.png" alt="image-20220512150709656"></p>
<p>类加载机制的过程：首先Java虚拟机将描述类的数据从Class文件中<strong>加载到内存</strong>，然后对数据进行<strong>连接以及初始化</strong>的过程，最终形成了可以被JVM可以直接使用的类型。</p>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><p>加载只是整个“类加载”过程的第一步。这个过程Java虚拟机完成了三件事：</p>
<p>1）通过一个类的全限定名来<strong>获取定义此类的二进制字节流</strong>。</p>
<p>2）将这个字节流代表的静态存储结构<strong>转化</strong>为方法区的运行时数据结构（注意：这里仅仅是转化）。</p>
<p>3）在内存中生成一个代表这个类的java.lang.Class对象，<strong>作为方法区这个类的各种数据访问入口</strong>。</p>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><p>作为连接的第一步，验证的目的主要是确保加载的Class字节流<strong>不会危害</strong>到虚拟机自身安全（本步骤对应的代码如果已经在之前执行过程中反复验证过了，就可以关掉该步骤，以缩短虚拟机类加载时间）：</p>
<p>1）文件格式验证：验证字节流<strong>是否符合Class文件格式规范</strong></p>
<p>2）元数据验证：对字节码进行<strong>语义分析</strong>，比如某个类有无父类，是否继承了不允许继承的类等一些违规的语义</p>
<p>3）字节码验证：确定程序语义的<strong>合法性、逻辑性</strong>，较复杂，具体见《深入理解JVM》P270</p>
<p>4）符号引用验证：这个验证要在后面的解析阶段发生，通俗来讲，就是<strong>检验该类是否缺少或者被禁止访问它依赖的某些资源</strong>。</p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h3><p>本阶段开始正式为类中定义的<strong>静态变量分配内存</strong>并<strong>设置初始零值</strong>。注意：JDK 7之前，这部分变量分配在方法区中，而<strong>JDK 8之后，则分配到堆中</strong>。以下两点需要注意：</p>
<p>1）这里分配内存和设置零值都<strong>仅限于类变量</strong>（静态变量），实例变量将在<strong>对象实例化时随着对象一起分配到Java堆中</strong>。</p>
<p>2）注意是设置零值，<strong>一般情况不是初始化</strong>。</p>
<p>3）特殊情况就是<strong>static final定义的变量</strong>，Javac<strong>编译时</strong>就已经为该变量生成ConstantValue属性（可以理解为<strong>设置初始零值</strong>），类加载的准备阶段，就<strong>直接为其赋值</strong>了。</p>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><p>将字节码中常量池内的符号引用替换为直接引用。</p>
<p>1）符号引用：是任何形式的字面量，只要使用时能无歧义的“精准定位”即可。</p>
<p>2）直接引用：可以是<strong>直接指向</strong>目标的<strong>指针</strong>、<strong>相对偏移量</strong>或能<strong>间接定位</strong>到目标的<strong>句柄</strong>。一旦有直接引用，那么相对应的<strong>目标必定在虚拟机内存中存在</strong>。</p>
<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><p>该阶段，虚拟机才正式开始执行类中编写的Java程序代码，将主导权移交给应用程序。在前面的”准备“阶段中，我们已经为类变量进行分配内存和设置零值的操作，接下来就<strong>轮到初始化阶段真正为这些变量赋值</strong>了。</p>
<p>1）直接来讲，<strong>初始化就是执行类构造器clinit&gt;()方法的过程</strong>，clinit&gt;()是Javac编译器的自动生成物。</p>
<p>2）clinit&gt;()是编译器自动收集类中<strong>所有的静态变量的赋值动作和静态语句块中的语句</strong>合并而成的，收集顺序就是源代码书写顺序。</p>
<p>3）在子类执行clinit&gt;()方法前，<strong>先要执行其父类clinit&gt;()<strong>，这也是为什么父类静态语句块要先执行的原因。与类的构造函数（虚拟机视角的实例构造器init&gt;()方法）不同，</strong>不需要显示调用父类构造器</strong>。</p>
<h2 id="☆类加载器"><a href="#☆类加载器" class="headerlink" title="☆类加载器"></a>☆类加载器</h2><p><img src="D:\Picgo\img\image-20220512194439270.png" alt="image-20220512194439270"></p>
<p>前面提到，类加载机制的第一步就是加载，我们用到的工具自然是类加载器。其实类加载器分类很简单，就是C&#x2F;C++写的启动类加载器和Java写的类加载器，具体分类如下：</p>
<p><img src="D:\Picgo\img\image-20220512194934161.png" alt="image-20220512194934161"></p>
<h3 id="1-启动类加载器（引导类加载器-Bootstrap-ClassLoader）"><a href="#1-启动类加载器（引导类加载器-Bootstrap-ClassLoader）" class="headerlink" title="1.启动类加载器（引导类加载器, Bootstrap ClassLoader）"></a>1.启动类加载器（引导类加载器, Bootstrap ClassLoader）</h3><p>1）<strong>虚拟机自带</strong>，C++编写</p>
<p>2）用来<strong>加载Java核心库</strong></p>
<p>3）<strong>没有父加载器，也没有父类</strong></p>
<p>4）<strong>加载其下面的</strong>扩展类加载器和系统类加载器</p>
<h3 id="2-扩展类加载器（Extension-ClassLoader）"><a href="#2-扩展类加载器（Extension-ClassLoader）" class="headerlink" title="2.扩展类加载器（Extension ClassLoader）"></a>2.扩展类加载器（Extension ClassLoader）</h3><p>1）Java编写，**<u>独立存在于虚拟机外部</u>**</p>
<p>2）<strong>继承自抽象类</strong>java.lang.ClassLoader</p>
<p>3）父类加载器就是上边的Bootstrap ClassLoader</p>
<h3 id="3-系统类加载器（应用程序类加载器，System-ClassLoader）"><a href="#3-系统类加载器（应用程序类加载器，System-ClassLoader）" class="headerlink" title="3.系统类加载器（应用程序类加载器，System ClassLoader）"></a>3.系统类加载器（应用程序类加载器，System ClassLoader）</h3><p>1）Java编写，**<u>独立存在于虚拟机外部</u>**</p>
<p>2）<strong>继承自抽象类</strong>java.lang.ClassLoader</p>
<p>3）父类加载器就是上边的Extension ClassLoader</p>
<p>4）负责加载环境变量和系统属性指定路径下的类库</p>
<p>5）程序的默认类加载器，<strong>一般Java应用类都是它加载的</strong>。</p>
<h3 id="4-用户自定义类加载器"><a href="#4-用户自定义类加载器" class="headerlink" title="4.用户自定义类加载器"></a>4.用户自定义类加载器</h3><h2 id="☆双亲委派模型"><a href="#☆双亲委派模型" class="headerlink" title="☆双亲委派模型"></a>☆双亲委派模型</h2><p>首先我们要知道，虚拟机对class文件是<strong>按需加载</strong>的，也就是只有在需要使用该类的时候，才将其class文件加载到内存中生成class对象。</p>
<p>那么加载某个class文件的时候，具体的过程是怎么样的呢？这时候就要引入我们的一种特殊模式：双亲委派模式。工作原理如下：</p>
<p>1）一个类加载器收到类加载请求，<strong>先把请求依次委托其父类加载器去执行</strong>，请求<strong>最终到达顶层</strong>的启动类加载器。</p>
<p>2）如果父类加载器<strong>可以完成类加载的任务，就成功返回</strong>。若不能完成，<strong>才交给子加载器</strong>进行加载。</p>
<h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>其实就是利用了双亲委派模型的特点，假如我们定义一个String类，那么加载这个自定义String类的时候，<strong>会先委派到顶部的引导类加载器加载</strong>，引导类发现自己可以加载，就<strong>接着加载JDK自带的文件java.lang.String</strong>，这样就可以避免我们自定义String类对核心源代码的破坏。</p>
<h3 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h3><p>1）避免类的重复加载</p>
<p>2）保护程序安全，避免核心API被随意篡改</p>
<h2 id="☆判断两个class对象是否相同，我们需要看什么？"><a href="#☆判断两个class对象是否相同，我们需要看什么？" class="headerlink" title="☆判断两个class对象是否相同，我们需要看什么？"></a>☆判断两个class对象是否相同，我们需要看什么？</h2><p>1）类的名字首先得相同，包名也得一致</p>
<p>2）加载这个class的类加载器（<strong>ClassLoader实例对象</strong>）必须相同。</p>
<h2 id="☆Java什么时候对类进行主动引用？"><a href="#☆Java什么时候对类进行主动引用？" class="headerlink" title="☆Java什么时候对类进行主动引用？"></a>☆Java什么时候对类进行主动引用？</h2><p>1）使用new关键字实例化对象的时候</p>
<p>2）访问某个<strong>类（或接口）的静态变量</strong>，或者对该静态变量<strong>赋值</strong></p>
<p>3）调用某个类的<strong>静态方法</strong></p>
<p>4）使用java.lang.reflect包的方法对某个类进行<strong>反射调用</strong></p>
<p>5）初始化某个类，<strong>优先触发其父类初始化</strong></p>
<p>6）虚拟机启动时，用户需要<strong>指定一个要执行的主类</strong>（包括main()方法的那个类），虚拟机先初始化该类</p>
<p>7）JDK 7开始提供<strong>动态语言支持</strong>（不懂）</p>
<p>8）JDK 8在**接口中定义了默认方法(**default标识)，如果这个接口的实现类发生了初始化，那么该接口要率先初始化。</p>
<h1 id="☆虚拟机栈的作用是什么？"><a href="#☆虚拟机栈的作用是什么？" class="headerlink" title="☆虚拟机栈的作用是什么？"></a>☆虚拟机栈的作用是什么？</h1><p>栈是<strong>运行时</strong>的单位，而堆是<strong>存储的</strong>单位。栈解决的是程序如何执行，如何处理数据的问题；而堆是解决数据存储的问题。当然一些数据也会存在栈中，只能说栈的主要功能是处理数据，它<strong>是线程私有的</strong>。内部存储着一个个栈帧，<strong>每一个栈帧对应一个Java方法</strong>。</p>
<p>上面是比较泛泛的总结，虚拟机栈具体是什么作用呢？它主管程序的运行，<strong>在每个栈帧的局部变量表中保存相应方法的局部变量</strong>（8种<strong>基本数据</strong>类型、引用类型变量的<strong>引用地址</strong>），一<strong>部分结果</strong>，并参与方法的<strong>调用和返回</strong>。</p>
<p>栈操作只有两个：</p>
<p>1）执行方法的时候，<strong>进栈</strong>（入栈、压栈）</p>
<p>2）方法执行结束的时候，<strong>出栈</strong></p>
<p>所以栈<strong>没有垃圾回收机制</strong>，只<strong>存在栈溢出</strong>的现象。</p>
<h1 id="☆虚拟机栈的常见异常？如何设置栈的大小？"><a href="#☆虚拟机栈的常见异常？如何设置栈的大小？" class="headerlink" title="☆虚拟机栈的常见异常？如何设置栈的大小？"></a>☆虚拟机栈的常见异常？如何设置栈的大小？</h1><p>当<strong>某个线程请求分配的栈容量超过</strong>了Java虚拟机栈允许的最大容量，虚拟机会报<strong>StackOverflowError</strong>，即栈溢出。</p>
<p>我们可以通过-Xxx设置虚拟机栈的大小。在Idea的Run中，找到Edit Configurations，在当前程序的VM options中写入-Xxx256k即可。</p>
<p>如果Java虚拟机栈可以动态扩展，但<strong>扩展的时候无法申请到足够的内存</strong>，或者创建新线程的时候<strong>没有足够内存去创建对应的虚拟机栈</strong>，则虚拟机会报OutOfMemoryError异常，也就是我们所说的OOM。</p>
<h1 id="☆栈帧的内部结构"><a href="#☆栈帧的内部结构" class="headerlink" title="☆栈帧的内部结构"></a>☆栈帧的内部结构</h1><p>栈帧内部包括：局部变量表、操作数栈、动态链接、方法返回地址、一些附加信息。其中，<strong>局部变量表和操作数栈占的内存最大</strong>，主要影响栈帧的大小，而栈帧的大小决定了每个线程的虚拟机栈能存放多少个栈帧。</p>
<p>1）局部变量表：就是<strong>数字数组</strong>，主要用于<strong>存储方法参数和定义在方法体内的局部变量</strong>，包括基本数据类型、对象引用、returnAddress类型。<strong>slot(变量槽)<strong>是最基本的存储单元，对于byte、short、char在存储前，被</strong>转换为int</strong>,而boolean也被<strong>转换为int</strong>，false对应0，true对应非0。他们都<strong>占用一个slot</strong>。long和double类型的变量<strong>占两个slot</strong>。</p>
<p>栈帧的<strong>局部变量表与性能调优关系最为密切</strong>，因为在垃圾回收过程中，表中的变量是重要的<strong>垃圾回收根节点</strong>，只要<strong>被表中直接或间接引用的对象</strong>都不会被回收。</p>
<p>2）操作数栈：在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，例如执行<strong>复制、交换、求和</strong>等操作。主要用于<strong>保存计算过程中的中间结果</strong>，同时作为计算过程中的<strong>变量临时存储空间</strong>。</p>
<p>注意：操作数栈<strong>并非通过访问索引来进行数据访问</strong>的，它只是入栈出栈的一个实现工具。</p>
<p>3）动态链接：<strong>指向运行时常量池</strong>中的该栈帧所属<strong>方法的引用</strong>。在类加载之前，符号引用都在class文件的常量池中，类加载后，这些符号引用就被<strong>类加载阶段的“解析”过程</strong>转换为调用方法的直接引用。动态链接就是<strong>来实现这个“解析”过程的</strong>。</p>
<h1 id="☆局部变量和静态变量的对比"><a href="#☆局部变量和静态变量的对比" class="headerlink" title="☆局部变量和静态变量的对比"></a>☆局部变量和静态变量的对比</h1><p>我们知道静态变量就是类变量，是在累加载阶段就有初始化操作的，其一是<strong>“准备”阶段的初始化零值</strong>，另一阶段是<strong>”初始化“阶段为类变量赋初始值</strong>。</p>
<p>对于局部变量，<strong>因为要放在局部变量表中，表没有初始化过程</strong>，所以我们必须在写代码的时候，人为初始化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E4%B8%AA%E4%BA%BA%E5%AF%B9JVM%E7%9A%84%E7%90%86%E8%A7%A3/" data-id="cl31jc9hq00000cv6gfxp6myd" data-title="个人对JVM的理解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-双指针题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T09:01:55.000Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E8%A7%A3/">双指针题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcode-27-移除元素"><a href="#leetcode-27-移除元素" class="headerlink" title="leetcode 27.移除元素"></a>leetcode 27.移除元素</h1><p>**<u>题目</u>**：<u>给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。</u></p>
<p><u>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题因为要原地修改数组，所以必须要<strong>让元素之间换位</strong>来实现更改数组的操作。</p>
<p>所以我们采用双指针解法，既降低了空间复杂度，又实现了原位置换的好处。</p>
<p>具体操作就是让一个fast指针不停向后移动，而slow指针则必须“听从”fast指针安排，当fast没碰到val的时候，fast指针把当前位置的元素赋值给slow位置的元素，因为这些等于val的元素我们就不要了，所以不需要换位，只需要替代即可。</p>
<p>如果fast碰到val了，就让它继续向后走，这时一定不要对数组进行换位操作，因为只有碰到上面的情况，才实现换位，fast碰到的val让slow碰到了再解决。</p>
<p>可能会有以下问题：fast这样赋值，会不会打乱数组原有顺序？肯定不会。因为slow和fast是共起点的，只有当fast碰到val的那一刻，二者分开，而<strong>fast的作用就是要把不等于val的元素赋给slow</strong>，所以fast一定会依次将这些值赋给slow的，也就不会出现乱序的现象。</p>
<h1 id="leetcode-26-删除有序数组中的重复项"><a href="#leetcode-26-删除有序数组中的重复项" class="headerlink" title="leetcode 26.删除有序数组中的重复项"></a>leetcode 26.删除有序数组中的重复项</h1><p><u><strong>题目</strong>：给你一个<strong>升序排列</strong>的数组 <code>nums</code> ，请你原地删除重复出现的元素，使每个元素<strong>只出现一次</strong>，返回删除后数组的新长度。元素的<strong>相对顺序</strong>应该保持<strong>一致</strong>。不要使用额外的空间，你必须在并在使用 O(1) 额外空间的条件下完成</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>, fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[fast - <span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种解法我们可以发现：**比较的是nums[fast]和nums[fast - 1]**，也就是fast指针指向的元素和其指过的元素，直接想难度比较大，我们举例：[0,0,1,1,1,2,2,3,3,4]</p>
<p>因为我们要让fast和前面一位比，自然初始位置要从1开始，slow为1，这样可以让两者同步向后走。那么问题来了，slow为0行不行？</p>
<p>我们来看一下，如果slow为0，那么fast第一次比较的时候，发现0 &#x3D;&#x3D; 0会跳过当前位置，走到1的时候，发现1 !&#x3D; 0，这个时候，才把1赋给slow位置的0，<strong>那么slow一开始就丢掉了一个0，整个数组都会丢掉0</strong>。比如[1,1,2]答案是[2]，自己可以试一下。</p>
<p>所以slow和fast初始位置均为1，这样可以避免初始值被吞没的现象。</p>
<p>我们知道，<strong>比较重复值还可以让fast和其后面一个值比较</strong>，官方题解没有给出这种解法，但是确实是可以的，分析如下：</p>
<p>我们来比较nums[fast]和nums[fast + 1]，自然就要让fast从最初的的位置开始走起，所以初始值fast &#x3D; 0。那么slow也从0开始走吗？</p>
<p>我们假设slow也从0开始走，还是以简单的[1,1,2]为例，fast发现1和1相等，跳过，走到第二个1，发现1和2不等，肯定要把2给slow，给前面fast的就给乱了，所以要**把nums[fast + 1]赋给nums[slow]**。这个时候，我们发现slow在一开始就被赋予2，1压根不存在了。所以slow不能从最开始走，而要保留第一个值，从第二位走，也就是初始化slow &#x3D; 1。这只是我自己想到的一种向后比较的解法，纯粹是多思考一下，解法还是按照前面的思路比较简单。向后比较的题解代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[fast + <span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow] = nums[fast + <span class="number">1</span>];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-283-移动零"><a href="#leetcode-283-移动零" class="headerlink" title="leetcode 283.移动零"></a>leetcode 283.移动零</h1><p><u><strong>题目：</strong>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</u></p>
<p><u><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[slow];</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                nums[fast] = temp;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题要<strong>注意是移动0到末尾，而不是删除0</strong>，所以不能仅仅在nums[fast] !&#x3D; 0的时候进行覆盖操作，而要进行替换操作，<strong>将fast指向的非0数字赋给slow，把0转移给fast</strong>。</p>
<h1 id="leetcode-844-比较含退格的字符串"><a href="#leetcode-844-比较含退格的字符串" class="headerlink" title="leetcode 844.比较含退格的字符串"></a>leetcode 844.比较含退格的字符串</h1><p><u><strong>题目：</strong>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</u></p>
<p><u>注意：如果对空文本输入退格字符，文本继续为空。示例如下：</u></p>
<p><u>输入：s &#x3D; “ab#c”, t &#x3D; “ad#c”</u><br><u>输出：true</u><br><u>解释：s 和 t 都会变成 “ac”。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, j = t.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">skipA</span> <span class="operator">=</span> <span class="number">0</span>, skipB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    skipA++;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipA &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipA--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(j) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    skipB++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipB &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipB--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != t.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题虽然为简单题，但是想一次做对有些困难。</p>
<p>因为”#”是删除前一个字符，所以我们从后向前遍历比较好。整体的思路就是，先遍历s，如果碰到#，就计数，直到当前遍历无#，就跳出循环，然后同样的方式遍历t。</p>
<p>两个字符串的遍历走完之后，如果当前i或者j没有走完，就判断当前i和j位置对应的字符是否相等，如果不相等，那么肯定就返回false，为什么呢？因为我们<strong>同时从后向前遍历，一旦进行比较，就说明此时i和j后面的元素已经确定好了</strong>，没有一一对应的话，就没必要向前遍历了。如果有一个字符串走完了呢？一样的道理，还是没有一一对应上，因为<strong>此时连长度都对不上了</strong>，俩字符串更不可能相同了。</p>
<p>如果上述两个判断都没有问题，那么我就让两个指针都向前移动一位，继续判断。</p>
<p>什么时候跳出循环呢？一定要让两个指针都走完才可以，如果只有一个指针走完，我们就return true了。那么<u>absfds##asd##和a</u>就会误判了。</p>
<h1 id="leetcode-977-有序数组的平方"><a href="#leetcode-977-有序数组的平方" class="headerlink" title="leetcode 977.有序数组的平方"></a>leetcode 977.有序数组的平方</h1><p><u><strong>题目：</strong></u><u>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。举例如下：</u></p>
<p><u>输入：nums &#x3D; [-4,-1,0,3,10]</u><br><u>输出：[0,1,9,16,100]</u><br><u>解释：平方后，数组变为 [16,1,0,9,100]</u><br><u>排序后，数组变为 [0,1,9,16,100]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>, index = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] * nums[i] &lt; nums[j] * nums[j])&#123;</span><br><span class="line">                ans[index--] = nums[j] * nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[index--] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="img"></p>
<p>题解来自Carl大佬，这个图足够说明解题思路了。要注意的就是while的循环条件。</p>
<h1 id="leetcode-209-长度最小的子数组"><a href="#leetcode-209-长度最小的子数组" class="headerlink" title="leetcode 209.长度最小的子数组"></a>leetcode 209.长度最小的子数组</h1><p><u><strong>题目</strong>：给定一个含有 n 个正整数的数组和一个正整数 target 。</u></p>
<p><u>找出该数组中满足其和 ≥ target 的长度最小的<strong>连续子数组</strong> [numsl, numsl+1, …, numsr-1, numsr]，并返回其长度。如果不存在符合条件的子数组，返回0。</u></p>
<p><u><strong>示例 1：</strong></u></p>
<p><u>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</u><br><u>输出：2</u><br><u>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>, res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right &lt; nums.length;right++)&#123;</span><br><span class="line">            sum += nums[right];<span class="comment">//每次移动right指针都要将其所指元素添加进sum中</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;<span class="comment">//一旦总和大于目标值，就开始记录当前最短数组，并右移left指针</span></span><br><span class="line">                res = Math.min(res, right - left + <span class="number">1</span>)</span><br><span class="line">                sum -= nums[left++];<span class="comment">//记得删除left指针指向的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">res</span> <span class="operator">=</span>= Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题一定要看清楚题意，是<strong>连续子数组！</strong></p>
<p>这样我们才可以<strong>利用双指针来模拟滑动窗口</strong>，左指针就是滑动窗口的左边界，右指针对应着右边界。</p>
<p>每当我们移动一次right指针，我们就把right所指的元素添加进sum中，一旦sum &gt;&#x3D; target，我们就要<strong>开始记录当前数组长度和之前记录的res的最小值</strong>。记录之后，为了继续移动right指针，我们<strong>必须删除左指针指向的元素</strong>，同时<strong>一定不要忘了右移左指针</strong>。这样一个滑动窗口就形成了。</p>
<p>最后要<strong>记住判断res是否存在</strong>，不存在的话就是初始值Integer.MAX_VALUE。</p>
<h1 id="leetcode-904-水果成篮"><a href="#leetcode-904-水果成篮" class="headerlink" title="leetcode 904.水果成篮"></a>leetcode 904.水果成篮</h1><p><u><strong>题目</strong>：你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</u></p>
<p><u>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</u></p>
<p><u>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。</u><br><u>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</u><br><u>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</u><br><u>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</u></p>
<p><u>举例如下：</u></p>
<p><u>输入：fruits &#x3D; [0,1,2,2]</u><br><u>输出：3</u><br><u>解释：可以采摘 [1,2,2] 这三棵树。</u><br><u>如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; fruits.length;j++)&#123;</span><br><span class="line">            count.add(fruits[j], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(count.size() &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">                count.add(fruits[i], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(count.get(fruits[i]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    count.remove(fruits[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(k) ? <span class="built_in">super</span>.get(k) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">        put(k, get(k) + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题理解题意是难度比较大的，总的来说就是在一个<strong>含有重复元素的数组</strong>中，找到<strong>含有两种不同元素的最长连续子数组</strong>。这道题和前面的题的区别，就像背包问题，一个求背包重量，一个求方案数一样。这道题就是后者的情况，因为<strong>重复元素只算一种元素</strong>，所以我们必须要用HashMap来记录这个元素在数组中出现了多少次。而<strong>连续子数组的长度则由HashMap的size()来控制</strong>。</p>
<p>我们依旧是利用双指针模拟滑动窗口，让右指针j不停向右移动，移动一次就记录当前j指向的元素及其出现的次数，一旦我们的HashMap的size() &gt;&#x3D; 3了，说明当前HashMap存了3组不同种元素，要删一个，这时候，我们开始从左删，因为HashMap中记录的是重复元素的个数，<strong>所以先删key值fruits[i]对应的value，删一个就一次左指针i</strong>。直到这个value &#x3D;&#x3D; 0了，说明这个重复元素删干净了，就可以把当前fruits[i]删掉了。</p>
<p><strong>不管是删fruits[i]还是删其value值，都要进行i++，所以这个i++的位置一定要放对</strong>。</p>
<p>上述的操作因为与HashMap的原始方法有一些出入，所以我们可以看到官方题解又<strong>另写了一个继承HashMap的类来重写HashMap的方法</strong>，方便我们主方法进行重复元素的增删改查。</p>
<p>最后需要注意的是，每次向右移动一次指针j，不仅要记录当前的fruits[j]和其出现次数，还要累计当前的长度ans,别忘了，我们需要返回的最终结果，就是这个每次累计的ans值。如果当前HashMap的size() &gt;&#x3D; 3，那就先进入while循环，直到size() &lt; 3了，我们再更新ans的值。<strong>所以ans和while循环的顺序一定要写对</strong>。</p>
<p>总的来说，<strong>容易出现问题的地方</strong>，首先是：</p>
<p>​		①左指针i向右移动的时机</p>
<p>​		②更新ans的时机。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E8%A7%A3/" data-id="cl31ednen0000bgv69yxwh7fl" data-title="双指针题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-二分法题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E4%BA%8C%E5%88%86%E6%B3%95%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T06:01:09.000Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E4%BA%8C%E5%88%86%E6%B3%95%E9%A2%98%E8%A7%A3/">二分法题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="leetcode-704-二分查找"><a href="#leetcode-704-二分查找" class="headerlink" title="leetcode 704.二分查找"></a>leetcode 704.二分查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种二分查找的题，我们首先要看数组是不是<strong>有序的</strong>，因为我们要逐步缩小查找区间，如果数组不是有序的，那么就无法用二分法。</p>
<p>其次数组<strong>不能有重复元素</strong>，如果有重复元素我们只能找到符合条件的某一个元素，必须用一些其他手段才能找到所有符合条件的元素。</p>
<p>好了，本题自然是很简单的数组，满足有序且不重复的条件。</p>
<p>难点就是：边界条件比较难确定，即中点值大于target的时候，左边界和右边界如何收缩。</p>
<p>根据Carl大佬给的思路，我们将l和r的范围区间确定为左闭右闭的闭区间[l,r]，这样我们在while循环的时候，循环条件自然是l &lt;&#x3D; r了，<strong>因为l &#x3D;&#x3D; r也是符合闭区间的范围的</strong>。</p>
<p>进入循环后，如果nums[mid] &lt; target，说明当前mid位置的元素不符合条件，而且在target的左边，我们自然要将左边界l收缩，l &#x3D; mid还是l &#x3D; mid + 1呢？我们<strong>一定要看区间</strong>，我们确定的是闭区间，所以[mid, r]这个mid不是我们想要的范围为，[mid + 1, r]才是。</p>
<p>同理，nums[mid] &gt; target时，我们要收缩右边界r，所以[l, mid - 1]才是我们想要的范围。</p>
<p>其实，还可以将区间定义为左闭右开的区间[l, r)，这样循环体则时l &lt; r，if判断的边界条件也有区别。具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-35-搜索插入位置"><a href="#leetcode-35-搜索插入位置" class="headerlink" title="leetcode 35.搜索插入位置"></a>leetcode 35.搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。数组中无重复元素，请必须使用时间复杂度为 <code>O(log n)</code> 的算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题具体思路和上一题一样，但是难点是插入位置，也就是数组中可能不存在目标值，我们要将这个值插入到哪里是有讲究的。</p>
<p>通过二分法闭区间的思路，我们可以看出：<strong>只有跳出while循环之后return的值才是最终插入的位置</strong>，也就是没查找到目标值的情况。这个时候自然满足l &gt; r，也就是<strong>l &#x3D; r + 1</strong>。</p>
<p>既然确定了插入位置是return语句的返回值，我们就得考虑什么时候跳出循环的：走完最后一个if或者else if语句。</p>
<p>如果最后走的if语句，那么当前的l &#x3D; mid + 1，nums[mid]比target要小，我们肯定要把target插入到mid之后，也就是mid + 1，那么自然我们返回l即可。</p>
<p>如果最后走的是else if语句呢？当前r &#x3D; mid - 1，当前nums[mid]比target大，我们肯定要把target插入到mid的位置，进而把当前的mid位置的元素向后挤一位，为什么不插到mid - 1，因为mid - 1位置的元素肯定比target小，<strong>假设nums[mid - 1] &#x3D;&#x3D; 3, target &#x3D;&#x3D; 4, nums[mid] &#x3D;&#x3D; 5</strong>，就成了[4,3,5]了。所以必须要插在5的位置，形成[3, 4, 5]。因为r &#x3D; mid - 1，所以最后返回r + 1。因为跳出循环后，肯定满足前面说的l &#x3D; r + 1这个等式，所以上述分析的两种情况，即返回l或r + 1是一样的。</p>
<h2 id="leetcode-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#leetcode-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="leetcode 34.在排序数组中查找元素的第一个和最后一个位置"></a>leetcode 34.在排序数组中查找元素的第一个和最后一个位置</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBoard</span> <span class="operator">=</span> findLeftBoard(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBoard</span> <span class="operator">=</span> findRightBoard(nums, target);</span><br><span class="line">        <span class="keyword">if</span>(leftBoard == -<span class="number">2</span> || rightBoard == - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(rightBoard - leftBoard &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftBoard + <span class="number">1</span>, rightBoard - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLeftBoard</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBoard</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                leftBoard = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBoard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRightBoard</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBoard</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                rightBoard = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightBoard;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题明显有重复元素，用二分法难度陡增。</p>
<p>代码很长，所以思路一定要清晰。</p>
<p>可以看到代码分别找了左边界和右边界，两个寻找边界的方法都是采用的二分法，我们**<u>以findLeftBoard()为例</u>**。</p>
<p>我们首先定义了leftBoard的初始值，为什么是-2，这个得留到最后解释。</p>
<p>可以看到代码的if分了两部分，一部分是nums[mid] &lt; target这一部分，如果满足这个条件，那么我们让左边界</p>
<p>右移，这个没什么疑问。</p>
<p>但是else if这部分，为什么既包括了nums[mid] &gt; target的部分，又包括了nums[mid] &#x3D;&#x3D; target部分。</p>
<p>我们需要举个例子，比如当前数组是[1,2,3,3,3,3,3,3,3,3,3,3,3,3,4,5,5,6,6,7]，target是3，一上来二分法就能定位到3，但是我们要确定左边界，所以必须要通过循环体不断让mid逼近左边界，我们可以看到当确定闭区间[l, r]的时候，right是不断由mid - 1确定的，也就是<strong>真正不断向左移动的是right</strong>，所以我们的左边界一定要<strong>利用好区间[l, r]的右边界不断向左移动的这一个特点</strong>。</p>
<p>这样一来，我们就可以理解为什么每次right &#x3D; mid - 1的时候，还要更新leftBoard。right什么时候停止左移呢，答案是找到最后一个满足target &#x3D;&#x3D; 3的位置，跳出循环，返回leftBoard，这个左边界值我们可以用上一题的插入位置来考虑，因为<strong>最后的leftBoard &#x3D;&#x3D; right，而right &#x3D; mid - 1，mid这个位置是最后一个满足target的点，所以mid - 1自然是左边界的前一个值了</strong>。那么它就自然有等于-1的风险，所以我们初始化leftBoard为-2。</p>
<p>对于寻找右边界，我们的思路是一样的，只不过rightBoard最后没有等于-1的风险，所以我们可以为其初始化为-1或-2都可。</p>
<h2 id="leetcode-69-x的平方根"><a href="#leetcode-69-x的平方根" class="headerlink" title="leetcode 69.x的平方根"></a>leetcode 69.x的平方根</h2><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根。</p>
<p>由于返回类型是整数，结果只保留 整数部分，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = x, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &lt;= x)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案很简单，但是要注意用long型变量，因为mid + 1之后，其自身的平方很可能比Integer的最大范围还大，容易溢出报错，所以要用long型。</p>
<h2 id="leetcode-367-有效的完全平方数"><a href="#leetcode-367-有效的完全平方数" class="headerlink" title="leetcode 367.有效的完全平方数"></a>leetcode 367.有效的完全平方数</h2><p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = num;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &gt; num)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &lt; num)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与上一题需要注意的地方一样。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E4%BA%8C%E5%88%86%E6%B3%95%E9%A2%98%E8%A7%A3/" data-id="cl319inhr0000jgv6anb7cgxu" data-title="二分法题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-动态规划序列问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T04:37:29.101Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/">动态规划之序列问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-单数组找子序列问题"><a href="#1-单数组找子序列问题" class="headerlink" title="1.单数组找子序列问题"></a>1.单数组找子序列问题</h3><h4 id="lt-300-最长递增子序列"><a href="#lt-300-最长递增子序列" class="headerlink" title="lt 300.最长递增子序列"></a>lt 300.最长递增子序列</h4><p>在一个整数数组nums中，找到最长的严格<strong>递增的子序列的长度</strong>，返回其<strong>长度</strong>。如[10,9,2,5,3,7,101,18]中的[2,3,7,101]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                    max = Math.max(dp[i], max);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dp[i]是<strong>以nums[i]为结尾</strong>组成的最长递增子序列的<em><strong>长度</strong></em>。这是每个动态规划题目需要最先确定的。</p>
<p>1.首先我们知道，每一个数字都是一个长度为1的递增序列，所以<strong>每个dp[i]我们一定要初始化为1</strong>，后面具体等于多少是后面的事。</p>
<p>2.这里两层循环是重点，外层循环i(i &lt; nums.length)负责dp[i]的推进，每次推进dp[i]都<strong>需要比较nums[i]以前所有的数字</strong>，也就是内层循环j(i &lt; j)，一旦发现比nums[i]小的num[j]了，我们就要让dp[i]与当前的dp[j] + 1进行比较，取大者存入dp[i]。这才能保证<em><strong>每个dp[i]都比较过前面所有的数字，并留住了最大值</strong></em>。</p>
<p>3.我们要注意：[1,3,6,7,9,4,10,5]这个序列，如果我们没有一个随时记录的max，<em>而是直接最后返回dp[nums.length - 1]<em>，会出现这么一种情况：10这里对应的dp[6]是6，但是5这里的dp[7]只能记录比5小的dp[i]的最大值，也就是到4这里就停了，那么4呢，4会在它的循环中记录到3就停了，所以4这里的dp[5]是3，5这里的dp[7]也就是dp[nums.length]是4。最大值不是6反而成4了，这就是不随时记录max的后果，而</em></em>“罪魁祸首”是每次的dp[i]只有在nums[i] &gt; nums[j]的时候才记录**。</p>
<p><u>难点：①.初始化不是默认值0，而是1；②定义一个随时记录最大值的max</u></p>
<h4 id="lt-674-最长连续递增序列"><a href="#lt-674-最长连续递增序列" class="headerlink" title="lt 674.最长连续递增序列"></a>lt 674.最长连续递增序列</h4><p>一个没有排序的整数数组nums，找到<strong>最长的连续递增子序列</strong>，返回其<strong>长度</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                max = Math.max(dp[i], max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.一定要和300进行区分，这次是连续了，也就是增着增着突然断了是要从头（1）开始的，但是之前的长度也要记下，说不定就有最大值呢？所以还是要定义一个max来随时记录最大值；</p>
<p>2.此外，真的需要我们从头开始吗？其实不用，因为这个所谓的“头”，就是每个值得初始化——dp[i] &#x3D; 1。</p>
<p>3.最重要的是这次还用叠层循环吗？不用了，我们只需要每次让当前元素和前面的元素比较，比前面大就在前面的dp[i - 1]加上1即可，<strong>如果前面的这个dp[i - 1]“断了”，那么他自然就是1</strong>，所以也不需要我们从头开始了。</p>
<p><u>难点：1.每次断了要从1开始，容易思路变乱；2.持续记录最大值max</u></p>
<h3 id="2-两数组求子序列问题"><a href="#2-两数组求子序列问题" class="headerlink" title="2.两数组求子序列问题"></a>2.两数组求子序列问题</h3><h4 id="lt-718-最长重复子数组"><a href="#lt-718-最长重复子数组" class="headerlink" title="lt 718.最长重复子数组"></a>lt 718.最长重复子数组</h4><p>两个整数数组nums1和nums2，返回最长的<strong>公共子数组的长度</strong>。如nums1 &#x3D; [1,2,3,2,1], nums2 &#x3D; [3,2,1,4,7]，返回[3,2,1]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.二维数组解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.一维数组解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums2.length;j &gt;= <span class="number">1</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max, dp[j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.这道题叫重复子数组不如<strong>叫公共子序列</strong>，我们定义的dp[i][j)自然是以i - 1为结尾的nums1和j - 1为结尾的nums2的<strong>最长子序列长度</strong>。</p>
<p>2.就拿nums1 &#x3D; [1,2,3,2,1], nums2 &#x3D; [3,2,1,4,7]为例，外层循环一层层推进nums1中的元素，每推进一步，就执行内层循环遍历nums2所有元素，如果当前的nums1[i - 1] &#x3D;&#x3D; nums2[j - 1]，那么就让当前的dp等于不考虑这俩值的那个dp再加上考虑这俩值的1，也就是dp[i - 1][j - 1) + 1。效果如下图：</p>
<img src="https://img-blog.csdnimg.cn/2021011215282060.jpg" alt="718.最长重复子数组" style="zoom: 45%;" />

<p>3.我们看图中的最后三行，<strong>必须是45°角累加才能得到最大长度</strong>，这说明了只有当前的nums1[i - 1] &#x3D;&#x3D; nums2[j - 1]满足之后，又继续满足nums1[i - 2] &#x3D; nums2[j - 2]，以此类推，才可以实现45°累加，而这种程度的累加就说明了两个数组这些满足累加的元素<strong>必须紧挨着不能断开</strong>，才能实现累加，这就是连续的含义。<em>下面一题我们给出不连续的解法</em>。</p>
<p><u>难点：1.一维数组解法要注意<strong>每次不满足等值判断时</strong>要为当前dp赋值为0；2.一维数组解法每列要倒叙遍历；3.要随时记录最大值；4.dp的角标和nums角标很容易出错</u></p>
<h4 id="lt-1143-最长公共子序列"><a href="#lt-1143-最长公共子序列" class="headerlink" title="lt 1143.最长公共子序列"></a>lt 1143.最长公共子序列</h4><p>两个字符串text1和text2，返回两字符串最长公共子序列<strong>长度</strong>。如text1 &#x3D; “abcde”, text2 &#x3D; “ace”，返回3。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length() + <span class="number">1</span>][text2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= text1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= text2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.length()][text2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次是<strong>非连续</strong>的了，那么当前<strong>text1(i) !&#x3D; text2(j)<strong>该怎么办呢？肯定不能从头(0)来了，因为我们要查非连续的子序列，</strong>有多少算多少</strong>。以<strong>下右图</strong>的倒数第二行倒数第二列的2为例，这个时候d !&#x3D; c，那么我们看看分别<strong>让各自序列不含d或c</strong>的时候dp是多少：1.不含d，是[a,b,c]和[a,c]，有2；2.不含c，是[a,b,c,d]和[a]，只有1。所以我们取两者的最大值，来构建当前i,j下的dp(i)(j)。也就是<strong>下左图的左箭头和上箭头</strong>取最大值的方法。</p>
<p><img src="https://img-blog.csdnimg.cn/20210204115139616.jpg" alt="1143.最长公共子序列" style="zoom:45%;" /><img src="https://img-blog.csdnimg.cn/20210210150215918.jpg" alt="1143.最长公共子序列1" style="zoom: 50%;" /></p>
<p><u>难点：在text1(i) !&#x3D; text2(j)的时候，如何计算当前dp(i)(j)</u></p>
<h4 id="lt-1035-不相交的线"><a href="#lt-1035-不相交的线" class="headerlink" title="lt 1035.不相交的线"></a>lt 1035.不相交的线</h4><p>我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。</p>
<p>现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] &#x3D;&#x3D; B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p>
<p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。<img src="https://assets.leetcode.com/uploads/2019/04/26/142.png" alt="img" style="zoom:10%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= nums2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums1.length][nums2.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是求最长的公共子序列，与上面题解法一模一样</p>
<p><u>难点：将题目理解为最长公共子序列</u></p>
<h3 id="3-子序列求和"><a href="#3-子序列求和" class="headerlink" title="3.子序列求和"></a>3.子序列求和</h3><h4 id="lt-53-最大子序和"><a href="#lt-53-最大子序和" class="headerlink" title="lt 53.最大子序和"></a>lt 53.最大子序和</h4><p>在一个整数数组nums中，找到一个具有<strong>最大和</strong>的<strong>连续子数组</strong>，返回<strong>最大和</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.我们定义当前dp[i]为i之前的<strong>最大连续子序列和</strong>，那么这个和要不就是当前的nums[i] + dp[i - 1]，要么就是nums[i]，谁大是谁。</p>
<p>2.随时记录一个最大值max，以防数组中有一个很小的负数，使得最大子序和出现在中间。</p>
<p><u>难点：1.不能因为当前nums[i]太小就不加进来；2.随时记录最大值max</u></p>
<h3 id="4-一数组是另一数组的子序列问题"><a href="#4-一数组是另一数组的子序列问题" class="headerlink" title="4.一数组是另一数组的子序列问题"></a>4.一数组是另一数组的子序列问题</h3><h4 id="lt-392-判断子序列"><a href="#lt-392-判断子序列" class="headerlink" title="lt 392.判断子序列"></a>lt 392.判断子序列</h4><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。例如，”ace”是”abcde”的一个子序列，而”aec”不是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.双指针解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; j &lt; t.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == t.charAt(j))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">i</span> <span class="operator">=</span>= s.length() ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.二维数组解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> s.length(); <span class="type">int</span> <span class="variable">length2</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= length1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= length2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[length1][length2] == length1)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210303172354155.jpg" alt="392.判断子序列1" style="zoom:33%;" /><img src="https://img-blog.csdnimg.cn/2021030317364166.jpg" alt="392.判断子序列2" style="zoom:33%;" /></p>
<p><u>难点：不满足等值条件时，要让<strong>长数组</strong>不考虑当前值</u></p>
<h4 id="☆lt-115-不同的子序列-子序列个数"><a href="#☆lt-115-不同的子序列-子序列个数" class="headerlink" title="☆lt 115.不同的子序列(子序列个数)"></a>☆lt 115.不同的子序列(子序列个数)</h4><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。比如”baegg”和”bag”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= s.length();i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= t.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.这道题难度比较大，当满足等值条件的时候，dp(i)(j)要考虑两种情况，一种就是去掉这两个相等的元素，取dp(i - 1)(j - 1)；另一种很难想，就是取dp(i - 1)(j)。以”baegg”和”bag”为例，当最后一个”g” &#x3D;&#x3D; “g”的时候，可以考虑”baeg”包含“ba”的dp，<strong>也要考虑”baeg”包含”bag”的dp</strong>；如果两个g不相等，那么就只考虑”baeg”包含”ba?”的dp.</p>
<img src="https://code-thinking.cdn.bcebos.com/pics/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.jpg" alt="115.不同的子序列" style="zoom: 50%;" />

<p><u>难点：1.满足等值条件的时候，容易漏条件；2.dp(i)(0) &#x3D; 1的初始化很容易丢掉</u></p>
<h3 id="5-编辑字符串问题"><a href="#5-编辑字符串问题" class="headerlink" title="5.编辑字符串问题"></a>5.编辑字符串问题</h3><h4 id="lt-583-两个字符串的删除操作"><a href="#lt-583-两个字符串的删除操作" class="headerlink" title="lt 583.两个字符串的删除操作"></a>lt 583.两个字符串的删除操作</h4><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。例如: “sea”, “eat”，返回2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= word1.length();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt;= word2.length();j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= word1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= word2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j-<span class="number">1</span>] + <span class="number">1</span>), dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>);<span class="comment">//其实dp[i-1][j-1] + 2不用写</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题代码长，但是难度不大，只要记住初始化，含义是i或j表示字符长度，而0是空串，这样初始化就没难度了。然后就是等值的时候，因为不用删，所以dp(i)(j) &#x3D; dp(i - 1)(j - 1)；不等值就要取三种情况的最大值，<strong>其实dp(i - 1)(j - 1) + 2这个不用写</strong>。</p>
<p><u>难点：1.初始化容易忘；2.条件细节容易丢</u></p>
<h4 id="lt-72-编辑距离"><a href="#lt-72-编辑距离" class="headerlink" title="lt 72.编辑距离"></a>lt 72.编辑距离</h4><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p>
<p>你可以对一个单词进行如下三种操作：插入，删除或替换一个字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; word1.length() + <span class="number">1</span>;i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; word2.length() + <span class="number">1</span>;j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; word1.length() + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; word2.length() + <span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i -<span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>), dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实和上面的583非常相似，记住增加就是删除的逆推，所以合二为一，替换可以让两个分别的删除操作合二为一</p>
<p><u>难点：1.初始化容易忘；2.条件细节容易丢</u></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/" data-id="cl3cvqp5y0000ssv6fjn3a0kv" data-title="动态规划之序列问题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL个人总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/MySQL%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T03:37:29.914Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/MySQL%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">MySQL个人总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="01讲-基础架构：一条SQL查询语句是如何执行的？"><a href="#01讲-基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="01讲 | 基础架构：一条SQL查询语句是如何执行的？"></a>01讲 | 基础架构：一条SQL查询语句是如何执行的？</h2><p>下图是MySQL的逻辑架构图</p>
<img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img" style="zoom:30%;" />

<p>大体来说，MySQL可以分为Server层和存储引擎层两部分</p>
<p>Server层包括：连接器、查询缓存、分析器、优化器和执行器等。而<strong>不同的存储引擎共用</strong>一个Server层。</p>
<h3 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1.连接器"></a>1.连接器</h3><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</p>
<h3 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a>2.查询缓存</h3><p>MySQL拿到一个查询请求之后，会先到查询缓存中看看，之前查没查过，如果查过，之前执行过的语句和结果，会以key-value的形式，直接缓存在内存中。不过，只要有<strong>对一个表的更新操作，这个表上的所有查询缓存都会被清空</strong>，所以命中率较低，在MySQL 8.0以后已经<strong>被淘汰</strong>了。</p>
<h3 id="3-分析器（要做什么）"><a href="#3-分析器（要做什么）" class="headerlink" title="3.分析器（要做什么）"></a>3.分析器（要做什么）</h3><p>查询缓存未命中，则先走分析器，做<strong>“词法分析”</strong>，识别里面的字符串都是什么，代表什么。同时也会<strong>判断所查询的字段是否存在</strong>。然后做“<strong>语法分析</strong>”，判断这个SQL语句是否符合MySQL语法。</p>
<h3 id="4-优化器（该怎么做）"><a href="#4-优化器（该怎么做）" class="headerlink" title="4.优化器（该怎么做）"></a>4.优化器（该怎么做）</h3><p>优化器是在表里面有多个索引的时候，决定使用哪个索引，或者多表关联(join)的时候，决定各表连接顺序。</p>
<h3 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5.执行器"></a>5.执行器</h3><p>要先判断当前用户<strong>是否对表有查询权限</strong>。为什么到这里才查权限，其实一共有三层查询权限的过程，引用极客的评论：“连接器是账号权限校验   分析器是库权限验证   执行器是语句在表中权限验证。”</p>
<p>假如当前查询的字段<strong>没有索引</strong>，那么就是走全表扫描，具体操作<strong>不是存储引擎单独完成的，而是执行器每次调用InnoDB引擎的接口来走全表扫描的</strong>。</p>
<p>如果<strong>有索引</strong>，那么执行器就<strong>直接调用InnoDB“满足条件的这一行”这个接口</strong>。</p>
<p>我们在使用慢查询日志的时候看到的<strong>rows_examined</strong>的字段，表示<strong>语句执行过程中扫描了多少行</strong>，这个值其实就是<strong>执行器每次调用引擎</strong>获取数据行的时候<strong>累加</strong>的。<!--这里不确定执行器的这个累加值到底是怎么算的--></p>
<p>不过需要注意的是，<strong>执行器调用一次，引擎可能扫描多行</strong>，所以引擎扫描行数和rows_examined<strong>并不完全相同</strong>。</p>
<h2 id="16讲-“order-by”是怎么工作的？"><a href="#16讲-“order-by”是怎么工作的？" class="headerlink" title="16讲 | “order by”是怎么工作的？"></a>16讲 | “order by”是怎么工作的？</h2><h2 id="17讲-如何正确地显示随机消息"><a href="#17讲-如何正确地显示随机消息" class="headerlink" title="17讲 | 如何正确地显示随机消息"></a>17讲 | 如何正确地显示随机消息</h2><p>本文是沿着上一篇order by语句来进行展开的。本篇文章讲述一种排序的需求，即从大量数据（words）中随机查找若干个数据（word）。</p>
<h3 id="1-order-by-rand"><a href="#1-order-by-rand" class="headerlink" title="1. order by rand()"></a>1. order by rand()</h3><p>如果用MySQL自带的随机语句order by rand()来进行查找，流程如下：</p>
<p>1.先在<strong>内存中</strong>建立一个临时表，用来储存随机小数(R字段)以及word，此处需要扫描10000行</p>
<p>2.然后将临时表的内容一个一个存储到sort_buffer中，这里储存的是随机小数R字段和位置信息。这又需要扫描10000行</p>
<p>3.这时再将sort_buffer中的内容根据随机小数进行排序，这里不需要表操作，所以不需要扫描行数、</p>
<p>4.最后从排列好的sort_buffer中根据位置信息选出前三个，然后去内存临时表中取出三个对应的word</p>
<h3 id="2-随机排序方法"><a href="#2-随机排序方法" class="headerlink" title="2. 随机排序方法"></a>2. 随机排序方法</h3><p>然后为了优化上述方法，作者提出<strong>随机排序方法</strong>：</p>
<p>1.取得words表的主键id的最大值和最小值</p>
<p>2.用随机函数根据上面这俩值生成一个随机数X</p>
<p>3.取不小于X的第一个id的行</p>
<p>这种方法不严谨，因为X可能周围有可能含有好多空洞，也可能X本身的位置有空洞，所以每个数据被取到的概率是不一样的。</p>
<p>然后上述方法<strong>进行优化</strong>：</p>
<p>1.首先取得整个word表的行数，C</p>
<p>2.对这个行数C进行rand()函数运算，然后取整，Y</p>
<p>3.用limit Y,1取得一行（这里的意思是丢掉前Y个值，取第一个，如果是空洞则跳过）。</p>
<p>这种算法总共需要扫描C+Y+1行，代价其实比优化前要高，但是保证了空洞不会被取到，且每个数据能被公平取到。如果随机取三个数，那么扫描的行数就是C+(Y1+1)+(Y2+1)+(Y3+1)</p>
<p>本篇文章的核心思想就是：<strong>尽量将业务逻辑写在业务代码中，让数据库仅仅去做“读写数据”的事情</strong>。</p>
<h2 id="18讲-为什么这些SQL语句逻辑相同，性能却差异巨大？"><a href="#18讲-为什么这些SQL语句逻辑相同，性能却差异巨大？" class="headerlink" title="18讲 | 为什么这些SQL语句逻辑相同，性能却差异巨大？"></a>18讲 | 为什么这些SQL语句逻辑相同，性能却差异巨大？</h2><p>本篇文章讲述的是条件查询时，一些SQL语句执行过慢的现象以及原因。</p>
<h3 id="1-条件字段函数操作"><a href="#1-条件字段函数操作" class="headerlink" title="1.条件字段函数操作"></a>1.条件字段函数操作</h3><p>一个关于日期（datetime）的索引如下，这个索引的名字是t_modified，如果我们想查询索引中七月的数据，可以用函数month()，即where month(t_modified)&#x3D;7，但是这个时候，SQL语句执行的特别慢，原因就在于：我们对索引字段做了函数计算，人家字段明明是有年有月有日的字段，你只取其中的月来进行查询，必然需要month函数，但是MySQL规定<strong>对字段使用了函数计算，就不能使用索引了</strong>，这个时候就会<strong>执行全表扫描</strong>，执行速度非常慢。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from tradelog where month(t_modified)=7;</span><br></pre></td></tr></table></figure>

<p>为什么走全索引搜索？因为对索引字段进行函数操作，<strong>可能会对索引值的有序性造成破坏</strong>，所以优化器<strong>默认会放弃走树搜索功能</strong>。</p>
<p>这里<strong>要注意</strong>：<strong>不是放弃了使用这个索引</strong>，而是放弃在这个索引上面走树搜索，转而执行全索引扫描。</p>
<img src="https://static001.geekbang.org/resource/image/3e/86/3e30d9a5e67f711f5af2e2599e800286.png" alt="img" style="zoom: 50%;" />

<p>优化方法：执行如下代码，即优化器可以判断在t_modified索引上走树搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from tradelog where</span><br><span class="line">    -&gt; (t_modified &gt;= &#x27;2016-7-1&#x27; and t_modified&lt;&#x27;2016-8-1&#x27;) or</span><br><span class="line">    -&gt; (t_modified &gt;= &#x27;2017-7-1&#x27; and t_modified&lt;&#x27;2017-8-1&#x27;) or </span><br><span class="line">    -&gt; (t_modified &gt;= &#x27;2018-7-1&#x27; and t_modified&lt;&#x27;2018-8-1&#x27;);</span><br></pre></td></tr></table></figure>

<p>所以这里提到了优化器“偷懒”的行为：即使你认为你的SQL语句对索引字段的有序性不造成破坏，它还是默认会破坏的。比如如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where id + 1 = 10000</span><br></pre></td></tr></table></figure>

<p>我们在执行前必须手动改成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where id = 10000 - 1</span><br></pre></td></tr></table></figure>

<h3 id="2-隐式类型转换"><a href="#2-隐式类型转换" class="headerlink" title="2.隐式类型转换"></a>2.隐式类型转换</h3><p>这里<strong>需要记住：MySQL会自动将字符串转成数字</strong>，比如如下代码（假如tradeid是int类型变量）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where tradeid=&quot;110717&quot;;</span><br></pre></td></tr></table></figure>

<p>但是如果tradeid是varchar(32)类型，即字符串，那么如下的代码就需要隐式地将数字转换为字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where tradeid=110717;</span><br></pre></td></tr></table></figure>

<p>所以上面这个代码对于优化器来说，实际的执行语句是（即对索引字段执行了函数，优化器放弃走树搜索）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where CAST(tradid AS signed int) = 110717;</span><br></pre></td></tr></table></figure>

<h3 id="3-隐式字符编码转换"><a href="#3-隐式字符编码转换" class="headerlink" title="3.隐式字符编码转换"></a>3.隐式字符编码转换</h3><p>在如下代码中，执行了连表查询，即先在l表中找到id&#x3D;2的行，然后去d表中查找满足d.tradeid&#x3D;l.tradeid的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2;</span><br></pre></td></tr></table></figure>

<p>在这里，l是驱动表，d是被驱动表，tradeid是关联字段。</p>
<p>这个时候，如果驱动表和被驱动表的字符集不同，比如驱动表是utf8mb4，被驱动表是utf8，那么被驱动表的索引字段<strong>在查询的时候会被执行函数，这个函数隐式地将utf8向上转型为更大的字符集utf8mb4</strong>；如果反过来，即被驱动表的字符集比较大，则不会出现隐式地执行函数这一问题。</p>
<p>与前面两种情况相同，<strong>被驱动表的索引字段被执行了函数，优化器默认不走索引的树搜索</strong>。</p>
<p>优化的方式有二：</p>
<p>其一是将被驱动表的字符集直接转换为utf8mb4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null;</span><br></pre></td></tr></table></figure>

<p>但是数据量比较大或者业务不允许的话，可以主动地将驱动表的字符集下调至utf8，从而避免被驱动表在被隐式执行函数的操作，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2; </span><br></pre></td></tr></table></figure>

<h3 id="4-思考题补充情况"><a href="#4-思考题补充情况" class="headerlink" title="4.思考题补充情况"></a>4.思考题补充情况</h3><p>一个可变的字符串在定义的时候，长度只有10，即b varchar(10)：</p>
<p>如果执行如下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from table_a where b=&#x27;1234567890abcd&#x27;;</span><br></pre></td></tr></table></figure>

<p>按理说，表中肯定没有这个字段，返回null就行了，但是<strong>MySQL实际上对上述结果进行了截断</strong>，截断成长度为10的字符串，所以交给引擎层的数据实际是’1234567890’，假如满足这个查询条件的数据有数万行，那么<strong>一共需要做数万次回表操作</strong>，每次回表查出的整行数据<strong>再给server层判断</strong>，判断其是否与’1234567890abcd’相等，最后查询不到该数据就返回空值。</p>
<h2 id="19讲-为什么我只查一行的语句，也执行这么慢？"><a href="#19讲-为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="19讲 | 为什么我只查一行的语句，也执行这么慢？"></a>19讲 | 为什么我只查一行的语句，也执行这么慢？</h2><h3 id="1-第一类：查询长时间不返回"><a href="#1-第一类：查询长时间不返回" class="headerlink" title="1.第一类：查询长时间不返回"></a>1.第一类：查询长时间不返回</h3><p>有如下代码，查询结果长时间不返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1;</span><br></pre></td></tr></table></figure>

<p>可能的原因有如下几种：</p>
<h4 id="1-等MDL（metadata-lock）锁"><a href="#1-等MDL（metadata-lock）锁" class="headerlink" title="1.等MDL（metadata lock）锁"></a>1.等MDL（metadata lock）锁</h4><p>这种原因可以通过执行show processlist命令来查看Waiting for table metadata lock</p>
<img src="https://static001.geekbang.org/resource/image/50/28/5008d7e9e22be88a9c80916df4f4b328.png" alt="img" style="zoom: 50%;" />

<p>出现这种状态就表示：现在有一个线程<strong>正在表t上请求或者持有MDL写锁</strong>，把select语句堵住了。</p>
<p>复现如下：</p>
<img src="https://static001.geekbang.org/resource/image/74/ca/742249a31b83f4858c51bfe106a5daca.png" alt="img" style="zoom:50%;" />

<p>处理方式是：<strong>找到谁持有MDL写锁，把它kill掉</strong>。</p>
<p>但是上面图片中，这个线程对应的Command是Sleep，导致查找不便。我们可以在MySQL启动时设置performance_schema&#x3D;on，然后通过下面的命令找到该线程（然后kill它）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select blocking_pid from sys.schema_table_lock_waits;</span><br></pre></td></tr></table></figure>

<h4 id="2-等flush（刷盘）"><a href="#2-等flush（刷盘）" class="headerlink" title="2.等flush（刷盘）"></a>2.等flush（刷盘）</h4><p>这种堵塞，我们在执行show processlist命令时，可以看到Waiting for table flush</p>
<img src="https://static001.geekbang.org/resource/image/2d/24/2d8250398bc7f8f7dce8b6b1923c3724.png" alt="img" style="zoom:50%;" />

<p>出现这种状态就表示：<strong>现在有一个线程正在对表t做flush操作</strong>。</p>
<p>但是实际上，这个操作非常快，所以真正的原因应该是flush操作被其他线程堵住了，进而flush堵住了我们的select操作。</p>
<p>复现如下：</p>
<img src="https://static001.geekbang.org/resource/image/2b/9c/2bbc77cfdb118b0d9ef3fdd679d0a69c.png" alt="img" style="zoom:50%;" />

<h4 id="3-等行锁"><a href="#3-等行锁" class="headerlink" title="3.等行锁"></a>3.等行锁</h4><p>前面两个情况都是表级锁导致的阻塞，<strong>select语句并没有进入引擎中</strong>。</p>
<p>而等行锁的情况，用下面这种复现就一目了然了：</p>
<img src="https://static001.geekbang.org/resource/image/3e/75/3e68326b967701c59770612183277475.png" alt="img" style="zoom:50%;" />

<p>事务A并没有提交，所以事务A在id&#x3D;1上拥有持有写锁，而当前事务B执行的是当前读（lock in share mode是共享锁，for update是排他锁），所以事务B访问id&#x3D;1要加读锁，那么事务A占有的写锁自然会堵住事务B。</p>
<p>与MDL写锁的查询方式一样，可以通过 sys.innodb_lock_waits 表查到元凶。</p>
<img src="https://static001.geekbang.org/resource/image/d8/18/d8603aeb4eaad3326699c13c46379118.png" alt="img" style="zoom: 50%;" />

<p>但需要注意的是，这个表同时提到了KILL QUERY 4和KILL 4，实际上<strong>前者是停止4号线程当前正在执行的语句</strong>，这其实<strong>没用</strong>，因为update早已执行完，停止语句并不能让id&#x3D;1上的行锁去掉；只有执行KILL 4，即<strong>断开这个事务的连接，这时该线程会自动回滚</strong>，进而<strong>释放了id&#x3D;1上的行锁</strong>。</p>
<h3 id="2-第二类：查询慢"><a href="#2-第二类：查询慢" class="headerlink" title="2.第二类：查询慢"></a>2.第二类：查询慢</h3><p>来看看这个例子：</p>
<p>执行下面语句，但执行时间要800ms：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1;</span><br></pre></td></tr></table></figure>

<p>但给这个查询加共享锁（当前读），则只需要0.2ms：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1 lock in share mode;</span><br></pre></td></tr></table></figure>

<p>按理说，加锁比不加锁还多一个步骤，应该更慢才对，实际上看下面的复现就懂了：</p>
<img src="https://static001.geekbang.org/resource/image/84/ff/84667a3449dc846e393142600ee7a2ff.png" alt="img" style="zoom:50%;" />

<p>当前隔离级别是innoDB默认的repeatable read，所以不加行锁的查询语句执行的<strong>是一致读</strong>，需要<strong>将执行100万次的更新回滚至更新之前</strong>；而加共享锁的查询语句执行的<strong>是当前读</strong>，<strong>不需要回滚操作</strong>，直接返回当前快照的结果，步骤如下：</p>
<img src="https://static001.geekbang.org/resource/image/46/8c/46bb9f5e27854678bfcaeaf0c3b8a98c.png" alt="img" style="zoom: 33%;" />

<h2 id="第20讲-幻读是什么，幻读有什么问题？"><a href="#第20讲-幻读是什么，幻读有什么问题？" class="headerlink" title="第20讲 | 幻读是什么，幻读有什么问题？"></a>第20讲 | 幻读是什么，幻读有什么问题？</h2><p>这篇文章难度较大，作者通过假设与反证法证明了间隙锁存在的意义。</p>
<p>首先我们给出一个例子，在例子的基础上理解这节课的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure>

<p>可以看出，这个表有两个索引，一个是主键索引，另一个是普通索引c。</p>
<h3 id="1-所查询字段没有索引（走主键索引）"><a href="#1-所查询字段没有索引（走主键索引）" class="headerlink" title="1.所查询字段没有索引（走主键索引）"></a>1.所查询字段没有索引（走主键索引）</h3><p>下面我们执行如下语句，<strong>是怎么加锁的，这些锁是什么时候释放的呢</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where d=5 for update;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>结果是：因为数据d没有建立索引，所以在查询过程中<strong>需要走全表索引</strong>，也就是主键id的索引，这个时候<strong>不会锁单独的某行，而是对全表上锁</strong>，即上表锁。如果在该事务提交前，有其他事物进行CRUD操作，都会被表锁阻塞，即发生上一讲的“等MDL锁”现象。</p>
<h3 id="2-所查询字段有普通索引（走普通索引）"><a href="#2-所查询字段有普通索引（走普通索引）" class="headerlink" title="2.所查询字段有普通索引（走普通索引）"></a>2.所查询字段有普通索引（走普通索引）</h3><p>如果执行如下语句，<strong>又是怎么加锁的，这些锁是什么时候释放的呢</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where c=5 for update;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>注意这里c有索引，所以该查询语句走普通索引，这个时候会对c&#x3D;5上行锁，同时在(0,5)以及(5,10)上间隙锁。</p>
<p>表t的普通索引c和主键索引的行锁和间隙锁如下图所示（注意这里的数值之所以一样，是因为插入的时候id和c的值是一样的，比如(0,0,0),(5,5,5)等）：</p>
<img src="https://static001.geekbang.org/resource/image/e7/61/e7f7ca0d3dab2f48c588d714ee3ac861.png" alt="img" style="zoom: 50%;" />

<p>按照B+树搜索规则，找到满足c&#x3D;5的位置，然后对c&#x3D;5上行锁，同时在(0,5)与(5,10)这两个区间上间隙锁，这还没完，我们<strong>还要找到第一个不满足c&#x3D;5的位置才可以结束</strong>，显然该行为c&#x3D;10，所以c&#x3D;10这一行也被上了行锁，所以整个c的索引上，在区间(0,5] &amp;&amp; (5,10]也就是(0,10]上了锁，然后因为c&#x3D;10不满足条件，c&#x3D;10的行锁会去掉（下一章会讲到），所以<strong>最后为两个间隙锁(0,5), (5,10)和一个c&#x3D;5的行锁</strong>。此时如果在该事物提交之前有其他事物在这个区间执行CRUD操作会被阻塞，<strong>这种阻塞是行锁性质的阻塞</strong>。</p>
<h3 id="3-间隙锁的引入对并发度的影响"><a href="#3-间隙锁的引入对并发度的影响" class="headerlink" title="3.间隙锁的引入对并发度的影响"></a>3.间隙锁的引入对并发度的影响</h3><p>有如下操作：</p>
<img src="https://static001.geekbang.org/resource/image/df/be/df37bf0bb9f85ea59f0540e24eb6bcbe.png" alt="img" style="zoom:50%;" />

<p>首先A事物执行查询语句，此时因为表t中没有id&#x3D;9的行，所以会在(5,10)区间上间隙锁，下一时刻B同样执行查询语句，我们知道，<strong>如果查的不是不存在的id&#x3D;9而是id&#x3D;5</strong>，那么<strong>A事物拥有id&#x3D;5的写锁，会阻塞B事物访问id&#x3D;5</strong>。但是现在A事物查询的是不存在的id&#x3D;9，上的是区间的间隙锁，那么此时B事物的查询语句不会被该间隙锁阻塞，同样也会对(5,10)区间上间隙锁。这也就说明：<strong>间隙锁之间不会像读写锁一样发生冲突</strong>。所以B在执行下一条插入语句时，会被A事物的间隙锁阻塞，同样A执行插入语句也会被B事物的间隙锁阻塞，进而产生了死锁现象。</p>
<h2 id="第21讲-为什么我只改一行的语句，锁这么多？"><a href="#第21讲-为什么我只改一行的语句，锁这么多？" class="headerlink" title="第21讲 | 为什么我只改一行的语句，锁这么多？"></a>第21讲 | 为什么我只改一行的语句，锁这么多？</h2><h3 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h3><p>本集作者根据MySQL源码总结出了两个原则，两个优化和一个bug</p>
<p>1.原则1：加锁的基本单位是next-key lock，这其实是<strong>先加间隙锁再加行锁的产物</strong>，所以区间为前开后闭。</p>
<p>2.原则2：查找过程中访问到的对象才会加锁，<strong>没有访问到不会加锁</strong>。</p>
<p>3.优化1：索引上的<strong>等值查询</strong>，给<strong>唯一索引</strong>加锁的时候，next-key lock<strong>退化为行锁</strong>。</p>
<p>4.优化2：索引上的<strong>等值查询</strong>，直到最后向右遍历到不满足等值条件时，next-key lock退化为间隙锁。</p>
<p>5.一个bug：<strong>唯一索引</strong>的<strong>范围查询</strong>，也会访问到最后一个不满足条件的值。</p>
<p>首先拿出上节课的表数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure>

<p>可以看出，这个表有两个索引，一个是主键索引，另一个是普通索引c。</p>
<h3 id="案例一：等值查询间隙锁"><a href="#案例一：等值查询间隙锁" class="headerlink" title="案例一：等值查询间隙锁"></a>案例一：等值查询间隙锁</h3><img src="https://static001.geekbang.org/resource/image/58/6c/585dfa8d0dd71171a6fa16bed4ba816c.png" alt="img" style="zoom:50%;" />

<p>这个案例其实和上一讲的select * from t where c &#x3D; 5差不多。</p>
<p>因为是等值查询，根据原则1，先上锁(5,10]。然后根据优化2，等值查询，c&#x3D;10不满足条件，(5,10]退化为间隙锁(5,10)。</p>
<h3 id="☆案例二：非唯一索引等值锁（覆盖索引）"><a href="#☆案例二：非唯一索引等值锁（覆盖索引）" class="headerlink" title="☆案例二：非唯一索引等值锁（覆盖索引）"></a>☆案例二：非唯一索引等值锁（覆盖索引）</h3><img src="https://static001.geekbang.org/resource/image/46/65/465990fe8f6b418ca3f9992bd1bb5465.png" alt="img" style="zoom: 33%;" />

<p>首先根据原则1，先上锁(0,5]，<strong>如果c是唯一索引，那么我们就可以停止了，而且会退化为行锁c&#x3D;5</strong>，但是这里c是非唯一索引，所以还会向右遍历到第一个不满足条件的c&#x3D;10。<strong>根据原则2，c&#x3D;10被访问到了</strong>，所以继续给(5,10]上锁。然后根据优化2，c&#x3D;10不满足条件，所以退化为间隙锁(5,10)。</p>
<p>所以最终的锁为(0,5)和(5,10)的间隙锁还有c&#x3D;5的行锁。从中我们可以看出C事物必然被锁，那为什么B事物没有被锁呢，因为这个例子用的是<strong>共享锁，只锁覆盖索引</strong>，如果用<strong>排他锁</strong>(for update)，系统会默认你要更新数据，就会顺便<strong>把主键索引满足条件的行上行锁</strong>。</p>
<p>如果我们<strong>要查询的字段在覆盖索引中找不到，那么系统就会走主键索引</strong>，那么自然就会把主键索引中满足条件的行上行锁了。比如将A事物改为select d from t where c&#x3D;5 lock in share mode;</p>
<h3 id="案例三：主键索引的范围锁（唯一索引）"><a href="#案例三：主键索引的范围锁（唯一索引）" class="headerlink" title="案例三：主键索引的范围锁（唯一索引）"></a>案例三：主键索引的范围锁（唯一索引）</h3><img src="https://static001.geekbang.org/resource/image/30/80/30b839bf941f109b04f1a36c302aea80.png" alt="img" style="zoom: 33%;" />

<p>首先根据原则1，找到id&#x3D;10，next-key lock为(5,10]，根据优化1（<strong>这里id&#x3D;10按等值索引规则走</strong>），唯一索引的锁退化为行锁，即c&#x3D;10。因为是范围查询，我们还需要继续向后找到不满足的第一个条件，即c&#x3D;15，这个时候根据原则1，next-key lock为(10,15]，<strong>但是这里一定要注意，范围查询没有优化，只有所谓的bug，所以范围查询不会退化间隙锁</strong>。</p>
<p>所以最后有两个行锁c&#x3D;10和c&#x3D;15，还有间隙锁(5,10)。（根据评论，已经有版本修复了这个”bug”，即没有c&#x3D;15这个没必要的行锁了）</p>
<h3 id="案例四：非唯一索引范围锁"><a href="#案例四：非唯一索引范围锁" class="headerlink" title="案例四：非唯一索引范围锁"></a>案例四：非唯一索引范围锁</h3><img src="https://static001.geekbang.org/resource/image/73/7a/7381475e9e951628c9fc907f5a57697a.png" alt="img" style="zoom:33%;" />

<p>与案例三不同的是，这个索引是普通索引c。</p>
<p>首先根据原则1，找到c&#x3D;10的行，对(5,10]上锁。然后范围查询，找到第一个不满足条件的c&#x3D;15，对(10,15]上锁，<strong>同样因为范围查询没有优化，所以(10,15]不会退化为间隙锁</strong>。</p>
<p>所以最后为两个next-key lock，分别是(5,10]和(10,15]。（也可以说是两个间隙锁加两个行锁）</p>
<h3 id="案例五：唯一索引范围锁bug"><a href="#案例五：唯一索引范围锁bug" class="headerlink" title="案例五：唯一索引范围锁bug"></a>案例五：唯一索引范围锁bug</h3><img src="https://static001.geekbang.org/resource/image/b1/6d/b105f8c4633e8d3a84e6422b1b1a316d.png" alt="img" style="zoom:33%;" />

<p>这里要看清楚，是id&gt;10不是id&#x3D;10，所以没有案例三中的id&#x3D;10这个等值查询了（案例三id &gt;&#x3D; 10是等值查询），所以<strong>直接走范围查询找到id&#x3D;15</strong>，根据原则1，对(10,15]上next-key lock锁，这里因为是<strong>范围查询，没有优化</strong>，不会发生退化。按理说找到id &#x3D; 15就可以停止了，<strong>但是MySQL必须找到第一个不满足条件的数据才能停止</strong>，所以会继续找到id&#x3D;20，然后根据原则1，对(15,20]上next-key lock锁，这也就证明为什么事物B和事物C被锁上了。（后面的版本已经修复，貌似是8.0.18）</p>
<p>所以最终有两个next-key lock锁，分别是(10,15]和(15,20]。</p>
<h3 id="案例六：非唯一索引存在“等值”的例子"><a href="#案例六：非唯一索引存在“等值”的例子" class="headerlink" title="案例六：非唯一索引存在“等值”的例子"></a>案例六：非唯一索引存在“等值”的例子</h3><p>对本来就含有c&#x3D;10的索引中，再插入一个c&#x3D;10，会发生什么呢，执行语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t values(30,10,30);</span><br></pre></td></tr></table></figure>

<p>其实我们会发现索引c中c&#x3D;10会有两个数据，分别是(c&#x3D;10,id&#x3D;10)和(c&#x3D;10,id&#x3D;30)，如下图所示：</p>
<img src="https://static001.geekbang.org/resource/image/c1/59/c1fda36c1502606eb5be3908011ba159.png" alt="img" style="zoom: 33%;" />

<p>自然我们就可以发现，c&#x3D;10自身一会产生间隙的。</p>
<img src="https://static001.geekbang.org/resource/image/b5/78/b55fb0a1cac3500b60e1cf9779d2da78.png" alt="img" style="zoom:33%;" />

<p>首先声明：delete语句和select…for update语句加锁的逻辑类似，所以上面的枷锁规则依旧适用。</p>
<p>根据原则1，首先找到(c&#x3D;10,id&#x3D;10)而不是(c&#x3D;10,id&#x3D;30)，所以这里的next-key lock为(c&#x3D;5,id&#x3D;5)到(c&#x3D;5,id&#x3D;10)的左开右闭区间，然后直到找到不满足条件的行(c&#x3D;15,id&#x3D;15)，继续根据原则1，next-key lock为(c&#x3D;10,id&#x3D;10)到(c&#x3D;15,id&#x3D;15)的左开右闭区间，根据优化2，退化为间隙锁，即(c&#x3D;10,id&#x3D;10)到(c&#x3D;15,id&#x3D;15)的左开右开区间。</p>
<p>所以最终的区间是图中的开区间：</p>
<img src="https://static001.geekbang.org/resource/image/bb/24/bb0ad92483d71f0dcaeeef278f89cb24.png" alt="img" style="zoom:33%;" />

<h3 id="案例七：limit语句加锁"><a href="#案例七：limit语句加锁" class="headerlink" title="案例七：limit语句加锁"></a>案例七：limit语句加锁</h3><img src="https://static001.geekbang.org/resource/image/af/2e/afc3a08ae7a254b3251e41b2a6dae02e.png" alt="img" style="zoom: 50%;" />

<p>这次加了个limit，发现B事物通过了。其实这是因为索引遍历到(c&#x3D;10,id&#x3D;30)的时候，limit 2条件已经满足了，所以不会向后走了。</p>
<p>所以加锁范围如下所示(左开右闭)：</p>
<img src="https://static001.geekbang.org/resource/image/e5/d5/e5408ed94b3d44985073255db63bd0d5.png" alt="img" style="zoom: 33%;" />

<h3 id="案例八：一个死锁的例子"><a href="#案例八：一个死锁的例子" class="headerlink" title="案例八：一个死锁的例子"></a>案例八：一个死锁的例子</h3><img src="https://static001.geekbang.org/resource/image/7b/06/7b911a4c995706e8aa2dd96ff0f36506.png" alt="img" style="zoom: 33%;" />

<p>首先c&#x3D;10，我们可以根据案例1确定了上锁区间为(5,15)。然后事物B按道理被事物A锁住了，但是我们发现事物A在插入c&#x3D;8的操作时竟然被阻塞了，其实原因就是<strong>事物B上了间隙锁(5,10)，而行锁c&#x3D;10进入锁等待</strong>，所以在A执行插入操作的时候发生了死锁现象，InnoDB让事物B回滚，插入最终才成功。</p>
<p>这个案例证明了next-key lock其实是分步执行的，先上间隙锁，再上行锁。间隙锁之间无互斥现象，而行锁之间会互斥。</p>
<h2 id="第22讲-MySQL有哪些“饮鸩止渴”提高性能的方法？"><a href="#第22讲-MySQL有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="第22讲 | MySQL有哪些“饮鸩止渴”提高性能的方法？"></a>第22讲 | MySQL有哪些“饮鸩止渴”提高性能的方法？</h2><h3 id="1-短连接风暴"><a href="#1-短连接风暴" class="headerlink" title="1.短连接风暴"></a>1.短连接风暴</h3><p>业务高峰，MySQL会存在很多连接，连接数量过多会导致数据库压力较大，处理方法有以下几种：</p>
<p>1.调高max_connections，增加可容纳的连接数（风险很大）</p>
<p>2.先处理掉<strong>占着连接但长时间不工作（事务外空闲太久）</strong>的线程，如果还不够，再考虑断开<strong>事务内空闲太久</strong>的线程</p>
<p>3.减少连接过程的消耗（跳过权限验证），有极大的安全隐患。</p>
<h3 id="2-慢查询性能问题"><a href="#2-慢查询性能问题" class="headerlink" title="2.慢查询性能问题"></a>2.慢查询性能问题</h3><p>在 MySQL 中，会引发性能问题的慢查询，大体有以下三种可能：</p>
<p>1.索引没有设计好；</p>
<p>2.SQL 语句没写好；</p>
<p>3.MySQL 选错了索引。</p>
<h4 id="1-索引设计问题"><a href="#1-索引设计问题" class="headerlink" title="1.索引设计问题"></a>1.索引设计问题</h4><p>对于索引没有设计好，我们可以直接执行alter table语句来创建新的索引。具体方式是：</p>
<p>1.备库B执行set sql_log_bin&#x3D;off，即关掉binlog，然后执行alter table加上索引；</p>
<p>2.主备库切换；</p>
<p>3.目前备库是A，对A执行上面的1操作。</p>
<h4 id="2-SQL语句问题"><a href="#2-SQL语句问题" class="headerlink" title="2.SQL语句问题"></a>2.SQL语句问题</h4><p>使用query_rewrite语句对原SQL语句执行“查询重写”。</p>
<h4 id="3-MySQL选错索引问题"><a href="#3-MySQL选错索引问题" class="headerlink" title="3.MySQL选错索引问题"></a>3.MySQL选错索引问题</h4><p>同样使用查询重写，给原来的语句加上force index。</p>
<p>上述问题可以在一开始业务上线前避免，具体操作就是测试环境，进行预演。这里细节看原文，<strong>面试不考，工作要用</strong>。</p>
<h3 id="3-QPS突增问题"><a href="#3-QPS突增问题" class="headerlink" title="3.QPS突增问题"></a>3.QPS突增问题</h3><p>QPS是每秒查询率的意思，通常出现QPS高峰是新功能bug，解决QPS突增<strong>具体要看业务是否可以下掉这个新功能</strong>，具体也去看原文，原文写的很简洁明了。</p>
<h2 id="第23讲-MySQL是怎么保证数据不丢的？"><a href="#第23讲-MySQL是怎么保证数据不丢的？" class="headerlink" title="第23讲 | MySQL是怎么保证数据不丢的？"></a>第23讲 | MySQL是怎么保证数据不丢的？</h2><h3 id="1-binlog的写入机制"><a href="#1-binlog的写入机制" class="headerlink" title="1.binlog的写入机制"></a>1.binlog的写入机制</h3><img src="https://static001.geekbang.org/resource/image/9e/3e/9ed86644d5f39efb0efec595abb92e3e.png" alt="img" style="zoom: 50%;" />

<p>直接上图，我们可以清楚的看到，一个事务执行的时候：</p>
<p>1.先把日志写入binlog cache里（<strong>每个线程或事务独占一个binlog cache</strong>）；</p>
<p>2.事务提交时，执行器把binlog cache里的日志写入binlog中，并清空binlog cache（<strong>所有线程共用一个binlog</strong>）</p>
<p>​			(1).执行write，把日志写入文件系统的page cache中（这里<strong>操作系统分配的内存</strong>）</p>
<p>​			(2).执行fsync，将日志持久化到磁盘中</p>
<p>可以看到，写入binlog，分为write和fsync两个操作，<strong>只有fsync才发生IO</strong></p>
<p>两个操作的时机由sync_binlog参数控制：</p>
<p>1.参数为0，每次提交事务只write不fsync</p>
<p>2.参数为1，每次提交事务都fsync</p>
<p>3.参数为N（N&gt;1），每次提交事务都write，但累计N个事务才fsync</p>
<p>N设置比较可以<strong>缓解IO瓶颈</strong>问题，但是<strong>主机异常重启，或断电</strong>啥的，就会<strong>丢失最近N个事务的binlog日志</strong>。</p>
<h3 id="2-redo-log写入机制"><a href="#2-redo-log写入机制" class="headerlink" title="2.redo log写入机制"></a>2.redo log写入机制</h3><img src="https://static001.geekbang.org/resource/image/9d/d4/9d057f61d3962407f413deebc80526d4.png" alt="img" style="zoom: 67%;" />

<p>也是直接上图，我们会发现redo log与binlog最大的不同就是“图小了”，小哪了？所有线程（事务）共用一个redo log buffer。这就说明：<strong>一个事务提交并写道page cache或持久化到磁盘中</strong>（写入到黄色或者绿色区域），<strong>会把当前buffer里所有其他未提交事务全“带走”</strong>。</p>
<p>同样redo log的写入也由一个参数控制，就是InnoDB提供的innodb_flush_log_at-trx_commit：</p>
<p>1.参数为0，每次事务提交只把redo log留在redo log buffer中（<strong>留在缓冲区</strong>）</p>
<p>2.参数为1，每次事务提交都将redo log直接持久化(<strong>fsync</strong>)到磁盘（<strong>执行IO</strong>）</p>
<p>3.参数为2，每次事务提交都只把redo log写(<strong>write</strong>)到page cache（<strong>操作系统分配的内存</strong>）</p>
<h4 id="1-未提交事务的redo-log写盘的三种可能情况："><a href="#1-未提交事务的redo-log写盘的三种可能情况：" class="headerlink" title="1).未提交事务的redo log写盘的三种可能情况："></a>1).未提交事务的redo log写盘的三种可能情况：</h4><p>写入page cache或磁盘，统称为写盘</p>
<p>1.InnoDB有一个<strong>后台线程</strong>，<strong>每隔一秒</strong>，就会<strong>把buffer中日志write到page cache里</strong>，然后<strong>fsync到磁盘里</strong>。</p>
<p>2.redo log buffer<strong>占用空间即将达到innodb_log_buffer_size的一半时</strong>，后台线程主动写盘，因为事务还没提交，所以<strong>只write不fsync</strong>。</p>
<p>3.最后就是最开始提到的，<strong>一个并行事务的提交</strong>，会顺带把buffer里的内容全“带走”。</p>
<h4 id="2-MySQL的双“1”配置保证数据一致性（crash-safe）："><a href="#2-MySQL的双“1”配置保证数据一致性（crash-safe）：" class="headerlink" title="2).MySQL的双“1”配置保证数据一致性（crash-safe）："></a>2).MySQL的双“1”配置保证数据一致性（crash-safe）：</h4><p>双“1”就是把sync_binlog和innodb_flush_log_at-trx_commit都设置为1，那么<strong>redo log在prepare的时候就已经持久化到磁盘了</strong>，所以会分为以下四种情况：</p>
<p>​		情况1：redo log prepare阶段fsync失败</p>
<p>​		情况2：binlog的fsync失败</p>
<p>​		情况3：redo log commit失败</p>
<p>​		情况4：俩都成功</p>
<p>​				情况1，redo log和binlog均检查出未写入磁盘，事务回滚，内存数据丢失，不影响数据一致性；</p>
<p>​				情况2，redo log在prepare阶段持久化磁盘成功，但binlog持久化失败，那么MySQL如果异常重启，发现只有redo log没有binlog，而且redo log还未commit，事务回滚；（<!--这里有个疑问-->，redo log已经持久化到磁盘了，还能回滚吗？）</p>
<p>​				情况3，俩都持久化了，直接提交，数据一致；</p>
<p>​				情况4，俩都持久化了，并且事务commit了，数据一致。</p>
<p>最后作者讲到了<strong>组提交</strong>，一句话，MySQL尽可能拖时间，为的就是<strong>组员尽可能地多，进而减少磁盘IO</strong>。</p>
<h2 id="第24讲-MySQL是怎么保证主备一致的？"><a href="#第24讲-MySQL是怎么保证主备一致的？" class="headerlink" title="第24讲 | MySQL是怎么保证主备一致的？"></a>第24讲 | MySQL是怎么保证主备一致的？</h2><p>本讲主要讲了一下之前答疑的时候binlog的三种格式：statement, row, mixed</p>
<h3 id="1-MySQL主备的基本原理（M-S结构）："><a href="#1-MySQL主备的基本原理（M-S结构）：" class="headerlink" title="1.MySQL主备的基本原理（M-S结构）："></a>1.MySQL主备的基本原理（M-S结构）：</h3><img src="https://static001.geekbang.org/resource/image/fd/10/fd75a2b37ae6ca709b7f16fe060c2c10.png" alt="img" style="zoom: 33%;" />

<p>状态1：<strong>客户端读写都访问节点A</strong>，此时B是A的备库，<strong>B只是将A的更新同步过来</strong>；</p>
<p>当需要<strong>主备切换</strong>的时候，就切换成状态2，仍然与上面状态1的流程一样。</p>
<p>这时我们最好将备库设置为<strong>只读(readonly)模式</strong>，主要考虑了以下三点：</p>
<p>​		1.<strong>运营类的查询语句会被放到备库查询</strong>，备库只读可以防止误操作；</p>
<p>​		2.防止切换的一瞬间出现<strong>双写问题</strong>；</p>
<p>​		3.用只读状态<strong>判断主备库（节点）的身份</strong>。</p>
<p>以下是节点A同步到节点B的内部流程图：</p>
<img src="https://static001.geekbang.org/resource/image/a6/a3/a66c154c1bc51e071dd2cc8c1d6ca6a3.png" alt="img" style="zoom: 50%;" />

<p>主库A的第一行就是<strong>接收到客户端的请求后</strong>，执行内部事务的逻辑，<strong>同时写binlog</strong>；</p>
<p>备库B和主库A之间一直<strong>维持着一个长连接</strong>，主库A内有一个线程专门服务这个长连接，主备库的事务日志同步流程如下：</p>
<p>​		1.<strong>备库B设置A的各种参数</strong>，包含了A的IP，端口，用户名密码，从哪个位置（文件名和日志偏移量）开始请求binlog。</p>
<p>​		2.备库B启动两个线程：io_thread和sql_thread，<strong>前者负责与主库建立连接</strong>。</p>
<p>​		3.主库A校验用户名密码后，开始按照B要求的位置，<strong>从本地（page cache或磁盘）取</strong>binlog发给B；</p>
<p>​		4.B拿到binlog，写到本地文件，称为<strong>中转文件(relay log)</strong></p>
<p>​		5.sql_thread线程读取这个中转日志，<strong>解析命令并执行</strong>。</p>
<h3 id="2-binlog的三种格式对比："><a href="#2-binlog的三种格式对比：" class="headerlink" title="2.binlog的三种格式对比："></a>2.binlog的三种格式对比：</h3><p>binlog一共有三种格式，分别为statement, row, mixed，第三种就是前两种的混合格式。</p>
<h4 id="1-binlog-format-x3D-statement"><a href="#1-binlog-format-x3D-statement" class="headerlink" title="1)binlog_format&#x3D;statement"></a>1)binlog_format&#x3D;statement</h4><p>如果binlog设置为statement，那么binlog记录的就是SQL语句的原文，比如下面这条SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from t /*comment*/  where a&gt;=4 and t_modified&lt;=&#x27;2018-11-10&#x27; limit 1;</span><br></pre></td></tr></table></figure>

<p>那么binlog记录的内容如下：</p>
<img src="https://static001.geekbang.org/resource/image/b9/31/b9818f73cd7d38a96ddcb75350b52931.png" alt="img"  />

<p>但实际上这条语句在执行的时候是会报警的：</p>
<img src="https://static001.geekbang.org/resource/image/96/2b/96c2be9c0fcbff66883118526b26652b.png" alt="img"  />

<p>原因是该语句<strong>用了limit</strong>，主备库可能会<strong>走不同的索引</strong>。所以MySQL这样写有风险。</p>
<h4 id="2-binlog-format-x3D-row"><a href="#2-binlog-format-x3D-row" class="headerlink" title="2)binlog_format&#x3D;row"></a>2)binlog_format&#x3D;row</h4><p>如果binlog设置为row格式，那么binlog内容如下：</p>
<img src="https://static001.geekbang.org/resource/image/d6/26/d67a38db154afff610ae3bb64e266826.png" alt="img"  />

<p>这一次SQL原文变成了Table_map和Delete_rows：</p>
<p>​		Table_map用于说明<strong>接下来操作的表是谁</strong></p>
<p>​		Delete_rows用于<strong>定义删除的行为</strong></p>
<p>实际上设置为row格式，binlog里面记录了真实删除行的主键id，也就是具体删除的参数，这就避免了主从库走不同索引导致的主从不一致的隐患。</p>
<h4 id="3-binlog-format-x3D-mixed"><a href="#3-binlog-format-x3D-mixed" class="headerlink" title="3)binlog_format&#x3D;mixed"></a>3)binlog_format&#x3D;mixed</h4><p>mixed格式就是statement和row格式的混合，MySQL会<strong>根据SQL语句是否可能引起主从不一致</strong>而选择row或者statement。这看起来很好，但其实row还有一大优势就是<strong>恢复数据</strong>！</p>
<p>设置成row，delete语句回滚可以直接被转成insert，反之亦然。而update语句回滚只需要对调更新前后的两个数据即可。</p>
<p>以上的操作，statement都不行，所以row格式主键称为主流。</p>
<h3 id="3-双M结构"><a href="#3-双M结构" class="headerlink" title="3.双M结构"></a>3.双M结构</h3><img src="https://static001.geekbang.org/resource/image/20/56/20ad4e163115198dc6cf372d5116c956.png" alt="img" style="zoom: 33%;" />

<p>以上为<strong>双M结构</strong>，也是<strong>实际生产中使用较多</strong>的结构。这种结构其实就是<strong>AB互为主备库</strong>的方式，这样在切换的时候就<strong>不用修改主备关系</strong>了。（注意：主备库<strong>同时只能有一个库接受更新</strong>）</p>
<p>具体流程就是：</p>
<p>A更新了一条语句，把生成的binlog给B，B执行完这条语句也生成一个binlog，再给A。（这里建议log_slave_updates设置为on，表示<strong>备库执行relay log后生成binlog</strong>）</p>
<h4 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h4><p>这样会有循环复制binlog的问题，所以MySQL会给<strong>两个库设置不同的server id</strong>，所以A生成的binlog里记录的都是A的server id，而B生成的binlog的server id也是A的server id，这样再传回给A的时候，A发现这个binlog的server id是自己的，就不再处理这个日志了。</p>
<h2 id="第25讲-MySQL是怎么保证高可用的？"><a href="#第25讲-MySQL是怎么保证高可用的？" class="headerlink" title="第25讲 | MySQL是怎么保证高可用的？"></a>第25讲 | MySQL是怎么保证高可用的？</h2><p>这节就着上一节讲的主备切换，我们继续以双M为例，因为这个在生产中用的最多。</p>
<h3 id="1-主备延迟"><a href="#1-主备延迟" class="headerlink" title="1.主备延迟"></a>1.主备延迟</h3><p>主备切换<strong>一般发生在</strong>软件升级、主库所在机器按计划下线或者机器掉电了。</p>
<p>主备切换时<strong>数据同步的三个关键时间点</strong>：</p>
<p>​		1.主库A完成一个事务，<strong>写入binlog</strong>，这个时刻记为T1；</p>
<p>​		2.备库B<strong>接收完A库传来的binlog</strong>，记为T2；</p>
<p>​		3.备库B也<strong>执行完此事务</strong>，记为T3.</p>
<p><strong>主备延迟</strong>：备库执行完事务与主库执行完事务的时间差(***<!--这里有疑问-->***，为什么不是A写完binlog的时刻)，即T3-T1（网络正常下，T2-T1非常小）</p>
<p>这个时间差不会因为主备库机器的系统时间不一样而出现数据不准的现象，因为备库连接主库的时候<strong>会获得当前主库的系统时间</strong>，在后续做主备延迟的时间计算时，<strong>自动扣掉两系统时间的差值</strong>。</p>
<h4 id="主备延迟的来源"><a href="#主备延迟的来源" class="headerlink" title="主备延迟的来源"></a>主备延迟的来源</h4><h5 id="1-备库机器性能比主库的差"><a href="#1-备库机器性能比主库的差" class="headerlink" title="1.备库机器性能比主库的差"></a>1.备库机器性能比主库的差</h5><p>所以一般<strong>要求做对称部署</strong>，即主备库选用相同规格的机器。</p>
<h5 id="2-备库压力大"><a href="#2-备库压力大" class="headerlink" title="2.备库压力大"></a>2.备库压力大</h5><p>例如备库查询耗费大量CPU，严重影响数据同步速度，造成主备延迟。一般情况下，会采取以下两种方式：</p>
<p>​		1).<strong>一主多从</strong>。一个主库对应一个备库和多个从库。</p>
<p>​		2).<strong>binlog输出到外部系统</strong>，如Hadoop，让外部系统<strong>提供统计类查询</strong>的能力。</p>
<h5 id="3-大事务"><a href="#3-大事务" class="headerlink" title="3.大事务"></a>3.大事务</h5><p>因为<strong>主库必须等待事务执行完成才会写入binlog，再传给备库B</strong>。如果主库有个大事务需要长时间执行，那么主备切换的延迟自然就很大了。比如<strong>一次性delete太多数据</strong>或<strong>大表的DDL</strong>。</p>
<h5 id="4-备库并行复制（下一讲）"><a href="#4-备库并行复制（下一讲）" class="headerlink" title="4.备库并行复制（下一讲）"></a>4.备库并行复制（下一讲）</h5><h3 id="2-可靠性优先策略"><a href="#2-可靠性优先策略" class="headerlink" title="2.可靠性优先策略"></a>2.可靠性优先策略</h3><p><img src="D:\Picgo\img\image-20220424142142508.png" alt="image-20220424142142508"></p>
<p>图是双M结构，SBM指的是seconds_behind_master，也就是前面提到的T3-T1，以上的主备切换流程如下：</p>
<p>1.首先需要等到SBM小于某个值（这里是5s）才能进入下一步，否则持续等待</p>
<p>2.把主库A改为只读(readonly&#x3D;true)</p>
<p>3.判断备库B的SBM值是否为0，等到了0才能进入下一步</p>
<p>4.把备库B改为可读写状态(readonly&#x3D;false)</p>
<p>5.把业务请求切到备库B</p>
<p>可以看到在状态<strong>处于步骤2和3的时候，AB库都是只读的</strong>，说明这个时候两个库都不可写，所以SBM太长会严重影响业务，但是<strong>数据一致性</strong>得到了保障。</p>
<h3 id="3-可用性优先策略"><a href="#3-可用性优先策略" class="headerlink" title="3.可用性优先策略"></a>3.可用性优先策略</h3><p>该策略就是强行让上面的<strong>步骤4和5放到步骤1的前面</strong>。这个时候就会出现数据不一致的现象。</p>
<p>举例：</p>
<img src="https://static001.geekbang.org/resource/image/37/3a/3786bd6ad37faa34aca25bf1a1d8af3a.png" alt="img" style="zoom: 60%;" />

<p>表中只有id和c两个数据，插入c&#x3D;4的时候主库还是A，插入c&#x3D;5的时候主库突然变成B了，由于<strong>插入操作比relay log的解析要快</strong>，又因为插入一个c，主键<strong>id只需要自增</strong>即可，所以会插入一个错误的(4,5)，如果<strong>binlog_format&#x3D;mixed</strong>，那么此时A库会根据B传来的binlog增加一个(5,5)的数据，B库也会根据A库的binlog增加一个(5,4)的数据，此时出现了<strong>两行数据不一致</strong>的现象。</p>
<p>如果<strong>binlog_format&#x3D;row</strong>呢?</p>
<img src="https://static001.geekbang.org/resource/image/b8/43/b8d2229b2b40dd087fd3b111d1bdda43.png" alt="img" style="zoom:60%;" />

<p>由于row格式的binlog<strong>会记录新插入的行的所有字段值</strong>，所以只会在B突然切换成主库的时候，插入了一条(4,5)，而不会出现上面的binlog导致的不一致的情况，所以<strong>最终只会出现一行不一致的数据</strong>。</p>
<p>所以<strong>可用性优先策略会出现数据不一致的现象</strong>。</p>
<h3 id="4-结论"><a href="#4-结论" class="headerlink" title="4.结论"></a>4.结论</h3><p>最后结论：“在满足数据可靠性的前提下，MySQL 高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。”</p>
<h2 id="第26讲-备库为什么会延迟好几个小时？"><a href="#第26讲-备库为什么会延迟好几个小时？" class="headerlink" title="第26讲 | 备库为什么会延迟好几个小时？"></a>第26讲 | 备库为什么会延迟好几个小时？</h2><img src="https://static001.geekbang.org/resource/image/1a/ef/1a85a3bac30a32438bfd8862e5a34eef.png" alt="img" style="zoom: 40%;" />

<p>再贴上主备流程图，这次多了两个箭头，分别是<strong>客户端写入主库的粗箭头</strong>，和<strong>备库上sql_thread执行中转日志(relay log)的细箭头</strong>。箭头越粗，代表并发度越高。</p>
<p>主库上，影响客户端写入主库的并发度自然就是各种锁，除了<strong>某个单行的高并发极端状况</strong>，<strong>InnoDB行锁</strong>对业务的支持还是很友好的。</p>
<p>但是备库上的这个这个细箭头，虽然不粗，但是在<strong>官方MySQL5.6版本之前，是不支持多线程复制的</strong>。</p>
<p>因此<strong>主库并发度高的时候</strong>，传来的binlog单线程复制会带来<strong>严重的主备延迟现象</strong>。</p>
<h3 id="1-多线程模型"><a href="#1-多线程模型" class="headerlink" title="1.多线程模型"></a>1.多线程模型</h3><img src="https://static001.geekbang.org/resource/image/bc/45/bcf75aa3b0f496699fd7885426bc6245.png" alt="img" style="zoom:40%;" />

<p><strong>coordinator</strong>就是原来的sql_thread，现在它不再直接更新数据，而<strong>只负责读取中转日志和分发事务</strong>。</p>
<p>真正<strong>更新日志</strong>的工作，交给worker。</p>
<p>coordinator的基本要求：</p>
<p>​		1.不能造成更新覆盖：更新同一行的两个事务，必须被分发到同一个worker中</p>
<p>​		2.同一个事物不能被拆开，必须放到同一个worker中</p>
<h3 id="2-按表分发策略"><a href="#2-按表分发策略" class="headerlink" title="2.按表分发策略"></a>2.按表分发策略</h3><p>基本思路是：两个事务<strong>更新不同的表</strong>，就可以并行。这样可以<strong>保证两个worker不会更新同一行</strong>。</p>
<img src="https://static001.geekbang.org/resource/image/8b/76/8b6976fedd6e644022d4026581fb8d76.png" alt="img" style="zoom: 40%;" />

<p>每个worker对应一个hash表，用于保存所涉及的表，<strong>key是“库名.表名”，value是“队列中有多少个事务修改这个表”</strong>。</p>
<p>每个事务在分发的时候，<strong>跟所有worker的冲突关系</strong>包括以下三种情况：</p>
<p>​		1.如果和所有worker<strong>都不冲突</strong>，coordinator会把这个事务<strong>分配给最闲的</strong>worker</p>
<p>​		2.如果<strong>只和一个</strong>worker冲突，那就把事务<strong>分配给这个worker</strong></p>
<p>​		3.如果<strong>和多个</strong>worker冲突，coordinator<strong>进入等待状态</strong>，直到冲突的worker只剩下一个</p>
<p>多个表负载均衡的时候，按表分发的效果比较好，但是对于热点表，就变成单线程复制了。</p>
<h3 id="3-按行分发策略"><a href="#3-按行分发策略" class="headerlink" title="3.按行分发策略"></a>3.按行分发策略</h3><p>基本思路是，两个事务<strong>更新不同的行</strong>，就可以并行。这个模式必须要求binlog的格式是row，因为statement格式不能记录具体更新的某行。</p>
<p>这个时候key对应的就是“库名+表名+索引名字+值”（<strong>不能有外键</strong>）。这就表明<strong>按行分发会消耗更多的计算资源</strong>。</p>
<h3 id="4-MySQL-5-6版本的并行复制策略"><a href="#4-MySQL-5-6版本的并行复制策略" class="headerlink" title="4.MySQL 5.6版本的并行复制策略"></a>4.MySQL 5.6版本的并行复制策略</h3><p>该版本第一次支持并行复制，只不过支持的粒度是<strong>按库并行</strong>。碰到事务都在一个库里进行，就gg了，该策略用的不多。</p>
<h3 id="5-MariaDB的并行策略"><a href="#5-MariaDB的并行策略" class="headerlink" title="5.MariaDB的并行策略"></a>5.MariaDB的并行策略</h3><p>MariaDB的实现方式（采用了redo log组提交的特性）：</p>
<p>​		1.在一组里面一起提交的事务，有相同的commit_id，下一组就是commit_id+1;</p>
<p>​		2.commit_id直接写在binlog中</p>
<p>​		3.传到备库的时候，相同的commit_id的事务分发到多个worker执行</p>
<p>​		4.这一组全执行完，coordinator再去取下一批</p>
<p>其实就是<strong>模拟了主库的并行模式</strong>，但是并没有真正实现模拟主库，因为主库（追求效率）中，一组事务commit的同时，下一组已经在执行中了。而MariaDB则必须一组一组来，这样如果某一组有大事务，那么某一时间可能只有一个worker在工作，是严重浪费资源的。</p>
<h3 id="6-MySQL-5-7的并行复制策略（不太理解）"><a href="#6-MySQL-5-7的并行复制策略（不太理解）" class="headerlink" title="6.MySQL 5.7的并行复制策略（不太理解）"></a>6.MySQL 5.7的并行复制策略（不太理解）</h3><p>其实就是在MariaDB的基础上进行优化，利用前面章节学到的两阶段提交的特点，不用等到commit阶段，只要能够到达redo log prepare阶段，就表示事务已经通过锁冲突检验了。所以：</p>
<p>​		1.同时处于prepare的事务，在备库可以并行执行</p>
<p>​		2.处于prepare与commit之间的事务，在备库也可以并行执行。</p>
<p>所以延长prepare到commit之间的时间，制造更多“同时处于prepare的事务”，可以增加备库复制的并行度。</p>
<h3 id="7-MySQL-5-7-22的并行复制策略（不太理解）"><a href="#7-MySQL-5-7-22的并行复制策略（不太理解）" class="headerlink" title="7.MySQL 5.7.22的并行复制策略（不太理解）"></a>7.MySQL 5.7.22的并行复制策略（不太理解）</h3><h2 id="第27讲-主库出问题了，从库怎么办？"><a href="#第27讲-主库出问题了，从库怎么办？" class="headerlink" title="第27讲 | 主库出问题了，从库怎么办？"></a>第27讲 | 主库出问题了，从库怎么办？</h2><img src="https://static001.geekbang.org/resource/image/00/53/0014f97423bd75235a9187f492fb2453.png" alt="img" style="zoom:40%;" />

<p>如图，是一主多从结构发生主备切换的示意图。可以看出，在切换之前，所有从库都指向A，现在转向A’，必然需要A‘的“身份信息”。</p>
<h3 id="1-基于位点的主备切换"><a href="#1-基于位点的主备切换" class="headerlink" title="1.基于位点的主备切换"></a>1.基于位点的主备切换</h3><p>以B为例，当把B切换为A’从库的时候，需要执行change master命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$password </span><br><span class="line">MASTER_LOG_FILE=$master_log_name </span><br><span class="line">MASTER_LOG_POS=$master_log_pos  </span><br></pre></td></tr></table></figure>

<p>前四个参数自然是A’库的IP、端口、用户名和密码。后俩则是<strong>同步位点</strong>，也就是<strong>主库对应的文件名和日志偏移量</strong>。</p>
<p>这个同步位点容易出现偏差，是不精确的。比如主库A执行完一条语句，并把binlog传给A’和其他从库（包括B），A’和B也都同步了这个binlog，但是<strong>主库A还没接收到回执ack就挂了</strong>，那么此时同步位点肯定是这个位置，这就会<strong>导致A’和B即使同步了此数据，但是同步位点“不知情”</strong>。</p>
<p>一般有两种方式处理这种错误，一种是<strong>碰到这种错误就跳过</strong>，另一种是<strong>设置跳过指定的错误类型</strong>。</p>
<h3 id="2-GTID（全局事务ID）"><a href="#2-GTID（全局事务ID）" class="headerlink" title="2.GTID（全局事务ID）"></a>2.GTID（全局事务ID）</h3><p>全称是Global Transaction Identifier</p>
<p>GTID是<strong>事务提交的时候才生成</strong>的，要与事务id区分开来，事务id是<strong>执行过程中就分配</strong>了，如果事务回滚，后面的事务仍旧id递增。所以<strong>最终表现为GTID是连续的，而事务id经常不是连续的</strong>。</p>
<p>基于GTID的主备切换语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$password </span><br><span class="line">master_auto_position=1 </span><br></pre></td></tr></table></figure>

<p>这时就不需要主库对应的文件名和偏移量了，直接<strong>设置主备关系使用GTID协议</strong>即可。</p>
<p>取binlog的逻辑如下：</p>
<p>然后A’和B（**<!--文中说的实例，不太懂--><strong>）分别有自己的GTID集合，B把自己的发给A’，A‘核对两个集合，并判断此时A’有但B没有的这一部分GTID，然后看A’有没有这些的GTID对应的binlog(</strong><!--这里可能说明有误，但是整体意思是对的-->**)，没有的话，直接返回错误，如果有的话，就找出第一个不再B集合里的事务开始发给B。</p>
<p>上述思想有个<strong>前提</strong>，就是原先的主备库的<strong>日志是完整且一致的</strong>。</p>
<p>严谨的说：主备切换不是不需要找位点了，而是<strong>找位点的这个工作在A’内部就自动完成了</strong>，对开发人员非常友好。</p>
<h2 id="第28讲-读写分离有哪些坑？（处理主备延迟带来的问题）"><a href="#第28讲-读写分离有哪些坑？（处理主备延迟带来的问题）" class="headerlink" title="第28讲 | 读写分离有哪些坑？（处理主备延迟带来的问题）"></a>第28讲 | 读写分离有哪些坑？（处理主备延迟带来的问题）</h2><p>由于主从可能存在延迟现象，<strong>客户端更新后立刻发起查询</strong>，如果查询的是从库，很可能<strong>读到更新之前的状态</strong>，这就是“过期读”（非术语，只是方便理解）。</p>
<h3 id="1-强制走主库方案"><a href="#1-强制走主库方案" class="headerlink" title="1.强制走主库方案"></a>1.强制走主库方案</h3><p>对于必须要拿到最新结果的请求，我们必须强制让查询请求直接走主库查询，但主库的压力不言而喻</p>
<h3 id="2-Sleep方案"><a href="#2-Sleep方案" class="headerlink" title="2.Sleep方案"></a>2.Sleep方案</h3><p>主库更新后，<strong>读从库之前先sleep一会</strong>，但是很可能出现睡多了，或者睡得太短的现象。</p>
<h3 id="3-判断主备无延迟方案"><a href="#3-判断主备无延迟方案" class="headerlink" title="3.判断主备无延迟方案"></a>3.判断主备无延迟方案</h3><p>有三种做法：</p>
<p>​		1.查询前判断<strong>seconds_behind_master</strong>（第25讲提到的）是否为0，但是<strong>精度不太够</strong></p>
<p>​		2.查询前判断<strong>主库的最新位点与备库的最新位点</strong>是不是完全相同</p>
<p>​		3.查询前判断备库<strong>收到的所有日志</strong>的GTID集合与备库所有<strong>已经执行完成</strong>的GTID集合是否相同</p>
<p>但是还是有问题：因为主库<strong>写入binlog之后就反馈客户端</strong>了，所以有一部分binlog处于<strong>客户端已经收到提交确认，而备库还没有收到binlog的状态</strong>。</p>
<h3 id="4-配合semi-sync"><a href="#4-配合semi-sync" class="headerlink" title="4.配合semi-sync"></a>4.配合semi-sync</h3><p>这个时候就需要引入半同步复制，即semi-sync replication</p>
<p>设计如下：</p>
<p>​		1.事务提交，主库把binlog发给从库；</p>
<p>​		2.从库收到binlog，发回给主库一个ack，表示收到</p>
<p>​		3.主库收到ack，才给客户端返回”事务完成”的确认。</p>
<p>也就是说，<strong>等从库确认收到了传来的binlog，主库才返回客户端“确认”。</strong></p>
<p>但是又带来了新的问题：</p>
<p>​		1.semi-sync对于一主一备没问题，一主多从就很可能出现<strong>当前读取的从表并没有返回ack，而返回ack的从表却没有被读到</strong>。这仍旧会导致过期读的现象存在。</p>
<p>​		2.<strong>业务更新高峰期，主库位点或GTID更新极快</strong>，位点和GTID的<strong>等值判断</strong>可能长时间不成立，就会出现持续等待的现象。</p>
<h3 id="5-等主库位点方案"><a href="#5-等主库位点方案" class="headerlink" title="5.等主库位点方案"></a>5.等主库位点方案</h3><p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure>

<p>逻辑如下：</p>
<p>​		1.主库一个事务更新之后，立刻<strong>去主库找位点</strong>，得到主库执行到的file和pos；</p>
<p>​		2.<strong>选一个从库</strong>执行当前的查询语句；</p>
<p>​		3.在从库执行上述语句，如果<strong>在timeout规定时间内查到了，就返回一个&gt;&#x3D;0的正整数</strong>，并决定在这个从库执行查询语句</p>
<p>​		4.<strong>否则，去主库</strong>执行查询语句</p>
<p>以上的思路就是<strong>给从库查询一个限时，找不到位点，就直接去主库</strong>，不过这就回到了第一个方法强制走主库可能会碰到所有查询都超过timeout了，这就需要业务开发人员来权衡了。</p>
<h3 id="6-GTID方案"><a href="#6-GTID方案" class="headerlink" title="6.GTID方案"></a>6.GTID方案</h3><p>与主库位点很相似，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select wait_for_executed_gtid_set(gtid_set, 1);</span><br></pre></td></tr></table></figure>

<p>不同的是第一步，不找位点了，改成<strong>获取事物的GTID</strong>，如果<strong>超时了就返回1，找到了就返回0</strong>。</p>
<h2 id="第29讲-如何判断一个数据库是不是出问题了？"><a href="#第29讲-如何判断一个数据库是不是出问题了？" class="headerlink" title="第29讲 | 如何判断一个数据库是不是出问题了？"></a>第29讲 | 如何判断一个数据库是不是出问题了？</h2><h3 id="1-select-1判断"><a href="#1-select-1判断" class="headerlink" title="1.select 1判断"></a>1.select 1判断</h3><p>select 1成功返回，只能说明<strong>这个库的进程还在</strong>，不能说明<strong>这个库可能发生堵塞了</strong>，因为select 1<strong>没有深入innoDB</strong>层。</p>
<p>这里作者提到了一个innodb_thread_concurrency的参数，目的是<strong>控制innoDB的并发线程上限</strong>。这里要记住，这里的<strong>并发量指的不是并发连接数，而是并发查询</strong>。大量的并发查询才会占CPU，大量的连接只是占内存</p>
<p>当线程<strong>进入锁等待</strong>的时候，并发线程的<strong>计数会-1</strong>。</p>
<h3 id="2-查表判断"><a href="#2-查表判断" class="headerlink" title="2.查表判断"></a>2.查表判断</h3><p>在数据库里面特意定义一个心跳表health_check，里面只放一行数据进行查询操作。</p>
<p>想判断数据库有没有问题就查这个库里的数据，这种方法<strong>可以检测由于并发线程过多导致数据库不可用</strong>的情况。</p>
<p>但是一旦binlog所在磁盘利用率达到100%，<strong>事务的更新和提交都堵住了，但是查询依旧可行</strong>。所以还需要进一步完善。</p>
<h3 id="3-更新判断"><a href="#3-更新判断" class="headerlink" title="3.更新判断"></a>3.更新判断</h3><p>在上述心跳表里放一个随时可以更新的字段，比如更新时间&#x3D;now()</p>
<p>但是节点可用性检测既要检测主库，也要检测备库，这个时候<strong>我们要给备库以写的能力</strong>。</p>
<p>那么就会<strong>发生主备库都写同一条更新命令的情况</strong>。</p>
<p>所以要在心跳表中存入多行数据，并用<strong>A、B表一定不同的server_id来作为主键</strong>。这就不会发生“更新冲突”了。</p>
<p>但是，假如当前日志盘的IO利用率是100%，那么<strong>执行更新操作会非常的慢</strong>，这个时候也说明主库出问题了，需要主备切换，但是<strong>当前update操作需要的资源很小</strong>，所以可能表现为：更新速度很快。这就<strong>误让我们认为</strong>主库还是可用的。</p>
<h3 id="4-内部统计"><a href="#4-内部统计" class="headerlink" title="4.内部统计"></a>4.内部统计</h3><p>MySQL 5.6版本以后提供了performance_schema库，可以查询<strong>统计每次IO请求的时间</strong>，也就是对MySQL库实时监控。</p>
<p>综上，作者建议<strong>优先update系统表</strong>，然后<strong>配合增加检测performance_schema</strong>的信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/MySQL%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" data-id="cl3117rey0000tcv60nf2d3td" data-title="MySQL个人总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/">Redis知识点</a>
          </li>
        
          <li>
            <a href="/2022/05/30/%E5%9B%9E%E6%BA%AF%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/">回溯系列题解</a>
          </li>
        
          <li>
            <a href="/2022/05/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/">操作系统笔记</a>
          </li>
        
          <li>
            <a href="/2022/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/">二叉树题解</a>
          </li>
        
          <li>
            <a href="/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/">Java基础知识点</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>