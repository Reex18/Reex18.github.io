<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Reex</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Reex">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Reex">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Reex" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Reex</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Java基础知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2022-05-15T09:03:41.000Z" itemprop="datePublished">2022-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/">Java基础知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><img src="https://javaguide.cn/assets/java-collection-hierarchy.1727461b.png" alt="img"  />

<h2 id="为什么要使用集合？"><a href="#为什么要使用集合？" class="headerlink" title="为什么要使用集合？"></a>为什么要使用集合？</h2><p>数组一旦声明了，长度就不可变；</p>
<p>数组存储数据类型单一，而且有序且可重复的，特点也单一；</p>
<p>集合提高了数据存储的灵活性，不仅可以不同<strong>类型</strong>、不同<strong>数量</strong>，还可以<strong>控制元素重复</strong>，并且保存具有<strong>映射关系</strong>的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  数组转换为类型一致的集合</span></span><br><span class="line">  <span class="type">int</span> [] arr1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">  <span class="comment">//  注意：这里直接传入int [] 的数组，返回的List的泛型参数为 int [],而不是Integer</span></span><br><span class="line">  List&lt;<span class="type">int</span>[]&gt; list1 = Arrays.asList(arr1);</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer [] arr2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//  传入的参数类型为 Integer时，返回泛型参数就是Integer</span></span><br><span class="line">List&lt;Integer&gt; list2 = Arrays.asList(arr2);</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList和LinkedList区别与联系？"><a href="#ArrayList和LinkedList区别与联系？" class="headerlink" title="ArrayList和LinkedList区别与联系？"></a>ArrayList和LinkedList区别与联系？</h2><p>A和L都实现了List接口，他们都是<strong>线程不安全的</strong>；</p>
<p>A底层使用的是<u>Object[]数组</u>，L底层使用的是<u>双向链表</u>；</p>
<p>A在数组中的某个位置<strong>删除，插入</strong>元素都需要让整个数组跟着移动，L虽然不会移动，但是需要先移动到那个位置才能进行插入或删除操作，所以<strong>两者复杂度都较高</strong>，L只有头和尾插入或删除时，时间复杂度时o(1)。</p>
<p><strong>A支持快速随机访问</strong>，因为数组下标。而L不行。</p>
<p>A占内存主要是因为<strong>尾部需要预留空间</strong>，L空间花费更多体现在每个结点要记录的内容。</p>
<p>A好，用A，<strong>能用L的地方都能用A</strong>。</p>
<h2 id="comparable和comparator区别？"><a href="#comparable和comparator区别？" class="headerlink" title="comparable和comparator区别？"></a>comparable和comparator区别？</h2><p>comparable接口是java.lang包下的，接口有comareTo(Object obj)方法</p>
<p>comparator接口时java.util工具包下的，接口中有compare(Object obj1, Object obj2)方法</p>
<h2 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h2><p>JDK 1.7之前，底层是<strong>数组+链表</strong>的形式存储数据的。每次存储都对数据执行扰动函数，得到hash值，如果哈希碰撞，就equals比较，若相等则覆盖，如<strong>不等则拉链法</strong>，即用链表存储。</p>
<p>JDK 1.8之后，底层是<strong>数组+链表+红黑树</strong>。还是用扰动函数，但是<strong>扰动函数有所更新</strong>，减少了哈希碰撞几率，但是如果碰撞还是equals比较，若相等则覆盖，若不等则拉链法，当链表长度大于阈值（默认8），则检查当前数组长度是否大于64，<strong>小于64则扩容数组</strong>（这里需要rehash），大于64则将超过阈值的链表<strong>转化为红黑树</strong>。</p>
<h2 id="HashMap长度为什么是2的幂次方？"><a href="#HashMap长度为什么是2的幂次方？" class="headerlink" title="HashMap长度为什么是2的幂次方？"></a>HashMap长度为什么是2的幂次方？</h2><p><strong>这个还没搞懂</strong></p>
<h2 id="ConcurrentHashMap和Hashtable的区别？"><a href="#ConcurrentHashMap和Hashtable的区别？" class="headerlink" title="ConcurrentHashMap和Hashtable的区别？"></a>ConcurrentHashMap和Hashtable的区别？</h2><p>先说Hashtable，<strong>全表锁</strong>，效率很低</p>
<p>对于<strong>JDK 1.7</strong>的cchashmap，用segment即<strong>分段锁</strong>，只要多个线程没有哈希碰撞到同一个段就没事。</p>
<p><strong>JDK 1.8</strong>以后的cchashmap，<strong>只锁当前的链表或者红黑树的首节点</strong>，只要hash冲突不到数组的同一个节点上，就没事。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="cl39jz0gd00001cv61jgv7ohf" data-title="Java基础知识点" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-栈与队列题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/14/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-14T08:58:47.000Z" itemprop="datePublished">2022-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/14/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E9%A2%98%E8%A7%A3/">栈与队列题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="leetcode-20-有效的括号"><a href="#leetcode-20-有效的括号" class="headerlink" title="leetcode 20.有效的括号"></a>leetcode 20.有效的括号</h2><p><u><strong>题目</strong>：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</u></p>
<p><u>有效字符串需满足：</u></p>
<p><u>左括号必须用相同类型的右括号闭合。</u><br><u>左括号必须以正确的顺序闭合。</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：s = &quot;([)]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(deque.isEmpty() || deque.peek() != ch)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                deque.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题是典型的用栈来解决的问题，因为我们需要左右括号两两出现，而且顺序不能打乱，栈的入栈出栈操作正好可以满足该要求。</p>
<p>如果我们遍历到当前位置是左括号，那么就<strong>向栈中压入相对应的右括号</strong>；</p>
<p>如果<strong>当前栈为空，或者当前的括号和栈顶括号不相等</strong>，那我们就直接返回false。因为这个时候我们还要继续判断ch呢，走到这一步肯定不是左括号了，那必然是右括号，<strong>如果这个时候栈没有元素了，那就说明右括号冗余了</strong>。</p>
<p>上面都不满足，说明现在<strong>栈不是空栈</strong>，而且当前的ch是右括号，**而且！ch &#x3D;&#x3D; deque.peek()**，那么我们自然可以将栈顶元素弹出栈了。</p>
<h2 id="leetcode-1047-删除字符串中的所有相邻重复项"><a href="#leetcode-1047-删除字符串中的所有相邻重复项" class="headerlink" title="leetcode 1047.删除字符串中的所有相邻重复项"></a>leetcode 1047.删除字符串中的所有相邻重复项</h2><p><u><strong>题目</strong>：给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</u></p>
<p><u>在 S 上反复执行重复项删除操作，直到无法继续删除。</u></p>
<p><u>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</u></p>
<p><u>示例：</u></p>
<p><u>输入：”abbaca”</u><br><u>输出：”ca”</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：用栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.push(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(deque.isEmpty() || deque.peek() != ch)&#123;</span><br><span class="line">                deque.push(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                deque.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            str = deque.pop() + str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用StringBuilder模拟栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sb.length() == <span class="number">0</span> || s.charAt(i) != sb.charAt(sb.length() - <span class="number">1</span>))&#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法一我们直接用栈来解决这道题：</p>
<p>如果<strong>当前栈为空，或者栈顶元素和当前元素不相等</strong>，那么我们就把该元素压栈；</p>
<p>如果当前栈不为空且栈顶元素等于当前元素，我们<strong>不仅不压入当前元素，还要弹出这个相同的元素</strong>，即把栈顶元素弹出栈。</p>
<p>最后不要忘了返回值是String，<strong>记得写对str和deque.pop()相加的顺序</strong>，str +&#x3D; deque.pop()和str &#x3D; deque.pop() + str是相反的结果。</p>
<p>方法二我们是用StringBuilder来模拟栈：</p>
<p>思路与法一相似，注意sb要删除最后一位，且比较过程中，一定要拿s的当前值与sb的最后一位比，<strong>这里容易写成s自身比较的判断</strong>。</p>
<p>最后直接返回字符串，不需要再次遍历，所以推荐方法二。</p>
<h2 id="leetcode-150-逆波兰表达式求值"><a href="#leetcode-150-逆波兰表达式求值" class="headerlink" title="leetcode 150.逆波兰表达式求值"></a>leetcode 150.逆波兰表达式求值</h2><p><u><strong>题目</strong>：根据逆波兰表示法，求表达式的值。</u></p>
<p><u>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</u></p>
<p><u>注意 两个整数之间的除法只保留整数部分。</u></p>
<p><u>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</u></p>
<p><u>输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”*”]</u><br><u>输出：9</u><br><u>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</u></p>
<p><u>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]</u><br><u>输出：6</u><br><u>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(s))&#123;</span><br><span class="line">                deque.push(deque.pop() + deque.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;-&quot;</span>.equals(s))&#123;</span><br><span class="line">                deque.push(-deque.pop() + deque.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;*&quot;</span>.equals(s))&#123;</span><br><span class="line">                deque.push(deque.pop() * deque.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;/&quot;</span>.equals(s))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">                deque.push(deque.pop() / temp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                deque.push(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deque.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题需要注意的易错点，我们很容易去定义一个ans去记录最后的结果值，但是我们要注意：数组是String类型的数组，所以我们必然要在每次计算之前，将字符串数组中的每个字符串转换成数字，也就是说我们可以<strong>每次压栈的时候就将压入栈的字符串转换成数字</strong>，这是最关键的一步。</p>
<p>字符串转换成数字之后，我们会发现：每次遍历到运算符的时候，我们要将该运算符前面的栈顶元素和次栈顶元素进行相应的运算操作，但是这个结果存在哪呢？存给专门的变量ans？不行，我们<strong>后面还需要对这个运算结果进一步运算</strong>啊！所以一定要将运算结果继续压栈操作，这是另一个容易犯错的位置。</p>
<p>上面两个问题都避免了，那么正确的答案很容易写出来了，<strong>最后栈中一定只剩一个元素了</strong>，就是最终答案，我们把它弹出栈即可。</p>
<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><h2 id="leetcode-347-前K个高频元素"><a href="#leetcode-347-前K个高频元素" class="headerlink" title="leetcode 347.前K个高频元素"></a>leetcode 347.前K个高频元素</h2><p><u><strong>题目</strong>：给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</u></p>
<p><u>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</u><br><u>输出: [1,2]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries= map.entrySet();</span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue());</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : entries)&#123;</span><br><span class="line">            queue.offer(entry);</span><br><span class="line">            <span class="keyword">if</span>(queue.size() &gt; k)&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            res[i] = queue.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题<strong>采用优先队列</strong>的数据结构，这里的优先级我们定义的是每个数字的出现频率，<strong>出现频率越小，优先级越高</strong>，出现频率最小的先出队列。至于原因，往下看就明白了。</p>
<p>既然谈到出现频率，又是老生常谈的HashMap了，key存入每个数字，value是他们对应的出现频率；</p>
<p>为了方便遍历map中的每个key和其value值，我们选用Map的一个内部接口，Map.Entry&lt;Integer, Integer&gt;，<strong>其代表每个key-value键值对组成的一个个实体</strong>，因为有多个键值对，所以用Set来存储，这里泛型要写准确，Set的泛型是Map.Entry&lt;Integer, Integer&gt;，<strong>这个步骤容易出错！！！</strong></p>
<p>接下来定义优先级队列，因为我们要根据每个key-value键值对中的value进行从小到大的排列，所以用Lamada表达式为o1.getValue() - o2.getValue()，<strong>o1和o2分别对应着entry实体（key-value键值对）</strong>。</p>
<p>接下来开始一个个入栈排队，进入队列的是每个entry实体的key还是value？<strong>是两者组成的entry入栈！！！</strong>因为，我们排队的时候虽然只用到value，但是<strong>后面真正返回的值是value较大的前几个key</strong>，所以我们的优先级队列要存入整个实体才可以。</p>
<p>如果队列中实体的个数大于k个，那么我们就<strong>让队头出队</strong>即可，这个对头是当前队列value最小的key。</p>
<p>最后我们定义一个长度为k的数组，存储队列中的<strong>k个entry实体的key值</strong>即可。</p>
<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><h2 id="leetcode-239-滑动窗口最大值（单调队列）"><a href="#leetcode-239-滑动窗口最大值（单调队列）" class="headerlink" title="leetcode 239.滑动窗口最大值（单调队列）"></a>leetcode 239.滑动窗口最大值（单调队列）</h2><p><u><strong>题目</strong>：给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</u></p>
<p><u>返回 滑动窗口中的最大值 。</u></p>
<p><u>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</u><br><u>输出：[3,3,5,5,6,7]</u><br><u>解释：</u><br><u>滑动窗口的位置                最大值</u></p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">MyQueue</span> <span class="variable">myQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length - k + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//定义一个随时存放窗口最大值的数组，作为返回结果</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先把第一个窗口里面的元素按照myQueue的方法入队，即形成一个队头到队尾由大到小排列的k个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            myQueue.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将第一个窗口对应的单调队列的队头弹出，即为第一个窗口的最大值，记录到数组中。</span></span><br><span class="line">        ans[num++] = myQueue.peek();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//先让单调队列弹出窗口最左边的元素，这里很可能在offer添加的过程中就被弹出了</span></span><br><span class="line">            myQueue.poll(nums[i - k]);</span><br><span class="line">            <span class="comment">//再让单调队列添加窗口最右边的元素</span></span><br><span class="line">            myQueue.offer(nums[i]);</span><br><span class="line">            <span class="comment">//弹出当前单调队列的队头，即当前窗口的最大值，记录到ans数组中</span></span><br><span class="line">            ans[num++] = myQueue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个双端队列，用于存放从队头到队尾由大到小排列的双端队列</span></span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//弹出队列的队头元素，只有当前队头元素与val相等时才弹出，否则就说明val太小了，早就被谈出去了，所以当前队列不用弹出任何元素</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!deque.isEmpty() &amp;&amp; val == deque.peek())&#123;</span><br><span class="line">            deque.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向队尾添加元素，如果队尾的元素比当前val小，就一直弹出队尾元素，直到val &lt;= 当前队尾元素才停止弹出，并将当前val添加到队尾，实现队头到队尾由大到小排列</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; val &gt; deque.getLast())&#123;</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.offer(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出队头元素，即取当前队列的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个题要慢慢来，首先我们先确定一个思路：</p>
<p>用队列装每个窗口的元素，怎么装呢？队头我们要保留当前窗口的最大值，这样<strong>每次我们弹出队头就是我们想要的结果</strong>；</p>
<p>队头后面的元素呢？我们<strong>让这些元素由大到小排列，队头最大，队尾最小</strong>。</p>
<p>所以我们要设计一个单调队列，上面的代码顺序先写的弹出队头的操作，其实先写添加队尾操作更简单一些。添加队尾操作，即把每次滑动窗口最右边val添加到队尾，但是我们要求队头到队尾始终是由大到小排列，所以<strong>val如果比当前队尾元素大，那么这个队尾元素就没用了</strong>，我们直接把<strong>队尾元素弹出</strong>，直到val &lt;&#x3D; 队尾元素，我们就把val添加到队尾。</p>
<p>上面的添加队尾操作存在一个问题，你添加就添加，干嘛删元素，要知道被删的元素可能正是一会要被删的“当前滑动窗口的最左边的元素val”。从这句话也可以看出，我们在添加队尾的时候<strong>可能就把现在才要删的元素提前删掉</strong>了。</p>
<p>所以我们在写弹出操作的时候，<strong>只需要看看这个val是不是等于当前的队头元素</strong>，如果是，那么不好意思，刚刚在添加过程中还没真没把这个值删了，因为这个是上一个窗口的最大值，添加操作不可能把它删了的。如果val不等于当前队头元素，说明刚刚添加元素的时候已经把它删了。</p>
<p>最后写的是取队头的操作，这个简单，<strong>弹出的就是队头也就是当前队列（窗口）的最大值</strong>。</p>
<p>主方法比较简单，看着注释就能明白。</p>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="leetcode-739-每日温度"><a href="#leetcode-739-每日温度" class="headerlink" title="leetcode 739.每日温度"></a>leetcode 739.每日温度</h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; temperatures.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temperatures[i] &lt;= temperatures[stack.peek()])&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()])&#123;</span><br><span class="line">                    ans[stack.peek()] = i - stack.peek();</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);<span class="comment">//栈空了，或者当前元素小于等于栈顶元素对应的温度才走到这一步</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题采用单调栈，意思是我们自己构造一个栈，<strong>栈中的元素对应的温度始终是由小到大（栈顶到栈底）排列的</strong>。</p>
<p>一旦要入栈的元素对应的温度 &gt; 当前栈顶元素对应的温度，那么就开始出栈，<strong>一直出一直出</strong>，直到入栈元素对应的温度 &lt;&#x3D; 当前栈顶元素对应的温度，就把这个元素入栈，当作最新的栈顶。</p>
<h2 id="leetcode-496-下一个更大元素-I"><a href="#leetcode-496-下一个更大元素-I" class="headerlink" title="leetcode 496.下一个更大元素 I"></a>leetcode 496.下一个更大元素 I</h2><p><u><strong>题目</strong>：nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</u></p>
<p><u>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。</u></p>
<p><u>对于每个 0 &lt;&#x3D; i &lt; nums1.length ，找出满足 nums1[i] &#x3D;&#x3D; nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</u></p>
<p><u>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素</u> </p>
<p><u>输入：nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</u><br><u>输出：[-1,3,-1]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">//先用map把nums1的元素和其对应的下标存起来</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums1.length;i++)&#123;</span><br><span class="line">            map.put(nums1[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="comment">//这一步初始化很容易忘记</span></span><br><span class="line">        Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums2.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums2[i] &lt;= nums2[stack.peek()])&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()])&#123;</span><br><span class="line">                    <span class="comment">//如果当前栈顶元素比nums2[i]小，就去看看map中的key有没有存栈顶元素</span></span><br><span class="line">                    <span class="keyword">if</span>(map.containsKey(nums2[stack.peek()]))&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(nums2[stack.peek()]);</span><br><span class="line">                        ans[index] = nums2[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题是从一个数组找与另一个数组相关联的数字，这个关联性就是比大小。</p>
<p>所以我们可以用上一题的每日温度的思路，继续依次将nums2的元素压栈，当然，压栈是有前提的，必须在<strong>栈为空</strong>或者栈顶元素<strong>大于等于</strong>当前遍历的nums2[i]元素才可以。</p>
<p>一旦找到了不能压栈的元素，那么我们就说明当前栈顶元素小于nums2[i]，<strong>这不就找到了满足后者比前者大的两个数了嘛</strong>。</p>
<p>那么我就看看nums1中有没有这个数，哪个数？当然是较小的那个数了！所以我们需要<strong>用一个map来存储每个nums1中的元素</strong>。为什么用map，因为我们还要利用nums1中每个元素对应的下标，别忘了最后我们要返回的是一个数组。<strong>数组中每个元素都是：比nums1相应位置大的nums2数</strong>，所以这个位置我们还是需要nums1的下标的，就和每日温度题目也需要温度数组的下标一个道理。</p>
<p><strong>最后不要忘了ans的初始化！！！！</strong>找不到比相应位置元素大的话，当前位置为-1</p>
<h2 id="leetcode-503-下一个更大元素-II"><a href="#leetcode-503-下一个更大元素-II" class="headerlink" title="leetcode 503.下一个更大元素 II"></a>leetcode 503.下一个更大元素 II</h2><p><u><strong>题目</strong>：给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。</u></p>
<p><u>数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。</u></p>
<p><u>输入: nums &#x3D; [1,2,1]</u><br><u>输出: [2,-1,2]</u></p>
<p><u>输入: nums &#x3D; [1,2,3,4,3]</u><br><u>输出: [2,3,4,-1,4]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size * <span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i % size] &gt; nums[stack.peek()])&#123;</span><br><span class="line">                ans[stack.peek()] = nums[i % size];</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i % size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这道题虽说是循环数组，但其实就是让每个元素都与数组中所有元素进行比较。与自己比也没事，因为我们只记录有没有比自己大的元素。</p>
<p>题解给的是遍历两个长度的nums数组，那自然就会遍历到包括自己的每个元素，而且ans会出现赋值之后再被重复赋值的情况。</p>
<h2 id="leetcode-42-接雨水"><a href="#leetcode-42-接雨水" class="headerlink" title="leetcode 42.接雨水"></a>leetcode 42.接雨水</h2><p><u><strong>题目</strong>：给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</u></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p>
<p><u>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</u><br><u>输出：6</u><br><u>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：双指针法（官方题解，时间复杂度为o(n)）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;<span class="comment">//定义左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> <span class="number">0</span>, rightMax = <span class="number">0</span>;<span class="comment">//定义左右最大值</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            leftMax = Math.max(leftMax, height[left]);<span class="comment">//每次都记录当前的最大左边界</span></span><br><span class="line">            rightMax = Math.max(rightMax, height[right]);<span class="comment">//每次都记录当前的最大右边界</span></span><br><span class="line">            <span class="keyword">if</span>(leftMax &lt; rightMax)&#123;<span class="comment">//哪边的边界小，就算哪边，这里是重点！！！</span></span><br><span class="line">                ans += leftMax - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += rightMax - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从双指针法，我们可以看出，首先我们要先定义一个从头和尾分别向中间走的两个指针，即left和right，然后我们在指针移动的过程中，随时记录左边最大值leftMAX和右边最大值rightMAX。</p>
<p>我们要特别重视这个leftMAX和rightMax的变化过程：</p>
<p>首先<strong>只有指针移动，这俩值才会发生变化</strong>；</p>
<p>其次这俩值一定是<strong>他们各自指针经过的最大高度</strong>。</p>
<p>接着进入判断语句：我们看到这个if语句肯定有疑惑，为什么左边最大值比右边最大值   小的时候，我们就要算左边的呢，算右边不行吗？还真不行！因为当前指针移动的位置下，左边最大值如果比当前右边最大值小，那么肯定<strong>现在左指针所处的位置右边有比自己高的</strong>，这是因为<strong>右边最大值随着右指针向左移动会逐渐变大</strong>。我们接雨水一定要取最短的那条边，就是木桶效应，要找自己的短板。</p>
<p>同理当前指针移动的位置下，右边的最大值如果比左边最大值 小的话，那么当前右指针所处的位置，其左边肯定有比自己高的，最起码<strong>还有现在leftMax充数呢</strong>是不是？所以我们要取短边，计算短边的接雨水量。</p>
<p>接下来的难点就是实际的雨水量的计算。左右指针的算法一样，我们以左指针为例，leftMax - height[left]是什么？我们知道leftMax是height[left]的最大值，所以就有两种情况，一种是leftMax就是当前左指针下的height[left]，那么<strong>自然这个差值就是0了</strong>，不影响我们计算，无非就是<strong>ans +&#x3D; 0</strong>嘛。还有一种情况，就是leftMax 与height[left]差着至少一个位置，这个时候算出来的差值，就是<strong>当前left指针位置（一个单位的）左右最小边界下积累的雨水量了</strong>。比如图示中间那部分雨水，按照双指针法就要分成三个纵向的计算，也就是<strong>左指针移动三次</strong>，<strong>右指针不动</strong>（因为右边最大值始终比左边最大值大），直到左指针与右指针碰撞，所以雨水积累完毕，跳出循环。</p>
<p><img src="https://img-blog.csdnimg.cn/20210402091208445.png" alt="42.接雨水1"></p>
<p>图中就是双指针解法每次计算的雨水量，全部都是按列计算的。</p>
<p>接下来看看单调栈解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二：单调栈（Carl题解，时间复杂度为o(n)）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; height.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i] == height[stack.peek()])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(height[i], height[left]) - height[mid];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> i - left - <span class="number">1</span>;</span><br><span class="line">                        ans += len * h;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种解法else里边的while循环里的if语句是很重要的一个判断，为什么这么说呢，先看看第一个左边界凹槽的情况：</p>
<p>左边界凹槽的高度是0，默认入栈的。下一个高度是1，比凹槽高，说明进入了while循环，也就是开始接雨水。那么我们就要思考，接雨水需要什么条件，凹槽左边和右边都要有比凹槽高的点，我们才可以接水。但是左边界凹槽的左边是没有点的，那么我们怎么避免这种情况的计算呢？</p>
<p>代码给出的就是进入while循环后，<strong>先保存我们要计算的凹槽对应的位置，然后将该位置弹出</strong>。这是<u>非常重要且关键的一步</u>，这个凹槽是我们当前唯一要接水的位置，记录该位置是必然的操作，而将该位置弹出栈是为了后面对左边界的有无进行判断的前提。</p>
<p>像左边界这种情况，由于前面的弹出栈操作，现在栈为空了，<strong>对于空栈，我们只能把height[i]入栈了</strong>。这就有效弹出了左边界凹槽，并且没有将其进行接雨水的操作。</p>
<p>接下来就依次向后遍历，第二个注意的点就是相同高度的判断，对于相同高度，我们只需要保留最右边的位置即可，所以有一个先弹出前面的高度，再添加后面高度的操作。其实不弹出，直接添加也行。但是<strong>接雨水的时候过程是不一样的，最后计算结果一样</strong>。我们来具体看一下：</p>
<p>我们把示例中的图，中间的那个凹槽填平，这样就有三个相同高度的平台，接下来按照左边那个高台向右走我们看看代码是怎么实现的：</p>
<p>1）不弹出，直接一个个添加相同高度的平台：</p>
<p>第一个平台比左边高台要低，添加第一个平台位置，第二个平台和第一个平台等高，继续添加，第三个和第二个等高，继续添加，直到右边很高的台子了，这个时候进入while循环，弹出第一个平台，结果发现我们在给h赋值的时候，h为0，<strong>这样就白白让ans计空了一次</strong>。还好，我们已经把这个平台弹出了，但是还有第二个平台，能怎么办，接着弹出，ans又白白计空了一次。第三次，弹出最左边的平台，这个时候h就是左高平台减去当前最左边的等高平台了，这样ans才有记录的意义。</p>
<p>所以我们可以在进入while循环就避免这些无意义的ans计算</p>
<p>2）一等高就弹出，只保留最右边的：</p>
<p>也就是如上的代码，只保留最右边的平台的下标值，这样只有一个平台，一旦弹出，left就是左边高台的下标了。我们ans每次计算就都是有效的。这种方式在数据量特别大，且等高平台特别多的时候，是非常省时的。</p>
<p>所以这俩操作计算过程不一样，但结果是一样的。原因在于：前者在做了<strong>很多无效的ans计算</strong>之后，最后用了<strong>最左边的等高平台</strong>进行了有效的ans计算；而后者直接利用了<strong>最右边的等高平台</strong>进行了有且<strong>仅有一次的有效ans计算</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20210223092629946.png" alt="42.接雨水2"></p>
<p>可以看出单调栈解法是按行进行计算的，代码中的len &#x3D; Math.max(height[i], height[left]) - height[stack.peek()]就可以看出。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/14/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E9%A2%98%E8%A7%A3/" data-id="cl35vggaa0000swv66rwn2pde" data-title="栈与队列题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-我的项目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/13/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2022-05-13T12:30:20.000Z" itemprop="datePublished">2022-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/13/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/">我的项目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="开发社区首页——分页查询帖子"><a href="#开发社区首页——分页查询帖子" class="headerlink" title="开发社区首页——分页查询帖子"></a>开发社区首页——分页查询帖子</h1><h2 id="1-创建实体类对象DiscussPost"><a href="#1-创建实体类对象DiscussPost" class="headerlink" title="1.创建实体类对象DiscussPost"></a>1.创建实体类对象DiscussPost</h2><p>先创建一个DiscussPost的实体类对象，与之对应的数据库数据是discuss_post</p>
<p>分别把id, userId, title, content, type, status, createTime, commentCount, score变量及其get, set方法, toString()方法定义出来。</p>
<h2 id="2-开发DAO层——DiscussPostMapper"><a href="#2-开发DAO层——DiscussPostMapper" class="headerlink" title="2.开发DAO层——DiscussPostMapper"></a>2.开发DAO层——DiscussPostMapper</h2><p>首先定义一个<strong>查询帖子信息的方法</strong>selectDiscussPosts，形参包括userId, offset, limit，其中userId在后面个人主页的帖子才需要，offset是每一页起始行的行号，limit是每一页最多显示多少数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;DiscussPost&gt; <span class="title function_">selectDiscussPosts</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> <span class="type">int</span> userId, <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit)</span>;</span><br></pre></td></tr></table></figure>

<p>为了方便显示页码，还要定义一个方法selectDiscussPostRows来查询一共多少行帖子，只有一个形参userId，同理，也是在后面个人主页帖子的时候才需要这个userId</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">selectDiscussPostRows</span><span class="params">(<span class="type">int</span> userId)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-配置文件——discusspost-mapper-xml"><a href="#3-配置文件——discusspost-mapper-xml" class="headerlink" title="3.配置文件——discusspost-mapper.xml"></a>3.配置文件——discusspost-mapper.xml</h2><p>在mapper配置文件里定义一个discusspost-mapper.xml，在&lt;mapper 标签里的namespace参数写上配置文件<strong>为具体哪个接口服务</strong>的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.DiscussPostMapper&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体sql语句如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span></span><br><span class="line">       id, user_id, title, content, type, status, create_time, comment_count, score</span><br><span class="line">   <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDiscussPosts&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;DiscussPost&quot;</span>&gt;</span></span><br><span class="line">       select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">       from discuss_post</span><br><span class="line">       where status != 2</span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId!=0&quot;</span>&gt;</span></span><br><span class="line">           and user_id = #&#123;userId&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       order by type desc, create_time desc</span><br><span class="line">       limit #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDiscussPostRows&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">       select count(id)</span><br><span class="line">       from discuss_post</span><br><span class="line">       where status != 2</span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId!=0&quot;</span>&gt;</span></span><br><span class="line">           and user_id = #&#123;userId&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-开发Service层——DiscussPostService和UserService"><a href="#4-开发Service层——DiscussPostService和UserService" class="headerlink" title="4.开发Service层——DiscussPostService和UserService"></a>4.开发Service层——DiscussPostService和UserService</h2><p>DiscussPostService很简单，直接调用DAO层的DiscussPostMapper的两个方法即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscussPostService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostMapper discussPostMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;DiscussPost&gt; <span class="title function_">findDiscussPosts</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.selectDiscussPosts(userId, offset, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDiscussPostRows</span><span class="params">(<span class="type">int</span> userId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.selectDiscussPostRows(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserService是用来开发<strong>根据用户id来查询用户</strong>的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;<span class="comment">//用于管理User类方法的dao层Mapper组件</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-开发Controller层——HomeController"><a href="#5-开发Controller层——HomeController" class="headerlink" title="5.开发Controller层——HomeController"></a>5.开发Controller层——HomeController</h2><p>因为这一层要用到SpringMVC，方法需要用@RequestMapping()编写访问路径，因为访问的是首页，所以路径是**&#x2F;index<strong>，请求方式因为是</strong>查询<strong>，所以是RequestMethod.GET，</strong>返回的是相应的网页，所以不要加ResponseBody**，直接返回String，即视图的名字。</p>
<p>形参写入Model model，因为我们要通过model携带数据传给模板，最终返回的也是模板的路径，即Templates下的index.html</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> <span class="keyword">implements</span> <span class="title class_">CommunityConstant</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/index&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getIndexPage</span><span class="params">(Model model, Page page)</span>&#123;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//方法调用前，SpringMVC会自动实例化Model和Page，并将Page注入Model，所以在thymeleaf中可以直接访问Page对象的数据</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取帖子的总行数</span></span><br><span class="line">        page.setRows(discussPostService.findDiscussPostRows(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//页面index就可以复用这个路径了</span></span><br><span class="line">        page.setPath(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//页码offset和limit就可以根据上面的数据和Page类来获取了</span></span><br><span class="line">        List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(<span class="number">0</span>, page.getOffset(), page.getLimit());<span class="comment">//list只有id和userId，没有User的具体信息，所以我们通过定义一个map来存放每个帖子的具体信息和User对象</span></span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; discussPosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(list != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(DiscussPost post : list)&#123;<span class="comment">//要一个个遍历帖子内容</span></span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                map.put(<span class="string">&quot;post&quot;</span>, post);<span class="comment">//先存放帖子信息</span></span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(post.getUserId());</span><br><span class="line">                map.put(<span class="string">&quot;user&quot;</span>, user);<span class="comment">//再存放User信息</span></span><br><span class="line">                discussPosts.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//DispatcherServlet会自动将page装到model里面，所以不用单独添加page了</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;discussPosts&quot;</span>, discussPosts);<span class="comment">//要把数据传给model</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index&quot;</span>;<span class="comment">//返回模板路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-创建实体类Page封装分页相关操作"><a href="#5-1-创建实体类Page封装分页相关操作" class="headerlink" title="5.1 创建实体类Page封装分页相关操作"></a>5.1 创建实体类Page封装分页相关操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">    <span class="comment">//当前页码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//显示上限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//数据总数(用于计算总页数)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rows;</span><br><span class="line">    <span class="comment">//查询路径(用于复用分页链接)</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCurrent</span><span class="params">()</span> &#123;<span class="keyword">return</span> current;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurrent</span><span class="params">(<span class="type">int</span> current)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(current &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.current = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLimit</span><span class="params">()</span> &#123;<span class="keyword">return</span> limit;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLimit</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(limit &gt;= <span class="number">1</span> &amp;&amp; limit &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRows</span><span class="params">()</span> &#123;<span class="keyword">return</span> rows;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRows</span><span class="params">(<span class="type">int</span> rows)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(rows &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.rows = rows;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span> &#123;<span class="keyword">return</span> path;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPath</span><span class="params">(String path)</span> &#123;<span class="built_in">this</span>.path = path;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前页的起始行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOffset</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//current * limit - limit</span></span><br><span class="line">        <span class="keyword">return</span> (current - <span class="number">1</span>) * limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取总页数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTotal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//rows / limit [+1]</span></span><br><span class="line">        <span class="keyword">if</span>(rows % limit == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rows / limit;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rows / limit + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取起始页码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFrom</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> current - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> from &lt; <span class="number">1</span> ? <span class="number">1</span> : from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取结束页码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> current + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> getTotal();</span><br><span class="line">        <span class="keyword">return</span> to &gt; total ? total : to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要<strong>查询帖子就要访问数据库</strong>，与数据库打交道，那就是数据访问层干的活，<strong>业务层其实就是实现查询数据库的操作</strong>，所以直接调用数据访问层的查询方法，所以重点是DAO层写出查询方法，mapper.xml要写几个sql语句查询数据库的帖子详情。查询逻辑写好之后，DAO层直接调用mapper.xml的逻辑，然后业务层调DAO层，这样就来到了控制层。控制层其实就是调用业务层，<strong>把从数据库中查询到的帖子数据和用户数据传给model</strong>。因为帖子需要分页，所以我们最好专门写个实体类来实现分页功能，分页功能主要让起始行和每页帖子数量上限是一个变量，否则每次数据库变动了还得重新计算并填入到控制层方法的形参中。</p>
<h1 id="2-1开发邮件发送功能"><a href="#2-1开发邮件发送功能" class="headerlink" title="2.1开发邮件发送功能"></a>2.1开发邮件发送功能</h1><h2 id="1-设置邮箱，导入SpringBoot的Mail包"><a href="#1-设置邮箱，导入SpringBoot的Mail包" class="headerlink" title="1.设置邮箱，导入SpringBoot的Mail包"></a>1.设置邮箱，导入SpringBoot的Mail包</h2><p>新浪邮箱的设置里POP3&#x2F;SMTP功能开启，并启用授权码。</p>
<p>通过Maven导入spring-boot-starter-mail的包</p>
<h2 id="2-书写配置文件参数"><a href="#2-书写配置文件参数" class="headerlink" title="2.书写配置文件参数"></a>2.书写配置文件参数</h2><p>然后配置邮箱参数，在resources-application.properties中配置参数，具体参数如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MailProperties</span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.sina.com</span></span><br><span class="line"><span class="comment">#spring.mail.port=465</span></span><br><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">ryn2020@sina.com</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=<span class="string">21ad95cfc6c4b05e    #这里是新浪邮箱的授权码</span></span><br><span class="line"><span class="comment">#spring.mail.protocol=smtps</span></span><br><span class="line"><span class="comment">#spring.mail.properties.mail.smtp.ssl.enable=true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtl.auth</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtl.starttls.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtl.starttls.required</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h2 id="3-创建工具类MailClient"><a href="#3-创建工具类MailClient" class="headerlink" title="3.创建工具类MailClient"></a>3.创建工具类MailClient</h2><p>然后去util包下创建一个工具类MailClient，该工具类将发邮件的任务委托给新浪邮箱去完成，相当于客户端</p>
<p>该类我们要加上@Component注解，成为一个Bean。</p>
<p>先声明一个日志，后面操作要记录日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MailClient.class);</span><br></pre></td></tr></table></figure>

<p>然后<strong>注入Spring的核心组件</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JavaMailSender mailSender;</span><br></pre></td></tr></table></figure>

<p>因为每次系统邮箱，也就是发件人都是一样的，所以我们<strong>将发件人地址注入Spring中</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span><span class="comment">//这里是配置文件中参数</span></span><br><span class="line"><span class="keyword">private</span> String from;</span><br></pre></td></tr></table></figure>

<p>接下来定义发送的方法，我们只需要收件人，邮件主题和内容即可，所以形参只有它们三个。</p>
<p>发邮件的关键就是<strong>把组件JavaMailSender中的MimeMessage邮件主体构建出来</strong>，用谁构建呢？帮助类MimeMessageHelper</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMail</span><span class="params">(String to, String subject, String content)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用核心组件JavaMailSender构建邮件主体message</span></span><br><span class="line">            <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">            <span class="comment">//用帮助类构建message</span></span><br><span class="line">            <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message);</span><br><span class="line">            <span class="comment">//向帮助类传入发件人，收件人，主体和html格式的内容</span></span><br><span class="line">            helper.setFrom(from);</span><br><span class="line">            helper.setTo(to);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            helper.setText(content, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//再回到核心组件JavaMailSender执行Send方法发送邮件</span></span><br><span class="line">            mailSender.send(helper.getMimeMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;发送邮件失败：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-7开发注册功能"><a href="#2-7开发注册功能" class="headerlink" title="2.7开发注册功能"></a>2.7开发注册功能</h1><h2 id="1-开发Controller层——访问注册页面"><a href="#1-开发Controller层——访问注册页面" class="headerlink" title="1.开发Controller层——访问注册页面"></a>1.开发Controller层——访问注册页面</h2><p>直接开发控制层，设置一个跳转页面。跳转到site下的register</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518210741410.png" alt="image-20220518210741410"></p>
<h2 id="2-开发随机字符生成和加密方法——CommunityUtil工具类"><a href="#2-开发随机字符生成和加密方法——CommunityUtil工具类" class="headerlink" title="2.开发随机字符生成和加密方法——CommunityUtil工具类"></a>2.开发随机字符生成和加密方法——CommunityUtil工具类</h2><p>导入这个包，主要目的是<strong>判断一些数据、字符串、集合空值的</strong>情况，后面会用到。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518211922078.png" alt="image-20220518211922078"></p>
<p>接下来去配置文件把域名配置好，其实现在就是<strong>本机地址</strong>，因为<strong>发邮件</strong>要写上目标地址要作为链接地址</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518212611807.png" alt="image-20220518212611807"></p>
<p>因为注册要生成激活码，所以我们最好定义一个<strong>专门的方法用来生成随机字符串</strong>。而且将来上传头像，上传文件等，也要给这些资源生成随机名字，也需要这个工具。UUID.randomUUID就是<strong>Java自带的生成随机字符的方法</strong>，不过可能有“-”，所以要用空格替换。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518213026318.png" alt="image-20220518213026318"></p>
<p>另外注册的时候上传的<strong>密码是明文的，我们需要MD5加密</strong>。</p>
<p>为了防止一些<strong>简单字符串</strong>每次加密后的字符都一样，所以我们也可以看到数据库表中有盐salt，也就是<strong>每次给密码加盐</strong>，也就是<strong>加随机字符串</strong>，这样就避免密码的盗取。</p>
<p>加密是<strong>Spring自带的工具类DigestUtils</strong>的方法，加密前，我们用<strong>前面导入的lang3包对字符串先进性判空操作</strong>，非空字符串我们再加密（要求16进制的byte类型，所以要转一下）。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518213714266.png" alt="image-20220518213714266"></p>
<h2 id="3-开发Service层——UserService实现注册业务逻辑"><a href="#3-开发Service层——UserService实现注册业务逻辑" class="headerlink" title="3.开发Service层——UserService实现注册业务逻辑"></a>3.开发Service层——UserService实现注册业务逻辑</h2><p>因为注册要发邮件，所以把邮件注入进来，也注入模板引擎，后面要用。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518214006254.png" alt="image-20220518214006254"></p>
<p>然后还需要用到<strong>域名和项目名</strong>，也注入进来</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518214038726.png" alt="image-20220518214038726"></p>
<p>开始写注册业务方法，因为返回值要<strong>包括好多“报错信息”，所以我们用Map</strong>，注册需要用户传入账号，密码和邮箱，所以我们传入一个User。</p>
<p>首先对形参user进行空值判断，如果<strong>是空则报异常（注意不是报错</strong>）。然后是user的具体信息，如果哪个空了，就把哪个错误记录在map里面，返回给用户看。</p>
<p>如果都不空，还要验证邮箱和用户名是不是数据库里面已经有了，所以还要<strong>有验证操作</strong>。</p>
<p>然后才开始注册用户：</p>
<p>1）先<strong>设置盐</strong>，用随机生成字符串的方法</p>
<p>2）给密码<strong>加盐</strong></p>
<p>3）设置<strong>用户类型，激活状态</strong>，然后<strong>设置激活码</strong>（还是随机生成）</p>
<p>4）给用户<strong>设置默认头像</strong>，用牛客网默认的1000个头像中随机一个</p>
<p>5）最后给用户设置一个<strong>账号创建时间</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">register</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空值处理</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不能为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(user.getUsername()))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;账号不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(user.getPassword()))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;passwordMsg&quot;</span>, <span class="string">&quot;密码不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(user.getEmail()))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;emailMsg&quot;</span>, <span class="string">&quot;邮箱不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;<span class="comment">//这个地方第一次忘记写了，导致邮箱重复仍旧注册账户，注册后才提示邮箱重复</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证账号</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> userMapper.selectByName(user.getUsername());</span><br><span class="line">    <span class="keyword">if</span>(u != <span class="literal">null</span>)&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;该账号已存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证邮箱</span></span><br><span class="line">    u = userMapper.selectByEmail(user.getEmail());</span><br><span class="line">    <span class="keyword">if</span>(u != <span class="literal">null</span>)&#123;</span><br><span class="line">        map.put(<span class="string">&quot;emailMsg&quot;</span>, <span class="string">&quot;该邮箱已被注册&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册用户</span></span><br><span class="line">    user.setSalt(CommunityUtil.generateUUID().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">    user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt()));</span><br><span class="line">    user.setType(<span class="number">0</span>);</span><br><span class="line">    user.setStatus(<span class="number">0</span>);</span><br><span class="line">    user.setActivationCode(CommunityUtil.generateUUID());</span><br><span class="line">    user.setHeaderUrl(String.format(<span class="string">&quot;http://images.nowcoder.com/head/%dt.png&quot;</span>, <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>)));</span><br><span class="line">    user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">    userMapper.insertUser(user);<span class="comment">//这里因为我们配置文件要求mybatis自动生成id，所以不需要我们显示为id赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//激活邮件</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();<span class="comment">//这里的Context类属于org.thymeleaf.context的Context</span></span><br><span class="line">    context.setVariable(<span class="string">&quot;email&quot;</span>, user.getEmail());</span><br><span class="line">    <span class="comment">// http://localhost:8080/community/activation/101/code</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> domain + contextPath + <span class="string">&quot;/activation/&quot;</span> + user.getId() + <span class="string">&quot;/&quot;</span> + user.getActivationCode();</span><br><span class="line">    context.setVariable(<span class="string">&quot;url&quot;</span>, url);</span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> templateEngine.process(<span class="string">&quot;/mail/activation&quot;</span>, context);</span><br><span class="line">    mailClient.sendMail(user.getEmail(), <span class="string">&quot;激活账号&quot;</span>, content);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-开发Controller层——LoginController处理注册请求"><a href="#4-开发Controller层——LoginController处理注册请求" class="headerlink" title="4.开发Controller层——LoginController处理注册请求"></a>4.开发Controller层——LoginController处理注册请求</h2><p>先把前面开发的UserService业务层注入进来</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518221058302.png" alt="image-20220518221058302"></p>
<p>定义一个方法<strong>处理注册请求</strong>，浏览器要向服务器提交数据，肯定是POST请求</p>
<p>其实就是用业务层的map，如果<strong>map为空我们就可以发激活码</strong>了，表明成功，跳转到成功页面，然后过8秒跳到首页；如果map不为空，说明验证失败，就重新跳转到注册页面，并<strong>通过前端提示后端map传来的错误信息</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/register&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(Model model,User user)</span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = userService.register(user);</span><br><span class="line">    <span class="keyword">if</span>(map == <span class="literal">null</span> || map.isEmpty())&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;注册成功，我们已经向您的邮箱发送了一封激活邮件，请尽快激活！&quot;</span>);</span><br><span class="line">        <span class="comment">//倒计时之后要跳转到首页</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;target&quot;</span>, <span class="string">&quot;/index&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/operate-result&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;usernameMsg&quot;</span>, map.get(<span class="string">&quot;usernameMsg&quot;</span>));</span><br><span class="line">        model.addAttribute(<span class="string">&quot;passwordMsg&quot;</span>, map.get(<span class="string">&quot;passwordMsg&quot;</span>));</span><br><span class="line">        model.addAttribute(<span class="string">&quot;emailMsg&quot;</span>, map.get(<span class="string">&quot;emailMsg&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/register&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-定义常量接口——CommunityConstant"><a href="#5-定义常量接口——CommunityConstant" class="headerlink" title="5.定义常量接口——CommunityConstant"></a>5.定义常量接口——CommunityConstant</h2><p>该接口专门定义一些常量，后面哪个类需要用到这些常量直接实现这些接口即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommunityConstant</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 激活成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ACTIVATION_SUCCESS</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重复激活</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ACTIVATION_REPEAT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 激活失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ACTIVATION_FAILURE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-开发Service层——还是UserService处理激活账号业务"><a href="#6-开发Service层——还是UserService处理激活账号业务" class="headerlink" title="6.开发Service层——还是UserService处理激活账号业务"></a>6.开发Service层——还是UserService处理激活账号业务</h2><p>一共有三种结果：激活成功，重复激活，激活失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">activation</span><span class="params">(<span class="type">int</span> userId, String code)</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(userId);</span><br><span class="line">    <span class="keyword">if</span>(user.getStatus() == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ACTIVATION_REPEAT;<span class="comment">//如果用户状态已经为1，说明当前是重复激活</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(user.getActivationCode().equals(code))&#123;</span><br><span class="line">        userMapper.updateStatus(userId, <span class="number">1</span>);<span class="comment">//如果用户状态不为1，而且当前激活码满足条件，就把状态设为1</span></span><br><span class="line">        <span class="keyword">return</span> ACTIVATION_SUCCESS;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ACTIVATION_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-开发激活控制层Controller——还是LoginController"><a href="#7-开发激活控制层Controller——还是LoginController" class="headerlink" title="7.开发激活控制层Controller——还是LoginController"></a>7.开发激活控制层Controller——还是LoginController</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://localhost:8080/community/activation/101/code</span></span><br><span class="line">  <span class="meta">@RequestMapping(path = &quot;/activation/&#123;userId&#125;/&#123;code&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">activation</span><span class="params">(Model model, <span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="type">int</span> userId, <span class="meta">@PathVariable(&quot;code&quot;)</span> String code)</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userService.activation(userId, code);</span><br><span class="line">      <span class="comment">//激活成功了就返回登录页面</span></span><br><span class="line">      <span class="keyword">if</span>(result == ACTIVATION_SUCCESS)&#123;</span><br><span class="line">          model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;激活成功，您的账号已经可以正常使用了！&quot;</span>);</span><br><span class="line">          model.addAttribute(<span class="string">&quot;target&quot;</span>, <span class="string">&quot;/login&quot;</span>);</span><br><span class="line">      <span class="comment">//重复激活或失败了都返回主页</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result == ACTIVATION_REPEAT)&#123;</span><br><span class="line">          model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;无效操作，该账号已经激活过了！&quot;</span>);</span><br><span class="line">          model.addAttribute(<span class="string">&quot;target&quot;</span>, <span class="string">&quot;/index&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;激活失败，您提供的激活码不正确！&quot;</span>);</span><br><span class="line">          model.addAttribute(<span class="string">&quot;target&quot;</span>, <span class="string">&quot;/index&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;/site/operate-result&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>因为激活方法中返回登陆页面，我们还没写登陆页面的方法，所以下面写getLogin方法</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519161309172.png" alt="image-20220519161309172"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>注册功能的实现肯定底层逻辑是先验证当前的用户名，密码和邮箱<strong>是否合法</strong>（包括空值和是否在库的情况）。通过了这些合法性验证，我们就可以<strong>给用户的信息存储到数据库</strong>中，但是存储过程中，我们需要<strong>给用户的密码加密</strong>，否则很容易被盗。所以我们需要写个工具专门给字符串进行加密。但是加密操作如md5对简单字符串加密是对称加密，所以我们还需要在这些<strong>密码的基础上加点salt</strong>，这些salt我们用随机字符串来表示。所以还需要写个生成随机字符串的方法，我们<strong>用lang3包下的工具类</strong>对这个字符串进行<strong>判空</strong>操作。注册完成之后，就可以通过系统邮箱发邮件和激活码了，激活码我们也用随机字符串方法生成。OK，注册业务逻辑写完（伴随工具类的开发）。</p>
<p>注册业务逻辑写完了，控制层就可以调用该方法了，业务中报的错误我们都传给model，由<strong>model传给前端</strong>，然后<strong>跳转到注册页面并报错</strong>；如果没错，我们就<strong>跳到激活页面</strong>，倒计时之后<strong>转到首页</strong>。</p>
<p>激活完了有三种情况：成功，失败和重复激活。我们把这仨情况写到常量接口中，<strong>后面业务层和控制层要复用</strong>。然后写业务逻辑，说白了就是三种情况我们分别要干什么，<strong>后面控制层收到才可以进一步操作</strong>。处理完了就可以写控制层，根据激活业务<strong>返回的激活状态</strong>，将<strong>激活信息传给model</strong>，并<strong>确定每种情况要返回的页面</strong>。</p>
<h1 id="2-17-生成验证码"><a href="#2-17-生成验证码" class="headerlink" title="2.17 生成验证码"></a>2.17 生成验证码</h1><h2 id="1-导入Kaptcha包"><a href="#1-导入Kaptcha包" class="headerlink" title="1.导入Kaptcha包"></a>1.导入Kaptcha包</h2><p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519185233228.png" alt="image-20220519185233228"></p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519185721410.png" alt="image-20220519185721410"></p>
<h2 id="2-将kaptcha注入Spring容器——KaptchaConfig"><a href="#2-将kaptcha注入Spring容器——KaptchaConfig" class="headerlink" title="2.将kaptcha注入Spring容器——KaptchaConfig"></a>2.将kaptcha注入Spring容器——KaptchaConfig</h2><p>在config包下写配置类KaptchaConfig，<strong>通过配置类Properties直接写入验证码的参数</strong>：如宽度，高度，字体大小，颜色，字符范围，字符数量，干扰项。然后把配置类信息<strong>赋予kaptcha的Config类</strong>，然后<strong>传给DefaultKaptcha类</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KaptchaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Producer <span class="title function_">kaptchaProducer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.width&quot;</span>, <span class="string">&quot;100&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.height&quot;</span>, <span class="string">&quot;40&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.size&quot;</span>, <span class="string">&quot;32&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.color&quot;</span>, <span class="string">&quot;0,0,0&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.string&quot;</span>, <span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.length&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.noise.impl&quot;</span>, <span class="string">&quot;com.google.code.kaptcha.impl.NoNoise&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DefaultKaptcha</span> <span class="variable">kaptcha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultKaptcha</span>();</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>(properties);</span><br><span class="line">        kaptcha.setConfig(config);</span><br><span class="line">        <span class="keyword">return</span> kaptcha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Controller层——LoginController生成验证码的方法"><a href="#3-开发Controller层——LoginController生成验证码的方法" class="headerlink" title="3.开发Controller层——LoginController生成验证码的方法"></a>3.开发Controller层——LoginController生成验证码的方法</h2><p>接下来就要把验证码应用到登录功能中，没有业务逻辑（与数据库交互），所以直接写控制层逻辑。</p>
<p>写在哪呢，访问登录页面的方法会返回一个html页面（<u>&#x2F;site&#x2F;login</u>），<strong>此页面中有访问验证码的路径</strong>，浏览器<strong>通过该路径访问服务器</strong>，才获得验证码图片。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519201235211.png" alt="image-20220519201235211"></p>
<p>因为我们要访问一个特殊的数据——图片，所以不设置返回值，直接通过response手动地向浏览器输出，同时也要把验证码的字符串内容存入服务器端session（存在浏览器端cookie容易被盗取）。最后不要忘了<strong>注入刚刚写的配置类kaptchaProducer</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/kaptcha&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getKaptcha</span><span class="params">(HttpServletResponse response, HttpSession session)</span>&#123;</span><br><span class="line">    <span class="comment">//生成验证码</span></span><br><span class="line">    <span class="comment">//生成验证码字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> kaptchaProducer.createText();</span><br><span class="line">    <span class="comment">//生成验证码图片</span></span><br><span class="line">    <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> kaptchaProducer.createImage(text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将验证码存入session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;kaptcha&quot;</span>, text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将图片输出给浏览器</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取response输出流（字节流）向浏览器响应</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">//用javax工具类输出图片</span></span><br><span class="line">        ImageIO.write(image, <span class="string">&quot;png&quot;</span>, os);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;响应验证码失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-23-开发登录、退出功能"><a href="#2-23-开发登录、退出功能" class="headerlink" title="2.23 开发登录、退出功能"></a>2.23 开发登录、退出功能</h1><p>大纲如下：</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519204318213.png" alt="image-20220519204318213" style="zoom:50%;" />

<h2 id="1-创建实体类entity——LoginTicket"><a href="#1-创建实体类entity——LoginTicket" class="headerlink" title="1.创建实体类entity——LoginTicket"></a>1.创建实体类entity——LoginTicket</h2><p>我们把登录的用户信息单独存在一张数据库表里，字段分别有序号id, 用户序号user_id, 登陆凭证ticket, 用户登陆状态status, 用户登录过期时间expired</p>
<h2 id="2-开发DAO数据访问层——LoginTicketMapper"><a href="#2-开发DAO数据访问层——LoginTicketMapper" class="headerlink" title="2.开发DAO数据访问层——LoginTicketMapper"></a>2.开发DAO数据访问层——LoginTicketMapper</h2><p>插入一条数据，<strong>根据登陆凭证ticket查询数据</strong>，<strong>根据ticket更新登录状态</strong>（失效，有效）</p>
<p>上次用的xml的格式写的sql，本次<strong>用注解的方式</strong>写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoginTicketMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&#123;</span></span><br><span class="line"><span class="meta">            &quot;insert into login_ticket(user_id,ticket,status,expired) &quot;,</span></span><br><span class="line"><span class="meta">            &quot;values(#&#123;userId&#125;,#&#123;ticket&#125;,#&#123;status&#125;,#&#123;expired&#125;)&quot;</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span><span class="comment">//设置id是自增的</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertLoginTicket</span><span class="params">(LoginTicket loginTicket)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&#123;</span></span><br><span class="line"><span class="meta">            &quot;select id,user_id,ticket,status,expired &quot;,</span></span><br><span class="line"><span class="meta">            &quot;from login_ticket where ticket=#&#123;ticket&#125;&quot;</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    LoginTicket <span class="title function_">selectByTicket</span><span class="params">(String ticket)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&#123;</span></span><br><span class="line"><span class="meta">            &quot;update login_ticket set status=#&#123;status&#125; where ticket=#&#123;ticket&#125;&quot;</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateStatus</span><span class="params">(<span class="meta">@Param(&quot;ticket&quot;)</span> String ticket, <span class="meta">@Param(&quot;status&quot;)</span> <span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Service层——登录业务UserService"><a href="#3-开发Service层——登录业务UserService" class="headerlink" title="3.开发Service层——登录业务UserService"></a>3.开发Service层——登录业务UserService</h2><p>先把刚才的LoginTicketMapper组件注入进来，然后再开始实现登录功能。因为登录也会像注册一样，可能有很多报错，所以<strong>返回值为Map类型数据用来存储报错信息</strong>。</p>
<p>另外，登录功能可以肯定的是<strong>需要我们传入用户名和密码，还有过期时间也要传入</strong>，这个容易忘记！！！</p>
<p>具体功能和注册功能的业务逻辑很像，首先判断空值，然后验证合法性（<strong>注意密码要加salt</strong>），都通过了就生成登陆凭证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">login</span><span class="params">(String username, String password, <span class="type">int</span> expiredSeconds)</span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空值处理</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(username))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;账号不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(password))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;passwordMsg&quot;</span>, <span class="string">&quot;密码不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证账号</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectByName(username);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;该账号不存在！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证状态（注册后有没有激活）</span></span><br><span class="line">    <span class="keyword">if</span>(user.getStatus() == <span class="number">0</span>)&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;该账号未激活！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证密码</span></span><br><span class="line">    password = CommunityUtil.md5(password + user.getSalt());</span><br><span class="line">    <span class="keyword">if</span>(!user.getPassword().equals(password))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;passwordMsg&quot;</span>, <span class="string">&quot;密码不正确！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成登录凭证</span></span><br><span class="line">    <span class="type">LoginTicket</span> <span class="variable">loginTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginTicket</span>();</span><br><span class="line">    loginTicket.setUserId(user.getId());</span><br><span class="line">    loginTicket.setTicket(CommunityUtil.generateUUID());</span><br><span class="line">    loginTicket.setStatus(<span class="number">0</span>);</span><br><span class="line">    loginTicket.setExpired(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expiredSeconds * <span class="number">1000</span>));</span><br><span class="line">    loginTicketMapper.insertLoginTicket(loginTicket);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以传入loginTicket整个对象，但没必要，我们只需要登陆凭证，其他的登录信息可以用凭证去库里查</span></span><br><span class="line">    map.put(<span class="string">&quot;ticket&quot;</span>, loginTicket.getTicket());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-开发Controller——登录功能login"><a href="#4-开发Controller——登录功能login" class="headerlink" title="4.开发Controller——登录功能login"></a>4.开发Controller——登录功能login</h2><p>这里返回页面也是&#x2F;login，不会与前面的返回&#x2F;login页面的方法冲突是因为，<strong>前面是get请求，当前方法是post请求。</strong></p>
<p>传入的参数分别有用户名，密码，因为<strong>要与页面直接交互</strong>了，所以还有<strong>验证码code</strong>，因为<strong>验证码要去session中取</strong>，所以要有Session session，另外还有<strong>页面上的选框“记住我”rememberme</strong>，如果登录成功，要<strong>将ticket登陆凭证存入浏览器的cookie</strong>中，所以要用response接收，最后别忘了Model <strong>model</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/login&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password, String code, <span class="type">boolean</span> rememberme,</span></span><br><span class="line"><span class="params">                    Model model, HttpSession session, HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="comment">//检查验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">kaptcha</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;kaptcha&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code))&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;codeMsg&quot;</span>, <span class="string">&quot;验证码不正确！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/login&quot;</span>;<span class="comment">//回到登录页面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查账号，密码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expiredSeconds</span> <span class="operator">=</span> rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;</span><br><span class="line">    Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds);</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(<span class="string">&quot;ticket&quot;</span>))&#123;</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;ticket&quot;</span>, map.get(<span class="string">&quot;ticket&quot;</span>).toString());</span><br><span class="line">        <span class="comment">//生成cookie有效路径</span></span><br><span class="line">        cookie.setPath(contextPath);</span><br><span class="line">        <span class="comment">//设置cookie有效时间</span></span><br><span class="line">        cookie.setMaxAge(expiredSeconds);</span><br><span class="line">        <span class="comment">//将cookie加入到response中，响应时就会将cookie发送给浏览器</span></span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;usernameMsg&quot;</span>, map.get(<span class="string">&quot;usernameMsg&quot;</span>));</span><br><span class="line">        model.addAttribute(<span class="string">&quot;passwordMsg&quot;</span>, map.get(<span class="string">&quot;passwordMsg&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在“记住我”选框判断的时候，需要利用<strong>常量接口中</strong>的两个属性，要记得在接口中加上：</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519215357488.png" alt="image-20220519215357488" style="zoom: 67%;" />

<h2 id="5-开发Service层——退出业务logout"><a href="#5-开发Service层——退出业务logout" class="headerlink" title="5.开发Service层——退出业务logout"></a>5.开发Service层——退出业务logout</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(String ticket)</span>&#123;<span class="comment">//传入凭证即可</span></span><br><span class="line">    loginTicketMapper.updateStatus(ticket, <span class="number">1</span>);<span class="comment">//将用户状态改为1即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-开发Controller层——退出功能logout"><a href="#6-开发Controller层——退出功能logout" class="headerlink" title="6.开发Controller层——退出功能logout"></a>6.开发Controller层——退出功能logout</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/logout&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">logout</span><span class="params">(<span class="meta">@CookieValue(&quot;ticket&quot;)</span> String ticket)</span>&#123;</span><br><span class="line">    userService.logout(ticket);</span><br><span class="line">    <span class="comment">//重定向到登陆页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/login&quot;</span>;<span class="comment">//重定向默认是GET请求的/login</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-27-显示登录信息（头部信息）"><a href="#2-27-显示登录信息（头部信息）" class="headerlink" title="2.27 显示登录信息（头部信息）"></a>2.27 显示登录信息（头部信息）</h1><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220520165750148.png" alt="image-20220520165750148" style="zoom: 67%;" />

<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220520170844188.png" alt="image-20220520170844188"></p>
<p>以上的过程我们通过拦截器来实现。</p>
<h2 id="1-开发Controller——LoginTicketInterceptor拦截器"><a href="#1-开发Controller——LoginTicketInterceptor拦截器" class="headerlink" title="1.开发Controller——LoginTicketInterceptor拦截器"></a>1.开发Controller——LoginTicketInterceptor拦截器</h2><p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220521193636861.png" alt="image-20220521193636861"></p>
<p>所在包及类的位置如图所示</p>
<p>该类首先要注入Spring容器中，然后实现HandlerInterceptor接口，该接口有三个默认方法用于我们对数据的拦截操作。</p>
<p>第一步自然是在请求之前通过cookie得到ticket，所以重写preHandle()，因为接口方法的形参我们不能随便改动，preHandle有形参request，我们需要<strong>专门写一个工具类来封装从request中获取cookie的操作（1.1）</strong>。</p>
<p>除此之外，获得cookie之后，我们就可以<strong>从cookie中获得ticket（1.2）</strong>了，这也需要我们专门开发业务层<strong>查询ticket</strong>的逻辑。</p>
<p>当我们用ticket获取到用户身份后，需要根据用户来查询用户信息，并暂存在内存中的，方便我们在页面模板中使用，因为每次请求都会建立一个线程，<strong>浏览器对服务器是一对多的并发请求</strong>，所以我们要让<strong>每个当前线程持有该用户信息</strong>。所以不能简单用session来存储，我们需要单独建立一个工具类<strong>HostHolder来持有用户信息（1.3）</strong>。然后通过hostHolder来暂存用户信息。</p>
<p>接下来我们就可以开发preHandle方法了；</p>
<p>然后请求过后，<strong>模板执行之前</strong>，我们执行postHandle，此时就该从hostHandle中获取用户信息了，然后传给modelAndView。</p>
<p>最后在模板结束后，清除线程暂存的user信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginTicketInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从cookie中获取凭证</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ticket</span> <span class="operator">=</span> CookieUtil.getValue(request, <span class="string">&quot;ticket&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ticket != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//查询凭证</span></span><br><span class="line">            <span class="type">LoginTicket</span> <span class="variable">loginTicket</span> <span class="operator">=</span> userService.findLoginTicket(ticket);</span><br><span class="line">            <span class="comment">//检查凭证是否有效(凭证存在，状态为0有效，没超时)</span></span><br><span class="line">            <span class="keyword">if</span>(loginTicket != <span class="literal">null</span> &amp;&amp; loginTicket.getStatus() == <span class="number">0</span> &amp;&amp; loginTicket.getExpired().after(<span class="keyword">new</span> <span class="title class_">Date</span>()))&#123;</span><br><span class="line">                <span class="comment">//根据凭证查询用户</span></span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(loginTicket.getUserId());</span><br><span class="line">                <span class="comment">//在本次请求中持有用户信息</span></span><br><span class="line">                hostHolder.setUser(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="literal">null</span> &amp;&amp; modelAndView != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将用户信息传给modelAndView，模板即可利用user信息</span></span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;loginUser&quot;</span>, user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">        hostHolder.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-开发工具类CookieUtil"><a href="#1-1-开发工具类CookieUtil" class="headerlink" title="1.1 开发工具类CookieUtil"></a>1.1 开发工具类CookieUtil</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getValue</span><span class="params">(HttpServletRequest request, String name)</span>&#123;</span><br><span class="line">        <span class="comment">//对request和请求的cookie名字做一个判空操作</span></span><br><span class="line">        <span class="keyword">if</span>(request == <span class="literal">null</span> || name == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取request中的cookie数组</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="comment">//遍历数组元素</span></span><br><span class="line">        <span class="keyword">if</span>(cookies != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Cookie cookie : cookies)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cookie.getName().equals(name))&#123;</span><br><span class="line">                    <span class="keyword">return</span> cookie.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-开发Service层——findLoginTicket（通过ticket查询数据库的ticket）"><a href="#1-2-开发Service层——findLoginTicket（通过ticket查询数据库的ticket）" class="headerlink" title="1.2 开发Service层——findLoginTicket（通过ticket查询数据库的ticket）"></a>1.2 开发Service层——findLoginTicket（通过ticket查询数据库的ticket）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LoginTicket <span class="title function_">findLoginTicket</span><span class="params">(String ticket)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loginTicketMapper.selectByTicket(ticket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-开发工具类HostHolder"><a href="#1-3-开发工具类HostHolder" class="headerlink" title="1.3 开发工具类HostHolder"></a>1.3 开发工具类HostHolder</h3><p>为了多个线程访问服务器没有冲突，我们可以用ThreadLocal来对线程进行隔离。该方法源码显示，set方法是获取当前线程，然后在该线程中创建一个map，把信息存到map中；而get方法是通过线程获取其自身的map来获得信息。因为<strong>每个线程的map不一样，进而实现了线程隔离</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HostHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂存用户信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        users.set(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取用户信息</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> users.get();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//清楚用户信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        users.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-开发配置类WebMvcConfig"><a href="#2-开发配置类WebMvcConfig" class="headerlink" title="2.开发配置类WebMvcConfig"></a>2.开发配置类WebMvcConfig</h2><p>将刚刚开发的拦截器注入，然后通过接口WebMvcConfigurer的方法addInterceptors()来将拦截器进行注册及配置。</p>
<p>注册很简单，调用注册器registry的addInterceptor方法即可。可以为拦截路径设限 -&gt; excludePathPatterns()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginTicketInterceptor loginTicketInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//除了静态资源都需要拦截</span></span><br><span class="line">        registry.addInterceptor(loginTicketInterceptor)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/**/*.png&quot;</span>, <span class="string">&quot;/**/*.jpg&quot;</span>, <span class="string">&quot;/**/*.jpeg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="疑问与解答"><a href="#疑问与解答" class="headerlink" title="疑问与解答"></a>疑问与解答</h2><p><u><strong>问</strong>：一是如果是首次登录的时候, cookie中还没有ticket, 也就会直接跳过preHandle中的代码, 然后直接进controller中的login方法, 最后返回给客户端一个含有ticket的cookie, 没有返回user对象, 所以是不是此时页面顶部并没有渲染到数据?</u></p>
<p><u>二是点击退出的登录的时候, 请求会先过preHandle方法, 此时cookie中还带有ticket, 并且因为还没有进controller中的方法, 所以ticket的状态没有被修改为1, 所以本次请求还是会持有user, 那这样走完controller中的方法返回后还是带有user数据, 那按理说页面顶部会错误判断成user !&#x3D; null, 但是最后演示的结果是正确的, 请问这是为什么呢?</u></p>
<p><strong>答</strong>：登陆成功、退出成功时，<strong>会进行重定向</strong>。届时，浏览器和服务器之间的<strong>连接被刷新</strong>了，经过重定向之后的结果页面，状态是OK的</p>
<h1 id="2-33-账号设置——上传头像"><a href="#2-33-账号设置——上传头像" class="headerlink" title="2.33 账号设置——上传头像"></a>2.33 账号设置——上传头像</h1><h2 id="1-访问账号设置页面——UserController"><a href="#1-访问账号设置页面——UserController" class="headerlink" title="1.访问账号设置页面——UserController"></a>1.访问账号设置页面——UserController</h2><p>访问页面的功能，没有业务，直接开发Controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">	<span class="comment">//访问账号设置页面</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/setting&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSettingPage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/setting&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-上传头像"><a href="#2-上传头像" class="headerlink" title="2.上传头像"></a>2.上传头像</h2><h3 id="2-1-配置头像存放路径"><a href="#2-1-配置头像存放路径" class="headerlink" title="2.1 配置头像存放路径"></a>2.1 配置头像存放路径</h3><p><strong>先放到本机服务器</strong>（这里一定要<strong>先在这个路径下创建一个文件夹</strong>，否则后面找不到指定路径资源），后期会上传到Linux系统的云服务器</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">community.path.upload</span>=<span class="string">d:/workspace_idea/data/upload</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-开发Service层——更改头像路径updateHeader"><a href="#2-2-开发Service层——更改头像路径updateHeader" class="headerlink" title="2.2 开发Service层——更改头像路径updateHeader"></a>2.2 开发Service层——更改头像路径updateHeader</h3><p>因为我们是将图片上传到服务器中，所以没有与数据库交互的操作，自然也就没有数据访问层DAO。</p>
<p>而我们上传图片后，用户的headerUrl路径就会发生改变，所以我们要开发业务层逻辑。</p>
<p>因为我们需要用SpringMVC提供的<strong>MultipartFile类来处理上传文件</strong>，所以业务层不上传头像，只改变用户头像路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateHeader</span><span class="params">(<span class="type">int</span> userId, String headerUrl)</span>&#123;</span><br><span class="line">    <span class="comment">//直接调用之前写的Mapper接口的updateHeader方法即可</span></span><br><span class="line">    <span class="keyword">return</span> userMapper.updateHeader(userId, headerUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Controller层——上传头像uploadHeader"><a href="#3-开发Controller层——上传头像uploadHeader" class="headerlink" title="3.开发Controller层——上传头像uploadHeader"></a>3.开发Controller层——上传头像uploadHeader</h2><p>1）先判断图片<strong>是否为空</strong></p>
<p>2）获取图片文件名，并<strong>截取其后缀</strong></p>
<p>3）生成随机文件名（<strong>随机字符串+后缀</strong>），调用<u>transferTo</u>方法<strong>存储图片</strong>至服务器</p>
<p>4）<strong>更新用户头像</strong>路径</p>
<p>5）<strong>重定向</strong>到首页</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/upload&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">uploadHeader</span><span class="params">(MultipartFile headerImage, Model model)</span>&#123;</span><br><span class="line">    <span class="comment">//对图片进行判空</span></span><br><span class="line">    <span class="keyword">if</span>(headerImage == <span class="literal">null</span>)&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;您还没有选择图片！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/setting&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> headerImage.getOriginalFilename();</span><br><span class="line">    <span class="comment">//截取文件后缀名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(suffix))&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;文件的格式不正确！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/setting&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成随机文件名</span></span><br><span class="line">    fileName = CommunityUtil.generateUUID() + suffix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定文件存放的路径</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadPath + <span class="string">&quot;/&quot;</span> + fileName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//存储文件transferTo方法即是MultiPartFile类的方法</span></span><br><span class="line">        headerImage.transferTo(dest);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;上传文件失败：&quot;</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;上传文件失败，服务器发生异常！&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新当前用户的头像的路径(web访问路径) 如下：</span></span><br><span class="line">    <span class="comment">//http://localhost:8080/community/user/header/xxx.png</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line">    <span class="type">String</span> <span class="variable">headerUrl</span> <span class="operator">=</span> domain + contextPath + <span class="string">&quot;/user/header/&quot;</span> + fileName;</span><br><span class="line"></span><br><span class="line">    userService.updateHeader(user.getId(), headerUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重定向的目的是刷新连接，不刷新头像还是原来的那个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-开发Controller层——获取头像getHeader"><a href="#4-开发Controller层——获取头像getHeader" class="headerlink" title="4.开发Controller层——获取头像getHeader"></a>4.开发Controller层——获取头像getHeader</h2><p>1）先获取头像图片<strong>在服务器中的位置</strong></p>
<p>2）<strong>获得图片后缀名</strong>，response要用</p>
<p>3）response响应图片，<strong>先设置响应的图片的格式</strong>为后缀名</p>
<p>4）由response创建<strong>输出流os</strong>，然后<strong>手动创建输入流fis</strong>，fis接收文件，os输出文件</p>
<p>5）<strong>关闭流资源</strong>，利用JDK 7新特性，将finally语句写入try()内，os可自动关，<strong>fis必须写进来</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/header/&#123;fileName&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHeader</span><span class="params">(<span class="meta">@PathVariable(&quot;fileName&quot;)</span> String fileName, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//获取服务器存放路径</span></span><br><span class="line">    fileName = uploadPath + <span class="string">&quot;/&quot;</span> + fileName;</span><br><span class="line">    <span class="comment">//获取文件后缀</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">//响应图片</span></span><br><span class="line">    <span class="comment">//设置响应图片的格式</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;image/&quot;</span> + suffix);</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">//写在()自动执行finally关闭流操作</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//response由SpringMVC管理，自动关闭输出流</span></span><br><span class="line">        	<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        	<span class="comment">//fis输入流是我们自行创建的，要手动关闭</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName);</span><br><span class="line">            ) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((b = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, b);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;读取头像失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-41-检查登陆状态"><a href="#2-41-检查登陆状态" class="headerlink" title="2.41 检查登陆状态"></a>2.41 检查登陆状态</h1><p>当用户<strong>没有登录的时候</strong>，虽然功能选项没有显示出来，但是<strong>网页还是可以照常访问</strong>，所以我们必须在用户访问这些网页的时候，服务端进行判断操作。</p>
<p>我们以下操作通过注解的方式实现，所以<strong>新建annotation注解package包</strong></p>
<h2 id="1-开发注解接口——LoginRequired"><a href="#1-开发注解接口——LoginRequired" class="headerlink" title="1.开发注解接口——LoginRequired"></a>1.开发注解接口——LoginRequired</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span><span class="comment">//声明该注解作用于方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//声明该注解在运行时才有效</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LoginRequired &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-标识需要拦截的方法——UserController中的方法"><a href="#2-标识需要拦截的方法——UserController中的方法" class="headerlink" title="2.标识需要拦截的方法——UserController中的方法"></a>2.标识需要拦截的方法——UserController中的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有登录了才能访问个人设置页面，所以该方法需要拦截</span></span><br><span class="line"><span class="meta">@LoginRequired</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/setting&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSettingPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/site/setting&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有登陆了才能上传头像，所以该方法需要拦截</span></span><br><span class="line"><span class="meta">@LoginRequired</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/upload&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">uploadHeader</span><span class="params">(MultipartFile headerImage, Model model)</span>&#123;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发拦截器——LoginRequiredInterceptor"><a href="#3-开发拦截器——LoginRequiredInterceptor" class="headerlink" title="3.开发拦截器——LoginRequiredInterceptor"></a>3.开发拦截器——LoginRequiredInterceptor</h2><p>开发拦截器判断标识了注解的方法有没有登录，没有登陆是不能访问这俩方法的。所以重写preHandle方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequiredInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//确保当前拦截的目标是方法类型的</span></span><br><span class="line">        <span class="keyword">if</span>(handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</span><br><span class="line">            <span class="comment">//获取拦截的method对象</span></span><br><span class="line">            <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> handlerMethod.getMethod();</span><br><span class="line">            <span class="comment">//从method对象中取方法的注解</span></span><br><span class="line">            <span class="type">LoginRequired</span> <span class="variable">loginRequired</span> <span class="operator">=</span> method.getAnnotation(LoginRequired.class);</span><br><span class="line">            <span class="comment">//访问到标识注解的方法了，但当前用户未登录</span></span><br><span class="line">            <span class="keyword">if</span>(loginRequired != <span class="literal">null</span> &amp;&amp; hostHolder.getUser() == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//重定向到登陆界面</span></span><br><span class="line">                response.sendRedirect(request.getContextPath() + <span class="string">&quot;/login&quot;</span>);</span><br><span class="line">                <span class="comment">//拒绝后续的请求</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-配置拦截器生效路径（排除静态资源）——WebMvcConfig"><a href="#4-配置拦截器生效路径（排除静态资源）——WebMvcConfig" class="headerlink" title="4.配置拦截器生效路径（排除静态资源）——WebMvcConfig"></a>4.配置拦截器生效路径（排除静态资源）——WebMvcConfig</h2><p>其实拦截器寻找带LoginRequired注解的方法已经是一种路径，但是我们还需要将一些静态资源的访问排除掉，所以我们要去WebMvcConfig中注册该拦截器进行配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginRequiredInterceptor loginRequiredInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(loginRequiredInterceptor)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/**/*.png&quot;</span>, <span class="string">&quot;/**/*.jpg&quot;</span>, <span class="string">&quot;/**/*.jpeg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-1-过滤敏感词"><a href="#3-1-过滤敏感词" class="headerlink" title="3.1 过滤敏感词"></a>3.1 过滤敏感词</h1><h2 id="1-创建敏感词文件——sensitive-words"><a href="#1-创建敏感词文件——sensitive-words" class="headerlink" title="1.创建敏感词文件——sensitive-words"></a>1.创建敏感词文件——sensitive-words</h2><p>可以把敏感词放到数据库里，也可以放到文件中。我们在resources目录下创建一个txt文本文件——sensitive-words</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220524163219968.png" alt="image-20220524163219968" style="zoom:50%;" />

<h2 id="2-开发工具类——SensitiveFilter"><a href="#2-开发工具类——SensitiveFilter" class="headerlink" title="2.开发工具类——SensitiveFilter"></a>2.开发工具类——SensitiveFilter</h2><h3 id="1）定义前缀树"><a href="#1）定义前缀树" class="headerlink" title="1）定义前缀树"></a>1）定义前缀树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义前缀树，因为该方法比较特殊，所以就设定为private内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键词结束标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isKeyWordEnd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子节点(key是下级节点的字符，value是下级节点)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, TrieNode&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isKeyWordEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isKeyWordEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKeyWordEnd</span><span class="params">(<span class="type">boolean</span> keyWordEnd)</span> &#123;</span><br><span class="line">        isKeyWordEnd = keyWordEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加子节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSubNode</span><span class="params">(Character c, TrieNode node)</span>&#123;</span><br><span class="line">        subNodes.put(c, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取子节点</span></span><br><span class="line">    <span class="keyword">public</span> TrieNode <span class="title function_">getSubNode</span><span class="params">(Character c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subNodes.get(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）构造初始化函数——将敏感词添加到前缀树中"><a href="#2）构造初始化函数——将敏感词添加到前缀树中" class="headerlink" title="2）构造初始化函数——将敏感词添加到前缀树中"></a>2）构造初始化函数——将敏感词添加到前缀树中</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//定义日志</span><br><span class="line">private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);</span><br><span class="line"></span><br><span class="line">//将敏感词替换成常量***</span><br><span class="line">private static final String REPLACEMENT = &quot;***&quot;;</span><br><span class="line"></span><br><span class="line">//根节点</span><br><span class="line">private TrieNode rootNode = new TrieNode();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当容器实例化SensitiveFilter以后/调用SensitiveFilter构造器(服务启动时)，本方法就被调用</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里getClass()方法会让路径寻址到target目录下的classes中</span></span><br><span class="line">    <span class="comment">//txt文本格式文件属于非class文件，需要Maven先clean再compile才能在target.classes目录中显示出来</span></span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;sensitive-words.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//将字符流转换为缓冲流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>((is)));</span><br><span class="line">    ) &#123;</span><br><span class="line">        String keyword;</span><br><span class="line">        <span class="comment">//每次缓冲流读取的词都放入变量keyword中</span></span><br><span class="line">        <span class="keyword">while</span>((keyword = reader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//添加前缀树</span></span><br><span class="line">            <span class="built_in">this</span>.addKeyword(keyword);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;加载敏感词文件失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加前缀树的addKeyword()逻辑比较复杂，我们单独写一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个敏感词添加到前缀树中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addKeyword</span><span class="params">(String keyword)</span>&#123;</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> rootNode;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; keyword.length();i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> keyword.charAt(i);</span><br><span class="line">        <span class="comment">//获得当前节点的子节点</span></span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">subNode</span> <span class="operator">=</span> tempNode.getSubNode(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前节点的子节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(subNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//初始化子节点</span></span><br><span class="line">            subNode = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            tempNode.addSubNode(c, subNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指向子节点，进入下一轮循环</span></span><br><span class="line">        tempNode = subNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到字符串的最后，设置结束标识</span></span><br><span class="line">        <span class="keyword">if</span>(i == keyword.length() - <span class="number">1</span>)&#123;</span><br><span class="line">            tempNode.setKeyWordEnd(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3）过滤敏感词方法"><a href="#3）过滤敏感词方法" class="headerlink" title="3）过滤敏感词方法"></a>3）过滤敏感词方法</h3><p>最后就是重头戏——filter()。</p>
<p>总体的思想就是：让指针1指向<strong>前缀树的根节点</strong>，然后指针2作为<strong>滑动窗口的开端</strong>，指针3<strong>每次从开端向后走</strong>。如果当前根节点的下一个节点的字符<strong>不等于</strong>当前开端的字符，那么指针2和指针3都向后走；如果当前根节点的下一个节点的字符<strong>等于</strong>当前开端的字符，就让指针2停在开端处，让指针3向后走，如果碰到了前缀树<strong>一个分支的叶子节点</strong>，就说明当前指针2与指针3之间的词为敏感词，替换为”三个*“；如果没碰到叶子节点，指针3就继续向后走，直到走到叶子节点或与<strong>前缀树的节点值不等</strong>为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤敏感词</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text 待过滤文本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 过滤后的文本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(text))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针1</span></span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> rootNode;</span><br><span class="line">    <span class="comment">//指针2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//指针3</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//结果</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(position &lt; text.length())&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> text.charAt(position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳过符号</span></span><br><span class="line">        <span class="keyword">if</span>(isSymbol(c))&#123;</span><br><span class="line">            <span class="comment">//若指针1处于根节点，将此符号计入结果，让指针2向下走一步</span></span><br><span class="line">            <span class="keyword">if</span>(tempNode == rootNode)&#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//无论符号在不在根节点，指针3都向下走一步</span></span><br><span class="line">            position++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不是符号，则检查下级节点</span></span><br><span class="line">        tempNode = tempNode.getSubNode(c);</span><br><span class="line">        <span class="keyword">if</span>(tempNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//以begin开头的字符串不是敏感词</span></span><br><span class="line">            sb.append(text.charAt(begin));</span><br><span class="line">            <span class="comment">//指针2、3进入下一个位置</span></span><br><span class="line">            position = ++begin;</span><br><span class="line">            <span class="comment">//指针1重新指向根节点</span></span><br><span class="line">            tempNode = rootNode;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tempNode.isKeyWordEnd())&#123;</span><br><span class="line">            <span class="comment">//发现敏感词，将begin~position字符串替换掉</span></span><br><span class="line">            sb.append(REPLACEMENT);</span><br><span class="line">            <span class="comment">//指针2、3进入下一个位置</span></span><br><span class="line">            begin = ++position;</span><br><span class="line">            <span class="comment">//指针3重新指向根节点</span></span><br><span class="line">            tempNode = rootNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//检查下一个字符</span></span><br><span class="line">            position++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将最后一批字符计入结果</span></span><br><span class="line">    sb.append(text.substring(begin));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-6-发布帖子"><a href="#3-6-发布帖子" class="headerlink" title="3.6 发布帖子"></a>3.6 发布帖子</h1><h2 id="1-开发DAO层——DiscussPostMapper"><a href="#1-开发DAO层——DiscussPostMapper" class="headerlink" title="1.开发DAO层——DiscussPostMapper"></a>1.开发DAO层——DiscussPostMapper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertDiscussPost</span><span class="params">(DiscussPost discussPost)</span>;</span><br></pre></td></tr></table></figure>

<p>然后在discusspost-mapper.xml把插入帖子的sql语句写出来</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.DiscussPostMapper&quot;</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span></span><br><span class="line">    user_id, title, content, type, status, create_time, comment_count, score</span><br><span class="line">	<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertDiscussPost&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;DiscussPost&quot;</span>&gt;</span></span><br><span class="line">        insert into discuss_post(<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>)</span><br><span class="line">        values(#&#123;userId&#125;,#&#123;title&#125;,#&#123;content&#125;,#&#123;type&#125;,#&#123;status&#125;,#&#123;createTime&#125;,#&#123;commentCount&#125;,#&#123;score&#125;)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-开发Service层——DiscussPostService"><a href="#2-开发Service层——DiscussPostService" class="headerlink" title="2.开发Service层——DiscussPostService"></a>2.开发Service层——DiscussPostService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscussPostService</span> &#123;    </span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SensitiveFilter sensitiveFilter;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addDiscussPost</span><span class="params">(DiscussPost post)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(post == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不能为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转义HTML标记符号</span></span><br><span class="line">        post.setTitle(HtmlUtils.htmlEscape(post.getTitle()));</span><br><span class="line">        post.setContent(HtmlUtils.htmlEscape(post.getContent()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//过滤敏感词</span></span><br><span class="line">        post.setTitle(sensitiveFilter.filter(post.getTitle()));</span><br><span class="line">        post.setTitle(sensitiveFilter.filter(post.getContent()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现插入帖子数据</span></span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.insertDiscussPost(post);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发CommunityUtil工具类——字符串转换为JSON格式"><a href="#3-开发CommunityUtil工具类——字符串转换为JSON格式" class="headerlink" title="3.开发CommunityUtil工具类——字符串转换为JSON格式"></a>3.开发CommunityUtil工具类——字符串转换为JSON格式</h2><p>因为我们的帖子内容都是字符串文本存入数据库的，但是在网页端显示的都是JSON格式的字符串，所以我们需要提供一个工具类，来实现字符串向JSON格式字符串的转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJSONString</span><span class="params">(<span class="type">int</span> code, String msg, Map&lt;String, Object&gt; map)</span>&#123;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    json.put(<span class="string">&quot;code&quot;</span>, code);<span class="comment">//向前端页面响应状态码</span></span><br><span class="line">    json.put(<span class="string">&quot;msg&quot;</span>, msg);<span class="comment">//向前端页面响应提示信息</span></span><br><span class="line">    <span class="keyword">if</span>(map != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            json.put(key, map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> json.toJSONString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJSONString</span><span class="params">(<span class="type">int</span> code, String msg)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSONString(code, msg, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJSONString</span><span class="params">(<span class="type">int</span> code)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSONString(code, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-开发Controller层——DiscussPostController"><a href="#4-开发Controller层——DiscussPostController" class="headerlink" title="4.开发Controller层——DiscussPostController"></a>4.开发Controller层——DiscussPostController</h2><p>控制层开发的时候要注意：我们返回给页面的是字符串，所以要<strong>使用@ResponseBody注解</strong>；先检查用户<strong>是否登录</strong>；登陆了就向数据库添加帖子。不要忘了<strong>给页面一个提示信息</strong>，提示成功。</p>
<p>如果报错的话，后面会统一处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/discuss&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscussPostController</span> <span class="keyword">implements</span> <span class="title class_">CommunityConstant</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/add&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addDiscussPost</span><span class="params">(String title, String content)</span>&#123;</span><br><span class="line">        <span class="comment">//先检查用户有没有登录</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">403</span>,<span class="string">&quot;你还没有登录哦！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加帖子</span></span><br><span class="line">        <span class="type">DiscussPost</span> <span class="variable">post</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiscussPost</span>();</span><br><span class="line">        post.setUserId(user.getId());</span><br><span class="line">        post.setTitle(title);</span><br><span class="line">        post.setContent(content);</span><br><span class="line">        post.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        discussPostService.addDiscussPost(post);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//报错的情况，将来统一处理</span></span><br><span class="line">        <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">0</span>,<span class="string">&quot;发布成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-11-帖子详情"><a href="#3-11-帖子详情" class="headerlink" title="3.11 帖子详情"></a>3.11 帖子详情</h1><h2 id="1-开发DAO层——DiscussPostMapper-1"><a href="#1-开发DAO层——DiscussPostMapper-1" class="headerlink" title="1.开发DAO层——DiscussPostMapper"></a>1.开发DAO层——DiscussPostMapper</h2><p>首先在数据访问层开发查询帖子（ById）的功能，然后在discusspost-mapper.xml写查询sql语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiscussPost <span class="title function_">selectDiscussPostById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDiscussPostById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;DiscussPost&quot;</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from discuss_post</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-开发Service层——DiscussPostService-1"><a href="#2-开发Service层——DiscussPostService-1" class="headerlink" title="2.开发Service层——DiscussPostService"></a>2.开发Service层——DiscussPostService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DiscussPost <span class="title function_">findDiscussPostById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> discussPostMapper.selectDiscussPostById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Controller层——DiscussPostController"><a href="#3-开发Controller层——DiscussPostController" class="headerlink" title="3.开发Controller层——DiscussPostController"></a>3.开发Controller层——DiscussPostController</h2><p>现在查询帖子详情其实只查询帖子对象本身和帖子对应的发布者。帖子真正的详情如评论，评论的评论，点赞，我们都放到后面去处理。所以本节<strong>只是查询帖子对象</strong>，以及根据对象去<strong>查询发布帖子的id对应的user</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/discuss&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscussPostController</span> <span class="keyword">implements</span> <span class="title class_">CommunityConstant</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/detail/&#123;discussPostId&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDiscussPost</span><span class="params">(<span class="meta">@PathVariable(&quot;discussPostId&quot;)</span> <span class="type">int</span> discussPostId, Model model)</span>&#123;</span><br><span class="line">        <span class="comment">//查询帖子</span></span><br><span class="line">        <span class="type">DiscussPost</span> <span class="variable">post</span> <span class="operator">=</span> discussPostService.findDiscussPostById(discussPostId);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;post&quot;</span>,post);</span><br><span class="line">        <span class="comment">//查询帖子的作者</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(post.getUserId());</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        </span><br><span class="line"> 		<span class="keyword">return</span> <span class="string">&quot;/site/discuss-detail&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-20-显示评论"><a href="#3-20-显示评论" class="headerlink" title="3.20 显示评论"></a>3.20 显示评论</h1><h2 id="1-认识comment数据库"><a href="#1-认识comment数据库" class="headerlink" title="1.认识comment数据库"></a>1.认识comment数据库</h2><p>comment数据库中含有id和user_id，这俩好理解，前者是序号，后者代表当前评论是谁发布的。</p>
<p>entity_type是评论类型，比如1代表对帖子的评论，2代表对评论的评论；</p>
<p><strong>entity_id就是帖子或者评论或者某个课程的id</strong>；</p>
<p>target_id是被评论的某个用户的id，content是帖子内容，status表示这个这个评论被禁用了，不可用了。creat_time是帖子发表时间。</p>
<h2 id="2-开发实体类——Comment"><a href="#2-开发实体类——Comment" class="headerlink" title="2.开发实体类——Comment"></a>2.开发实体类——Comment</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comment</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> userId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> entityType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> entityId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> targetId;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserId</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEntityType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> entityType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEntityType</span><span class="params">(<span class="type">int</span> entityType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.entityType = entityType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEntityId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> entityId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEntityId</span><span class="params">(<span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.entityId = entityId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTargetId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> targetId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTargetId</span><span class="params">(<span class="type">int</span> targetId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.targetId = targetId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreateTime</span><span class="params">(Date createTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Comment&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, userId=&quot;</span> + userId +</span><br><span class="line">                <span class="string">&quot;, entityType=&quot;</span> + entityType +</span><br><span class="line">                <span class="string">&quot;, entityId=&quot;</span> + entityId +</span><br><span class="line">                <span class="string">&quot;, targetId=&quot;</span> + targetId +</span><br><span class="line">                <span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, status=&quot;</span> + status +</span><br><span class="line">                <span class="string">&quot;, createTime=&quot;</span> + createTime +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发DAO层——CommentMapper"><a href="#3-开发DAO层——CommentMapper" class="headerlink" title="3.开发DAO层——CommentMapper"></a>3.开发DAO层——CommentMapper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommentMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据实体来查询评论：分为帖子的评论，评论的评论，课程的评论等....</span></span><br><span class="line">    List&lt;Comment&gt; <span class="title function_">selectCommentsByEntity</span><span class="params">(<span class="meta">@Param(&quot;entityType&quot;)</span> <span class="type">int</span> entityType, <span class="meta">@Param(&quot;entityId&quot;)</span> <span class="type">int</span> entityId, <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询具体某个实体的评论的总数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">selectCountByEntity</span><span class="params">(<span class="meta">@Param(&quot;entityType&quot;)</span> <span class="type">int</span> entityType, <span class="meta">@Param(&quot;entityId&quot;)</span> <span class="type">int</span> entityId)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在comment-mapper.xml中写对应的sql语句</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.CommentMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span></span><br><span class="line">        id, user_id, entity_type, entity_id, target_id, content, status, create_time</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectCommentsByEntity&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        from comment</span><br><span class="line">        where status = 0</span><br><span class="line">        and entity_type = #&#123;entityType&#125;</span><br><span class="line">        and entity_id = #&#123;entityId&#125;</span><br><span class="line">        order by create_time asc</span><br><span class="line">        limit #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectCountByEntity&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select count(id)</span><br><span class="line">        from comment</span><br><span class="line">        where status = 0</span><br><span class="line">        and entity_type = #&#123;entityType&#125;</span><br><span class="line">        and entity_id = #&#123;entityId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-开发Service层——CommentService"><a href="#4-开发Service层——CommentService" class="headerlink" title="4.开发Service层——CommentService"></a>4.开发Service层——CommentService</h2><p>将刚开发的CommentMapper注入进来，直接写出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentService</span> <span class="keyword">implements</span> <span class="title class_">CommunityConstant</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CommentMapper commentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Comment&gt; <span class="title function_">findCommentsByEntity</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commentMapper.selectCommentsByEntity(entityType, entityId, offset, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCommentCount</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commentMapper.selectCountByEntity(entityType, entityId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-开发Controller层——DiscussPostController"><a href="#5-开发Controller层——DiscussPostController" class="headerlink" title="5.开发Controller层——DiscussPostController"></a>5.开发Controller层——DiscussPostController</h2><p>因为评论就是在帖子内容的下方，所以我们的控制层不需要单独写一个方法，直接<strong>沿用帖子详情的方法</strong>即可。</p>
<p>因为数据库里有entity_type字段，指明了实体的类型，为了代码的阅读性，我们<strong>在常量接口创建以下两个常量</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommunityConstant</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实体类型：帖子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ENTITY_TYPE_POST</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实体类型：评论</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ENTITY_TYPE_COMMENT</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着向帖子详情功能的方法中添加内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping(path = &quot;/detail/&#123;discussPostId&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDiscussPost</span><span class="params">(<span class="meta">@PathVariable(&quot;discussPostId&quot;)</span> <span class="type">int</span> discussPostId, Model model, Page page)</span>&#123;</span><br><span class="line">        <span class="comment">//查询某个具体的帖子</span></span><br><span class="line">        <span class="type">DiscussPost</span> <span class="variable">post</span> <span class="operator">=</span> discussPostService.findDiscussPostById(discussPostId);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;post&quot;</span>,post);</span><br><span class="line">        <span class="comment">//查询该帖子的作者</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(post.getUserId());</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="comment">//为评论设置分页信息</span></span><br><span class="line">        page.setLimit(<span class="number">5</span>);</span><br><span class="line">        page.setPath(<span class="string">&quot;/discuss/detail/&quot;</span> + discussPostId);</span><br><span class="line">        page.setRows(post.getCommentCount());<span class="comment">//这里为了方便查询评论数量，我们在discuss_post数据库中存了commentCount变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//评论：给帖子的评论</span></span><br><span class="line">        <span class="comment">//回复：给评论的评论</span></span><br><span class="line">        <span class="comment">//获取相关评论信息(评论列表)</span></span><br><span class="line">        List&lt;Comment&gt; commentList = commentService.findCommentsByEntity(</span><br><span class="line">                ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建评论信息的显示对象(View object)的集合</span></span><br><span class="line">        <span class="comment">//泛型中的Comment和Map&lt;String, Object&gt;一一对应</span></span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; commentVoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(commentList != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Comment comment : commentList) &#123;</span><br><span class="line">                <span class="comment">//每个comment都用一个map来存储用于呈现给页面的数据</span></span><br><span class="line">                Map&lt;String, Object&gt; commentVo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                <span class="comment">//向评论VO添加评论和作者</span></span><br><span class="line">                commentVo.put(<span class="string">&quot;comment&quot;</span>, comment);</span><br><span class="line">                commentVo.put(<span class="string">&quot;user&quot;</span>, userService.findUserById(comment.getUserId()));</span><br><span class="line">                <span class="comment">//每个评论下面的回复列表（该列表就不分页了，有多少显示多少）</span></span><br><span class="line">                List&lt;Comment&gt; replyList = commentService.findCommentsByEntity(</span><br><span class="line">                        ENTITY_TYPE_COMMENT, comment.getId(), <span class="number">0</span>, Integer.MAX_VALUE);</span><br><span class="line">                <span class="comment">//创建回复信息的显示对象(View object)的集合</span></span><br><span class="line">                <span class="comment">//泛型中的Comment和Map&lt;String, Object&gt;一一对应</span></span><br><span class="line">                List&lt;Map&lt;String, Object&gt;&gt; replyVoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span>(replyList != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(Comment reply : replyList)&#123;</span><br><span class="line">                        <span class="comment">//一个回复的显示对象(View object)</span></span><br><span class="line">                        Map&lt;String, Object&gt; replyVo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                        <span class="comment">//向回复VO添加评论和作者</span></span><br><span class="line">                        replyVo.put(<span class="string">&quot;reply&quot;</span>, reply);</span><br><span class="line">                        replyVo.put(<span class="string">&quot;user&quot;</span>, userService.findUserById(reply.getUserId()));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//回复的目标</span></span><br><span class="line">                        <span class="type">User</span> <span class="variable">target</span> <span class="operator">=</span> reply.getTargetId() == <span class="number">0</span> ? <span class="literal">null</span> : userService.findUserById(reply.getTargetId());</span><br><span class="line">                        replyVo.put(<span class="string">&quot;target&quot;</span>, target);</span><br><span class="line">                        </span><br><span class="line">                        replyVoList.add(replyVo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//一定要把每个评论的replyVoList装进commentVo中</span></span><br><span class="line">                commentVo.put(<span class="string">&quot;replys&quot;</span>, replyVoList);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//记录每条评论下面回复的数量</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">replyCount</span> <span class="operator">=</span> commentService.findCommentCount(ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">                commentVo.put(<span class="string">&quot;replyCount&quot;</span>, replyCount);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//每一次遍历，都要将Map添加进集合中</span></span><br><span class="line">                commentVoList.add(commentVo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">&quot;comments&quot;</span>, commentVoList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/discuss-detail&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-22-添加评论"><a href="#3-22-添加评论" class="headerlink" title="3.22 添加评论"></a>3.22 添加评论</h1><h2 id="1-开发DAO层——CommentMapper"><a href="#1-开发DAO层——CommentMapper" class="headerlink" title="1.开发DAO层——CommentMapper"></a>1.开发DAO层——CommentMapper</h2><p>前两个方法是上一节的，<strong>第三个插入方法是本节的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommentMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据实体来查询评论：分为帖子的评论，评论的评论，课程的评论等....</span></span><br><span class="line">    List&lt;Comment&gt; <span class="title function_">selectCommentsByEntity</span><span class="params">(<span class="meta">@Param(&quot;entityType&quot;)</span> <span class="type">int</span> entityType, <span class="meta">@Param(&quot;entityId&quot;)</span> <span class="type">int</span> entityId, <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询具体某个实体的评论的总数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">selectCountByEntity</span><span class="params">(<span class="meta">@Param(&quot;entityType&quot;)</span> <span class="type">int</span> entityType, <span class="meta">@Param(&quot;entityId&quot;)</span> <span class="type">int</span> entityId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertComment</span><span class="params">(Comment comment)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在comment-mapper.xml中写sql</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.CommentMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span></span><br><span class="line">        user_id, entity_type, entity_id, target_id, content, status, create_time</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertComment&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="line">        insert into comment(<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>)</span><br><span class="line">        values(#&#123;userId&#125;,#&#123;entityType&#125;,#&#123;entityId&#125;,#&#123;targetId&#125;,#&#123;content&#125;,#&#123;status&#125;,#&#123;createTime&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-开发DAO层——DiscussPostMapper-1"><a href="#2-开发DAO层——DiscussPostMapper-1" class="headerlink" title="2.开发DAO层——DiscussPostMapper"></a>2.开发DAO层——DiscussPostMapper</h2><p>不要忘了discusspost数据库存了一个“相对冗余”的变量，即每个帖子的评论数量。所以要更新该库里每个帖子的评论数量（最后一个方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscussPostMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;DiscussPost&gt; <span class="title function_">selectDiscussPosts</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> <span class="type">int</span> userId, <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">selectDiscussPostRows</span><span class="params">(<span class="type">int</span> userId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertDiscussPost</span><span class="params">(DiscussPost discussPost)</span>;</span><br><span class="line"></span><br><span class="line">    DiscussPost <span class="title function_">selectDiscussPostById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">	<span class="comment">//更新帖子的评论数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateCommentCount</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id, <span class="meta">@Param(&quot;commentCount&quot;)</span> <span class="type">int</span> commentCount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在discusspost-mapper.xml写更新语句的sql：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.DiscussPostMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateCommentCount&quot;</span>&gt;</span></span><br><span class="line">        update discuss_post set comment_count = #&#123;commentCount&#125; where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-开发Service层——DiscussPostService"><a href="#3-开发Service层——DiscussPostService" class="headerlink" title="3.开发Service层——DiscussPostService"></a>3.开发Service层——DiscussPostService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscussPostService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把刚刚写的DAO层导进来就行了</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostMapper discussPostMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateCommentCount</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> commentCount)</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> discussPostMapper.updateCommentCount(id, commentCount);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-开发Service层——CommentService-1"><a href="#4-开发Service层——CommentService-1" class="headerlink" title="4.开发Service层——CommentService"></a>4.开发Service层——CommentService</h2><p>这个业务我们要明白：<strong>添加评论的同时，我们要在数据库更新一条评论</strong>。我们必须保证上述操作具有事务的一致性，原子性，所以我们要用Spring来声明该方法需要<strong>事务管理</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentService</span> <span class="keyword">implements</span> <span class="title class_">CommunityConstant</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CommentMapper commentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SensitiveFilter sensitiveFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostService discussPostService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addComment</span><span class="params">(Comment comment)</span>&#123;</span><br><span class="line">        <span class="comment">//评论是空的就抛异常</span></span><br><span class="line">        <span class="keyword">if</span>(comment == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不能为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先对评论comment进行符号和敏感词的过滤</span></span><br><span class="line">        comment.setContent(HtmlUtils.htmlEscape(comment.getContent()));</span><br><span class="line">        comment.setContent(sensitiveFilter.filter(comment.getContent()));</span><br><span class="line">        <span class="comment">//返回插入的行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> commentMapper.insertComment(comment);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新帖子的评论数量（评论的评论不算）</span></span><br><span class="line">        <span class="keyword">if</span>(comment.getEntityType() == ENTITY_TYPE_POST)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> commentMapper.selectCountByEntity(comment.getEntityType(), comment.getEntityId());</span><br><span class="line">            <span class="comment">//调用刚才写的业务逻辑，更新库里的帖子数量</span></span><br><span class="line">            discussPostService.updateCommentCount(comment.getEntityId(), count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-开发Controller层——CommentController"><a href="#5-开发Controller层——CommentController" class="headerlink" title="5.开发Controller层——CommentController"></a>5.开发Controller层——CommentController</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/comment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CommentService commentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/add/&#123;discussPostId&#125;&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addComment</span><span class="params">(<span class="meta">@PathVariable(&quot;discussPostId&quot;)</span> <span class="type">int</span> discussPostId, Comment comment)</span>&#123;</span><br><span class="line">        <span class="comment">//后面会有统一的异常处理，可以保证这里肯定是用户登陆的</span></span><br><span class="line">        comment.setUserId(hostHolder.getUser().getId());</span><br><span class="line">        <span class="comment">//保证评论是有效的</span></span><br><span class="line">        comment.setStatus(<span class="number">0</span>);</span><br><span class="line">        comment.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        commentService.addComment(comment);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//评论以后，要跳回当前具体的帖子详情页面，每个帖子都有一个discussPostId来对应</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/discuss/detail/&quot;</span> + discussPostId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-24-私信列表和私信详情"><a href="#3-24-私信列表和私信详情" class="headerlink" title="3.24 私信列表和私信详情"></a>3.24 私信列表和私信详情</h1><h2 id="1-创建实体类——Message"><a href="#1-创建实体类——Message" class="headerlink" title="1.创建实体类——Message"></a>1.创建实体类——Message</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> fromId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> toId;</span><br><span class="line">    <span class="keyword">private</span> String conversationId;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFromId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fromId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFromId</span><span class="params">(<span class="type">int</span> fromId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fromId = fromId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getToId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setToId</span><span class="params">(<span class="type">int</span> toId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.toId = toId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConversationId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> conversationId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConversationId</span><span class="params">(String conversationId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conversationId = conversationId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreateTime</span><span class="params">(Date createTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, fromId=&quot;</span> + fromId +</span><br><span class="line">                <span class="string">&quot;, toId=&quot;</span> + toId +</span><br><span class="line">                <span class="string">&quot;, conversationId=&#x27;&quot;</span> + conversationId + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, status=&quot;</span> + status +</span><br><span class="line">                <span class="string">&quot;, createTime=&quot;</span> + createTime +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-开发DAO层——MessageMapper"><a href="#2-开发DAO层——MessageMapper" class="headerlink" title="2.开发DAO层——MessageMapper"></a>2.开发DAO层——MessageMapper</h2><p>包括查询<strong>当前用户</strong>的会话列表和会话数量，<strong>某个会话</strong>的会话列表和会话数量，还有<strong>未读会话</strong>（包括<strong>所有未读</strong>和<strong>某条会话</strong>的未读）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前用户的会话列表，针对每个会话只返回最新的一条私信（根据userId查询）</span></span><br><span class="line">    List&lt;Message&gt; <span class="title function_">selectConversations</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> <span class="type">int</span> userId, <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前用户的会话数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">selectConversationCount</span><span class="params">(<span class="type">int</span> userId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个会话所包含的私信列表（根据conversationId查询）</span></span><br><span class="line">    List&lt;Message&gt; <span class="title function_">selectLetters</span><span class="params">(<span class="meta">@Param(&quot;conversationId&quot;)</span> String conversationId, <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个会话所包含的私信数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">selectLetterCount</span><span class="params">(String conversationId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询未读私信的数量（包括当前用户所有未读数量 和 某个会话的未读数量）</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">selectLetterUnreadCount</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> <span class="type">int</span> userId, <span class="meta">@Param(&quot;conversationId&quot;)</span> String conversationId)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写配置文件<strong>message-mapper.xml</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.MessageMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span></span><br><span class="line">        id, from_id, to_id, conversation_id, content, status, create_time</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span></span><br><span class="line">        from_id, to_id, conversation_id, content, status, create_time</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectConversations&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Message&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        from message</span><br><span class="line">        where id in (</span><br><span class="line">            select max(id) from message</span><br><span class="line">            where status != 2</span><br><span class="line">            and from_id != 1</span><br><span class="line">            and (from_id = #&#123;userId&#125; or to_id = #&#123;userId&#125;)</span><br><span class="line">            group by conversation_id</span><br><span class="line">        )</span><br><span class="line">        order by id desc</span><br><span class="line">        limit #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectConversationCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select count(m.maxid) from (</span><br><span class="line">            select max(id) as maxid from message</span><br><span class="line">            where status != 2</span><br><span class="line">            and from_id != 1</span><br><span class="line">            and (from_id = #&#123;userId&#125; or to_id = #&#123;userId&#125;)</span><br><span class="line">            group by conversation_id</span><br><span class="line">        ) as m</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectLetters&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Message&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        from message</span><br><span class="line">        where status != 2</span><br><span class="line">        and from_id != 1</span><br><span class="line">        and conversation_id = #&#123;conversationId&#125;</span><br><span class="line">        order by id desc</span><br><span class="line">        limit #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectLetterCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select count(id)</span><br><span class="line">        from message</span><br><span class="line">        where status != 2</span><br><span class="line">        and from_id != 1</span><br><span class="line">        and conversation_id = #&#123;conversationId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectLetterUnreadCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select count(id)</span><br><span class="line">        from message</span><br><span class="line">        where status = 0</span><br><span class="line">        and from_id != 1</span><br><span class="line">        and to_id = #&#123;userId&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;conversationId!=null&quot;</span>&gt;</span></span><br><span class="line">            and conversation_id = #&#123;conversationId&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-开发Service层——MessageService"><a href="#3-开发Service层——MessageService" class="headerlink" title="3.开发Service层——MessageService"></a>3.开发Service层——MessageService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageMapper messageMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Message&gt; <span class="title function_">findConversations</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageMapper.selectConversations(userId, offset, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findConversationCount</span><span class="params">(<span class="type">int</span> userId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageMapper.selectConversationCount(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Message&gt; <span class="title function_">findLetters</span><span class="params">(String conversationId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageMapper.selectLetters(conversationId, offset, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLetterCount</span><span class="params">(String conversationId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageMapper.selectLetterCount(conversationId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLetterUnreadCount</span><span class="params">(<span class="type">int</span> userId, String conversationId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageMapper.selectLetterUnreadCount(userId, conversationId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-开发Controller层——MessageController"><a href="#4-开发Controller层——MessageController" class="headerlink" title="4.开发Controller层——MessageController"></a>4.开发Controller层——MessageController</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私信列表</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/letter/list&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLetterList</span><span class="params">(Model model, Page page)</span>&#123;</span><br><span class="line">        <span class="comment">//后面形参需要获取当前用户user的id</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line">        <span class="comment">//分页信息</span></span><br><span class="line">        page.setLimit(<span class="number">5</span>);</span><br><span class="line">        page.setPath(<span class="string">&quot;/letter/list&quot;</span>);</span><br><span class="line">        page.setRows(messageService.findConversationCount(user.getId()));<span class="comment">//这里通过当前的用户user来获取当前user的id</span></span><br><span class="line">        <span class="comment">//会话列表</span></span><br><span class="line">        List&lt;Message&gt; conversationList = messageService.findConversations(</span><br><span class="line">                user.getId(), page.getOffset(), page.getLimit());</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; conversations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(conversationList != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Message message : conversationList)&#123;</span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                <span class="comment">//先把整个私信传入map</span></span><br><span class="line">                map.put(<span class="string">&quot;conversation&quot;</span>, message);</span><br><span class="line">                <span class="comment">//把私信数量传入map</span></span><br><span class="line">                map.put(<span class="string">&quot;letterCount&quot;</span>, messageService.findLetterCount(message.getConversationId()));</span><br><span class="line">                <span class="comment">//把未读私信数量传入map</span></span><br><span class="line">                map.put(<span class="string">&quot;unreadCount&quot;</span>, messageService.findLetterUnreadCount(user.getId(), message.getConversationId()));</span><br><span class="line">                <span class="comment">//要显示当前私信发起者的头像，所以要找到该对象的id</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">targetId</span> <span class="operator">=</span> user.getId() == message.getFromId() ? message.getToId() : message.getFromId();</span><br><span class="line">                map.put(<span class="string">&quot;target&quot;</span>, userService.findUserById(targetId));</span><br><span class="line"></span><br><span class="line">                conversations.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;conversations&quot;</span>, conversations);</span><br><span class="line">        <span class="comment">//查询当前用户的所有的未读消息数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">letterUnreadCount</span> <span class="operator">=</span> messageService.findLetterUnreadCount(user.getId(), <span class="literal">null</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;letterUnreadCount&quot;</span>, letterUnreadCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/letter&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//具体私信内容</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;letter/detail/&#123;conversationId&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLetterDetail</span><span class="params">(<span class="meta">@PathVariable(&quot;conversationId&quot;)</span> String conversationId, Page page, Model model)</span>&#123;</span><br><span class="line">        <span class="comment">//分页信息</span></span><br><span class="line">        page.setLimit(<span class="number">5</span>);</span><br><span class="line">        page.setPath(<span class="string">&quot;/letter/detail/&quot;</span> + conversationId);</span><br><span class="line">        page.setRows(messageService.findLetterCount(conversationId));</span><br><span class="line">        <span class="comment">//当前某个会话的私信列表</span></span><br><span class="line">        List&lt;Message&gt; letterList = messageService.findLetters(conversationId, page.getOffset(), page.getLimit());</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; letters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(letterList != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Message message : letterList)&#123;</span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                <span class="comment">//把该私信详情的所有内容存起来</span></span><br><span class="line">                map.put(<span class="string">&quot;letter&quot;</span>, message);</span><br><span class="line">                <span class="comment">//因为私信详情里总要显示发私信的人的头像，所以我们要获取fromUser</span></span><br><span class="line">                map.put(<span class="string">&quot;fromUser&quot;</span>, userService.findUserById(message.getFromId()));</span><br><span class="line">                letters.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;letters&quot;</span>, letters);</span><br><span class="line">        <span class="comment">//查询与当前用户私信的人是谁</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;target&quot;</span>, getLetterTarget(conversationId));</span><br><span class="line">        <span class="comment">//将所有未读消息设置已读（下一节3.27）</span></span><br><span class="line">        List&lt;Integer&gt; ids = getLetterIds(letterList);</span><br><span class="line">        <span class="keyword">if</span>(!ids.isEmpty())&#123;</span><br><span class="line">            messageService.readMessage(ids);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/letter-detail&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询target的具体方法</span></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">getLetterTarget</span><span class="params">(String conversationId)</span>&#123;</span><br><span class="line">        String[] ids = conversationId.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">id0</span> <span class="operator">=</span> Integer.parseInt(ids[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">id1</span> <span class="operator">=</span> Integer.parseInt(ids[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(hostHolder.getUser().getId() == id0)&#123;</span><br><span class="line">            <span class="keyword">return</span> userService.findUserById(id1);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> userService.findUserById(id0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里是下一节更新私信需要用到的——得到未读消息（多条消息组成的集合）</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">getLetterIds</span><span class="params">(List&lt;Message&gt; letterList)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(letterList != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Message message : letterList)&#123;</span><br><span class="line">                <span class="comment">//检查当前用户是不是一个接收者的身份并且信息是不是处于未读的状态</span></span><br><span class="line">                <span class="keyword">if</span>(hostHolder.getUser().getId() == message.getToId() &amp;&amp; message.getStatus() == <span class="number">0</span>)&#123;</span><br><span class="line">                    ids.add(message.getId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ids;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-27-发送私信"><a href="#3-27-发送私信" class="headerlink" title="3.27 发送私信"></a>3.27 发送私信</h1><h2 id="1-开发DAO层——MessageMapper"><a href="#1-开发DAO层——MessageMapper" class="headerlink" title="1.开发DAO层——MessageMapper"></a>1.开发DAO层——MessageMapper</h2><p>上一节3.24已经写了五个方法，这节再加俩方法，分别是<strong>新增一条</strong>私信和<strong>修改消息的状态</strong>（已读，未读）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增一个消息</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertMessage</span><span class="params">(Message message)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改消息状态</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateStatus</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> List&lt;Integer&gt; ids, <span class="meta">@Param(&quot;status&quot;)</span> <span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在xml配置文件写sql语句。注意！更新语句<strong>要涉及多个id的更新操作</strong>，用MyBatis的foreach遍历集合：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.MessageMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span></span><br><span class="line">        from_id, to_id, conversation_id, content, status, create_time</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertMessage&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Message&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into message (<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>)</span><br><span class="line">        values(#&#123;fromId&#125;,#&#123;toId&#125;,#&#123;conversationId&#125;,#&#123;content&#125;,#&#123;status&#125;,#&#123;createTime&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStatus&quot;</span>&gt;</span></span><br><span class="line">        update message set status = #&#123;status&#125;</span><br><span class="line">        where id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-开发Service层——MessageService"><a href="#2-开发Service层——MessageService" class="headerlink" title="2.开发Service层——MessageService"></a>2.开发Service层——MessageService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageMapper messageMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SensitiveFilter sensitiveFilter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//增加私信只需要对内容进行标记符号和敏感词的过滤</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addMessage</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        message.setContent(HtmlUtils.htmlEscape(message.getContent()));</span><br><span class="line">        message.setContent(sensitiveFilter.filter(message.getContent()));</span><br><span class="line">        <span class="keyword">return</span> messageMapper.insertMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//将集合ids中的多个id对应的status设为1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">readMessage</span><span class="params">(List&lt;Integer&gt; ids)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageMapper.updateStatus(ids, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Controller层——MessageController"><a href="#3-开发Controller层——MessageController" class="headerlink" title="3.开发Controller层——MessageController"></a>3.开发Controller层——MessageController</h2><p>因为我们要异步更新私信内容，所以<strong>需要返回字符串而不是指定页面</strong>，所以<strong>用@ResponseBody</strong></p>
<p>因为我们传入的是用户名，而实际要对用户进行操作。所以要先在UserService里声明一个<strong>根据用户名查询用户的功能</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">findUserByName</span><span class="params">(String username)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userMapper.selectByName(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以在MessageController中声明发送私信的功能了，其实就是查询用户存不存在，存在就创建一个message对象，存入响应的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/letter/send&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sendLetter</span><span class="params">(String toName, String content)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过用户名查询被私信人</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">target</span> <span class="operator">=</span> userService.findUserByName(toName);</span><br><span class="line">    <span class="comment">//先判断被私信人存不存在</span></span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">1</span>,<span class="string">&quot;目标用户不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建message对象并赋值</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">    message.setFromId(hostHolder.getUser().getId());</span><br><span class="line">    message.setToId(target.getId());</span><br><span class="line">    <span class="comment">//私信人和被私信人谁的id小，就放前面</span></span><br><span class="line">    <span class="keyword">if</span>(message.getFromId() &lt; message.getToId())&#123;</span><br><span class="line">        message.setConversationId(message.getFromId() + <span class="string">&quot;_&quot;</span> + message.getToId());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        message.setConversationId(message.getToId() + <span class="string">&quot;_&quot;</span> + message.getFromId());</span><br><span class="line">    &#125;</span><br><span class="line">    message.setContent(content);</span><br><span class="line">    message.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    messageService.addMessage(message);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-将未读消息设置为已读"><a href="#4-将未读消息设置为已读" class="headerlink" title="4.将未读消息设置为已读"></a>4.将未读消息设置为已读</h2><p>其实本功能在上一节（3.24）中已经写了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ids = getLetterIds(letterList);</span><br><span class="line"><span class="keyword">if</span>(!ids.isEmpty())&#123;</span><br><span class="line">	messageService.readMessage(ids);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;/site/letter-detail&quot;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="3-31-统一异常处理"><a href="#3-31-统一异常处理" class="headerlink" title="3.31 统一异常处理"></a>3.31 统一异常处理</h1><p>因为DAO层和Service层的异常都要向上传给Controller层，所以我们直接在Controller层统一处理异常即可。</p>
<p><strong>基于SpringBoot</strong>的异常处理方式，我们只需要<strong>在templates目录下放入error目录</strong>，在error目录下创建404.html和500.html常见页面，这样在出现异常的时候，系统会<strong>自动跳转</strong>到404或500页面。</p>
<p>对于404用这种方式没问题，但是500属于服务端报错，<strong>需要记录日志</strong>方便于以后分析错误，另外，如果请求是<strong>异步</strong>的，我们最好不是跳转页面而是直接在当前页面<strong>返回JSON格式的字符串</strong>。</p>
<p>所以我们用Spring的@ControllerAdvice注解来解决。</p>
<h2 id="1-开发Controller层——getErrorPage"><a href="#1-开发Controller层——getErrorPage" class="headerlink" title="1.开发Controller层——getErrorPage"></a>1.开发Controller层——getErrorPage</h2><p><strong>因为我们要手动处理服务端异常</strong>，所以需要在主页HomeController中定义一个方法，用于异常时<strong>定位（重定向）到templates&#x2F;error&#x2F;500.html</strong>，（重定向）的意思是我们不把重定向的操作写在当前方法中，而<strong>交给异常处理方法来亲自重定向</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/error&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getErrorPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/error/500&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-开发Controller层——advice通知层——ExceptionAdvice"><a href="#2-开发Controller层——advice通知层——ExceptionAdvice" class="headerlink" title="2.开发Controller层——advice通知层——ExceptionAdvice"></a>2.开发Controller层——advice通知层——ExceptionAdvice</h2><p>1）用Spring的注解@ControllerAdvice去<strong>扫描带有Controller注解的组件</strong></p>
<p>2）一旦哪个Controller层组件出现异常，就会调用当前类ExceptionAdvice类中<strong>注明@ExceptionHandler注解的handleException方法</strong>，进而完成了异常处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该注解只去扫描带有Controller注解的组件</span></span><br><span class="line"><span class="meta">@ControllerAdvice(annotations = Controller.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ExceptionAdvice.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本注解用于修饰方法，表明Controller出现异常后调用本方法，Exception.class说明要处理所有异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;Exception.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleException</span><span class="params">(Exception e, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//这只是一个异常的概括</span></span><br><span class="line">        logger.error(<span class="string">&quot;服务器发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">        <span class="comment">//遍历异常数组的所有信息，并逐条记录下来</span></span><br><span class="line">        <span class="keyword">for</span>(StackTraceElement element : e.getStackTrace())&#123;</span><br><span class="line">            logger.error(element.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从请求头参数判断当前是否为异步请求(key:x-requested-with)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xRequestedWith</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;x-requested-with&quot;</span>);</span><br><span class="line">        <span class="comment">//XML是异步请求</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;XMLHttpRequest&quot;</span>.equals(xRequestedWith))&#123;</span><br><span class="line">            <span class="comment">//返回给页面JSON格式的普通字符串，页面主动将其转换为Js对象</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/plain;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//获取输出流</span></span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">            <span class="comment">//输出一个字符串</span></span><br><span class="line">            writer.write(CommunityUtil.getJSONString(<span class="number">1</span>,<span class="string">&quot;服务器异常！&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//普通请求就直接重定向到错误页面（HomeController层会通过该路径访问getErrorPage方法）</span></span><br><span class="line">            response.sendRedirect(request.getContextPath() + <span class="string">&quot;/error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-33-统一记录日志"><a href="#3-33-统一记录日志" class="headerlink" title="3.33 统一记录日志"></a>3.33 统一记录日志</h1><p>这一节主要是为了记录业务层的日志，我们自然可以想到<u>在每个处理业务的时候加上记录日志的逻辑</u>，但是这就增加了代码的<strong>耦合度</strong>，<strong>一旦想改变记录日志的位置</strong>，会代码巨大的工作量。因为每个业务都需要记录日志，这些代码就可以称为是<strong>系统需求</strong>，我们可以进行统一封装——SpringAOP。</p>
<h2 id="1-开发aspect切面层——ServiceLogAspect"><a href="#1-开发aspect切面层——ServiceLogAspect" class="headerlink" title="1.开发aspect切面层——ServiceLogAspect"></a>1.开发aspect切面层——ServiceLogAspect</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nowcoder.community.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ryn2020</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-04-30 20:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceLogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ServiceLogAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置切点及其切入的位置——处理所有业务组件及其方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.nowcoder.community.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表明本通知为前置通知——在切点之前通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line"><span class="comment">//日志的格式：用户[1.2.3.4]，在[xxx]时间，访问了[com.nowcoder.community.service.xxx()]某个功能.</span></span><br><span class="line">        <span class="comment">//用工具类RequestContextHolder获得请求的attributes</span></span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="comment">//通过attributes获得请求对象request</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">        <span class="comment">//通过request获得ip地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> request.getRemoteHost();</span><br><span class="line">        <span class="comment">//获得当前时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//下面代码前者获得类名com.nowcoder.community，后者获得方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> joinPoint.getSignature().getDeclaringTypeName() + <span class="string">&quot;.&quot;</span> + joinPoint.getSignature().getName();</span><br><span class="line">        <span class="comment">//定义记录日志的格式</span></span><br><span class="line">        logger.info(String.format(<span class="string">&quot;用户[%s],在[%s],访问了[%s].&quot;</span>, ip, now, target));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-7-Spring整合Redis"><a href="#4-7-Spring整合Redis" class="headerlink" title="4.7 Spring整合Redis"></a>4.7 Spring整合Redis</h1><h2 id="1-导入Redis包"><a href="#1-导入Redis包" class="headerlink" title="1.导入Redis包"></a>1.导入Redis包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#RedisProperties</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">11</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>

<h2 id="3-开发配置类——RedisConfig"><a href="#3-开发配置类——RedisConfig" class="headerlink" title="3.开发配置类——RedisConfig"></a>3.开发配置类——RedisConfig</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//将连接Redis数据库的工厂赋给template，template有了工厂就有了访问数据库的能力</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置key的序列化方式</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">//设置value的序列化方式</span></span><br><span class="line">        template.setValueSerializer(RedisSerializer.json());</span><br><span class="line">        <span class="comment">//设置hash的key的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">//设置hash的value的序列化方式</span></span><br><span class="line">        template.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让template生效</span></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-10-4-13-点赞与我收到的赞"><a href="#4-10-4-13-点赞与我收到的赞" class="headerlink" title="4.10-4.13 点赞与我收到的赞"></a>4.10-4.13 点赞与我收到的赞</h1><h2 id="1-开发工具类——RedisKeyUtil"><a href="#1-开发工具类——RedisKeyUtil" class="headerlink" title="1.开发工具类——RedisKeyUtil"></a>1.开发工具类——RedisKeyUtil</h2><p>因为Redis是面向key-value编程的，为了后续代码对key可以反复复用，所以我们专门写一个生成<strong>与点赞相关的key的生成工具</strong>——RedisKeyUtil</p>
<p>关于被点赞的实体（帖子、评论、评论的评论等），我们定义该实体<strong>与点赞行为相关的key</strong>的前缀为like:entity，然后<strong>拼接上entityType和entityId</strong>，共同构成了like:entity:entityType:entityId格式的RedisKey</p>
<p>另外，个人主页也有显示某个用户获得多少赞的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisKeyUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key在拼接的过程中，:用来分割单词</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLIT</span> <span class="operator">=</span> <span class="string">&quot;:&quot;</span>;</span><br><span class="line">    <span class="comment">//声明前缀：以实体为key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_ENTITY_LIKE</span> <span class="operator">=</span> <span class="string">&quot;like:entity&quot;</span>;</span><br><span class="line">    <span class="comment">//声明前缀：以用户为key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_USER_LIKE</span> <span class="operator">=</span> <span class="string">&quot;like:user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//某个实体的赞</span></span><br><span class="line">    <span class="comment">//之后会将value存入set集合中(谁给这个实体点了赞，就把谁的userId存到set集合中，这样不仅可以累计点赞数量，也可以知道是谁给该实体点过赞)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getEntityLikeKey</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId)</span>&#123;</span><br><span class="line">        <span class="comment">//格式：like:entity:entityType:entityId</span></span><br><span class="line">        <span class="keyword">return</span> PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//某个用户获得的赞（在个人主页显示）</span></span><br><span class="line">    <span class="comment">//value存int值就可以</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getUserLikeKey</span><span class="params">(<span class="type">int</span> userId)</span>&#123;</span><br><span class="line">        <span class="comment">//格式：like:user:userId</span></span><br><span class="line">        <span class="keyword">return</span> PREFIX_USER_LIKE + SPLIT + userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-开发Service层——LikeService"><a href="#2-开发Service层——LikeService" class="headerlink" title="2.开发Service层——LikeService"></a>2.开发Service层——LikeService</h2><p>开发完生成与点赞相关的key的工具类之后，我们就可以开发业务层了，因为Redis本身就是数据库，我们<strong>不需要开发DAO层</strong>，而是直接<strong>通过业务层</strong>来实现与Redis库的交互。</p>
<p>因为每次点赞既要更新当前对某个实体的赞，又要更新某个用户获得的赞的数量（用于个人主页查询）。所以要保证事务性，需要事务管理。</p>
<p>1）首先利用刚刚的工具类生成<strong>与点赞相关的key</strong>和<strong>与用户相关的key</strong>；</p>
<p>2）判断当前实体有没有被点过赞。</p>
<p>3）<u><strong>事务管理</strong></u>：如果点过赞就删掉key对应的value，同时让个人获得赞的数量-1；如果没点过赞，就<strong>把点赞的用户的userId</strong>传入value中，同时让个人获得赞的数量+1。</p>
<p>因为对于帖子这种实体，需要显示一共被点了多少赞，所以需要单独<strong>统计点赞数量</strong>——findEntityLikeCount</p>
<p>如果某个用户在<strong>登陆的状态</strong>下访问某个帖子，帖子会显示<strong>当前帖子或某个评论有没有被用户点过赞</strong>，如果点过，要显示已赞，当再次点击时就取消赞。所以需要单独查询<strong>某个用户对某个实体的点赞状态</strong>——findEntityLikeStatus</p>
<p>最后不要忘了查询某个<strong>用户获得的赞</strong>的数量（用于个人主页显示）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LikeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点赞</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">like</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType, <span class="type">int</span> entityId, <span class="type">int</span> entityUserId)</span>&#123;</span><br><span class="line">        <span class="comment">//因为点赞操作要涉及两次更新操作，所以要保证事务性</span></span><br><span class="line">        redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">SessionCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">                <span class="comment">//生成与点赞某个实体相关的key</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">entityLikeKey</span> <span class="operator">=</span> RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">                <span class="comment">//生成与某个用户获得点赞相关的key</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">userLikeKey</span> <span class="operator">=</span> RedisKeyUtil.getUserLikeKey(entityUserId);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//查看当前用户有没有对该实体点过赞</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> operations.opsForSet().isMember(entityLikeKey, userId);</span><br><span class="line">				<span class="comment">//此时才可以开启事务，因为Redis是把事务放到队列中等待事务提交后统一执行</span></span><br><span class="line">                operations.multi();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(isMember)&#123;</span><br><span class="line">                    operations.opsForSet().remove(entityLikeKey, userId);</span><br><span class="line">                    operations.opsForValue().decrement(userLikeKey);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果没有点过赞，就向key中添加userId作为value</span></span><br><span class="line">                    operations.opsForSet().add(entityLikeKey, userId);</span><br><span class="line">                    operations.opsForValue().increment(userLikeKey);</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//提交事务</span></span><br><span class="line">                <span class="keyword">return</span> operations.exec();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个实体被点赞的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">findEntityLikeCount</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">entityLikeKey</span> <span class="operator">=</span> RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().size(entityLikeKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某人对某实体的点赞状态（已赞还是赞）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findEntityLikeStatus</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType, <span class="type">int</span> entityId)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">entityLikeKey</span> <span class="operator">=</span> RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">        <span class="comment">//因为后续可能还有点踩的功能，所以我们当前返回0，1，将来点踩就返回-1</span></span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个用户获得的赞的数量（用于个人主页显示）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findUserLikeCount</span><span class="params">(<span class="type">int</span> userId)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userLikeKey</span> <span class="operator">=</span> RedisKeyUtil.getUserLikeKey(userId);</span><br><span class="line">        <span class="comment">//这里默认返回值是Object，需要手动强转为Integer类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> (Integer) redisTemplate.opsForValue().get(userLikeKey);</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="literal">null</span> ? <span class="number">0</span> : count.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Controller层——LikeController"><a href="#3-开发Controller层——LikeController" class="headerlink" title="3.开发Controller层——LikeController"></a>3.开发Controller层——LikeController</h2><p>首先我们不可能每次点赞都刷新网页，所以我们<strong>采用异步请求</strong>，返回JSON格式的字符串，所以用@ResponseBody注解。</p>
<p>首先获取当前登录的用户，执行点赞操作必然是<strong>当前的用户来执行</strong>，然后就可以<u>执行点赞操作</u>，获取<u>某个实体被点赞的数量</u>，还有<u>当前用户对某个实体的点赞状态</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LikeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LikeService likeService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/like&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>  <span class="comment">//因为是异步请求，所以是ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">like</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId, <span class="type">int</span> entityUserId)</span>&#123;</span><br><span class="line">        <span class="comment">//获取当前用户user</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line">        <span class="comment">//执行点赞操作</span></span><br><span class="line">        likeService.like(user.getId(), entityType, entityId, entityUserId);</span><br><span class="line">        <span class="comment">//获取某个实体中点赞的数量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">likeCount</span> <span class="operator">=</span> likeService.findEntityLikeCount(entityType, entityId);</span><br><span class="line">        <span class="comment">//当前用户对某个实体的点赞状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">likeStatus</span> <span class="operator">=</span> likeService.findEntityLikeStatus(user.getId(), entityType, entityId);</span><br><span class="line">        <span class="comment">//返回结果放到Map中</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;likeCount&quot;</span>, likeCount);</span><br><span class="line">        map.put(<span class="string">&quot;likeStatus&quot;</span>, likeStatus);</span><br><span class="line">        <span class="comment">//因为是异步请求，返回JSON格式数据</span></span><br><span class="line">        <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">0</span>, <span class="literal">null</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-在主页的查询帖子功能中增加查询点赞数量操作"><a href="#4-在主页的查询帖子功能中增加查询点赞数量操作" class="headerlink" title="4.在主页的查询帖子功能中增加查询点赞数量操作"></a>4.在主页的查询帖子功能中增加查询点赞数量操作</h2><p>只需要在HomeController类中的getIndexPage()方法中，添加累计点赞数量的操作即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主页只需要查询每个帖子的点赞数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">likeCount</span> <span class="operator">=</span> likeService.findEntityLikeCount(ENTITY_TYPE_POST, post.getId());</span><br><span class="line">map.put(<span class="string">&quot;likeCount&quot;</span>, likeCount);</span><br></pre></td></tr></table></figure>

<h2 id="5-在帖子详情页面中增加点赞的相关功能"><a href="#5-在帖子详情页面中增加点赞的相关功能" class="headerlink" title="5.在帖子详情页面中增加点赞的相关功能"></a>5.在帖子详情页面中增加点赞的相关功能</h2><p>只需要在DiscussPostController类的getDiscussPost()方法中，分别在帖子，评论，和评论的评论中增加点赞的操作即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//帖子</span></span><br><span class="line"><span class="comment">//点赞数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">likeCount</span> <span class="operator">=</span> likeService.findEntityLikeCount(ENTITY_TYPE_POST, discussPostId);</span><br><span class="line">model.addAttribute(<span class="string">&quot;likeCount&quot;</span>, likeCount);</span><br><span class="line"><span class="comment">//查询当前用户是否为当前帖子点过赞</span></span><br><span class="line"><span class="type">int</span> <span class="variable">likeStatus</span> <span class="operator">=</span> hostHolder.getUser() == <span class="literal">null</span> ? <span class="number">0</span> : likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_POST, discussPostId);</span><br><span class="line">model.addAttribute(<span class="string">&quot;likeStatus&quot;</span>, likeStatus);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//评论</span></span><br><span class="line"><span class="comment">//点赞数量</span></span><br><span class="line">likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">commentVo.put(<span class="string">&quot;likeCount&quot;</span>, likeCount);</span><br><span class="line"><span class="comment">//查询当前用户是否为当前评论点过赞</span></span><br><span class="line">likeStatus = hostHolder.getUser() == <span class="literal">null</span> ? <span class="number">0</span> : likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">commentVo.put(<span class="string">&quot;likeStatus&quot;</span>, likeStatus);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//评论的回复</span></span><br><span class="line"><span class="comment">//点赞数量</span></span><br><span class="line">likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, reply.getId());</span><br><span class="line">replyVo.put(<span class="string">&quot;likeCount&quot;</span>, likeCount);</span><br><span class="line"><span class="comment">//查询当前用户是否为当前评论点过赞</span></span><br><span class="line">likeStatus = hostHolder.getUser() == <span class="literal">null</span> ? <span class="number">0</span> : likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, reply.getId());</span><br><span class="line">replyVo.put(<span class="string">&quot;likeStatus&quot;</span>, likeStatus);</span><br></pre></td></tr></table></figure>

<h2 id="6-开发个人主页功能——UserController类的getProfilePage"><a href="#6-开发个人主页功能——UserController类的getProfilePage" class="headerlink" title="6.开发个人主页功能——UserController类的getProfilePage()"></a>6.开发个人主页功能——UserController类的getProfilePage()</h2><p>因为我们不仅可以查询当前登录的user的主页，也可以<strong>点击任何一个用户的头像就可以进入他的主页</strong>，所以我们在控制层要<strong>传入userId</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//个人主页</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/profile/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getProfilePage</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="type">int</span> userId, Model model)</span>&#123;</span><br><span class="line">    <span class="comment">//根据用户id获取用户user</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(userId);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该用户不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将用户user传给模板</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="comment">//查询当前用户user获得的点赞数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">likeCount</span> <span class="operator">=</span> likeService.findUserLikeCount(userId);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;likeCount&quot;</span>, likeCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/site/profile&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-16-关注、取消关注"><a href="#4-16-关注、取消关注" class="headerlink" title="4.16 关注、取消关注"></a>4.16 关注、取消关注</h1><h2 id="1-更新工具类——RedisKeyUtil"><a href="#1-更新工具类——RedisKeyUtil" class="headerlink" title="1.更新工具类——RedisKeyUtil"></a>1.更新工具类——RedisKeyUtil</h2><p>在生成key的工具类中更新两个方法，分别是生成<strong>关注者的key</strong>和<strong>粉丝的key</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisKeyUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key在拼接的过程中，:用来分割单词</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLIT</span> <span class="operator">=</span> <span class="string">&quot;:&quot;</span>;</span><br><span class="line">    <span class="comment">//声明前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_ENTITY_LIKE</span> <span class="operator">=</span> <span class="string">&quot;like:entity&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_USER_LIKE</span> <span class="operator">=</span> <span class="string">&quot;like:user&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_FOLLOWEE</span> <span class="operator">=</span> <span class="string">&quot;followee&quot;</span>;<span class="comment">//被关注的实体</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_FOLLOWER</span> <span class="operator">=</span> <span class="string">&quot;follower&quot;</span>;<span class="comment">//粉丝</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//某个用户关注的实体（谁userId关注的哪个实体entityType）</span></span><br><span class="line">    <span class="comment">//格式为：followee:userId:entityType  存储到zset有序集合中，存放的value是entityId，按照时间now先后排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFolloweeKey</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_FOLLOWEE + SPLIT + userId + SPLIT + entityType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//某个实体拥有的粉丝(entityType, entityId唯一标识某个实体)</span></span><br><span class="line">    <span class="comment">//格式为：follower:entityType:entityId  存储到zset有序集合中，存放的value是userId，按照时间now先后排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFollowerKey</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_FOLLOWER + SPLIT + entityType + SPLIT + entityId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-开发Service层——FollowService"><a href="#2-开发Service层——FollowService" class="headerlink" title="2.开发Service层——FollowService"></a>2.开发Service层——FollowService</h2><p>业务层主要有以下逻辑：对某个实体（用户、帖子等）的<strong>关注操作和取消关注的操作</strong>，因为我们只开发了关注用户的操作，所以<strong>这里的实体就是用户</strong>。因为关注的时候，既要<u><strong>增加被关注者的粉丝</strong></u>，又要<u><strong>增加当前用户的关注者</strong></u>，所以要保证这个事物的事务性。</p>
<p>另外个人主页还要显示某个用户的<strong>关注人数和粉丝人数</strong>，所以要分别声明这两个方法</p>
<p>最后是<strong>关注的状态</strong>，因为我们点击关注之后，再点击就会取消关注，所以这个<strong>当前登录的用户是否关注了本用户</strong>，需要将这个状态查询出来，向前端页面传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FollowService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关注操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="comment">//因为follow的业务要同时存储被关注的目标和目标的粉丝，所以要保证事务性</span></span><br><span class="line">        redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">SessionCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">                <span class="comment">//先分别创建关注和粉丝的key</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">followeeKey</span> <span class="operator">=</span> RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">                <span class="type">String</span> <span class="variable">followerKey</span> <span class="operator">=</span> RedisKeyUtil.getFollowerKey(entityType, entityId);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//开启事务</span></span><br><span class="line">                operations.multi();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//分别添加关注者key的value和粉丝key的value</span></span><br><span class="line">                operations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());</span><br><span class="line">                operations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> operations.exec();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消关注</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="comment">//因为unfollow的业务要同时删除被关注的目标和目标的粉丝，所以要保证事务性</span></span><br><span class="line">        redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">SessionCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">                <span class="comment">//先分别创建关注和粉丝的key</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">followeeKey</span> <span class="operator">=</span> RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">                <span class="type">String</span> <span class="variable">followerKey</span> <span class="operator">=</span> RedisKeyUtil.getFollowerKey(entityType, entityId);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//开启事务</span></span><br><span class="line">                operations.multi();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//分别删除关注者key的value和粉丝key的value</span></span><br><span class="line">                operations.opsForZSet().remove(followeeKey, entityId);</span><br><span class="line">                operations.opsForZSet().remove(followerKey, userId);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> operations.exec();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个用户关注实体的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">findFolloweeCount</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">followeeKey</span> <span class="operator">=</span> RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().zCard(followeeKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个实体（用户）的粉丝数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">findFollowerCount</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">followerKey</span> <span class="operator">=</span> RedisKeyUtil.getFollowerKey(entityType, entityId);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().zCard(followerKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前用户是否已关注该实体（用户）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasFollowed</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">followeeKey</span> <span class="operator">=</span> RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">        <span class="comment">//查看对应的key值是否有score</span></span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().score(followeeKey, entityId) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Controller层——FollowController"><a href="#3-开发Controller层——FollowController" class="headerlink" title="3.开发Controller层——FollowController"></a>3.开发Controller层——FollowController</h2><p>本步骤就是简单的视图层开发，添加两个操作，分别是<strong>关注和取关</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FollowController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FollowService followService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关注</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/follow&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">follow</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="comment">//这里其实需要用拦截器判断是否登录</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">        followService.follow(user.getId(), entityType, entityId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">0</span>, <span class="string">&quot;已关注！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取消关注</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/unfollow&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">        followService.unfollow(user.getId(), entityType, entityId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">0</span>, <span class="string">&quot;已取消关注！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-更新Controller层——UserController"><a href="#4-更新Controller层——UserController" class="headerlink" title="4.更新Controller层——UserController"></a>4.更新Controller层——UserController</h2><p>之前个人主页只有收集点赞数量的功能，本次加上收集**<u>关注数量</u><strong>，</strong><u>粉丝数量</u><strong>以及</strong><u>关注状态</u>**三个功能。</p>
<p>注意关注状态必须要求用户登录，如果用户没有登录，因为<strong>无法点击关注</strong>，所以就谈不上用户状态了，始终**<u>返回给前端页面一个“未关注”的状态</u>**即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//个人主页</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/profile/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getProfilePage</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="type">int</span> userId, Model model)</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(userId);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该用户不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="comment">//点赞数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">likeCount</span> <span class="operator">=</span> likeService.findUserLikeCount(userId);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;likeCount&quot;</span>, likeCount);</span><br><span class="line">    <span class="comment">//关注数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">followeeCount</span> <span class="operator">=</span> followService.findFolloweeCount(userId, ENTITY_TYPE_USER);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;followeeCount&quot;</span>, followeeCount);</span><br><span class="line">    <span class="comment">//粉丝数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">followerCount</span> <span class="operator">=</span> followService.findFollowerCount(ENTITY_TYPE_USER, userId);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;followerCount&quot;</span>, followerCount);</span><br><span class="line">    <span class="comment">//是否已关注，如果没登录默认显示关注</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasFollowed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//当前用户登陆了才可以点击关注</span></span><br><span class="line">    <span class="keyword">if</span>(hostHolder.getUser() != <span class="literal">null</span>) &#123;</span><br><span class="line">        hasFollowed = followService.hasFollowed(hostHolder.getUser().getId(), ENTITY_TYPE_USER, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;hasFollowed&quot;</span>, hasFollowed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/site/profile&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-19-关注列表、粉丝列表"><a href="#4-19-关注列表、粉丝列表" class="headerlink" title="4.19 关注列表、粉丝列表"></a>4.19 关注列表、粉丝列表</h1><h2 id="1-更新Service层——FollowService"><a href="#1-更新Service层——FollowService" class="headerlink" title="1.更新Service层——FollowService"></a>1.更新Service层——FollowService</h2><p>主要增加了查询<strong>某个用户的关注的所有人</strong>和<strong>粉丝所有人</strong>逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询某用户关注的人</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">findFollowees</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    <span class="comment">//创建关注者key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">followeeKey</span> <span class="operator">=</span> RedisKeyUtil.getFolloweeKey(userId, ENTITY_TYPE_USER);</span><br><span class="line">    <span class="comment">//获取followeeKey对应的value按照时间从大到小排列的集合，集合里边是value，也就是用户id</span></span><br><span class="line">    <span class="comment">//注意这里的Set被重写了，是有序的集合</span></span><br><span class="line">    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followeeKey, offset, offset + limit - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(targetIds == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Integer targetId : targetIds) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//根据targetId查询对应的用户user</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(targetId);</span><br><span class="line">        map.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="comment">//获取当前targetId用户的关注时间</span></span><br><span class="line">        <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> redisTemplate.opsForZSet().score(followeeKey, targetId);</span><br><span class="line">        <span class="comment">//将score转换为具体时间</span></span><br><span class="line">        map.put(<span class="string">&quot;followTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(score.longValue()));</span><br><span class="line">        list.add(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询某用户的粉丝</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">findFollowers</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">followerKey</span> <span class="operator">=</span> RedisKeyUtil.getFollowerKey(ENTITY_TYPE_USER, userId);</span><br><span class="line">    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followerKey, offset, offset + limit - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(targetIds == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Integer targetId : targetIds) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//根据targetId查询对应的用户user</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(targetId);</span><br><span class="line">        map.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="comment">//获取当前targetId用户的关注时间</span></span><br><span class="line">        <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> redisTemplate.opsForZSet().score(followerKey, targetId);</span><br><span class="line">        <span class="comment">//将score转换为具体时间</span></span><br><span class="line">        map.put(<span class="string">&quot;followTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(score.longValue()));</span><br><span class="line">        list.add(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-更新Controller层——FollowController"><a href="#2-更新Controller层——FollowController" class="headerlink" title="2.更新Controller层——FollowController"></a>2.更新Controller层——FollowController</h2><p>1）查看某个用户的<strong>关注列表</strong><u>getFollowees()</u></p>
<p>2）查看某个用户的<strong>粉丝列表</strong><u>getFollowers()</u></p>
<p>3）查看当前登陆的用户<strong>有没有关注</strong>列表中的某个用户userId——<u>hasFollowed()</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看某个用户(userId)的关注列表</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/followees/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getFollowees</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="type">int</span> userId, Page page, Model model)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(userId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该用户不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为关注列表的最上方需要显示当前关注列表是谁的列表，所以需要向前端页面传入user</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置分页信息</span></span><br><span class="line">    page.setLimit(<span class="number">5</span>);</span><br><span class="line">    page.setPath(<span class="string">&quot;/followees/&quot;</span> + userId);</span><br><span class="line">    <span class="comment">//调用查询关注者数量的方法，返回是long型，要进行强制转换</span></span><br><span class="line">    page.setRows((<span class="type">int</span>) followService.findFolloweeCount(userId, ENTITY_TYPE_USER));</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; userList = followService.findFollowees(userId, page.getOffset(), page.getLimit());</span><br><span class="line">    <span class="keyword">if</span>(userList != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Map&lt;String, Object&gt; map : userList) &#123;</span><br><span class="line">            <span class="comment">//关注列表中的每一个用户u</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User) map.get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            <span class="comment">//查询当前登录的用户user有没有关注列表中的某个指定的用户u</span></span><br><span class="line">            map.put(<span class="string">&quot;hasFollowed&quot;</span>, hasFollowed(u.getId()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;users&quot;</span>, userList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/site/followee&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看某个用户(userId)的粉丝列表</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/followers/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getFollowers</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="type">int</span> userId, Page page, Model model)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(userId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该用户不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为关注列表的最上方需要显示当前关注列表是谁的列表，所以需要向前端页面传入user</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置分页信息</span></span><br><span class="line">    page.setLimit(<span class="number">5</span>);</span><br><span class="line">    page.setPath(<span class="string">&quot;/followers/&quot;</span> + userId);</span><br><span class="line">    page.setRows((<span class="type">int</span>) followService.findFollowerCount(ENTITY_TYPE_USER, userId));</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; userList = followService.findFollowers(userId, page.getOffset(), page.getLimit());</span><br><span class="line">    <span class="keyword">if</span>(userList != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Map&lt;String, Object&gt; map : userList) &#123;</span><br><span class="line">            <span class="comment">//关注列表中的每一个用户u</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User) map.get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            <span class="comment">//查询当前登录的用户user有没有关注列表中的某个指定的用户u</span></span><br><span class="line">            map.put(<span class="string">&quot;hasFollowed&quot;</span>, hasFollowed(u.getId()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;users&quot;</span>, userList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/site/follower&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为列表中要显示登录用户(hostHolder.getUser)有没有关注过列表中的某个用户(userId)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasFollowed</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(hostHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果登陆了，就直接查询登录用户对userId的关注状态</span></span><br><span class="line">    <span class="keyword">return</span> followService.hasFollowed(hostHolder.getUser().getId(), ENTITY_TYPE_USER, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-23-优化登录模块-验证码、登陆凭证、用户信息"><a href="#4-23-优化登录模块-验证码、登陆凭证、用户信息" class="headerlink" title="4.23 优化登录模块(验证码、登陆凭证、用户信息)"></a>4.23 优化登录模块(验证码、登陆凭证、用户信息)</h1><h2 id="1-更新工具类——RedisKeyUtil-验证码"><a href="#1-更新工具类——RedisKeyUtil-验证码" class="headerlink" title="1.更新工具类——RedisKeyUtil(验证码)"></a>1.更新工具类——RedisKeyUtil(验证码)</h2><p>加一个验证码的key生成方法，因为验证码无法与某一个<strong>还未登录的用户</strong>绑定，所以要专门<strong>生成一个随机字符串</strong>来与验证码进行绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisKeyUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key在拼接的过程中，:用来分割单词</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLIT</span> <span class="operator">=</span> <span class="string">&quot;:&quot;</span>;</span><br><span class="line">    <span class="comment">//声明前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_KAPTCHA</span> <span class="operator">=</span> <span class="string">&quot;kaptcha&quot;</span>;<span class="comment">//验证码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//登录验证码(owner是用户的临时凭证)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getKaptchaKey</span><span class="params">(String owner)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_KAPTCHA + SPLIT + owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-重写Controller层——LoginController-验证码"><a href="#2-重写Controller层——LoginController-验证码" class="headerlink" title="2.重写Controller层——LoginController(验证码)"></a>2.重写Controller层——LoginController(验证码)</h2><p>之前是<strong>从session中</strong>获取验证码，但是这<strong>不利于后期分布式部署</strong>，所以我们本次通过将验证码存入Redis中，并设置<strong>生存时间</strong>，来提高验证码的访问效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取验证码功能</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/kaptcha&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getKaptcha</span><span class="params">(HttpServletResponse response<span class="comment">/*, HttpSession session*/</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//生成验证码</span></span><br><span class="line">    <span class="comment">//生成验证码字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> kaptchaProducer.createText();</span><br><span class="line">    <span class="comment">//生成验证码图片</span></span><br><span class="line">    <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> kaptchaProducer.createImage(text);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将验证码存入session</span></span><br><span class="line">        <span class="comment">//session.setAttribute(&quot;kaptcha&quot;, text);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证码的归属（属于哪个用户）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">kaptchaOwner</span> <span class="operator">=</span> CommunityUtil.generateUUID();</span><br><span class="line">    <span class="comment">//将临时凭证存入cookie中</span></span><br><span class="line">    <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;kaptchaOwner&quot;</span>, kaptchaOwner);</span><br><span class="line">    <span class="comment">//为该cookie设置生存时间：60s</span></span><br><span class="line">    cookie.setMaxAge(<span class="number">60</span>);</span><br><span class="line">    <span class="comment">//cookie在整个项目路径下都有效</span></span><br><span class="line">    cookie.setPath(contextPath);</span><br><span class="line">    <span class="comment">//将cookie发送给客户端</span></span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将验证码存入Redis中，设置生存时间为60s</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getKaptchaKey(kaptchaOwner);</span><br><span class="line">    redisTemplate.opsForValue().set(redisKey, text, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将图片输出给浏览器</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取response输出流（字节流）向浏览器响应</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">//用javax工具类输出图片</span></span><br><span class="line">        ImageIO.write(image, <span class="string">&quot;png&quot;</span>, os);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;响应验证码失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//登录功能</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/login&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password, String code, <span class="type">boolean</span> rememberme,</span></span><br><span class="line"><span class="params">                    Model model<span class="comment">/*, HttpSession session*/</span>, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                    <span class="meta">@CookieValue(&quot;kaptchaOwner&quot;)</span> String kaptchaOwner)</span>&#123;</span><br><span class="line">    <span class="comment">//检查验证码</span></span><br><span class="line">        <span class="comment">//String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;);</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">kaptcha</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//从cookie中取到临时凭证，若非空，则根据凭证创建key，并获得验证码</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotBlank(kaptchaOwner)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getKaptchaKey(kaptchaOwner);</span><br><span class="line">        kaptcha = (String) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code))&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;codeMsg&quot;</span>, <span class="string">&quot;验证码不正确！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/login&quot;</span>;<span class="comment">//回到登录页面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查账号，密码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expiredSeconds</span> <span class="operator">=</span> rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;</span><br><span class="line">    Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds);</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(<span class="string">&quot;ticket&quot;</span>))&#123;</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;ticket&quot;</span>, map.get(<span class="string">&quot;ticket&quot;</span>).toString());</span><br><span class="line">        <span class="comment">//生成cookie有效路径</span></span><br><span class="line">        cookie.setPath(contextPath);</span><br><span class="line">        <span class="comment">//设置cookie有效时间</span></span><br><span class="line">        cookie.setMaxAge(expiredSeconds);</span><br><span class="line">        <span class="comment">//将cookie加入到response中，响应时就会将cookie发送给浏览器</span></span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;usernameMsg&quot;</span>, map.get(<span class="string">&quot;usernameMsg&quot;</span>));</span><br><span class="line">        model.addAttribute(<span class="string">&quot;passwordMsg&quot;</span>, map.get(<span class="string">&quot;passwordMsg&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-更新工具类——RedisKeyUtil-登陆凭证"><a href="#3-更新工具类——RedisKeyUtil-登陆凭证" class="headerlink" title="3.更新工具类——RedisKeyUtil(登陆凭证)"></a>3.更新工具类——RedisKeyUtil(登陆凭证)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisKeyUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key在拼接的过程中，:用来分割单词</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLIT</span> <span class="operator">=</span> <span class="string">&quot;:&quot;</span>;</span><br><span class="line">    <span class="comment">//声明前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_TICKET</span> <span class="operator">=</span> <span class="string">&quot;ticket&quot;</span>;<span class="comment">//登陆凭证</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//登录凭证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getTicketKey</span><span class="params">(String ticket)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_TICKET + SPLIT + ticket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-废弃DAO层——LoginTicketMapper-登陆凭证"><a href="#4-废弃DAO层——LoginTicketMapper-登陆凭证" class="headerlink" title="4.废弃DAO层——LoginTicketMapper(登陆凭证)"></a>4.废弃DAO层——LoginTicketMapper(登陆凭证)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Deprecated</span><span class="comment">//声明本方法不推荐使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoginTicketMapper</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-重写Service层——UserService-登录凭证"><a href="#5-重写Service层——UserService-登录凭证" class="headerlink" title="5.重写Service层——UserService(登录凭证)"></a>5.重写Service层——UserService(登录凭证)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">login</span><span class="params">(String username, String password, <span class="type">int</span> expiredSeconds)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//空值处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证账号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证状态（注册后有没有激活）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证密码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成登录凭证</span></span><br><span class="line">        <span class="type">LoginTicket</span> <span class="variable">loginTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginTicket</span>();</span><br><span class="line">        loginTicket.setUserId(user.getId());</span><br><span class="line">        loginTicket.setTicket(CommunityUtil.generateUUID());</span><br><span class="line">        loginTicket.setStatus(<span class="number">0</span>);</span><br><span class="line">        loginTicket.setExpired(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expiredSeconds * <span class="number">1000</span>));</span><br><span class="line"><span class="comment">//        loginTicketMapper.insertLoginTicket(loginTicket);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getTicketKey(loginTicket.getTicket());</span><br><span class="line">        <span class="comment">//Redis自动将loginTicket对象转换为JSON格式的字符串</span></span><br><span class="line">        redisTemplate.opsForValue().set(redisKey, loginTicket);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//也可以传入loginTicket整个对象，但没必要，我们只需要登陆凭证，其他的登录信息可以用凭证去库里查</span></span><br><span class="line">        map.put(<span class="string">&quot;ticket&quot;</span>, loginTicket.getTicket());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(String ticket)</span>&#123;</span><br><span class="line"><span class="comment">//      废弃loginTicketMapper.updateStatus(ticket, 1);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先把ticket从redis中取出来，然后再更新状态为1，最后再存回去</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getTicketKey(ticket);</span><br><span class="line">        <span class="type">LoginTicket</span> <span class="variable">loginTicket</span> <span class="operator">=</span> (LoginTicket)redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">        loginTicket.setStatus(<span class="number">1</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(redisKey, loginTicket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LoginTicket <span class="title function_">findLoginTicket</span><span class="params">(String ticket)</span>&#123;</span><br><span class="line"><span class="comment">//      废弃return loginTicketMapper.selectByTicket(ticket);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//直接从Redis中获取凭证ticket</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getTicketKey(ticket);</span><br><span class="line">        <span class="keyword">return</span> (LoginTicket) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-更新工具类——RedisKeyUtil-用户信息"><a href="#6-更新工具类——RedisKeyUtil-用户信息" class="headerlink" title="6.更新工具类——RedisKeyUtil(用户信息)"></a>6.更新工具类——RedisKeyUtil(用户信息)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisKeyUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key在拼接的过程中，:用来分割单词</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLIT</span> <span class="operator">=</span> <span class="string">&quot;:&quot;</span>;</span><br><span class="line">    <span class="comment">//声明前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX_USER</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;<span class="comment">//用户信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getUserKey</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_USER + SPLIT + userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-更新Service层——UserService-用户信息"><a href="#7-更新Service层——UserService-用户信息" class="headerlink" title="7.更新Service层——UserService(用户信息)"></a>7.更新Service层——UserService(用户信息)</h2><p>三个<u>添加</u>：</p>
<p>1）在userService类中构造getCache()，表明所有查询user的业务<strong>先从Redis中查询</strong></p>
<p>2）Redis查询不到user，就<strong>从MySQL中查询</strong>，然后<strong>放到Redis库中</strong></p>
<p>3）涉及到<strong>user信息变更</strong>的业务，需要<strong>清除</strong>Redis中存储的user</p>
<p>三个<u>更新</u>：</p>
<ul>
<li>更改findUserById()，之前是从数据库中查询user，<strong>效率低</strong>，改为直接从Redis中查询</li>
<li>更改activation()，激活步骤中可能会<strong>更新用户的激活状态</strong>，更新后要清除Redis关于该user的缓存</li>
<li>更改updateHeader()，本方法<strong>更改了用户头像</strong>，要清除Redis关于该user的缓存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.优先从缓存中取值</span></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">getCache</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getUserKey(userId);</span><br><span class="line">        <span class="keyword">return</span> (User) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.取不到数据就初始化缓存数据(从mysql中取数据存到redis中)</span></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">initCache</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(userId);</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getUserKey(userId);</span><br><span class="line">        redisTemplate.opsForValue().set(redisKey, user, <span class="number">3600</span>, TimeUnit.SECONDS);<span class="comment">//设置1h过期时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.数据变更时清除缓存数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clearCache</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getUserKey(userId);</span><br><span class="line">        redisTemplate.delete(redisKey);</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过用户id查找用户信息user</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line"><span class="comment">//      废弃return userMapper.selectById(id);</span></span><br><span class="line">        <span class="comment">//改从Redis中取user，取不到就去数据库找到并init-Redis库，然后返回user</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getCache(id);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">            user = initCache(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//激活</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">activation</span><span class="params">(<span class="type">int</span> userId, String code)</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(userId);</span><br><span class="line">        <span class="keyword">if</span>(user.getStatus() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ACTIVATION_REPEAT;<span class="comment">//如果用户状态已经为1，说明当前是重复激活</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(user.getActivationCode().equals(code))&#123;</span><br><span class="line">            userMapper.updateStatus(userId, <span class="number">1</span>);<span class="comment">//如果用户状态不为1，而且当前激活码满足条件，就把状态设为1</span></span><br><span class="line">            <span class="comment">//因为更新了用户信息，所以清除缓存中用户的信息</span></span><br><span class="line">            clearCache(userId);</span><br><span class="line">            <span class="keyword">return</span> ACTIVATION_SUCCESS;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ACTIVATION_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新用户头像</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateHeader</span><span class="params">(<span class="type">int</span> userId, String headerUrl)</span>&#123;</span><br><span class="line"><span class="comment">//      废弃return userMapper.updateHeader(userId, headerUrl);</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.updateHeader(userId, headerUrl);</span><br><span class="line">        <span class="comment">//因为更新了用户信息，所以清除缓存中用户的信息</span></span><br><span class="line">        clearCache(userId);</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Spring整合Kafka"><a href="#Spring整合Kafka" class="headerlink" title="Spring整合Kafka"></a>Spring整合Kafka</h1><p>首先导入kafka包，然后在application.properties配置文件中，写入如下配置：</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220628145328194.png" alt="image-20220628145328194" style="zoom: 67%;" />

<p>分别对应了kafka服务器地址；消费者组id；消费者根据索引offset获取信息时，需要提交（记录）这个索引；消费者提交索引的频率为3000ms（3s）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/13/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/" data-id="cl34jfrpo0000agv65zyw0788" data-title="我的项目" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-05-13T06:38:33.000Z" itemprop="datePublished">2022-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/">计算机网络笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="路由器相关知识"><a href="#路由器相关知识" class="headerlink" title="路由器相关知识"></a>路由器相关知识</h2><ol>
<li>MAC头部的作用就是<strong>将包传送到路由器</strong>，其中的接收方MAC地址，就是路由器端口的MAC地址。所以，当包到达了路由器，MAC头部任务就完成了，<strong>MAC头部即被丢弃</strong>。</li>
<li>在网络包的传输过程中，<strong>源IP和目标IP始终不变</strong>，而为了两两设备在以太网中传输，必须<strong>实时变化MAC地址</strong>。</li>
<li>在发送数据包的时候，<strong>如果目标主机不是本地局域网内的主机，那MAC地址填入的是路由器地址</strong>，通过路由器的层层转发，<strong>一直转发到目标主机的路由器</strong>，发现IP地址是自己局域网内的主机，就会通过ARP请求<strong>获取目标主机的MAC地址</strong>，进而转发到这个服务器主机。</li>
</ol>
<h2 id="GET和POST区别？"><a href="#GET和POST区别？" class="headerlink" title="GET和POST区别？"></a>GET和POST区别？</h2><p>GET请求的参数一般<strong>写在URL中</strong>，URL规定<strong>只能支持ASCII</strong>，虽然HTTP协议并没有限制URL长度，但是<strong>浏览器自身会对URL长度有限制</strong>。</p>
<p>POST请求的参数一般<strong>放在请求报文（body）中</strong>，body参数<strong>没有格式限制</strong>，只要浏览器和服务器都可接受就行，而且body参数的<strong>长度没有限制</strong>。</p>
<h2 id="HTTPS和HTTP"><a href="#HTTPS和HTTP" class="headerlink" title="HTTPS和HTTP"></a>HTTPS和HTTP</h2><p>前者就是在HTTP的基础上，在TCP和HTTP之间添加了一层SSL&#x2F;TLS安全协议，使得报文能够加密传输。</p>
<p>所以HTTPS不仅要进行TCP的三次握手，还要接着进行SSL&#x2F;TLS握手判断，才可以加密传输报文。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png" alt="HTTP 与 HTTPS 网络层"  />

<h2 id="HTTP对应OSI模型哪几层？"><a href="#HTTP对应OSI模型哪几层？" class="headerlink" title="HTTP对应OSI模型哪几层？"></a>HTTP对应OSI模型哪几层？</h2><p>用来管理通信连接的<strong>会话层</strong>，转换数据格式的<strong>表示层</strong>，与对端主机交互的<strong>应用层</strong>。</p>
<h2 id="应用层各大常见协议"><a href="#应用层各大常见协议" class="headerlink" title="应用层各大常见协议"></a>应用层各大常见协议</h2><h3 id="1-TELNET：远程登陆协议"><a href="#1-TELNET：远程登陆协议" class="headerlink" title="1. TELNET：远程登陆协议"></a>1. TELNET：远程登陆协议</h3><p>建立在TCP协议之上，通过一个终端登录到其他远端的服务器。<strong>最大缺点：明文传输</strong>，所以有了SSH</p>
<h3 id="2-SSH（Secure-Shell）：安全的网络传输协议"><a href="#2-SSH（Secure-Shell）：安全的网络传输协议" class="headerlink" title="2. SSH（Secure Shell）：安全的网络传输协议"></a>2. SSH（Secure Shell）：安全的网络传输协议</h3><p>有效防止远程管理过程中的信息泄露，加密传输，也是建立在TCP协议之上的。</p>
<h3 id="3-FTP：文件传输协议"><a href="#3-FTP：文件传输协议" class="headerlink" title="3. FTP：文件传输协议"></a>3. FTP：文件传输协议</h3><p>FTP是在两个“相连”的计算机之间进行文件传输的协议</p>
<p>最大特点：<strong>两条TCP连接</strong>，一条用于<strong>传送控制信息</strong>，比如：登录验证，发送文件的名称，发送方式部署等；另一条用于<strong>专门传输数据</strong>。</p>
<h3 id="4-SMTP（Simple-Mail-Transfer-Protocol）：简单邮件传输-发送-协议"><a href="#4-SMTP（Simple-Mail-Transfer-Protocol）：简单邮件传输-发送-协议" class="headerlink" title="4. SMTP（Simple Mail Transfer Protocol）：简单邮件传输(发送)协议"></a>4. SMTP（Simple Mail Transfer Protocol）：简单邮件传输(发送)协议</h3><p><strong>用来发送</strong>邮件的协议，<strong>只支持发送端主机行为</strong>，所以不会根据接收端的请求发送，而是根据发送端请求进行发送。</p>
<p>虽然建立在TCP协议上保证了传输的可靠性，但内容不能保证可靠，因为没有身份验证功能。所以现在规定“POP before SMTP”或者“SMTP认证”。</p>
<p>以前的邮件发送需要两端都要保持插电，很不友好，现在是<strong>一端发给服务器A，A发给服务器B，另一端从B接收</strong>。</p>
<h3 id="5-POP（Post-Office-Protocol）：邮局协议"><a href="#5-POP（Post-Office-Protocol）：邮局协议" class="headerlink" title="5. POP（Post Office Protocol）：邮局协议"></a>5. POP（Post Office Protocol）：邮局协议</h3><p><strong>用来接收</strong>邮件的协议，前面发送端的邮件通过SMTP<strong>发送给一直插电的POP服务器</strong>，接收端再根据POP从POP服务器把邮件“拿过来”。</p>
<p>注意：POP就有<strong>用户验证</strong>喽！</p>
<h3 id="6-IMAP（Internet-Message-Access-Protocol）：交互邮件访问协议"><a href="#6-IMAP（Internet-Message-Access-Protocol）：交互邮件访问协议" class="headerlink" title="6. IMAP（Internet Message Access Protocol）：交互邮件访问协议"></a>6. IMAP（Internet Message Access Protocol）：交互邮件访问协议</h3><p>与POP区别就是，POP是客户端管理邮件，而IMAP是<strong>服务器管理邮件</strong>。</p>
<p>这带来了极大的方便：比如我电脑已读某个邮件，那么手机也显示我读了，因为我是<strong>在一致的服务器处理</strong>了MIME信息。所以可以<strong>实现多终端同步的效果</strong>。</p>
<h2 id="电子邮箱发送过程？"><a href="#电子邮箱发送过程？" class="headerlink" title="电子邮箱发送过程？"></a>电子邮箱发送过程？</h2><p>比如一个163邮箱向一个QQ邮箱发邮件：</p>
<p>1）通过SMTP，163邮箱将邮件发给163邮箱服务器</p>
<p>2）163服务器发给QQ服务器</p>
<p>3）QQ服务器通知该QQ邮箱来取邮件，要通过POP&#x2F;IMAP取</p>
<h2 id="如何判断邮箱真正存在？"><a href="#如何判断邮箱真正存在？" class="headerlink" title="如何判断邮箱真正存在？"></a>如何判断邮箱真正存在？</h2><p>1）通过邮箱域名查找到对应的SMTP服务器地址（你家在哪？）</p>
<p>2）尝试与该服务器建立连接（找到你家）</p>
<p>3）服务器尝试向该邮箱发送邮件（你家给你打电话）</p>
<p>4）根据该邮箱返回结果判断真假（听听是自己儿子声音不）</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>首先，<strong>IP是面向无连接的</strong>，它尽管去传输，面向连接要交给它的上层TCP。</p>
<p>一开始分为ABCDE五类，都具有两个部分：网络号和主机号。其中D类用于多播（广播无法穿透路由，所以有了多播），E还没用</p>
<p>缺点：ABC所包含的主机数相差太大，不符合实际应用。</p>
<h3 id="无类别域间路由CIDR-Classless-Inter-Domain-Routing"><a href="#无类别域间路由CIDR-Classless-Inter-Domain-Routing" class="headerlink" title="无类别域间路由CIDR(Classless Inter-Domain Routing)"></a>无类别域间路由CIDR(Classless Inter-Domain Routing)</h3><p>所以有了无分类地址的CIDR：灵活分配网络号和主机号（32拆成两大部分）。这里有子网掩码的概念，<strong>掩码的意思是掩盖掉主机号。将子网掩码和IP地址按位计算AND，就可以得到网络号</strong>。</p>
<p>分离网络号和主机号的目的就是：同一个网络就<strong>直接本地传输</strong>了，不同网络我们再去通过路由向外传输。</p>
<p>下面是子网划分的示意图（<u>还没搞懂它的意义</u>）：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/18.jpg" alt="img"></p>
<h3 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h3><p>其实就是主机向另一个主机传输，如果需要跨网，就要通过路由器来路由。</p>
<p>注意：<strong>环回地址</strong>是特殊的IP地址，为127.0.0.1。localhost和它意义一样，使用这俩时，<strong>数据包不会流向网络</strong>。</p>
<h3 id="IP分片与重组"><a href="#IP分片与重组" class="headerlink" title="IP分片与重组"></a>IP分片与重组</h3><p>因为IP传输过程中，数据包要通过数据链路传输，所以要根据数据链路的最大传输单元MTU来对IP分片。</p>
<p>需要注意的时：<strong>IP在路由器上不会重组，只会在目标主机才重组</strong>。</p>
<h3 id="IPv6与IPv4"><a href="#IPv6与IPv4" class="headerlink" title="IPv6与IPv4"></a>IPv6与IPv4</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/30.jpg" alt=" IPv6 中的单播通信" style="zoom:50%;" />

<p>6比4多加了个<strong>链路本地单播地址</strong>，用于不走路由器的本数据链路传播。其他的像v6的<strong>唯一本地地址</strong>相当于v4的私有IP，v6的<strong>全局单播地址</strong>相当于v4的共有IP。</p>
<h4 id="IPv6相比IPv4的首部改进："><a href="#IPv6相比IPv4的首部改进：" class="headerlink" title="IPv6相比IPv4的首部改进："></a>IPv6相比IPv4的首部改进：</h4><p>1）<strong>取消首部校验和字段</strong>：因为数据链路层和传输层都要校验，所以v6直接取消了IP校验</p>
<p>2）<strong>取消分片&#x2F;重新组装相关字段</strong>：中间路由器不准分片和重组了</p>
<p>3）<strong>取消选项字段</strong></p>
<h2 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>解析域名的</p>
<h3 id="ARP（有缓存）"><a href="#ARP（有缓存）" class="headerlink" title="ARP（有缓存）"></a>ARP（有缓存）</h3><p>根据IP地址查询MAC地址的，主机A想找主机B的IP对应的MAC地址，就要先<strong>在同一数据链路下进行广播</strong>发送一个ARP请求包，包内<strong>包含了主机B的IP地址</strong>。</p>
<p>RARP就是通过MAC获取IP，一般在无法通过DHCP获取IP的情况下应用到。</p>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>1）DHCP客户端也就是没有IP地址的客户端<strong>发送DHCP发现报文</strong>（DHCP DISCOVER），在数据链路中以<strong>广播</strong>形式发送；</p>
<p>2）DHCP服务器收到后向客户端响应（还是广播），发送的是<strong>DHCP提供报文</strong>（DHCP OFFER），报文包括：可租约的IP地址，子网掩码，默认网关，DNS服务器以及<strong>IP地址租用期</strong>。</p>
<p>3）客户端可能收到多个DHCP发来的报文，选一个并向该服务器发送<strong>DHCP请求报文</strong>（DHCP REQUEST）</p>
<p>4）服务器发送DHCP响应报文（<strong>DHCP ACK</strong>），应答所要求的参数。</p>
<p>5）如果<strong>IP快到期</strong>了，客户端继续向服务器发送DHCP请求报文来申请。</p>
<p>DHCP交互中，<strong>全程都是UDP广播通信</strong>，为了解决不在同一个局域网的通信，出现了<strong>DHCP中继代理</strong>，相当于以前政府直接交涉，现在交给小区居委会代理，居委会负责找政府要IP。（链路广播，中继单播）</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/37.jpg" alt=" DHCP 中继代理" style="zoom:50%;" />

<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>把私有IP转换为公有IP，如果不加点什么这个好像没啥用，所以有了NAPT</p>
<p>NAPT就是<strong>将私有IP转换为IP地址＋端口号</strong>，这正是利用了网络传输需要使用传输层协议的特点。</p>
<p>每次转换都是在NAPT路由器上生成一张转换表，TCP首次握手发出SYN包的时候就<strong>生成了这个表</strong>，关闭连接时候FIN包发送的时候<strong>表就删掉了</strong>。</p>
<p>NAT&#x2F;NAPT依赖自己的转换表，带来的以下不足：</p>
<p>1）外部无法与NAT内部服务器建立连接（不懂）</p>
<p>2）转换表的生成和转换操作有性能开销</p>
<p>3）NAT路由器一旦重启，所有TCP连接都要重置</p>
<p>如何解决：</p>
<p>1）改用IPv6。</p>
<p>2）NAT穿透技术：就是客户端<strong>主动从NAT设备获取共有IP地址</strong>，然后<strong>自己建立端口映射条目</strong>，不用NAT来建立了。</p>
<h2 id="ICMP（Internet-Control-Message-Protocol）"><a href="#ICMP（Internet-Control-Message-Protocol）" class="headerlink" title="ICMP（Internet Control Message Protocol）"></a>ICMP（Internet Control Message Protocol）</h2><p>用来确认IP包是否成功发送到目标地址，报告IP被遗弃的原因，报告改善网络设置等。包括两类（橘色和黄色），如下：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/41.jpg" alt="常见的 ICMP 类型" style="zoom:33%;" />

<h3 id="IGMP（不懂）"><a href="#IGMP（不懂）" class="headerlink" title="IGMP（不懂）"></a>IGMP（不懂）</h3><p>组播地址不是IP地址，一般用于UDP协议</p>
<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzYuanBn?x-oss-process=image/format,png" alt="TCP 头格式" style="zoom: 40%;" />

<p>TCP四元组（源地址、源端口、目标地址、目标端口）可以<strong>唯一确定一个连接</strong>。</p>
<p>最大的<strong>TCP连接数</strong> &#x3D; 客户端**<u>IP数</u>** × 客户端<u><strong>端口数</strong></u>。实际远没有这么多，连接数还受<strong>文件描述符和内存</strong>的制约。</p>
<h3 id="为什么UDP头部没有首部长度字段，而TCP头部有？"><a href="#为什么UDP头部没有首部长度字段，而TCP头部有？" class="headerlink" title="为什么UDP头部没有首部长度字段，而TCP头部有？"></a>为什么UDP头部没有首部长度字段，而TCP头部有？</h3><p>因为TCP头部存在<strong>可变长的选项字段</strong>，而UDP头部长度始终不变。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEyLmpwZw?x-oss-process=image/format,png" alt="UDP 头部格式" style="zoom:50%;" />

<h3 id="为什么TCP头部没有包长度字段，而UDP头部有？"><a href="#为什么TCP头部没有包长度字段，而UDP头部有？" class="headerlink" title="为什么TCP头部没有包长度字段，而UDP头部有？"></a>为什么TCP头部没有包长度字段，而UDP头部有？</h3><p>UDP头部虽然只有四部分，但它<strong>比TCP多一个包长度</strong>（头部+数据的总长度），<strong>TCP的包长可由IP层获知</strong>。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEzLmpwZw?x-oss-process=image/format,png" alt="img" style="zoom:50%;" />

<h3 id="TCP和UDP各自的应用场景？"><a href="#TCP和UDP各自的应用场景？" class="headerlink" title="TCP和UDP各自的应用场景？"></a>TCP和UDP各自的应用场景？</h3><p>TCP可靠，所以多应用于FTP文件传输，HTTP&#x2F;HTTPS</p>
<p>UDP可以随时发送，高效。所以多应用于包较少的通信，如DNS、SNMP(Simple Network Management Protocol)等；视频，音频等；广播通信</p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>第三次握手<strong>可以携带数据</strong>，前两次握手不可携带数据。</p>
<p><u>三次握手意义</u>：阻止重复历史连接的初始化（<strong>主要意义</strong>），同步双方初始序列号，避免资源浪费。</p>
<p>每次<u>初始化序列号不一样的意义</u>：很大程度避免<strong>历史报文被下一个相同四元组的连接接收</strong>。</p>
<p>TCP头部字段的<strong>序列号</strong>和TCP建立连接的<strong>初始序列号都不是无限递增</strong>的，会发生<strong>回绕为初始值</strong>的情况，所以无法通过序列号来<strong>判断新老数据</strong>。</p>
<p>MTU和MSS的区别如下：</p>
<p>MTU(Maximum Transmission Unit)</p>
<p>MSS(Maximum Segment size)</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzIzLmpwZw?x-oss-process=image/format,png" alt="MTU 与 MSS"></p>
<h4 id="为什么TCP的整个报文（头部-数据）不交给IP分片？"><a href="#为什么TCP的整个报文（头部-数据）不交给IP分片？" class="headerlink" title="为什么TCP的整个报文（头部+数据）不交给IP分片？"></a>为什么TCP的整个报文（头部+数据）不交给IP分片？</h4><p>因为IP分片丢失，整个IP报文的<strong>所有分片都需要重传</strong>（IP层无响应，无超时重传机制）。</p>
<p>而TCP以MSS为单位分片后，某个TCP分片丢失，也是<strong>以MSS为单位重发</strong>的，重传效率大大增加。</p>
<h4 id="三次握手分别丢失的情况"><a href="#三次握手分别丢失的情况" class="headerlink" title="三次握手分别丢失的情况"></a>三次握手分别丢失的情况</h4><p><u>第一次握手丢失</u>：<strong>超时重传</strong>（默认逐次等1s, 2s, 4s, 16s, 32s），32s后仍没回应，不传了，直接断开TCP连接</p>
<p><u>第二次握手丢失</u>：客户端没收到ACK，触发超时重传，<strong>重传SYN报文</strong>；服务端没收到客户端的ACK（第三次握手），触发超时重传，<strong>重传SYN-ACK报文</strong>。</p>
<p><u>第三次握手丢失</u>：服务端<strong>重传SYN-ACK报文</strong>。</p>
<p>Linux半连接队列（SYN队列）和全连接队列（Accept队列）：</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzI2LmpwZw?x-oss-process=image/format,png" alt="正常流程" style="zoom:50%;" />

<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzMwLmpwZw?x-oss-process=image/format,png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom:50%;" />

<p><strong>主动关闭连接的一端</strong>才有TIME_WAIT状态。</p>
<h4 id="四次挥手分别丢失的情况"><a href="#四次挥手分别丢失的情况" class="headerlink" title="四次挥手分别丢失的情况"></a>四次挥手分别丢失的情况</h4><p><u>第一次挥手丢失</u>：客户端重传FIN报文，超过一定次数，直接进入close状态；</p>
<p><u>第二次挥手丢失</u>：因为<strong>ACK报文不会重传</strong>，所以还是客户端重传FIN报文，直到超过最大重传次数；</p>
<p><u>第三次挥手丢失</u>：<strong>服务端</strong>重发FIN报文，与客户端机制一样；</p>
<p><u>第四次挥手丢失</u>：<strong>服务端</strong>重发FIN报文。</p>
<h4 id="为什么TIME-WAIT等待时间是2MSL？"><a href="#为什么TIME-WAIT等待时间是2MSL？" class="headerlink" title="为什么TIME_WAIT等待时间是2MSL？"></a>为什么TIME_WAIT等待时间是2MSL？</h4><p>MSL（Maximum Segment Lifetime）报文最大生存时间，单位是时间，超时即丢弃。因为TCP基于IP协议，IP头部有TTL字段，是IP数据包可经过的最大路由数。TTL一般是64，Linux的MSL默认为30s，意味着<strong>Linux认为报文经过64个路由器的时间不超过30s</strong>。</p>
<p>其实2MSL时长是<strong>至少允许报文丢失一次</strong>。比如ACK在一个MSL内丢失，被动方重发的FIN会在第二个MSL内到达，TIME_WAIT就可以应对。如果一次ACK或一次FIN走不了一个MSL，那就很可能可以允许丢失两次、三次……所以2MSL时长至少允许一次报文丢失。</p>
<h4 id="为什么需要TIME-WAIT状态？"><a href="#为什么需要TIME-WAIT状态？" class="headerlink" title="为什么需要TIME_WAIT状态？"></a>为什么需要TIME_WAIT状态？</h4><p>①防止<strong>历史连接中的数据</strong>，被后面相同四元组的连接错误的接收；</p>
<p>②保证<strong>被动关闭连接的一方</strong>，能被正确的关闭。</p>
<h4 id="TIME-WAIT过多的危害？"><a href="#TIME-WAIT过多的危害？" class="headerlink" title="TIME_WAIT过多的危害？"></a>TIME_WAIT过多的危害？</h4><p>①客户端（发起连接方）<strong>端口资源</strong>被过多地占用；</p>
<p>②服务端（被动连接方）受<strong>系统资源</strong>限制。</p>
<h4 id="建立连接后，客户端突然出故障怎么办？"><a href="#建立连接后，客户端突然出故障怎么办？" class="headerlink" title="建立连接后，客户端突然出故障怎么办？"></a>建立连接后，客户端突然出故障怎么办？</h4><p>TCP存在保活机制，一段时间内没有任何连接活动，就每隔一个时间间隔发送一个探测报文。</p>
<h4 id="建立连接后，服务端突然出故障怎么办？"><a href="#建立连接后，服务端突然出故障怎么办？" class="headerlink" title="建立连接后，服务端突然出故障怎么办？"></a>建立连接后，服务端突然出故障怎么办？</h4><p>服务端发送FIN报文，与客户端进行四次挥手。</p>
<h2 id="TCP重传机制、滑动窗口、流量控制、拥塞控制"><a href="#TCP重传机制、滑动窗口、流量控制、拥塞控制" class="headerlink" title="TCP重传机制、滑动窗口、流量控制、拥塞控制"></a>TCP重传机制、滑动窗口、流量控制、拥塞控制</h2><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>RTT（Round-Trip Time往返时延）就是数据发送时刻到接收到确认时刻的差值，是动态变化的。</p>
<p>RTO（Retransmission Timeout超时重传时间），RTO要略大于RTT</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/8.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="RTO 应略大于 RTT" style="zoom: 67%;" />

<p>每当遇到一次超时重传，TCP都会将下一次超时重传时间间隔<strong>设为先前值的两倍</strong>。</p>
<h4 id="Linux如何计算RTO？"><a href="#Linux如何计算RTO？" class="headerlink" title="Linux如何计算RTO？"></a>Linux如何计算RTO？</h4><p>1）采样RTT时间，作<strong>加权平均</strong>，这个值不断变化</p>
<p>2）采样RTT<strong>波动范围</strong></p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>这种机制是<strong>数据驱动</strong>，而不是时间驱动。如下图，没收到就会<strong>一直传没收到2的ACK</strong>，连续收到<strong>3个</strong>就重传。</p>
<p>但是这种机制的弊端是：不知道重传2还是重传2、3、4、5，发送端不知道连续的3个ACK是谁传回来的。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传机制" style="zoom: 67%;" />

<h3 id="SACK方法（Selectice-ACK选择性确认）"><a href="#SACK方法（Selectice-ACK选择性确认）" class="headerlink" title="SACK方法（Selectice ACK选择性确认）"></a>SACK方法（Selectice ACK选择性确认）</h3><p>这种方式需要TCP头部的选项字段加一个SACK，它可以将缓存的地图发给发送方，这样发送方就知道哪些被收到了，哪些没被收到。然后就可以只重传丢失的数据了。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/11.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="选择性确认" style="zoom: 40%;" />

<p>Duplicate SACK（D-SACK）主要**使用了SACK来告诉[发送方]**有哪些数据被重复接收了。</p>
<p>D-SACK优点：</p>
<p>1）可以让[发送方]知道是<strong>包丢了</strong>还是对面的应答<strong>ACK丢了</strong>；</p>
<p>2）可以知道[发送方]的包是不是<strong>被网络延时</strong>了；</p>
<p>3）可以知道[发送方]的包是不是被<strong>网络复制</strong>了。（不懂）</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><u>窗口大小</u>：<strong>无需等待ACK</strong>而可以<strong>连续发送数据</strong>的最大值。</p>
<p><u>累计确认&#x2F;累计应答</u>：如下图：ACK 600没到<strong>但是ACK 700到了</strong>，也能说明前面的数据都收到了。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="用滑动窗口方式并行处理" style="zoom:50%;" />

<h3 id="窗口大小由哪一方决定？"><a href="#窗口大小由哪一方决定？" class="headerlink" title="窗口大小由哪一方决定？"></a>窗口大小由哪一方决定？</h3><p>窗口大小对应着TCP的<strong>Window</strong>字段。该字段是**[接收端]告诉[发送端]**自己还有多少缓冲区可以接收数据。</p>
<p>所以<strong>由[接收方]的窗口大小决定</strong>。</p>
<h3 id="发送方的滑动窗口"><a href="#发送方的滑动窗口" class="headerlink" title="发送方的滑动窗口"></a>发送方的滑动窗口</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/19.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="SND.WND、SND.UN、SND.NXT" style="zoom:45%;" />

<p>SND.WND：发送窗口的大小（<strong>接收方指定</strong>）</p>
<p>SND.UNA：<strong>绝对指针</strong>，指向<u>已发送但未收到ACK</u>的第一个字节的序列号</p>
<p>SND.NXT：<strong>绝对指针</strong>，指向<u>未发送但可发送范围</u>的第一个字节的序列号</p>
<p>指向<u>未发送且超出范围</u>（#4）的第一个字节的序列号是个<strong>相对指针</strong>。</p>
<p><strong>可用窗口大小</strong>由图可知是计算得来的。</p>
<h3 id="接收方的滑动窗口"><a href="#接收方的滑动窗口" class="headerlink" title="接收方的滑动窗口"></a>接收方的滑动窗口</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="接收窗口" style="zoom:45%;" />

<p>RCV.WND：接收窗口大小（通告<strong>给发送方的</strong>）</p>
<p>RCV.NXT：<strong>绝对指针</strong>，指向期望从发送方发来的下一个字节的序列号（#3的第一个字节）。</p>
<p>还有一个<strong>相对指针</strong>指向#4的第一个字节，是RCV.NXT+RCV.WND控制的。</p>
<p>因为接收方告诉发送方窗口大小有一定的<strong>时延</strong>，所以<strong>接收窗口约等于发送窗口</strong>。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="操作系统缓冲区与滑动窗口的关系"><a href="#操作系统缓冲区与滑动窗口的关系" class="headerlink" title="操作系统缓冲区与滑动窗口的关系"></a>操作系统缓冲区与滑动窗口的关系</h3><p>实际上，发送窗口和接收窗口中存放的字节数，都放在了操作系统缓冲区中。而应用进程就负责读取这一部分内容。</p>
<p>1）情况1</p>
<p>有的时候，应用进程非常忙碌，<strong>没有时间读取缓存区的内容</strong>，这样就会导致发送方发送来的一部分数据没办法及时被接收方的应用进程读取，滑动窗口的<strong>可用窗口越来越小，接收窗口也越来越小</strong>。（就像你吃饱了，另一个人还不停向你扔包子，虽然你告诉他一次最多仍5个，但是你现在肚子一点都装不下，所以就先放篮子里，放篮子里的早晚也要吃的，所以篮子有多少包子，你就要让你的接收窗口减少多少个包子，直到我们篮子里装了5个包子，那么就认为对方不能再扔了。）</p>
<p>所以从上边我们可以知道：缓冲区存了多少未读的数据，那么接收窗口缩小多少。接收窗口始终随缓冲区动态变化，就像消息队列一样，所以<strong>缓冲区未读数据M+接收窗口当前值N&#x3D;初始接收窗口的大小T</strong></p>
<p>上述情况就是：<strong>M一直增大，N一直减小，所以发送窗口逐渐减小</strong>。</p>
<p>2）情况2</p>
<p>有的时候，应用资源非常繁忙，操作系统会主动减少接收缓存（这就相当于操作系统自己给<strong>自己放了几个拿不走的包子——M永久性增大</strong>），这就直接导致我们现在窗口也要减少。但是窗口减少<strong>需要通知给发送方，这就需要一定的时间</strong>，在这时间内，很有可能有很大的包传过来，那么就会<strong>导致丢包</strong>（因为接收方的缓存收不下了）。</p>
<p>导致丢包的原因是：M增大的<strong>同时</strong>，N减小，但N传给发送方<strong>需要时间</strong>，这个时候发送方传来的包，接收方很可能接不住。</p>
<p>解决的方式就是：N<strong>先减小</strong>，过段时间（为了让N减小的消息通知给发送方）再让M增大（放入几个拿不走的包子）。</p>
<h3 id="窗口关闭（风险与解决）"><a href="#窗口关闭（风险与解决）" class="headerlink" title="窗口关闭（风险与解决）"></a>窗口关闭（风险与解决）</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/24.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口关闭潜在的危险" style="zoom:40%;" />

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/25.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口探测" style="zoom:35%;" />

<p>其实就是收到零窗口通知的一端会默认启用计时器，<strong>到点了就发送探测报文</strong>。</p>
<h3 id="糊涂窗口综合征（小接收与小发送问题）"><a href="#糊涂窗口综合征（小接收与小发送问题）" class="headerlink" title="糊涂窗口综合征（小接收与小发送问题）"></a>糊涂窗口综合征（小接收与小发送问题）</h3><p>有的时候，接收方通知给发送方的窗口大小越来越小，这就会带来一个问题，<strong>数据量很小的话，不值得传输一次</strong>，可以攒一攒，或者说等一等接收方接收一部分数据再传。（一个一个仍包子比较亏，等我一口能吃仨了，你一口气仍仨过来）</p>
<p>解决该问题有两种思路，一种是让接收方不通告小窗口给发送方；另一种是让发送方避免发送小数据。</p>
<h4 id="接收方不通告小窗口"><a href="#接收方不通告小窗口" class="headerlink" title="接收方不通告小窗口"></a>接收方不通告小窗口</h4><p>当 <strong>Window &lt; Math.min（MSS与缓存的一半）时</strong>，接收方就会向发送方<strong>通告Window为0</strong>。直到Window大于那俩值的时候，再通知Window值。</p>
<h4 id="发送方不发送小数据"><a href="#发送方不发送小数据" class="headerlink" title="发送方不发送小数据"></a>发送方不发送小数据</h4><p>Nagle算法，思路是延时处理。满足以下两条件之一才可以发送数据：</p>
<p>1）Window &gt;&#x3D; MSS 或 数据大小 &gt;&#x3D; MSS</p>
<p>2）收到之前发送数据的ACK回包</p>
<p>对于需要小数据包交互的场景如telnet或ssh，需要关闭Nagle算法。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>TCP不能一直按照流量控制传输，有的时候<strong>网络拥堵，就要减少传输量</strong>。</p>
<p><strong>发送窗口swnd</strong> &#x3D; min(拥塞窗口cwnd,接收窗口rwnd)</p>
<p>而拥塞窗口cwnd在网络中<strong>没有拥塞的时候，就会增大</strong>，出现拥塞，就会减少。</p>
<p><u>如何知道拥塞？</u>发送方没在规定时间收到ACK，也就是<strong>发生了超时重传</strong>，认为网络出现拥塞。</p>
<h3 id="拥塞控制的控制算法"><a href="#拥塞控制的控制算法" class="headerlink" title="拥塞控制的控制算法"></a>拥塞控制的控制算法</h3><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>慢启动算法规则：发送方每收到一个ACK，拥塞窗口cwnd就+1。（<strong>指数级增长</strong>）</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/27.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="慢启动算法" style="zoom: 40%;" />

<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>cwnd<strong>超过慢启动门限ssthresh</strong>就会进入拥塞避免算法。</p>
<p>规则：每收到一个ACK，cwnd增加1&#x2F;cwnd。（<strong>线性增长</strong>）</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/28.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="拥塞避免" style="zoom:40%;" />

<h4 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h4><p>上面两种都是cwnd逐渐增加，一旦网络拥塞，也就是拥塞发生，就会触发重传机制。</p>
<p><u><strong>超时重传</strong></u>：门限ssthresh设为cwnd&#x2F;2;cwnd置为1（<strong>急刹车并重新慢启动，一般不可取</strong>）</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="拥塞发送 —— 超时重传" style="zoom:30%;" />

<p><u><strong>快速重传</strong></u>：cwnd减半，门限ssthresh&#x3D;cwnd，然后<strong>进入快速恢复算法</strong>。</p>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>与<strong>快速重传</strong>一起“食用”。</p>
<p>规则：</p>
<ul>
<li>cwnd &#x3D; ssthresh + 3（3是指收到3个数据包）</li>
<li>重传丢失的数据包，收到一个重复ACK，cwnd就+1（线性增长）</li>
<li>一旦收到新数据ACK，就令cwnd &#x3D; ssthresh，说明恢复过程结束，<strong>再次进入拥塞避免状态</strong>（线性增长）</li>
</ul>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传和快速恢复" style="zoom:40%;" />

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" data-id="cl34efpty00001cv6d0asee9e" data-title="计算机网络笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作字符串题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/13/%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-13T03:26:25.000Z" itemprop="datePublished">2022-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/13/%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E8%A7%A3/">操作字符串题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="leetcode-344-反转字符串"><a href="#leetcode-344-反转字符串" class="headerlink" title="leetcode 344.反转字符串"></a>leetcode 344.反转字符串</h2><p><u><strong>题目</strong>：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</u></p>
<p><u>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</u></p>
<p><u>输入：s &#x3D; [“h”,”e”,”l”,”l”,”o”]</u><br><u>输出：[“o”,”l”,”l”,”e”,”h”]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = s.length - <span class="number">1</span>;i &lt; j;i++, j--) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[i];</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="☆leetcode-541-反转字符串II"><a href="#☆leetcode-541-反转字符串II" class="headerlink" title="☆leetcode 541.反转字符串II"></a>☆leetcode 541.反转字符串II</h2><p><u><strong>题目</strong>：给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</u></p>
<p><u>如果剩余字符少于 k 个，则将剩余字符全部反转。</u></p>
<p><u>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</u></p>
<p><u>示例:</u></p>
<p><u>输入: s &#x3D; “abcdefg”, k &#x3D; 2</u><br><u>输出: “bacdfeg”</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(i + k - <span class="number">1</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ch[start];</span><br><span class="line">                ch[start] = ch[end];</span><br><span class="line">                ch[end] = temp;</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环中的i，就相当于一个指针，每次走2*k个单位，走完一次，就定义当前反转字符串的起始位和终点位。</p>
<p>注意：<strong>终点位的要取i + k - 1和s.length() - 1的最小值</strong>，因为最后一次如果反转个数不够k个的时候，就直接将当前字符串从start到s.length() - 1的所有字符串翻转即可。</p>
<p>因为反转操作涉及字符串中每个字符的换位，所以最好将字符串转换为数组进行操作。最后记得再将数组转换为字符串。</p>
<h2 id="剑指Offer-05-替换空格"><a href="#剑指Offer-05-替换空格" class="headerlink" title="剑指Offer 05.替换空格"></a>剑指Offer 05.替换空格</h2><p><u>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</u></p>
<p><u>输入：s &#x3D; “We are happy.”</u><br><u>输出：”We%20are%20happy.”</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空间复杂度o(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空间复杂度o(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//凡是碰到空格，就将sb扩容</span></span><br><span class="line">                sb.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录原始s的右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        s += sb.toString();</span><br><span class="line">        <span class="comment">//记录添加空格之后的s的右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[left] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;%&#x27;</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ch[right--] = ch[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="☆leetcode-151-颠倒字符串中的单词"><a href="#☆leetcode-151-颠倒字符串中的单词" class="headerlink" title="☆leetcode 151.颠倒字符串中的单词"></a>☆leetcode 151.颠倒字符串中的单词</h2><p><u><strong>题目</strong>：给你一个字符串 s ，颠倒字符串中 单词 的顺序。</u></p>
<p><u>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</u></p>
<p><u>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</u></p>
<p><u>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</u></p>
<p><u>输入：s &#x3D; “the sky is blue”</u><br><u>输出：”blue is sky the”</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//1.移除多余的空格</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> removeSpace(s);</span><br><span class="line">        <span class="comment">//2.反转整个sb</span></span><br><span class="line">        reverseWord(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//3.反转每个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除字符串的多余空格</span></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">removeSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s.charAt(start) == <span class="string">&#x27; &#x27;</span>) start++;</span><br><span class="line">        <span class="keyword">while</span>(s.charAt(end) == <span class="string">&#x27; &#x27;</span>) end--;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start) != <span class="string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(s.charAt(start));</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转给定区间的字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseWord</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转每个字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="keyword">while</span>(start &lt; n) &#123;</span><br><span class="line">            <span class="comment">//注意！！！：一旦end不满足空格条件，要跳出while循环，容易写成while+if导致超时</span></span><br><span class="line">            <span class="keyword">while</span>(end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            reverseWord(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end = start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer-58-II-左旋转字符串"><a href="#剑指Offer-58-II-左旋转字符串" class="headerlink" title="剑指Offer 58 - II.左旋转字符串"></a>剑指Offer 58 - II.左旋转字符串</h2><p><u><strong>题目</strong>：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</u></p>
<p><u>输入: s &#x3D; “abcdefg”, k &#x3D; 2</u><br><u>输出: “cdefgab”</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">        <span class="comment">//先反转前n个</span></span><br><span class="line">        reverse(sb, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//再反转后面的字符串</span></span><br><span class="line">        reverse(sb, n, s.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//最后反转整个字符串</span></span><br><span class="line">        reverse(sb, <span class="number">0</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="☆leetcode-28-实现strStr"><a href="#☆leetcode-28-实现strStr" class="headerlink" title="☆leetcode 28.实现strStr()"></a>☆leetcode 28.实现strStr()</h2><p><u><strong>题目</strong>：实现 strStr() 函数。</u></p>
<p><u>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</u></p>
<p><u>示例 1: 输入: haystack &#x3D; “hello”, needle &#x3D; “ll” 输出: 2</u></p>
<p><u>示例 2: 输入: haystack &#x3D; “aaaaa”, needle &#x3D; “bba” 输出: -1</u></p>
<p><u>说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i + m &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(haystack.charAt(i + j) != needle.charAt(j))&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题我暂时只会暴力解法，后续学会了KMP算法会进行更新。</p>
<p>暴力解法其实思路比较简单，让haystack数组指针依次向后递进，每递进一次，我们就从当前位置开始判断，该指针及其后面的元素是不是和needle的每个元素相同，如果都相同，那么我们就找到了needle出现的第一个位置。一旦有一个不同，那么就可以继续让haystack指针向后走了。</p>
<p>这里我们需要定义一个boolean类型的变量flag，初始值是true，一定要注意其定义的位置：<strong>每次haystack递进一位就定义一个全新的flag</strong>，而<strong>不要定义为全局变量</strong>。因为这个flag是为每次寻找needle字符串服务的，所以<strong>每次比较都要用全新的flag</strong>。</p>
<p><strong>每次寻找needle字符串的操作结束之后，都要看看flag还是不是true</strong>，如果还是true，说明找到了needle；如果是false，就说明上面的寻找过程中，出现了某个字符没匹配上。</p>
<h2 id="☆leetcode-459-重复的子字符串"><a href="#☆leetcode-459-重复的子字符串" class="headerlink" title="☆leetcode 459.重复的子字符串"></a>☆leetcode 459.重复的子字符串</h2><p><u><strong>题目</strong>：给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</u></p>
<p><u>输入: s &#x3D; “abab”</u><br><u>输出: true</u><br><u>解释: 可由子串 “ab” 重复两次构成</u></p>
<p><u>输入: s &#x3D; “aba”</u><br><u>输出: false</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">//这里i表示子串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= len / <span class="number">2</span>;i++) &#123;</span><br><span class="line">            <span class="comment">//只有子串的长度是总长的因数，该子串才可能重复构成总字符串</span></span><br><span class="line">            <span class="keyword">if</span>(len % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//这里长度必须走到结尾，要判断所有字符串是否都可以由子串表示</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j &lt; len;j++) &#123;</span><br><span class="line">                    <span class="comment">//相距的区间是子串的长度i</span></span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(j - i) != s.charAt(j)) &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/13/%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E8%A7%A3/" data-id="cl33vz9vp0000qwv64bvmbn7e" data-title="操作字符串题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-哈希算法题目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/13/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2022-05-13T02:21:16.000Z" itemprop="datePublished">2022-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/13/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/">哈希算法题目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcode-202-快乐数"><a href="#leetcode-202-快乐数" class="headerlink" title="leetcode 202.快乐数"></a>leetcode 202.快乐数</h1><p><u><strong>题目</strong>：编写一个算法来判断一个数 n 是不是快乐数。</u></p>
<p><u>「快乐数」 定义为：</u></p>
<p><u>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</u><br><u>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</u><br><u>如果这个过程 结果为 1，那么这个数就是快乐数。</u><br><u>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</u></p>
<p><u>示例如下：</u></p>
<p><u>输入：n &#x3D; 19</u><br><u>输出：true</u><br><u>解释：</u><br><u>12 + 92 &#x3D; 82</u><br><u>82 + 22 &#x3D; 68</u><br><u>62 + 82 &#x3D; 100</u><br><u>12 + 02 + 02 &#x3D; 1</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//必须同时满足n != 1和set里面没有n，才进入循环：n == 1就是快乐数，set有n就是死循环</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !set.contains(n))&#123;</span><br><span class="line">            <span class="comment">//注意这里要先添加n到set中，再改变n的值。</span></span><br><span class="line">            set.add(n);</span><br><span class="line">            n = getNextNum(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">n</span> <span class="operator">=</span>= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            res += temp * temp;</span><br><span class="line">            n = n / <span class="number">10</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的思路有那么一点绕，一次写对不是很容易。</p>
<p>首先我们最好单独定义一个方法，<strong>用来计算每次不断更新的n，计算的过程就是不停的记录n % 10</strong>，然后让该位乘方值记录到res中，直到n &#x3D;&#x3D; 0，也就是把n的每一位的乘方都累加到res中。</p>
<p>然后将上面记录的更新之后的n，更新到主方法的n中。</p>
<p>在<strong>更新之前我们要记得用set保存n</strong>，防止后续的循环计算。</p>
<p>循环条件要想清楚，<strong>既然你进入这个循环了，那么你肯定不等于1</strong>，因为等于1就没要计算了，所以有n !&#x3D; 1这个条件。</p>
<p><strong>另一个条件自然是为了避免重复计算</strong>，所以n更新之后必须更新为之前没有计算过的n，如果计算过，那么就直接跳出循环吧。</p>
<p>所以循环条件有两个，一定不要丢了。</p>
<h1 id="leetcode-349-两个数组的交集"><a href="#leetcode-349-两个数组的交集" class="headerlink" title="leetcode 349.两个数组的交集"></a>leetcode 349.两个数组的交集</h1><p><u><strong>题目</strong>：给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。举例：</u></p>
<p><u>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</u><br><u>输出：[2]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; resSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums1)&#123;</span><br><span class="line">            set1.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(x))&#123;</span><br><span class="line">                resSet.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[resSet.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : resSet)&#123;</span><br><span class="line">            ans[index++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路比较简单，注意审题，相同的元素我们只记录一次，所以用HashSet是一种很简单的方式。</p>
<p>注意最后用数组记录即可。</p>
<h1 id="☆leetcode-350-两个数组的交集II"><a href="#☆leetcode-350-两个数组的交集II" class="headerlink" title="☆leetcode 350.两个数组的交集II"></a>☆leetcode 350.两个数组的交集II</h1><p><u><strong>题目</strong>：给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。举例：</u></p>
<p><u>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</u><br><u>输出：[2,2]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length &gt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums1)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            map.put(x, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(x))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.get(x);</span><br><span class="line">                ans[index++] = x;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    map.put(x, count);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.remove(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//注意这里是左闭右开区间</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(ans, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题与上面一题的区别就是重复元素要全部记录了，所以HashSet显得力不从心了。我们选用能记录每个重复元素出现次数的HashMap，利用value来记录每个key值出现的次数。</p>
<p><strong>为了节省哈希表得空间</strong>，我们用较小得数组存储到哈希表中。</p>
<p>每次存储的时候需要注意，为了书写和判断方便，我们利用map的getOrDefault方法，这可以让我们轻松的写出统一的count值，然后执行map.put(x, count)。</p>
<p>因为<strong>交集元素个数肯定 &lt;&#x3D; 较短的数组长度</strong>，所以我们记录交集元素只需要较短的长度即可。</p>
<p>在判断长数组存不存在map元素的时候，要注意：一旦存在，<strong>我们添加后一定要判断当前的count值，并且更新count值</strong>，更重要的是，count &#x3D;&#x3D; 0了要及时<strong>删除其所对应的key值</strong>，如果还没等于0，也要<strong>及时更新map中的count值</strong>，即map.put(x, count)。</p>
<h1 id="leetcode-1-两数之和"><a href="#leetcode-1-两数之和" class="headerlink" title="leetcode 1.两数之和"></a>leetcode 1.两数之和</h1><p><u><strong>题目</strong>：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</u></p>
<p><u>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</u></p>
<p><u>你可以按任意顺序返回答案。</u></p>
<p><u>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</u><br><u>输出：[0,1]</u><br><u>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tar</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(tar) &amp;&amp; map.get(tar) != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, map.get(tar)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里不能先添加，否则上面返回的数组</span></span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一步到位：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="☆leetcode-454-四数相加-II"><a href="#☆leetcode-454-四数相加-II" class="headerlink" title="☆leetcode 454.四数相加 II"></a>☆leetcode 454.四数相加 II</h1><p><u><strong>题目</strong>：给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</u></p>
<p><u>0 &lt;&#x3D; i, j, k, l &lt; n</u><br><u>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0</u></p>
<p><u>举例</u>：</p>
<p><u>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]</u><br><u>输出：2</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(temp)) &#123;</span><br><span class="line">                    map.put(temp, map.get(temp) + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(temp, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(<span class="number">0</span> - temp)) &#123;</span><br><span class="line">                    res += map.get(<span class="number">0</span> - temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-15-三数之和"><a href="#leetcode-15-三数之和" class="headerlink" title="leetcode 15.三数之和"></a>leetcode 15.三数之和</h1><p><u><strong>题目</strong>：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</u></p>
<p><u>注意：答案中不可以包含重复的三元组。</u></p>
<p><u>输入：nums &#x3D; [-1,0,1,2,-1,-4]</u><br><u>输出：[[-1,-1,2],[-1,0,1]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));</span><br><span class="line">                    left++; </span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-18-四数之和"><a href="#leetcode-18-四数之和" class="headerlink" title="leetcode 18.四数之和"></a>leetcode 18.四数之和</h1><p><u>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</u></p>
<p><u>0 &lt;&#x3D; a, b, c, d &lt; n</u><br><u>a、b、c 和 d 互不相同</u><br><u>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target</u><br><u>你可以按 任意顺序 返回答案 。</u></p>
<p><u>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0</u><br><u>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                    <span class="comment">//因为测试用例增加了一个相加会发生溢出的数组，所以用long型</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>)nums[i] + (<span class="type">long</span>)nums[j] + (<span class="type">long</span>)nums[left] + (<span class="type">long</span>)nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">                        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i], nums[j], nums[left], nums[right])));</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-242-有效的字母异位词"><a href="#leetcode-242-有效的字母异位词" class="headerlink" title="leetcode 242.有效的字母异位词"></a>leetcode 242.有效的字母异位词</h1><p><u><strong>题目</strong>：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</u></p>
<p><u>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</u></p>
<p><u>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”</u><br><u>输出: true</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            nums[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            nums[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-383-赎金信"><a href="#leetcode-383-赎金信" class="headerlink" title="leetcode 383.赎金信"></a>leetcode 383.赎金信</h1><p><u><strong>题目</strong>：给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</u></p>
<p><u>如果可以，返回 true ；否则返回 false 。</u></p>
<p><u>magazine 中的每个字符只能在 ransomNote 中使用一次。</u></p>
<p><u>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”</u><br><u>输出：false</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : magazine.toCharArray()) &#123;</span><br><span class="line">            nums[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : ransomNote.toCharArray()) &#123;</span><br><span class="line">            nums[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="comment">//这里直接判断，可以省去一次循环</span></span><br><span class="line">            <span class="keyword">if</span>(nums[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="☆leetcode-49-字母异位词分组"><a href="#☆leetcode-49-字母异位词分组" class="headerlink" title="☆leetcode 49.字母异位词分组"></a>☆leetcode 49.字母异位词分组</h1><p><u><strong>题目</strong>：给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。</u></p>
<p><u>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</u></p>
<p><u>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]</u><br><u>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str : strs) &#123;</span><br><span class="line">            <span class="comment">//1.注意：为每个字符串单独创建数组</span></span><br><span class="line">            <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">                nums[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.用sb存储每个字符串的标识符，如hello:h1e1ll2o1</span></span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append((<span class="type">char</span>) i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                    sb.append(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.注意：将StringBuilder转换为String</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="comment">//4.构建map的value，如果之前有key对应的value，就继续向list中添加新的字符串，然后将list统一放入map中。</span></span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.map.values()本身就是List&lt;String&gt;类型的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="☆leetcode-438-找到字符串中所有字母异位词"><a href="#☆leetcode-438-找到字符串中所有字母异位词" class="headerlink" title="☆leetcode 438.找到字符串中所有字母异位词"></a>☆leetcode 438.找到字符串中所有字母异位词</h1><p><u><strong>题目</strong>：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</u></p>
<p><u>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</u></p>
<p><u>输入: s &#x3D; “cbaebabacd”, p &#x3D; “abc”</u><br><u>输出: [0,6]</u><br><u>解释:</u><br><u>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。</u><br><u>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</u></p>
<p><u>输入: s &#x3D; “abab”, p &#x3D; “ab”</u><br><u>输出: [0,1,2]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滑动窗口+哈希法存储</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sLength</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pLength</span> <span class="operator">=</span> p.length();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(sLength &lt; pLength) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] sNums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] pNums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; pLength;i++) &#123;</span><br><span class="line">            sNums[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            pNums[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(sNums, pNums)) &#123;</span><br><span class="line">            ans.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保证窗口长度为pLength不变，逐个删除左边界i，添加右边界i + pLen</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; sLength - pLength;i++) &#123;</span><br><span class="line">            sNums[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            sNums[s.charAt(i + pLength) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(Arrays.equals(sNums, pNums)) &#123;</span><br><span class="line">                ans.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/13/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/" data-id="cl33tx2240000fkv6agf0ho2c" data-title="哈希算法题目" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-个人对JVM的理解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E4%B8%AA%E4%BA%BA%E5%AF%B9JVM%E7%9A%84%E7%90%86%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T12:04:43.000Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E4%B8%AA%E4%BA%BA%E5%AF%B9JVM%E7%9A%84%E7%90%86%E8%A7%A3/">个人对JVM的理解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="☆JVM内存结构："><a href="#☆JVM内存结构：" class="headerlink" title="☆JVM内存结构："></a>☆JVM内存结构：</h2><p><img src="D:\Picgo\img\image-20220511200810603.png" alt="image-20220511200810603"></p>
<p>首先给出JVM的结构图，包括了类装载器子系统、运行时数据区、执行引擎、本地方法接口、垃圾回收（<strong>这里不确定</strong>）</p>
<p>而内存结构呢，就是运行时数据区部分，也就包括了：程序计数器、虚拟机栈、本地方法栈、堆、方法区。其中方法区在jdk8以后就变成元数据区了。</p>
<p><u>程序计数器</u>：</p>
<p>是内存中很小的一个存储空间，可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。在程序运行过程中，线程是非常多的，但是CPU的核心数却是有限的，所以我们必须要通过不断切换线程来来为处理器分配时间，进而完成程序的执行。程序计数器就是为了实现线程切换用的，<strong>每个线程都用独立的程序计数器</strong>，两两互不干扰，其生命周期也与线程保持一致。</p>
<p>垃圾回收和内存溢出都与程序计数器无关。</p>
<h2 id="☆类加载机制整个过程是怎么样的"><a href="#☆类加载机制整个过程是怎么样的" class="headerlink" title="☆类加载机制整个过程是怎么样的"></a>☆类加载机制整个过程是怎么样的</h2><p><img src="D:\Picgo\img\image-20220512150709656.png" alt="image-20220512150709656"></p>
<p>类加载机制的过程：首先Java虚拟机将描述类的数据从Class文件中<strong>加载到内存</strong>，然后对数据进行<strong>连接以及初始化</strong>的过程，最终形成了可以被JVM可以直接使用的类型。</p>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><p>加载只是整个“类加载”过程的第一步。这个过程Java虚拟机完成了三件事：</p>
<p>1）通过一个类的全限定名来<strong>获取定义此类的二进制字节流</strong>。</p>
<p>2）将这个字节流代表的静态存储结构<strong>转化</strong>为方法区的运行时数据结构（注意：这里仅仅是转化）。</p>
<p>3）在内存中生成一个代表这个类的java.lang.Class对象，<strong>作为方法区这个类的各种数据访问入口</strong>。</p>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><p>作为连接的第一步，验证的目的主要是确保加载的Class字节流<strong>不会危害</strong>到虚拟机自身安全（本步骤对应的代码如果已经在之前执行过程中反复验证过了，就可以关掉该步骤，以缩短虚拟机类加载时间）：</p>
<p>1）文件格式验证：验证字节流<strong>是否符合Class文件格式规范</strong></p>
<p>2）元数据验证：对字节码进行<strong>语义分析</strong>，比如某个类有无父类，是否继承了不允许继承的类等一些违规的语义</p>
<p>3）字节码验证：确定程序语义的<strong>合法性、逻辑性</strong>，较复杂，具体见《深入理解JVM》P270</p>
<p>4）符号引用验证：这个验证要在后面的解析阶段发生，通俗来讲，就是<strong>检验该类是否缺少或者被禁止访问它依赖的某些资源</strong>。</p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h3><p>本阶段开始正式为类中定义的<strong>静态变量分配内存</strong>并<strong>设置初始零值</strong>。注意：JDK 7之前，这部分变量分配在方法区中，而<strong>JDK 8之后，则分配到堆中</strong>。以下两点需要注意：</p>
<p>1）这里分配内存和设置零值都<strong>仅限于类变量</strong>（静态变量），实例变量将在<strong>对象实例化时随着对象一起分配到Java堆中</strong>。</p>
<p>2）注意是设置零值，<strong>一般情况不是初始化</strong>。</p>
<p>3）特殊情况就是<strong>static final定义的变量</strong>，Javac<strong>编译时</strong>就已经为该变量生成ConstantValue属性（可以理解为<strong>设置初始零值</strong>），类加载的准备阶段，就<strong>直接为其赋值</strong>了。</p>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><p>将字节码中常量池内的符号引用替换为直接引用。</p>
<p>1）符号引用：是任何形式的字面量，只要使用时能无歧义的“精准定位”即可。</p>
<p>2）直接引用：可以是<strong>直接指向</strong>目标的<strong>指针</strong>、<strong>相对偏移量</strong>或能<strong>间接定位</strong>到目标的<strong>句柄</strong>。一旦有直接引用，那么相对应的<strong>目标必定在虚拟机内存中存在</strong>。</p>
<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><p>该阶段，虚拟机才正式开始执行类中编写的Java程序代码，将主导权移交给应用程序。在前面的”准备“阶段中，我们已经为类变量进行分配内存和设置零值的操作，接下来就<strong>轮到初始化阶段真正为这些变量赋值</strong>了。</p>
<p>1）直接来讲，<strong>初始化就是执行类构造器clinit&gt;()方法的过程</strong>，clinit&gt;()是Javac编译器的自动生成物。</p>
<p>2）clinit&gt;()是编译器自动收集类中<strong>所有的静态变量的赋值动作和静态语句块中的语句</strong>合并而成的，收集顺序就是源代码书写顺序。</p>
<p>3）在子类执行clinit&gt;()方法前，<strong>先要执行其父类clinit&gt;()<strong>，这也是为什么父类静态语句块要先执行的原因。与类的构造函数（虚拟机视角的实例构造器init&gt;()方法）不同，</strong>不需要显示调用父类构造器</strong>。</p>
<h2 id="☆类加载器"><a href="#☆类加载器" class="headerlink" title="☆类加载器"></a>☆类加载器</h2><p><img src="D:\Picgo\img\image-20220512194439270.png" alt="image-20220512194439270"></p>
<p>前面提到，类加载机制的第一步就是加载，我们用到的工具自然是类加载器。其实类加载器分类很简单，就是C&#x2F;C++写的启动类加载器和Java写的类加载器，具体分类如下：</p>
<p><img src="D:\Picgo\img\image-20220512194934161.png" alt="image-20220512194934161"></p>
<h3 id="1-启动类加载器（引导类加载器-Bootstrap-ClassLoader）"><a href="#1-启动类加载器（引导类加载器-Bootstrap-ClassLoader）" class="headerlink" title="1.启动类加载器（引导类加载器, Bootstrap ClassLoader）"></a>1.启动类加载器（引导类加载器, Bootstrap ClassLoader）</h3><p>1）<strong>虚拟机自带</strong>，C++编写</p>
<p>2）用来<strong>加载Java核心库</strong></p>
<p>3）<strong>没有父加载器，也没有父类</strong></p>
<p>4）<strong>加载其下面的</strong>扩展类加载器和系统类加载器</p>
<h3 id="2-扩展类加载器（Extension-ClassLoader）"><a href="#2-扩展类加载器（Extension-ClassLoader）" class="headerlink" title="2.扩展类加载器（Extension ClassLoader）"></a>2.扩展类加载器（Extension ClassLoader）</h3><p>1）Java编写，**<u>独立存在于虚拟机外部</u>**</p>
<p>2）<strong>继承自抽象类</strong>java.lang.ClassLoader</p>
<p>3）父类加载器就是上边的Bootstrap ClassLoader</p>
<h3 id="3-系统类加载器（应用程序类加载器，System-ClassLoader）"><a href="#3-系统类加载器（应用程序类加载器，System-ClassLoader）" class="headerlink" title="3.系统类加载器（应用程序类加载器，System ClassLoader）"></a>3.系统类加载器（应用程序类加载器，System ClassLoader）</h3><p>1）Java编写，**<u>独立存在于虚拟机外部</u>**</p>
<p>2）<strong>继承自抽象类</strong>java.lang.ClassLoader</p>
<p>3）父类加载器就是上边的Extension ClassLoader</p>
<p>4）负责加载环境变量和系统属性指定路径下的类库</p>
<p>5）程序的默认类加载器，<strong>一般Java应用类都是它加载的</strong>。</p>
<h3 id="4-用户自定义类加载器"><a href="#4-用户自定义类加载器" class="headerlink" title="4.用户自定义类加载器"></a>4.用户自定义类加载器</h3><h2 id="☆双亲委派模型"><a href="#☆双亲委派模型" class="headerlink" title="☆双亲委派模型"></a>☆双亲委派模型</h2><p>首先我们要知道，虚拟机对class文件是<strong>按需加载</strong>的，也就是只有在需要使用该类的时候，才将其class文件加载到内存中生成class对象。</p>
<p>那么加载某个class文件的时候，具体的过程是怎么样的呢？这时候就要引入我们的一种特殊模式：双亲委派模式。工作原理如下：</p>
<p>1）一个类加载器收到类加载请求，<strong>先把请求依次委托其父类加载器去执行</strong>，请求<strong>最终到达顶层</strong>的启动类加载器。</p>
<p>2）如果父类加载器<strong>可以完成类加载的任务，就成功返回</strong>。若不能完成，<strong>才交给子加载器</strong>进行加载。</p>
<h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>其实就是利用了双亲委派模型的特点，假如我们定义一个String类，那么加载这个自定义String类的时候，<strong>会先委派到顶部的引导类加载器加载</strong>，引导类发现自己可以加载，就<strong>接着加载JDK自带的文件java.lang.String</strong>，这样就可以避免我们自定义String类对核心源代码的破坏。</p>
<h3 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h3><p>1）避免类的重复加载</p>
<p>2）保护程序安全，避免核心API被随意篡改</p>
<h2 id="☆判断两个class对象是否相同，我们需要看什么？"><a href="#☆判断两个class对象是否相同，我们需要看什么？" class="headerlink" title="☆判断两个class对象是否相同，我们需要看什么？"></a>☆判断两个class对象是否相同，我们需要看什么？</h2><p>1）类的名字首先得相同，包名也得一致</p>
<p>2）加载这个class的类加载器（<strong>ClassLoader实例对象</strong>）必须相同。</p>
<h2 id="☆Java什么时候对类进行主动引用？"><a href="#☆Java什么时候对类进行主动引用？" class="headerlink" title="☆Java什么时候对类进行主动引用？"></a>☆Java什么时候对类进行主动引用？</h2><p>1）使用new关键字实例化对象的时候</p>
<p>2）访问某个<strong>类（或接口）的静态变量</strong>，或者对该静态变量<strong>赋值</strong></p>
<p>3）调用某个类的<strong>静态方法</strong></p>
<p>4）使用java.lang.reflect包的方法对某个类进行<strong>反射调用</strong></p>
<p>5）初始化某个类，<strong>优先触发其父类初始化</strong></p>
<p>6）虚拟机启动时，用户需要<strong>指定一个要执行的主类</strong>（包括main()方法的那个类），虚拟机先初始化该类</p>
<p>7）JDK 7开始提供<strong>动态语言支持</strong>（不懂）</p>
<p>8）JDK 8在**接口中定义了默认方法(**default标识)，如果这个接口的实现类发生了初始化，那么该接口要率先初始化。</p>
<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>程序计数器（pc寄存器）存放的是该方法要执行的下一条指令的值（存疑）。</p>
<h1 id="☆虚拟机栈的作用是什么？"><a href="#☆虚拟机栈的作用是什么？" class="headerlink" title="☆虚拟机栈的作用是什么？"></a>☆虚拟机栈的作用是什么？</h1><p>栈是<strong>运行时</strong>的单位，而堆是<strong>存储的</strong>单位。栈解决的是程序如何执行，如何处理数据的问题；而堆是解决数据存储的问题。当然一些数据也会存在栈中，只能说栈的主要功能是处理数据，它<strong>是线程私有的</strong>。内部存储着一个个栈帧，<strong>每一个栈帧对应一个Java方法</strong>。</p>
<p>上面是比较泛泛的总结，虚拟机栈具体是什么作用呢？它主管程序的运行，<strong>在每个栈帧的局部变量表中保存相应方法的局部变量</strong>（8种<strong>基本数据</strong>类型、引用类型变量的<strong>引用地址</strong>），一<strong>部分结果</strong>，并参与方法的<strong>调用和返回</strong>。</p>
<p>栈操作只有两个：</p>
<p>1）执行方法的时候，<strong>进栈</strong>（入栈、压栈）</p>
<p>2）方法执行结束的时候，<strong>出栈</strong></p>
<p>所以栈<strong>没有垃圾回收机制</strong>，只<strong>存在栈溢出</strong>的现象。</p>
<h1 id="☆虚拟机栈的常见异常？如何设置栈的大小？"><a href="#☆虚拟机栈的常见异常？如何设置栈的大小？" class="headerlink" title="☆虚拟机栈的常见异常？如何设置栈的大小？"></a>☆虚拟机栈的常见异常？如何设置栈的大小？</h1><p>当<strong>某个线程请求分配的栈容量超过</strong>了Java虚拟机栈允许的最大容量，虚拟机会报<strong>StackOverflowError</strong>，即栈溢出。</p>
<p>我们可以通过-Xxx设置虚拟机栈的大小。在Idea的Run中，找到Edit Configurations，在当前程序的VM options中写入-Xxx256k即可。</p>
<p>如果Java虚拟机栈可以动态扩展，但<strong>扩展的时候无法申请到足够的内存</strong>，或者创建新线程的时候<strong>没有足够内存去创建对应的虚拟机栈</strong>，则虚拟机会报OutOfMemoryError异常，也就是我们所说的OOM。</p>
<h1 id="☆栈帧的内部结构"><a href="#☆栈帧的内部结构" class="headerlink" title="☆栈帧的内部结构"></a>☆栈帧的内部结构</h1><p>栈帧内部包括：局部变量表、操作数栈、动态链接、方法返回地址、一些附加信息。其中，<strong>局部变量表和操作数栈占的内存最大</strong>，主要影响栈帧的大小，而栈帧的大小决定了每个线程的虚拟机栈能存放多少个栈帧。</p>
<p>1）局部变量表：就是<strong>数字数组</strong>，主要用于<strong>存储方法参数和定义在方法体内的局部变量</strong>，包括基本数据类型、对象引用、returnAddress类型。<strong>slot(变量槽)<strong>是最基本的存储单元，对于byte、short、char在存储前，被</strong>转换为int</strong>,而boolean也被<strong>转换为int</strong>，false对应0，true对应非0。他们都<strong>占用一个slot</strong>。long和double类型的变量<strong>占两个slot</strong>。</p>
<p>栈帧的<strong>局部变量表与性能调优关系最为密切</strong>，因为在垃圾回收过程中，表中的变量是重要的<strong>垃圾回收根节点</strong>，只要<strong>被表中直接或间接引用的对象</strong>都不会被回收。</p>
<p>2）操作数栈(其<strong>大小在编译时就确定</strong>了)：在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，例如执行<strong>复制、交换、求和</strong>等操作。主要用于<strong>保存计算过程中的中间结果</strong>，同时作为计算过程中的<strong>变量临时存储空间</strong>。</p>
<p>注意：操作数栈<strong>并非通过访问索引</strong>来进行数据访问的，它只是入栈出栈的一个实现工具。</p>
<p>3）动态链接：<strong>指向运行时常量池</strong>中的该栈帧所属<strong>方法的引用</strong>。在类加载之前，符号引用都在class文件的常量池中，类加载后，这些符号引用就被<strong>类加载阶段的“解析”过程</strong>转换为调用方法的直接引用。动态链接就是<strong>来实现这个“解析”过程的</strong>。</p>
<p>4）方法返回地址：存放调用该方法的<strong>pc寄存器的值</strong>（存疑）。本质上就是：比如当前方法退出了，意为当前方法出栈，<strong>那么就要恢复上层方法的栈帧</strong>，这时我们就需要程序计数器的值，所以方法返回地址就存放了这个值（类比接力赛传棒）。</p>
<p>动态链接，方法返回地址和其他附加信息被称为<strong>帧数据区</strong>。</p>
<p>总的来说，每一个栈帧对应一个方法，但是方法要运行就必须有一个专门的数据结构来对数据进行操作，这个数据结构就是操作数栈，数据就是局部变量表中的数据，方法执行过程中，各种字节码指令负责操作数栈的入栈出栈操作。</p>
<h1 id="☆局部变量和静态变量的对比"><a href="#☆局部变量和静态变量的对比" class="headerlink" title="☆局部变量和静态变量的对比"></a>☆局部变量和静态变量的对比</h1><p>我们知道静态变量就是类变量，是在累加载阶段就有初始化操作的，其一是<strong>“准备”阶段的初始化零值</strong>，另一阶段是<strong>”初始化“阶段为类变量赋初始值</strong>。</p>
<p>对于局部变量，<strong>因为要放在局部变量表中，表没有初始化过程</strong>，所以我们必须在写代码的时候，人为初始化。</p>
<h1 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h1><p>静态绑定&#x2F;链接（对应早期绑定）就是（被调用的方法）<strong>符号引用转换为直接引用在编译期</strong>就可以确定下来，比如定义一个<strong>final的常量或方法</strong>，此时这个符号在编译期就可以确定，没有多态的特性。</p>
<p>动态绑定&#x2F;链接（对应晚期绑定）就是（被调用的方法）符号引用转换为直接引用是<strong>在运行期间</strong>才可以确定下来，正是因为Java具有<strong>多态</strong>的特性，所以才有了动态链接。</p>
<h1 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h1><p>简单来说就是father类继承了Object类，然后写了两个新方法，然后Son类继承了father类，然后重写了father类的两个新方法，那么在Son调用这两个新方法的时候就会去father中找，但是调用object类的时候，就可以直接从虚方法表中找到，不用先上father中找，然后再去Object中找了。</p>
<p>这样就实现了，调用方法的时候，根据虚方法表直接确定压入操作数栈的直接引用，不用再一层层向上判断。</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220622200249524.png" alt="image-20220622200249524" style="zoom:50%;" />

<h1 id="本地方法接口和本地方法栈"><a href="#本地方法接口和本地方法栈" class="headerlink" title="本地方法接口和本地方法栈"></a>本地方法接口和本地方法栈</h1><p>本地方法接口就是一个java<strong>调用非java代码</strong>（C代码）的接口。</p>
<p>本地方法栈在运行时数据区内部，用于<strong>管理本地方法的调用</strong>。</p>
<h1 id="JVM实例-进程-运行时数据区的关系"><a href="#JVM实例-进程-运行时数据区的关系" class="headerlink" title="JVM实例-进程-运行时数据区的关系"></a>JVM实例-进程-运行时数据区的关系</h1><p>一个jvm实例对应着一个进程，一个进程只有一个运行时数据区。因为一个进程拥有多个线程，所以多线程共享一个堆和方法区，而他们各自拥有自己的程序计数器、虚拟机栈和本地方法栈。</p>
<h1 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h1><p>JVM一启动，引导类加载器就把JVM实例加载出来了，<strong>JVM实例创建出来了，运行时数据区就确定了</strong>，所以堆区的大小也就确定了。堆上的物理空间不是连续的，但逻辑上应该视为连续的。</p>
<p>栈、堆、方法区之间的关系如图所示：</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220623163626173.png" alt="image-20220623163626173" style="zoom: 50%;" />

<h1 id="对象在堆中的分配过程"><a href="#对象在堆中的分配过程" class="headerlink" title="对象在堆中的分配过程"></a>对象在堆中的分配过程</h1><p>new出来的对象先放在Eden区，当Eden区满了，触发YGC&#x2F;Minor GC即垃圾回收，剩余的对象放入servivor的to区，survivor的<strong>from区和to区必须有一个是空的，谁空谁是to区</strong>。</p>
<p>所以<strong>触发YGC之后，Eden区必为空</strong>，多出来的放入survivor的to区，放不下就放老年代。</p>
<p>如果survivor区满了，会触发GC吗？不会，只有Eden区满了才会触发YGC，其实YGC不仅回收Eden区，也回收两个survivor区，也就是说<strong>YGC回收的是整个新生代区的垃圾，但是只有Eden区满了才会触发YGC</strong>。</p>
<p>什么时候survivor满了？我们要知道：**<u>只有YGC的时候，才会从Eden和from区向to区转移对象</u>**，survivor满了的意思就是当前需要转移到to区的对象所占内存大于to区的内存，那么多出来的就会晋升至老年代（这时候就无视对象年龄）</p>
<p><strong>-Xx:MaxTenuringThreshold</strong>&#x3D; N是新生代到老年代的<strong>阈值</strong>，超过这个值就会晋升到老年代，当老年代满了，就会触发Major GC。</p>
<h1 id="为什么要有TLAB"><a href="#为什么要有TLAB" class="headerlink" title="为什么要有TLAB?"></a>为什么要有TLAB?</h1><p>TLAB(Thread Local Allocation Buffer)本地线程分配缓冲，说白了就是，一个运行数据区（只有一个堆）对应着一个进程，一个进程有多个线程，<strong>多个线程共享一个堆内的数据</strong>，高并发环境下会带来<strong>线程不安全问题</strong>。</p>
<p>下图画的有点大，其实TLAB内存非常小，仅占整个**Eden区的1%**（这里好像是每个线程占1%，不确定）。</p>
<p>注意：TLAB<strong>不能完全说是线程私有的</strong>，因为其他线程也<strong>可以访问</strong>这部分空间，但在这部分空间分<strong>配内存的权力</strong>只有当前线程拥有。</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220623171737389.png" alt="image-20220623171737389" style="zoom:60%;" />

<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><p>逃逸分析就是分析<strong>对象的动态作用域</strong>：</p>
<p>当一个对象只<strong>在当前方法中被定义并调用</strong>，就是没有逃逸，就可以将当前对象放入栈中，即<strong>栈上分配</strong>。</p>
<p>当一个对象在当前方法定义之后，不仅在当前方法调用，还在<strong>外部方法调用</strong>，则发生了逃逸。</p>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>将堆分配转换为栈分配</p>
<h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><p>一个对象<strong>只被一个线程访问</strong>（未逃逸），那么可以把对该对象的同步操作去掉（<strong>删除同步锁</strong>）。</p>
<h3 id="分离对象或标量替换"><a href="#分离对象或标量替换" class="headerlink" title="分离对象或标量替换"></a>分离对象或标量替换</h3><p>一个对象其实就是<strong>多个元素的聚合量</strong>，如果逃逸分析后发现当前对象只被一个线程调用，那么这个聚合量就可以被打散，放入栈中。比如对象Tom有name, age, sex，那么就可以将之前存放在堆中的Tom变量转换为标量name,age,sex分配到栈的局部变量表中。</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>方法区相当于JVM的“接口”，而永久代、元空间相当于JVM具体实现的类</p>
<p>jdk7及之前方法区在hotspot虚拟机<strong>具体实现</strong>是永久代；</p>
<p>jdk8以后方法区的<strong>具体实现</strong>是元空间（不占用虚拟机设置的内存，而是<strong>使用本地内存</strong>）。</p>
<p>JVM中方法区不能等价为元空间，只是hotspot虚拟机（默认虚拟机）的方法区等价为元空间</p>
<p><strong>方法区主要存放的是Class类</strong>，而堆主要存放的是实例化的对象。</p>
<p>下图可以看到，Person类在加载过程中是存到方法区的，而对象person如果是在方法中定义的，那么就是局部变量，存放在栈帧的局部变量表中，只不过存放的是地址，真正的对象是存放在堆中的。</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220623193754551.png" alt="image-20220623193754551" style="zoom:50%;" />

<h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p>方法区存放着[<strong>类型信息</strong>（域&#x2F;属性信息和方法信息）]、[<strong>运行时常量池</strong>（常量、静态变量）]、[JIT代码缓存]。</p>
<p><u>类型信息</u>：这个类型的完整有效名（<strong>包名</strong>.类名）、直接父类有效名、修饰符、<strong>直接接口的有序表</strong></p>
<p><u>域&#x2F;属性信息</u>：属性名称、类型、修饰符以及声明顺序</p>
<p><u>方法信息</u>：方法名称、返回类型、参数的数量和类型、修饰符、字节码、操作数栈、局部变量表及大小、异常表</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220623201600578.png" alt="image-20220623201600578" style="zoom: 40%;" />

<p>Hotspot中方法区的变化：</p>
<table>
<thead>
<tr>
<th>JDK1.6及以前</th>
<th>永久代，静态变量存储在永久代上</th>
</tr>
</thead>
<tbody><tr>
<td>JDK1.7</td>
<td>永久代，但已经逐步 “去永久代”，<strong>字符串常量池，静态变量移除，保存在堆中</strong></td>
</tr>
<tr>
<td>JDK1.8</td>
<td>元空间，类型信息，字段，方法，常量保存在本地内存的元空间，但<strong>字符串常量池、静态变量仍然在堆中</strong>。</td>
</tr>
</tbody></table>
<p>JDK6的时候</p>
<img src="D:/Java/JVM/1_内存与垃圾回收篇/9_方法区/images/image-20200708211541300.png" alt="image-20200708211541300" style="zoom:50%;" />

<p>JDK7的时候</p>
<img src="D:/Java/JVM/1_内存与垃圾回收篇/9_方法区/images/image-20200708211609911.png" alt="image-20200708211609911" style="zoom:50%;" />

<p>JDK8的时候，元空间大小只受物理内存影响（注意静态变量和字符串常量池的位置）</p>
<img src="D:/Java/JVM/1_内存与垃圾回收篇/9_方法区/images/image-20200708211637952.png" alt="image-20200708211637952" style="zoom:50%;" />

<h2 id="常量池与运行时常量池的关系"><a href="#常量池与运行时常量池的关系" class="headerlink" title="常量池与运行时常量池的关系"></a>常量池与运行时常量池的关系</h2><p>常量池表是<strong>Class文件的一部分</strong>，用于存放<strong>编译期生成</strong>的各种<strong>字面量和符号引用</strong>，这部分内容将在<strong>类加载后存放</strong>到方法区的运行时常量池中。</p>
<h2 id="永久代为什么要被元空间替换"><a href="#永久代为什么要被元空间替换" class="headerlink" title="永久代为什么要被元空间替换"></a>永久代为什么要被元空间替换</h2><p>因为永久代的<strong>空间大小不好确定</strong>，设置小了容易报OOM异常，索性用本地内存，即元空间。</p>
<p>另一方面，（<u><strong>方法区的垃圾回收</strong></u>主要是常量中废弃的变量及不再使用的类型）<strong>永久代进行调优是比较困难的</strong>，比如类型的卸载条件<strong>相当苛刻</strong>，所以为了<strong>降低Full GC的频率</strong>，替换为元空间。</p>
<h2 id="字符串常量池为什么要放到堆中？"><a href="#字符串常量池为什么要放到堆中？" class="headerlink" title="字符串常量池为什么要放到堆中？"></a>字符串常量池为什么要放到堆中？</h2><p>因为<strong>开发中会有大量的字符串被创建</strong>，如果放在方法区中，只有在Full GC（永久代或堆空间不足）的时候才会触发<strong>方法区的垃圾回收，频率极低</strong>。所以<u><strong>为了提高字符串常量池的回收效率</strong></u>，直接将字符串常量池放到堆中。</p>
<h2 id="静态变量是谁？不同版本jdk存放在哪里？"><a href="#静态变量是谁？不同版本jdk存放在哪里？" class="headerlink" title="静态变量是谁？不同版本jdk存放在哪里？"></a>静态变量是谁？不同版本jdk存放在哪里？</h2><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220627115757323.png" alt="image-20220627115757323" style="zoom:50%;" />

<p>图中分别有三个不同的变量，staticObj是静态类变量，instanceObj是非静态类变量，localObj是方法内的非静态局部变量，他们三个的对象（<u>各自new出来的对象</u>）<strong>不区分jdk版本，都统一放在堆中</strong>！</p>
<p>而等号左边的才是我们要讨论的变量本身：</p>
<p>对于类变量instanceObj因为是非静态的，所以<strong>随着对象实例存放在Java堆中</strong>；</p>
<p>而localObj则存放在foo()方法<strong>栈帧的局部变量表中</strong>；</p>
<p>而静态变量staticObj在<strong>jdk1.6时，存放在方法区</strong>中，1.7和1.8及以后的版本都<strong>存放在堆中</strong>，而且这个变量的地址和其对象（new出来的）的地址一致，是<strong>伴随的关系</strong>。（细节存疑：这里宋老师讲的是静态变量与类型在Java语言一端的映射Class对象存放在一起，存储于Java堆之中，这个映射不知道是等号右边的new ObjectHolder还是等号左边的ObjectHolder）</p>
<h1 id="运行时数据区总结图"><a href="#运行时数据区总结图" class="headerlink" title="运行时数据区总结图"></a>运行时数据区总结图</h1><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220627145745177.png" alt="image-20220627145745177" style="zoom: 60%;" />

<h1 id="对象创建的过程（实例化过程）"><a href="#对象创建的过程（实例化过程）" class="headerlink" title="对象创建的过程（实例化过程）"></a>对象创建的过程（实例化过程）</h1><p>①加载类元信息</p>
<p>②为对象分配内存（<strong>指针碰撞和空闲列表</strong>）</p>
<p>③处理并发问题</p>
<p>④<strong>属性的零值初始化</strong></p>
<p>⑤<strong>设置对象头</strong>的信息</p>
<p>⑥属性的默认初始化、显示初始化、代码块中的初始化、构造器的初始化</p>
<h1 id="☆面试常考：对象的内存布局"><a href="#☆面试常考：对象的内存布局" class="headerlink" title="☆面试常考：对象的内存布局"></a>☆面试常考：对象的内存布局</h1><p>这里指的是对象在堆内的布局，包括了<strong>对象头、实例数据、对齐填充</strong>。</p>
<p>​	<strong>对象头</strong>（Header）包括<u>运行时元数据</u>和<u>类型指针</u>：</p>
<p>​			<strong>运行时元数据</strong>（Mark Word）:哈希地址值、GC分代年龄、锁状态标志、（线程持有的锁、偏向线程ID及时间戳）</p>
<p>​			<strong>类型指针</strong>：指向类元数据InstanceKlass，确定该对象所属的类型。</p>
<p>​	<strong>实例数据</strong>（Instance Data）是对象真正存储的有效信息，包括代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段），这里注意：相同宽度的字段会被分配到一起，父类定义的变量出现在子类前。</p>
<p>​	<strong>对齐填充</strong>就是起到占位符的作用。</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220627165800364.png" alt="image-20220627165800364" style="zoom: 60%;" />

<h1 id="对象访问的方式"><a href="#对象访问的方式" class="headerlink" title="对象访问的方式"></a>对象访问的方式</h1><p><strong>句柄访问</strong>和<strong>直接指针</strong>，后者是HotSpot所用。</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220627172838950.png" alt="image-20220627172838950" style="zoom:40%;" />

<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220627172846452.png" alt="image-20220627172846452" style="zoom:40%;" />

<h1 id="直接内存会出现OOM异常吗？"><a href="#直接内存会出现OOM异常吗？" class="headerlink" title="直接内存会出现OOM异常吗？"></a>直接内存会出现OOM异常吗？</h1><p>直接内存与Java堆内存的<strong>总和受限于操作系统能给出的最大内存</strong>。所以Java堆内存分配过大，很容易造成直接内存过小，从而导致OOM异常发生。</p>
<p>注意：由于栈等区域占用内存较小，我们可以简单认为<strong>Java程序占用的内存 &#x3D; 堆内存+本地内存</strong></p>
<h1 id="执行引擎相关问题"><a href="#执行引擎相关问题" class="headerlink" title="执行引擎相关问题"></a>执行引擎相关问题</h1><h2 id="为什么Java是半编译半解释型语言？"><a href="#为什么Java是半编译半解释型语言？" class="headerlink" title="为什么Java是半编译半解释型语言？"></a>为什么Java是半编译半解释型语言？</h2><p>因为在处理字节码指令的时候，执行器既有解释器，也有即时编译器JIT。JVM在执行代码时，是将两者结合使用的。</p>
<p>解释器是根据规范<strong>对字节码采用逐行解释的方式执行</strong>，为每条字节码文件的内容“翻译”为对应平台的本地机器指令执行；</p>
<p>JIT是<strong>将字节码直接编译成本地机器语言</strong>。这里的编译属于后端编译，要与前端编译生成字节码文件.class做区分。编译后的本地代码缓存到元空间（方法区）中。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220628134138169.png" alt="image-20220628134138169"></p>
<h2 id="为什么Java源文件不直接给JVM翻译，而是要经过编译器编译成字节码这一过程？"><a href="#为什么Java源文件不直接给JVM翻译，而是要经过编译器编译成字节码这一过程？" class="headerlink" title="为什么Java源文件不直接给JVM翻译，而是要经过编译器编译成字节码这一过程？"></a>为什么Java源文件不直接给JVM翻译，而是要经过编译器编译成字节码这一过程？</h2><p>因为JVM直接翻译Java源文件代价很大，JVM执行引擎真正做的只是翻译字节码文件，所以各司其职，JVM处理字节码文件时最高效的。</p>
<h2 id="热点探测技术"><a href="#热点探测技术" class="headerlink" title="热点探测技术"></a>热点探测技术</h2><ul>
<li>方法调用器用于统计<strong>方法的调用次数</strong>。</li>
<li>回边计数器用于统计<strong>循环体执行的循环次数</strong>。</li>
</ul>
<p>上述的次数都有阈值，而且Client(小)和Server(大)模式下默认值也不一样，<strong>超过阈值就会触发JIT编译</strong>。</p>
<p>一段时间方法没有调用还会发生<strong>热度衰减</strong>，类似化学里的半衰期。</p>
<h2 id="HotSpotVM中JIT的分类"><a href="#HotSpotVM中JIT的分类" class="headerlink" title="HotSpotVM中JIT的分类"></a>HotSpotVM中JIT的分类</h2><p>C1和C2，分别对应Client Compiler和Server Compiler。</p>
<p>（客户端）C1编译器会对字节码进行简单和可靠的优化，耗时短，为的是<strong>更快的响应速度</strong>。</p>
<p>（服务端）C2编译器会发生耗时较长的优化，以及激进优化，但<strong>优化的代码执行效率更高</strong>。</p>
<h2 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h2><p>指在<strong>程序运行前</strong>，便将字节码转换为机器码。破坏了“一次编译，到处运行”。</p>
<h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><p>判断对象存活一般有两种方式：<u>引用计数算法</u>和<u>可达性分析算法</u>。</p>
<h2 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h2><p>举例对象A，被引用了计数器就+1，某个引用失效，计数器就-1，计数器为0就可以认为A对象不再被使用，可进行回收。</p>
<p>优点：实现简单、判定效率高，回收无延迟；</p>
<p>缺点：需要单独的字段存储计数器，并且<strong>无法处理循环引用</strong>，有内存泄漏的风险（致命缺陷）。</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220629161809224.png" alt="image-20220629161809224" style="zoom: 55%;" />

<h2 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h2><p>简单来说，就是<strong>被根对象集合</strong>直接或间接连接的对象才是存活对象，其他都是垃圾。</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220629162625333.png" alt="image-20220629162625333" style="zoom:50%;" />

<p><strong>GC Roots根节点</strong>具体指：除了堆空间外的一些结构，比如<u>虚拟机栈、本地方法栈、方法区、字符串常量池</u>等地方对堆空间的引用，还有一些“临时性”地加入地对象。</p>
<p>可达性分析必须在一致性快照中进行，所以GC时必须“Stop The World”</p>
<h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><p>finalization机制是对象被销毁前的自定义处理逻辑，<strong>当垃圾回收某个对象前，<u>总会</u>调用对象的finalize()<strong>，该方法允许</strong>子类重写</strong>，用于<strong>资源释放</strong>，比如关闭文件、套接字、数据库连接等。</p>
<p>如果极端情况下<strong>不发生GC</strong>，finailze()是没有机会被调用的。</p>
<p>虚拟机中的对象有三种状态：<u>可触及的、可复活的、不可触及</u>的，具体判定过程如下：</p>
<ul>
<li>当一个对象到GC Roots没有引用链，就进行<strong>第一次标记</strong>；</li>
<li>如果该对象<strong>没有重写</strong>finalize()或者<strong>调用过</strong>finalize()了，那么该对象直接为<strong>不可触及类型</strong>的；</li>
<li>如果对象重写了并且还没执行过finalize()，那么该对象就是可复活的，加入F-Queue队列中。</li>
<li>GC对F-Queue队列上的对象进行第二次标记，如果对象到GC Roots有引用链了，就直接移出队列，复活该对象。</li>
</ul>
<p>但是<strong>被二次标记过的对象</strong>如果再次出现没有被引用的情况，就<strong>直接被标记为不可触及</strong>了，也就说明：<u>finalize()仅能复活对象一次，且finalize()只能被调用一次</u>。</p>
<h2 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h2><ul>
<li>先标记，收集器Collector从引用根节点开始遍历，<strong>标记所有被引用的对象</strong>（注意，不是标记垃圾）。</li>
<li>再清除，收集器Collector从头到尾进行<strong>线性遍历</strong>，将没有标记的对象回收。</li>
</ul>
<p>这里的清除，只是把<strong>需要清除的对象地址保存在空闲列表中</strong>，用于新对象地址的覆盖。用空闲列表而不是指针碰撞的原因是内存不规整。</p>
<p>**<u>缺点</u>**：效率不高；GC的时候要STW，用户体验差；内存碎片问题，而且需要维护一个空闲列表。</p>
<h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><p>将内存空间分成两块，每次只使用一块。垃圾回收的时候，<strong>复制存活对象</strong>到另一块内存中，之后<strong>清除原内存区域的所有对象</strong>，最后<strong>交换</strong>两个内存块。</p>
<p><strong><u>优点</u><strong>：没有标记和清除的遍历操作，高效；存活的对象空间连续，</strong>无内存碎片</strong>。</p>
<p><strong><u>缺点</u><strong>：</strong>内存开销</strong>大；<strong>复制需要维护</strong>两个内存区对象的<strong>引用关系</strong>，时间开销也很大。</p>
<p>所以复制算法<strong>只适合存活对象少</strong>的，比如Eden区。</p>
<h2 id="清除阶段：标记-整理算法"><a href="#清除阶段：标记-整理算法" class="headerlink" title="清除阶段：标记-整理算法"></a>清除阶段：标记-整理算法</h2><p>第一阶段和标记清理算法一样，<strong>标记所有被引对象</strong>；</p>
<p>第二阶段将所有存活对象<strong>压缩到内存的一端</strong>，按序排放，最后<strong>清除边界</strong>所有的空间。</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220629193634936.png" alt="image-20220629193634936" style="zoom: 60%;" />

<p><strong>优点</strong>：减小了标记清除算法的<strong>维护空闲列表的开销</strong>，和复制算法需要一倍空间的开销；</p>
<p><strong>缺点</strong>：<strong>效率</strong>肯定不如复制算法；移动对象时需要考虑<strong>引用地址的调整</strong>；移动需要<strong>STW</strong>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table>
<thead>
<tr>
<th></th>
<th>标记清除</th>
<th>标记整理</th>
<th>复制</th>
</tr>
</thead>
<tbody><tr>
<td><strong>速率</strong></td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的2倍空间（不堆积碎片）</td>
</tr>
<tr>
<td><strong>移动对象</strong></td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>根据新生代和老年代存活对象数量及回收频率的不同，年轻代采用<strong>复制算法</strong>，老年代采用<u>标记-清除和标记-整理</u>的<strong>混合实现</strong>。</p>
<h2 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h2><p>上述所有算法，在垃圾回收过程中，应用软件都会处在STW状态。增量收集算法就是让垃圾回收线程和应用程序线程交替进行</p>
<p><strong>缺点</strong>：线程切换和上下文<strong>转换的消耗</strong>，使得垃圾回收成本上升，<strong>系统吞吐量下降</strong>。</p>
<h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>将内存区域分割成多个小块，每一个小区间都可独立使用，独立回收。</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220629200414624.png" alt="image-20220629200414624" style="zoom: 50%;" />

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E4%B8%AA%E4%BA%BA%E5%AF%B9JVM%E7%9A%84%E7%90%86%E8%A7%A3/" data-id="cl31jc9hq00000cv6gfxp6myd" data-title="个人对JVM的理解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-双指针题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T09:01:55.000Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E8%A7%A3/">双指针题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcode-27-移除元素"><a href="#leetcode-27-移除元素" class="headerlink" title="leetcode 27.移除元素"></a>leetcode 27.移除元素</h1><p>**<u>题目</u>**：<u>给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。</u></p>
<p><u>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题因为要原地修改数组，所以必须要<strong>让元素之间换位</strong>来实现更改数组的操作。</p>
<p>所以我们采用双指针解法，既降低了空间复杂度，又实现了原位置换的好处。</p>
<p>具体操作就是让一个fast指针不停向后移动，而slow指针则必须“听从”fast指针安排，当fast没碰到val的时候，fast指针把当前位置的元素赋值给slow位置的元素，因为这些等于val的元素我们就不要了，所以不需要换位，只需要替代即可。</p>
<p>如果fast碰到val了，就让它继续向后走，这时一定不要对数组进行换位操作，因为只有碰到上面的情况，才实现换位，fast碰到的val让slow碰到了再解决。</p>
<p>可能会有以下问题：fast这样赋值，会不会打乱数组原有顺序？肯定不会。因为slow和fast是共起点的，只有当fast碰到val的那一刻，二者分开，而<strong>fast的作用就是要把不等于val的元素赋给slow</strong>，所以fast一定会依次将这些值赋给slow的，也就不会出现乱序的现象。</p>
<h1 id="leetcode-26-删除有序数组中的重复项"><a href="#leetcode-26-删除有序数组中的重复项" class="headerlink" title="leetcode 26.删除有序数组中的重复项"></a>leetcode 26.删除有序数组中的重复项</h1><p><u><strong>题目</strong>：给你一个<strong>升序排列</strong>的数组 <code>nums</code> ，请你原地删除重复出现的元素，使每个元素<strong>只出现一次</strong>，返回删除后数组的新长度。元素的<strong>相对顺序</strong>应该保持<strong>一致</strong>。不要使用额外的空间，你必须在并在使用 O(1) 额外空间的条件下完成</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>, fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[fast - <span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种解法我们可以发现：**比较的是nums[fast]和nums[fast - 1]**，也就是fast指针指向的元素和其指过的元素，直接想难度比较大，我们举例：[0,0,1,1,1,2,2,3,3,4]</p>
<p>因为我们要让fast和前面一位比，自然<strong>初始位置要从1开始</strong>，slow为1，这样可以让两者同步向后走。那么问题来了，slow为0行不行？</p>
<p>我们来看一下，如果slow为0，那么fast第一次比较的时候，发现0 &#x3D;&#x3D; 0会跳过当前位置，走到1的时候，发现1 !&#x3D; 0，这个时候，才把1赋给slow位置的0，<strong>那么slow一开始就丢掉了一个0，整个数组都会丢掉0</strong>。比如[1,1,2]答案是[2]，自己可以试一下。</p>
<p>所以slow和fast初始位置均为1，这样可以避免初始值被吞没的现象。</p>
<p>我们知道，<strong>比较重复值还可以让fast和其后面一个值比较</strong>，官方题解没有给出这种解法，但是确实是可以的，分析如下：</p>
<p>我们来比较nums[fast]和nums[fast + 1]，自然就要让fast从最初的的位置开始走起，所以初始值fast &#x3D; 0。那么slow也从0开始走吗？</p>
<p>我们假设slow也从0开始走，还是以简单的[1,1,2]为例，fast发现1和1相等，跳过，走到第二个1，发现1和2不等，肯定要把2给slow，给前面fast的就给乱了，所以要**把nums[fast + 1]赋给nums[slow]**。这个时候，我们发现slow在一开始就被赋予2，1压根不存在了。所以slow不能从最开始走，而要保留第一个值，从第二位走，也就是初始化slow &#x3D; 1。这只是我自己想到的一种向后比较的解法，纯粹是多思考一下，解法还是按照前面的思路比较简单。向后比较的题解代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[fast + <span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow] = nums[fast + <span class="number">1</span>];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-283-移动零"><a href="#leetcode-283-移动零" class="headerlink" title="leetcode 283.移动零"></a>leetcode 283.移动零</h1><p><u><strong>题目：</strong>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</u></p>
<p><u><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[slow];</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                nums[fast] = temp;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题要<strong>注意是移动0到末尾，而不是删除0</strong>，所以不能仅仅在nums[fast] !&#x3D; 0的时候进行覆盖操作，而要进行替换操作，<strong>将fast指向的非0数字赋给slow，把0转移给fast</strong>。</p>
<h1 id="leetcode-844-比较含退格的字符串"><a href="#leetcode-844-比较含退格的字符串" class="headerlink" title="leetcode 844.比较含退格的字符串"></a>leetcode 844.比较含退格的字符串</h1><p><u><strong>题目：</strong>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</u></p>
<p><u>注意：如果对空文本输入退格字符，文本继续为空。示例如下：</u></p>
<p><u>输入：s &#x3D; “ab#c”, t &#x3D; “ad#c”</u><br><u>输出：true</u><br><u>解释：s 和 t 都会变成 “ac”。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, j = t.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">skipA</span> <span class="operator">=</span> <span class="number">0</span>, skipB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    skipA++;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipA &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipA--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(j) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    skipB++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipB &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipB--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != t.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题虽然为简单题，但是想一次做对有些困难。</p>
<p>因为”#”是删除前一个字符，所以我们从后向前遍历比较好。整体的思路就是，先遍历s，如果碰到#，就计数，直到当前遍历无#，就跳出循环，然后同样的方式遍历t。</p>
<p>两个字符串的遍历走完之后，如果当前i或者j没有走完，就判断当前i和j位置对应的字符是否相等，如果不相等，那么肯定就返回false，为什么呢？因为我们<strong>同时从后向前遍历，一旦进行比较，就说明此时i和j后面的元素已经确定好了</strong>，没有一一对应的话，就没必要向前遍历了。如果有一个字符串走完了呢？一样的道理，还是没有一一对应上，因为<strong>此时连长度都对不上了</strong>，俩字符串更不可能相同了。</p>
<p>如果上述两个判断都没有问题，那么我就让两个指针都向前移动一位，继续判断。</p>
<p>什么时候跳出循环呢？一定要让两个指针都走完才可以，如果只有一个指针走完，我们就return true了。那么<u>absfds##asd##和a</u>就会误判了。</p>
<h1 id="leetcode-977-有序数组的平方"><a href="#leetcode-977-有序数组的平方" class="headerlink" title="leetcode 977.有序数组的平方"></a>leetcode 977.有序数组的平方</h1><p><u><strong>题目：</strong></u><u>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。举例如下：</u></p>
<p><u>输入：nums &#x3D; [-4,-1,0,3,10]</u><br><u>输出：[0,1,9,16,100]</u><br><u>解释：平方后，数组变为 [16,1,0,9,100]</u><br><u>排序后，数组变为 [0,1,9,16,100]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>, index = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] * nums[i] &lt; nums[j] * nums[j])&#123;</span><br><span class="line">                ans[index--] = nums[j] * nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[index--] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="img"></p>
<p>题解来自Carl大佬，这个图足够说明解题思路了。要注意的就是while的循环条件。</p>
<h1 id="☆leetcode-209-长度最小的子数组"><a href="#☆leetcode-209-长度最小的子数组" class="headerlink" title="☆leetcode 209.长度最小的子数组"></a>☆leetcode 209.长度最小的子数组</h1><p><u><strong>题目</strong>：给定一个含有 n 个正整数的数组和一个正整数 target 。</u></p>
<p><u>找出该数组中满足其和 ≥ target 的长度最小的<strong>连续子数组</strong> [numsl, numsl+1, …, numsr-1, numsr]，并返回其长度。如果不存在符合条件的子数组，返回0。</u></p>
<p><u><strong>示例 1：</strong></u></p>
<p><u>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</u><br><u>输出：2</u><br><u>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>, res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right &lt; nums.length;right++)&#123;</span><br><span class="line">            sum += nums[right];<span class="comment">//每次移动right指针都要将其所指元素添加进sum中</span></span><br><span class="line">            <span class="comment">//这里容易写成if，要用while循环判断，直至窗口内的sum &lt; target</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;<span class="comment">//一旦总和大于目标值，就开始记录当前最短数组，并右移left指针</span></span><br><span class="line">                res = Math.min(res, right - left + <span class="number">1</span>)</span><br><span class="line">                sum -= nums[left++];<span class="comment">//记得删除left指针指向的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">res</span> <span class="operator">=</span>= Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题一定要看清楚题意，是<strong>连续子数组！</strong></p>
<p>这样我们才可以<strong>利用双指针来模拟滑动窗口</strong>，左指针就是滑动窗口的左边界，右指针对应着右边界。</p>
<p>每当我们移动一次right指针，我们就把right所指的元素添加进sum中，一旦sum &gt;&#x3D; target，我们就要<strong>开始记录当前数组长度和之前记录的res的最小值</strong>。记录之后，为了继续移动right指针，我们<strong>必须删除左指针指向的元素</strong>，同时<strong>一定不要忘了右移左指针</strong>。这样一个滑动窗口就形成了。</p>
<p>最后要<strong>记住判断res是否存在</strong>，不存在的话就是初始值Integer.MAX_VALUE。</p>
<h1 id="leetcode-904-水果成篮"><a href="#leetcode-904-水果成篮" class="headerlink" title="leetcode 904.水果成篮"></a>leetcode 904.水果成篮</h1><p><u><strong>题目</strong>：你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</u></p>
<p><u>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</u></p>
<p><u>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。</u><br><u>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</u><br><u>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</u><br><u>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</u></p>
<p><u>举例如下：</u></p>
<p><u>输入：fruits &#x3D; [0,1,2,2]</u><br><u>输出：3</u><br><u>解释：可以采摘 [1,2,2] 这三棵树。</u><br><u>如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; fruits.length;j++)&#123;</span><br><span class="line">            count.add(fruits[j], <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//一旦个数超过2个，就开始删除左指针指向的元素</span></span><br><span class="line">            <span class="keyword">while</span>(count.size() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                count.add(fruits[i], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(count.get(fruits[i]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    count.remove(fruits[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(k) ? <span class="built_in">super</span>.get(k) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">        put(k, get(k) + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题理解题意是难度比较大的，总的来说就是在一个<strong>含有重复元素的数组</strong>中，找到<strong>含有两种不同元素的最长连续子数组</strong>。这道题和前面的题的区别，就像背包问题，一个求背包重量，一个求方案数一样。这道题就是后者的情况，因为<strong>重复元素只算一种元素</strong>，所以我们必须要用HashMap来记录这个元素在数组中出现了多少次。而<strong>连续子数组的长度则由HashMap的size()来控制</strong>。</p>
<p>我们依旧是利用双指针模拟滑动窗口，让右指针j不停向右移动，移动一次就记录当前j指向的元素及其出现的次数，一旦我们的HashMap的size() &gt;&#x3D; 3了，说明当前HashMap存了3组不同种元素，要删一个，这时候，我们开始从左删，因为HashMap中记录的是重复元素的个数，<strong>所以先删key值fruits[i]对应的value，删一个就一次左指针i</strong>。直到这个value &#x3D;&#x3D; 0了，说明这个重复元素删干净了，就可以把当前fruits[i]删掉了。</p>
<p><strong>不管是删fruits[i]还是删其value值，都要进行i++，所以这个i++的位置一定要放对</strong>。</p>
<p>上述的操作因为与HashMap的原始方法有一些出入，所以我们可以看到官方题解又<strong>另写了一个继承HashMap的类来重写HashMap的方法</strong>，方便我们主方法进行重复元素的增删改查。</p>
<p>最后需要注意的是，每次向右移动一次指针j，不仅要记录当前的fruits[j]和其出现次数，还要累计当前的长度ans,别忘了，我们需要返回的最终结果，就是这个每次累计的ans值。如果当前HashMap的size() &gt;&#x3D; 3，那就先进入while循环，直到size() &lt; 3了，我们再更新ans的值。<strong>所以ans和while循环的顺序一定要写对</strong>。</p>
<p>总的来说，<strong>容易出现问题的地方</strong>，首先是：</p>
<p>​		①左指针i向右移动的时机</p>
<p>​		②更新ans的时机。</p>
<h1 id="leetcode-76-最小覆盖字串（未完成）"><a href="#leetcode-76-最小覆盖字串（未完成）" class="headerlink" title="leetcode 76.最小覆盖字串（未完成）"></a>leetcode 76.最小覆盖字串（未完成）</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E8%A7%A3/" data-id="cl31ednen0000bgv69yxwh7fl" data-title="双指针题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-二分法题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E4%BA%8C%E5%88%86%E6%B3%95%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T06:01:09.000Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E4%BA%8C%E5%88%86%E6%B3%95%E9%A2%98%E8%A7%A3/">二分法题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="leetcode-704-二分查找"><a href="#leetcode-704-二分查找" class="headerlink" title="leetcode 704.二分查找"></a>leetcode 704.二分查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种二分查找的题，我们首先要看数组是不是<strong>有序的</strong>，因为我们要逐步缩小查找区间，如果数组不是有序的，那么就无法用二分法。</p>
<p>其次数组<strong>不能有重复元素</strong>，如果有重复元素我们只能找到符合条件的某一个元素，必须用一些其他手段才能找到所有符合条件的元素。</p>
<p>好了，本题自然是很简单的数组，满足有序且不重复的条件。</p>
<p>难点就是：边界条件比较难确定，即中点值大于target的时候，左边界和右边界如何收缩。</p>
<p>根据Carl大佬给的思路，我们将l和r的范围区间确定为左闭右闭的闭区间[l,r]，这样我们在while循环的时候，循环条件自然是l &lt;&#x3D; r了，<strong>因为l &#x3D;&#x3D; r也是符合闭区间的范围的</strong>。</p>
<p>进入循环后，如果nums[mid] &lt; target，说明当前mid位置的元素不符合条件，而且在target的左边，我们自然要将左边界l收缩，l &#x3D; mid还是l &#x3D; mid + 1呢？我们<strong>一定要看区间</strong>，我们确定的是闭区间，所以[mid, r]这个mid不是我们想要的范围为，[mid + 1, r]才是。</p>
<p>同理，nums[mid] &gt; target时，我们要收缩右边界r，所以[l, mid - 1]才是我们想要的范围。</p>
<p>其实，还可以将区间定义为左闭右开的区间[l, r)，这样循环体则是l &lt; r，if判断的边界条件也有区别。具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-35-搜索插入位置"><a href="#leetcode-35-搜索插入位置" class="headerlink" title="leetcode 35.搜索插入位置"></a>leetcode 35.搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。数组中无重复元素，请必须使用时间复杂度为 <code>O(log n)</code> 的算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题具体思路和上一题一样，但是难点是插入位置，也就是数组中<strong>可能不存在目标值</strong>，我们要将这个值插入到哪里是有讲究的。</p>
<p>通过二分法闭区间的思路，我们可以看出：<strong>只有跳出while循环之后return的值才是最终插入的位置</strong>，也就是没查找到目标值的情况。这个时候自然满足l &gt; r，也就是<strong>l &#x3D; r + 1</strong>。</p>
<p>既然确定了插入位置是return语句的返回值，我们就得考虑什么时候跳出循环的：走完最后一个if或者else if语句。</p>
<p>如果最后走的if语句，那么当前的l &#x3D; mid + 1，nums[mid]比target要小，我们肯定要把target插入到mid之后，也就是mid + 1，那么自然我们返回l即可。</p>
<p>如果最后走的是else if语句呢？当前r &#x3D; mid - 1，当前nums[mid]比target大，我们肯定要把target插入到mid的位置，进而把当前的mid位置的元素向后挤一位，为什么不插到mid - 1，因为**<u>mid - 1位置的元素肯定比target小</u>**，假设nums[mid - 1] &#x3D;&#x3D; 3, target &#x3D;&#x3D; 4, nums[mid] &#x3D;&#x3D; 5，就成了[4,3,5]了。所以必须要插在5的位置，形成[3, 4, 5]。因为r &#x3D; mid - 1，所以最后返回r + 1。因为跳出循环后，肯定满足前面说的l &#x3D; r + 1这个等式，所以上述分析的两种情况，即返回l或r + 1是一样的。</p>
<h2 id="leetcode-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#leetcode-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="leetcode 34.在排序数组中查找元素的第一个和最后一个位置"></a>leetcode 34.在排序数组中查找元素的第一个和最后一个位置</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBoard</span> <span class="operator">=</span> findLeftBoard(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBoard</span> <span class="operator">=</span> findRightBoard(nums, target);</span><br><span class="line">        <span class="keyword">if</span>(leftBoard == -<span class="number">2</span> || rightBoard == - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(rightBoard - leftBoard &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftBoard + <span class="number">1</span>, rightBoard - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLeftBoard</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBoard</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                leftBoard = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBoard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRightBoard</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBoard</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                rightBoard = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightBoard;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题明显有重复元素，用二分法难度陡增。</p>
<p>代码很长，所以思路一定要清晰。</p>
<p>可以看到代码分别找了左边界和右边界，两个寻找边界的方法都是采用的二分法，我们**<u>以findLeftBoard()为例</u>**。</p>
<p>我们首先定义了leftBoard的初始值，为什么是-2，这个得留到最后解释。</p>
<p>可以看到代码的if分了两部分，一部分是nums[mid] &lt; target这一部分，如果满足这个条件，那么我们让左边界</p>
<p>右移，这个没什么疑问。</p>
<p>但是else if这部分，为什么既包括了nums[mid] &gt; target的部分，又包括了nums[mid] &#x3D;&#x3D; target部分。</p>
<p>我们需要举个例子，比如当前数组是[1,2,3,3,3,3,3,3,3,3,3,3,3,3,4,5,5,6,6,7]，target是3，一上来二分法就能定位到3，但是我们要确定左边界，所以必须要通过循环体不断让mid逼近左边界，我们可以看到当确定闭区间[l, r]的时候，right是不断由mid - 1确定的，也就是<strong>真正不断向左移动的是right</strong>，所以我们的左边界一定要<strong>利用好区间[l, r]的右边界不断向左移动的这一个特点</strong>。</p>
<p>这样一来，我们就可以理解为什么每次right &#x3D; mid - 1的时候，还要更新leftBoard。right什么时候停止左移呢，答案是找到最后一个满足target &#x3D;&#x3D; 3的位置，跳出循环，返回leftBoard，这个左边界值我们可以用上一题的插入位置来考虑，因为<strong>最后的leftBoard &#x3D;&#x3D; right，而right &#x3D; mid - 1，mid这个位置是最后一个满足target的点，所以mid - 1自然是左边界的前一个值了</strong>。那么它就自然有等于-1的风险，所以我们初始化leftBoard为-2。</p>
<p>对于寻找右边界，我们的思路是一样的，只不过rightBoard最后没有等于-1的风险，所以我们可以为其初始化为-1或-2都可。</p>
<h2 id="☆leetcode-69-x的平方根"><a href="#☆leetcode-69-x的平方根" class="headerlink" title="☆leetcode 69.x的平方根"></a>☆leetcode 69.x的平方根</h2><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根。</p>
<p>由于返回类型是整数，结果只保留 整数部分，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = x, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &lt;= x)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案很简单，但是要注意用long型变量，因为mid + 1之后，其自身的平方很可能比Integer的最大范围还大，容易溢出报错，所以要用long型。</p>
<h2 id="leetcode-367-有效的完全平方数"><a href="#leetcode-367-有效的完全平方数" class="headerlink" title="leetcode 367.有效的完全平方数"></a>leetcode 367.有效的完全平方数</h2><p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法1：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = num;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &gt; num)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &lt; num)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法2：</span></span><br><span class="line"><span class="comment">//只需与69题最后返回值不同即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = num, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>) mid * mid &lt;= num) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans * ans == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与上一题需要注意的地方一样。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E4%BA%8C%E5%88%86%E6%B3%95%E9%A2%98%E8%A7%A3/" data-id="cl319inhr0000jgv6anb7cgxu" data-title="二分法题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-动态规划序列问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T04:37:29.101Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/">动态规划之序列问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-单数组找子序列问题"><a href="#1-单数组找子序列问题" class="headerlink" title="1.单数组找子序列问题"></a>1.单数组找子序列问题</h3><h4 id="☆lt-300-最长递增子序列"><a href="#☆lt-300-最长递增子序列" class="headerlink" title="☆lt 300.最长递增子序列"></a>☆lt 300.最长递增子序列</h4><p><u><strong>题目</strong>：在一个整数数组nums中，找到最长的严格<strong>递增的子序列的长度</strong>，返回其<strong>长度</strong>。如[10,9,2,5,3,7,101,18]中的[2,3,7,101]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                    max = Math.max(dp[i], max);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dp[i]是<strong>以nums[i]为结尾</strong>组成的最长递增子序列的<em><strong>长度</strong></em>。这是每个动态规划题目需要最先确定的。</p>
<p>1.首先我们知道，每一个数字都是一个长度为1的递增序列，所以<strong>每个dp[i]我们一定要初始化为1</strong>，后面具体等于多少是后面的事。</p>
<p>2.这里两层循环是重点，外层循环i(i &lt; nums.length)负责dp[i]的推进，每次推进dp[i]都<strong>需要比较nums[i]以前所有的数字</strong>，也就是内层循环j(i &lt; j)，一旦发现比nums[i]小的num[j]了，我们就要让dp[i]与当前的dp[j] + 1进行比较，取大者存入dp[i]。这才能保证<em><strong>每个dp[i]都比较过前面所有的数字，并留住了最大值</strong></em>。</p>
<p>3.我们要注意：[1,3,6,7,9,4,10,5]这个序列，如果我们没有一个随时记录的max，<em>而是直接最后返回dp[nums.length - 1]<em>，会出现这么一种情况：10这里对应的dp[6]是6，但是5这里的dp[7]只能记录比5小的dp[i]的最大值，也就是到4这里就停了，那么4呢，4会在它的循环中记录到3就停了，所以4这里的dp[5]是3，5这里的dp[7]也就是dp[nums.length]是4。最大值不是6反而成4了，这就是不随时记录max的后果，而</em></em>“罪魁祸首”是每次的dp[i]只有在nums[i] &gt; nums[j]的时候才记录**。</p>
<p><u>难点：①.初始化不是默认值0，而是1；②定义一个随时记录最大值的max</u></p>
<h4 id="lt-674-最长连续递增序列"><a href="#lt-674-最长连续递增序列" class="headerlink" title="lt 674.最长连续递增序列"></a>lt 674.最长连续递增序列</h4><p><u><strong>题目</strong>：一个没有排序的整数数组nums，找到<strong>最长的连续递增子序列</strong>，返回其<strong>长度</strong></u>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                max = Math.max(dp[i], max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.一定要和300进行区分，这次是连续了，也就是增着增着突然断了是要从头（1）开始的，但是之前的长度也要记下，说不定就有最大值呢？所以还是要定义一个max来随时记录最大值；</p>
<p>2.此外，真的需要我们从头开始吗？其实不用，因为这个所谓的“头”，就是每个值得初始化——dp[i] &#x3D; 1。</p>
<p>3.最重要的是这次还用叠层循环吗？不用了，我们只需要每次让当前元素和前面的元素比较，比前面大就在前面的dp[i - 1]加上1即可，<strong>如果前面的这个dp[i - 1]“断了”，那么他自然就是1</strong>，所以也不需要我们从头开始了。</p>
<p><u>难点：1.每次断了要从1开始，容易思路变乱；2.持续记录最大值max</u></p>
<h3 id="2-两数组求子序列问题"><a href="#2-两数组求子序列问题" class="headerlink" title="2.两数组求子序列问题"></a>2.两数组求子序列问题</h3><h4 id="lt-718-最长重复子数组"><a href="#lt-718-最长重复子数组" class="headerlink" title="lt 718.最长重复子数组"></a>lt 718.最长重复子数组</h4><p><u><strong>题目</strong>：两个整数数组nums1和nums2，返回最长的<strong>公共子数组的长度</strong>。如nums1 &#x3D; [1,2,3,2,1], nums2 &#x3D; [3,2,1,4,7]，返回[3,2,1]的长度3。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.二维数组解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.一维数组解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums2.length;j &gt;= <span class="number">1</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max, dp[j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.这道题叫重复子数组不如<strong>叫公共子序列</strong>，我们定义的dp[i][j)自然是以i - 1为结尾的nums1和j - 1为结尾的nums2的<strong>最长子序列长度</strong>。</p>
<p>2.就拿nums1 &#x3D; [1,2,3,2,1], nums2 &#x3D; [3,2,1,4,7]为例，外层循环一层层推进nums1中的元素，每推进一步，就执行内层循环遍历nums2所有元素，如果当前的nums1[i - 1] &#x3D;&#x3D; nums2[j - 1]，那么就让当前的dp等于不考虑这俩值的那个dp再加上考虑这俩值的1，也就是dp[i - 1][j - 1) + 1。效果如下图：</p>
<img src="https://img-blog.csdnimg.cn/2021011215282060.jpg" alt="718.最长重复子数组" style="zoom: 45%;" />

<p>3.我们看图中的最后三行，<strong>必须是45°角累加才能得到最大长度</strong>，这说明了只有当前的nums1[i - 1] &#x3D;&#x3D; nums2[j - 1]满足之后，又继续满足nums1[i - 2] &#x3D; nums2[j - 2]，以此类推，才可以实现45°累加，而这种程度的累加就说明了两个数组这些满足累加的元素<strong>必须紧挨着不能断开</strong>，才能实现累加，这就是连续的含义。<em>下面一题我们给出不连续的解法</em>。</p>
<p><u>难点：1.一维数组解法要注意<strong>每次不满足等值判断时</strong>要为当前dp赋值为0；2.一维数组解法每列要倒叙遍历；3.要随时记录最大值；4.dp的角标和nums角标很容易出错</u></p>
<h4 id="lt-1143-最长公共子序列"><a href="#lt-1143-最长公共子序列" class="headerlink" title="lt 1143.最长公共子序列"></a>lt 1143.最长公共子序列</h4><p>两个字符串text1和text2，返回两字符串最长公共子序列<strong>长度</strong>。如text1 &#x3D; “abcde”, text2 &#x3D; “ace”，返回3。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length() + <span class="number">1</span>][text2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= text1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= text2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.length()][text2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次是<strong>非连续</strong>的了，那么当前<strong>text1(i) !&#x3D; text2(j)<strong>该怎么办呢？肯定不能从头(0)来了，因为我们要查非连续的子序列，</strong>有多少算多少</strong>。以<strong>下右图</strong>的倒数第二行倒数第二列的2为例，这个时候d !&#x3D; c，那么我们看看分别<strong>让各自序列不含d或c</strong>的时候dp是多少：1.不含d，是[a,b,c]和[a,c]，有2；2.不含c，是[a,b,c,d]和[a]，只有1。所以我们取两者的最大值，来构建当前i,j下的dp(i)(j)。也就是<strong>下左图的左箭头和上箭头</strong>取最大值的方法。</p>
<p><img src="https://img-blog.csdnimg.cn/20210204115139616.jpg" alt="1143.最长公共子序列" style="zoom:45%;" /><img src="https://img-blog.csdnimg.cn/20210210150215918.jpg" alt="1143.最长公共子序列1" style="zoom: 50%;" /></p>
<p><u>难点：在text1(i) !&#x3D; text2(j)的时候，如何计算当前dp(i)(j)</u></p>
<h4 id="lt-1035-不相交的线"><a href="#lt-1035-不相交的线" class="headerlink" title="lt 1035.不相交的线"></a>lt 1035.不相交的线</h4><p>我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。</p>
<p>现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] &#x3D;&#x3D; B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p>
<p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。<img src="https://assets.leetcode.com/uploads/2019/04/26/142.png" alt="img" style="zoom:10%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= nums2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums1.length][nums2.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是求最长的公共子序列，与上面题解法一模一样</p>
<p><u>难点：将题目理解为最长公共子序列</u></p>
<h3 id="3-子序列求和"><a href="#3-子序列求和" class="headerlink" title="3.子序列求和"></a>3.子序列求和</h3><h4 id="lt-53-最大子序和"><a href="#lt-53-最大子序和" class="headerlink" title="lt 53.最大子序和"></a>lt 53.最大子序和</h4><p>在一个整数数组nums中，找到一个具有<strong>最大和</strong>的<strong>连续子数组</strong>，返回<strong>最大和</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.我们定义当前dp[i]为i之前的<strong>最大连续子序列和</strong>，那么这个和要不就是当前的nums[i] + dp[i - 1]，要么就是nums[i]，谁大是谁。</p>
<p>2.随时记录一个最大值max，以防数组中有一个很小的负数，使得最大子序和出现在中间。</p>
<p><u>难点：1.不能因为当前nums[i]太小就不加进来；2.随时记录最大值max</u></p>
<h3 id="4-一数组是另一数组的子序列问题"><a href="#4-一数组是另一数组的子序列问题" class="headerlink" title="4.一数组是另一数组的子序列问题"></a>4.一数组是另一数组的子序列问题</h3><h4 id="lt-392-判断子序列"><a href="#lt-392-判断子序列" class="headerlink" title="lt 392.判断子序列"></a>lt 392.判断子序列</h4><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。例如，”ace”是”abcde”的一个子序列，而”aec”不是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.双指针解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; j &lt; t.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == t.charAt(j))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">i</span> <span class="operator">=</span>= s.length() ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.二维数组解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> s.length(); <span class="type">int</span> <span class="variable">length2</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= length1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= length2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length1][length2] == length1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210303172354155.jpg" alt="392.判断子序列1" style="zoom:33%;" /><img src="https://img-blog.csdnimg.cn/2021030317364166.jpg" alt="392.判断子序列2" style="zoom:33%;" /></p>
<p><u>难点：不满足等值条件时，要让<strong>长数组</strong>不考虑当前值</u></p>
<h4 id="☆lt-115-不同的子序列-子序列个数"><a href="#☆lt-115-不同的子序列-子序列个数" class="headerlink" title="☆lt 115.不同的子序列(子序列个数)"></a>☆lt 115.不同的子序列(子序列个数)</h4><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。比如”baegg”和”bag”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//难点1：初始化要从0开始，因为dp表示子序列个数而不是长度，所以需要有一个起始累加量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= s.length();i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= t.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="comment">//难点2：baegg和bag的g相同时，不仅考虑baeg包含ba的dp，也要考虑baeg包含bag的dp</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.这道题难度比较大，当满足等值条件的时候，dp(i)(j)要考虑两种情况，一种就是去掉这两个相等的元素，取dp(i - 1)(j - 1)；另一种很难想，就是取dp(i - 1)(j)。以”baegg”和”bag”为例，当最后一个”g” &#x3D;&#x3D; “g”的时候，可以考虑”baeg”包含“ba”的dp，<strong>也要考虑”baeg”包含”bag”的dp</strong>；如果两个g不相等，那么就只考虑”baeg”包含”ba?”的dp.</p>
<img src="https://code-thinking.cdn.bcebos.com/pics/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.jpg" alt="115.不同的子序列" style="zoom: 50%;" />

<p><u>难点：1.满足等值条件的时候，容易漏条件；2.dp(i)(0) &#x3D; 1的初始化很容易丢掉</u></p>
<h3 id="5-编辑字符串问题"><a href="#5-编辑字符串问题" class="headerlink" title="5.编辑字符串问题"></a>5.编辑字符串问题</h3><h4 id="lt-583-两个字符串的删除操作"><a href="#lt-583-两个字符串的删除操作" class="headerlink" title="lt 583.两个字符串的删除操作"></a>lt 583.两个字符串的删除操作</h4><p><u><strong>题目：</strong>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。例如: “sea”, “eat”，返回2</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= word1.length();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt;= word2.length();j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= word1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= word2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j-<span class="number">1</span>] + <span class="number">1</span>), dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>);<span class="comment">//其实dp[i-1][j-1] + 2不用写</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题代码长，但是难度不大，只要记住初始化，含义是i或j表示字符长度，而0是空串，这样初始化就没难度了。然后就是等值的时候，因为不用删，所以dp(i)(j) &#x3D; dp(i - 1)(j - 1)；不等值就要取三种情况的最大值，<strong>其实dp(i - 1)(j - 1) + 2这个不用写</strong>。</p>
<p><u>难点：1.初始化容易忘；2.条件细节容易丢</u></p>
<h4 id="lt-72-编辑距离"><a href="#lt-72-编辑距离" class="headerlink" title="lt 72.编辑距离"></a>lt 72.编辑距离</h4><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p>
<p>你可以对一个单词进行如下三种操作：插入，删除或替换一个字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; word1.length() + <span class="number">1</span>;i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; word2.length() + <span class="number">1</span>;j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; word1.length() + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; word2.length() + <span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i -<span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>), dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实和上面的583非常相似，记住增加就是删除的逆推，所以合二为一，替换可以让两个分别的删除操作合二为一</p>
<p><u>难点：1.初始化容易忘；2.条件细节容易丢</u></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/" data-id="cl3cvqp5y0000ssv6fjn3a0kv" data-title="动态规划之序列问题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/02/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E9%A2%98%E8%A7%A3/">股票问题题解</a>
          </li>
        
          <li>
            <a href="/2022/07/01/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">十大排序算法</a>
          </li>
        
          <li>
            <a href="/2022/06/26/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Linux学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/06/24/%E9%93%BE%E8%A1%A8%E9%A2%98%E8%A7%A3/">链表题解</a>
          </li>
        
          <li>
            <a href="/2022/06/20/acm%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/">acm输入输出练习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>