<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Reex</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Reex">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Reex">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Reex" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Reex</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-二叉树题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-17T03:19:44.000Z" itemprop="datePublished">2022-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/">二叉树题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;<span class="built_in">this</span>.val = val;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个很可能在二叉树面试的时候要求手撕，所以要回写！</p>
<h2 id="leetcode-144-二叉树的前序遍历"><a href="#leetcode-144-二叉树的前序遍历" class="headerlink" title="leetcode 144.二叉树的前序遍历"></a>leetcode 144.二叉树的前序遍历</h2><p><u><strong>题目</strong>：给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//方法一：递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        preOrder(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        preOrder(root.left, ans);</span><br><span class="line">        preOrder(root.right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法一递归法，需要<strong>注意的就是我们要对什么迭代</strong>，是不是树的结点，是不是每次迭代的当前结点的值要输出来？知道了这俩条件，我们就知道要创建一个<strong>无需返回值</strong>的递归方法，而递归的参数就是上述需要递归的树结点以及需要每次记录输出值的集合（数组）。</p>
<p>递归方法的第一步写出来了，就要<strong>找到递归终止条件</strong>，自然是当前结点为空喽。</p>
<p>递归函数呢？每次先记录当前结点，然后一直递归左节点，左节点没了最后再递归右节点。</p>
<p>方法二迭代法：这个就是用栈来操作，需要注意的是：</p>
<p>1）root先进行判空，再入栈</p>
<p>2）作为前序遍历，我们每次把当前的栈顶弹出来记录，然后再加入后面的树节点</p>
<p>3）然后就是<strong>先将谁入栈</strong>的问题，因为栈是先进后出，所以我们要先入栈右结点，再入栈左节点，所以出栈就是先左后右。记住<strong>这里是if连着另一个if，千万不要写成if else if语句</strong>。</p>
<h2 id="leetcode-94-二叉树的中序遍历"><a href="#leetcode-94-二叉树的中序遍历" class="headerlink" title="leetcode 94.二叉树的中序遍历"></a>leetcode 94.二叉树的中序遍历</h2><p><u><strong>题目</strong>：给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;<span class="comment">//指针负责压栈和向左子结点遍历</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//一旦指针空了，就弹出一个，肯定能弹，否则进不了循环</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                cur = temp.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前序遍历的迭代法中，我们每次通过栈访问的结点正是我们需要处理（放入集合中）的结点。但是中序遍历没这么简单，中序遍历要先访问左节点，这就<strong>必然导致我们得先压入几个结点之后，才开始向集合中放入元素</strong>。</p>
<p>所以我们需要分别定义一个指针，和一个栈。通过指针来<strong>控制遍历的次序和弹栈的时机</strong>。</p>
<p>如果当前指针不为空，我们就一直将指针向左子节点移动，同时压入栈（先压后移动）。</p>
<p>直到指针为空了，说明我们<strong>找到了“左中右”中的左</strong>了，所以弹出该元素并添加到集合中，让指针指向这个弹出的元素的右节点，如果右节点存在，则继续向左下遍历，如果不存在，那么就可以把刚刚添加的“左节点”的父节点，<strong>即”左中右“的中</strong>添加到集合中，然后继续让指针指向此节点的右结点，以此类推，就实现了左中右的顺序。</p>
<h2 id="leetcode-145-二叉树的后序遍历"><a href="#leetcode-145-二叉树的后序遍历" class="headerlink" title="leetcode 145.二叉树的后序遍历"></a>leetcode 145.二叉树的后序遍历</h2><p><u><strong>题目</strong>：给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>后序</strong> 遍历</em> 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root , pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;<span class="comment">//因为cur为空之后还有操作，所以这里不能用if了，要用while</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur.right == <span class="literal">null</span> || cur.right == pre)&#123;<span class="comment">//这里要用pre记录上一个遍历过的右节点</span></span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历的迭代法可以说是难度最大的，还是一样没有放上递归的版本，因为太简单了。</p>
<p>首先后序遍历与前两个最大的区别就是要定义一个标记指针pre，这是为了记录上一次循环的右结点，防止循环记录。下面我会详细说明。</p>
<p>大循环条件和中序遍历一致，一进入循环，我们可以看到<strong>这次用while了，而不是if（中序遍历用的if）</strong>。为啥？因为我们这次在cur指针指向null的时候还有其他操作和判断，所以我们必须让cur指针在小循环里就一直走到最左下角的位置（其实中序遍历也是一直走到左下角，因为while里面只有if和else，所以写if还是写while不影响）。所以<strong>这一步其实和中序遍历的思路是一样的，即一直走到左下角为止</strong>。</p>
<p>当cur一旦为空，就说明到左叶子结点的左指针了，这个时候我们就把栈弹出一个位置，也就是将左叶子结点赋给cur。如果是中序遍历，我们直接把这个指针结点加入就行了。但是后序遍历我们还要看一下这个结点有没有右子节点。所以还要继续判断。</p>
<p>右节点为空我们就继续让指针向右下走；如果为空，我们就可以真正记录现在的结点值了。最最重要的就是记录完之后怎么办？我们先看看前中序遍历都干了什么：前序遍历添加完之后继续压栈，因为他是自顶向下的遍历，所以自然<strong>加完了继续向下走</strong>就是了；中序遍历和后序遍历更像一些，<strong>中序遍历添加完元素因为其右下角还需要添加</strong>，所以要<strong>将cur指向右下角</strong>等待进入下一次循环的判断。</p>
<p>而后序遍历加完了当前元素可以确定肯定不往下走了，但是往树的上面走又要借助栈的弹出，所以索性让cur指向null（**<u>这里我们标记一下位置</u><strong>），然后交给下一次循环的判断，下一次肯定不会执行大while里的小while了，因为cur为空了嘛，所以cur一下就可以获得了栈顶元素，问题来了，我们还是会照常判断cur右结点是否为空，我们要知道刚刚是</strong>给cur指向null可不是给他所指向的结点本身赋值为空啊**（肯定不能这样做，这会改变树的结构）。所以又会继续把cur的右节点加入到list中，情景重现而且一直循环往复，出不来了！</p>
<p>所以这个时候，前面定义的pre记录指针就起到作用了，放在哪里？哪里有需要就放在哪里！刚刚发现的循环其实就是因为<strong>没有及时记录那个右节点</strong>，所以我们在上一段加粗并有下划线的位置之前，也就是<strong>cur指向null之前，先把cur指的树结点赋给pre指针</strong>，这样就记录了已经添加到list中的右节点，并在循环中加一个cur.right !&#x3D; pre的判断。</p>
<h2 id="leetcode-102-二叉树的层序遍历"><a href="#leetcode-102-二叉树的层序遍历" class="headerlink" title="leetcode 102.二叉树的层序遍历"></a>leetcode 102.二叉树的层序遍历</h2><p><u><strong>题目</strong>：给你二叉树的根节点 <code>root</code> ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        queue.offer(root);<span class="comment">//1.先把根节点加进来</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//2.注意要每次创建一个集合记录当前行的元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();<span class="comment">//3.记录每行queue的长度，也就是该层节点的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();<span class="comment">//4.遍历一个弹出一个，不用判空</span></span><br><span class="line">                list.add(node.val);<span class="comment">//5.弹出一个记录一个</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;<span class="comment">//6.记录完了要用当前节点遍历其左右节点</span></span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>层序遍历是纯模板类题目，最需要注意的就是考虑清楚：</p>
<p>1）每次<strong>向list中加的元素</strong>是谁？是从queue中弹出的元素！</p>
<p>2）每次<strong>向queue中加的元素</strong>是谁？是每次弹出的元素的左右结点，所以每次弹出后要用一个指针记录当前结点。</p>
<h2 id="leetcode-429-N叉树的层序遍历"><a href="#leetcode-429-N叉树的层序遍历" class="headerlink" title="leetcode 429.N叉树的层序遍历"></a>leetcode 429.N叉树的层序遍历</h2><p><u><strong>题目</strong>：给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</u></p>
<p><u>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        queue.offer(cur);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                List&lt;Node&gt; children = node.children;<span class="comment">//因为每次要加的集合中的元素，所以先列出来</span></span><br><span class="line">                <span class="keyword">if</span>(children == <span class="literal">null</span>) <span class="keyword">continue</span>;<span class="comment">//先看看当前集合是不是空的</span></span><br><span class="line">                <span class="keyword">for</span>(Node child : children)&#123;<span class="comment">//集合不空就依次让child入队</span></span><br><span class="line">                    <span class="keyword">if</span>(child != <span class="literal">null</span>)&#123;<span class="comment">//child可能是null，所以要判断一下</span></span><br><span class="line">                        queue.offer(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先要注意这题不是二叉树，所以<strong>没有TreeNode了</strong>，很容易写错；</p>
<p>其次，每次必须先把children集合列出来，然后看看它空不空，<strong>不空再一个个添加</strong>，添加的时候也要一个个看看child空不空。</p>
<h2 id="leetcode-116-填充每个节点的下一个右侧节点指针"><a href="#leetcode-116-填充每个节点的下一个右侧节点指针" class="headerlink" title="leetcode 116.填充每个节点的下一个右侧节点指针"></a>leetcode 116.填充每个节点的下一个右侧节点指针</h2><p><u><strong>题目</strong>：给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</u></p>
<p><u>初始状态下，所有 next 指针都被设置为 NULL。</u></p>
<img src="https://img-blog.csdnimg.cn/20210203152044855.jpg" alt="116.填充每个节点的下一个右侧节点指针" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        Deque&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(i != size - <span class="number">1</span>)&#123;</span><br><span class="line">                    head.next = queue.peek();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(head.left != <span class="literal">null</span>) queue.offer(head.left);</span><br><span class="line">                <span class="keyword">if</span>(head.right != <span class="literal">null</span>) queue.offer(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题难度不大，注意两点：</p>
<p>1）加了一个next指针，定义树结构的时候要注意（手撕的时候要会写）</p>
<p>2）每次取当前队列中的队头元素，然后判断指针i是否走到最后一位了，如果没走到，我们<strong>就把刚刚弹出来的队头的元素指向当前的队头元素</strong>。</p>
<h2 id="leetcode-117-填充每个节点的下一个右侧节点指针-II"><a href="#leetcode-117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="leetcode 117.填充每个节点的下一个右侧节点指针 II"></a>leetcode 117.填充每个节点的下一个右侧节点指针 II</h2><p><u><strong>题目</strong>：和116题一样，只不过这次不是完美二叉树了，有些节点可能没有左节点或右节点。</u></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);<span class="comment">//每次遍历当前行的时候都要有一个哑节点，用来定位下一层的首节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;<span class="comment">//作为下一层的遍历指针</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    pre.next = cur.left;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    pre.next = cur.right;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.next;<span class="comment">//每次操作完其左右节点要继续向右移动</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur = dummy.next;<span class="comment">//这一步很关键！容易忘！下次循环要遍历下一层了，cur要赋值为下一层首节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实完全可以用116的队列题解来做。但是本题的进阶要求是<strong>空间复杂度为常量级</strong>。</p>
<p>所以给出链表级解法。其实就是让指针依次在每一行向右移动，从每一行的最左边移动到最右边。但是next指针默认是指向空的啊！所以我们<strong>需要在遍历上边一层的时候，就把下边一层连接好了</strong>。因为头结点只有一个，不用连接，所以我们可以轻易的将第二层通过遍历第一层（root）的左右子节点来实现连接操作。</p>
<p>所以我们每次遍历当前层节点时候（指针cur），要定义一个哑节点（dummy），然后让另一个指针<strong>pre来逐个连接cur的左右子节点</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/" data-id="cl39u6yto0000sgv629dfa9fk" data-title="二叉树题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java基础知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2022-05-15T09:03:41.000Z" itemprop="datePublished">2022-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/">Java基础知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="为什么要使用集合？"><a href="#为什么要使用集合？" class="headerlink" title="为什么要使用集合？"></a>为什么要使用集合？</h2><p>数组一旦声明了，长度就不可变；</p>
<p>数组存储数据类型单一，而且有序且可重复的，特点也单一；</p>
<p>集合提高了数据存储的灵活性，不仅可以不同类型、不同数量，还可以控制元素重复，并且保存具有映射关系的数据。</p>
<h2 id="ArrayList和LinkedList区别与联系？"><a href="#ArrayList和LinkedList区别与联系？" class="headerlink" title="ArrayList和LinkedList区别与联系？"></a>ArrayList和LinkedList区别与联系？</h2><p>A和L都实现了List接口，他们都是线程不安全的；</p>
<p>A底层使用的是Object[]数组，L底层使用的是双向链表；</p>
<p>A在数组中的某个位置删除，插入元素都需要让整个数组跟着移动，L虽然不会移动，但是需要先移动到那个位置才能进行插入或删除操作，所以两者复杂度都较高，L只有头和尾插入或删除时，时间复杂度时o(1)。</p>
<p>A支持快速随机访问，因为数组下标。而L不行。</p>
<p>A占内存主要是因为尾部需要预留空间，L空间花费更多体现在每个结点要记录的内容。</p>
<p>A好，用A，能用L的地方都能用A。</p>
<h2 id="comparable和comparator区别？"><a href="#comparable和comparator区别？" class="headerlink" title="comparable和comparator区别？"></a>comparable和comparator区别？</h2><p>comparable接口是java.lang包下的，接口有comareTo(Object obj)方法</p>
<p>comparator接口时java.util工具包下的，接口中有compare(Object obj1, Object obj2)方法</p>
<h2 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h2><p>JDK 1.7之前，底层是数组+链表的形式存储数据的。每次存储都对数据执行扰动函数，得到hash值，如果哈希碰撞，就equals比较，若相等则覆盖，如不等则拉链法，即用链表存储。</p>
<p>JDK 1.8之后，底层是数组+链表+红黑树。还是用扰动函数，但是扰动函数有所更新，减少了哈希碰撞几率，但是如果碰撞还是equals比较，若相等则覆盖，若不等则拉链法，当链表长度大于阈值（默认8），则检查当前数组长度是否大于64，小于64则扩容数组（这里需要rehash），大于64则将超过阈值的链表转化为红黑树。</p>
<h2 id="HashMap长度为什么是2的幂次方？"><a href="#HashMap长度为什么是2的幂次方？" class="headerlink" title="HashMap长度为什么是2的幂次方？"></a>HashMap长度为什么是2的幂次方？</h2><p><strong>这个还没搞懂</strong></p>
<h2 id="ConcurrentHashMap和Hashtable的区别？"><a href="#ConcurrentHashMap和Hashtable的区别？" class="headerlink" title="ConcurrentHashMap和Hashtable的区别？"></a>ConcurrentHashMap和Hashtable的区别？</h2><p>先说Hashtable，全表锁，效率很低</p>
<p>对于JDK 1.7的cchashmap，用segment即分段锁，只要多个线程没有哈希碰撞到同一个段就没事。</p>
<p>JDK 1.8以后的cchashmap，只锁当前的链表或者红黑树的首节点，只要hash冲突不到数组的同一个节点上，就没事。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="cl39jz0gd00001cv61jgv7ohf" data-title="Java基础知识点" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-栈与队列题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/14/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-14T08:58:47.000Z" itemprop="datePublished">2022-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/14/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E9%A2%98%E8%A7%A3/">栈与队列题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="leetcode-20-有效的括号"><a href="#leetcode-20-有效的括号" class="headerlink" title="leetcode 20.有效的括号"></a>leetcode 20.有效的括号</h2><p><u><strong>题目</strong>：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</u></p>
<p><u>有效字符串需满足：</u></p>
<p><u>左括号必须用相同类型的右括号闭合。</u><br><u>左括号必须以正确的顺序闭合。</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：s = &quot;([)]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(deque.isEmpty() || deque.peek() != ch)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                deque.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题是典型的用栈来解决的问题，因为我们需要左右括号两两出现，而且顺序不能打乱，栈的入栈出栈操作正好可以满足该要求。</p>
<p>如果我们遍历到当前位置是左括号，那么就<strong>向栈中压入相对应的右括号</strong>；</p>
<p>如果<strong>当前栈为空，或者当前的括号和栈顶括号不相等</strong>，那我们就直接返回false。因为这个时候我们还要继续判断ch呢，走到这一步肯定不是左括号了，那必然是右括号，<strong>如果这个时候栈没有元素了，那就说明右括号冗余了</strong>。</p>
<p>上面都不满足，说明现在<strong>栈不是空栈</strong>，而且当前的ch是右括号，**而且！ch &#x3D;&#x3D; deque.peek()**，那么我们自然可以将栈顶元素弹出栈了。</p>
<h2 id="leetcode-1047-删除字符串中的所有相邻重复项"><a href="#leetcode-1047-删除字符串中的所有相邻重复项" class="headerlink" title="leetcode 1047.删除字符串中的所有相邻重复项"></a>leetcode 1047.删除字符串中的所有相邻重复项</h2><p><u><strong>题目</strong>：给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</u></p>
<p><u>在 S 上反复执行重复项删除操作，直到无法继续删除。</u></p>
<p><u>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</u></p>
<p><u>示例：</u></p>
<p><u>输入：”abbaca”</u><br><u>输出：”ca”</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：用栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.push(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(deque.isEmpty() || deque.peek() != ch)&#123;</span><br><span class="line">                deque.push(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                deque.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            str = deque.pop() + str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用StringBuilder模拟栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sb.length() == <span class="number">0</span> || s.charAt(i) != sb.charAt(sb.length() - <span class="number">1</span>))&#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法一我们直接用栈来解决这道题：</p>
<p>如果<strong>当前栈为空，或者栈顶元素和当前元素不相等</strong>，那么我们就把该元素压栈；</p>
<p>如果当前栈不为空且栈顶元素等于当前元素，我们<strong>不仅不压入当前元素，还要弹出这个相同的元素</strong>，即把栈顶元素弹出栈。</p>
<p>最后不要忘了返回值是String，<strong>记得写对str和deque.pop()相加的顺序</strong>，str +&#x3D; deque.pop()和str &#x3D; deque.pop() + str是相反的结果。</p>
<p>方法二我们是用StringBuilder来模拟栈：</p>
<p>思路与法一相似，注意sb要删除最后一位，且比较过程中，一定要拿s的当前值与sb的最后一位比，<strong>这里容易写成s自身比较的判断</strong>。</p>
<p>最后直接返回字符串，不需要再次遍历，所以推荐方法二。</p>
<h2 id="leetcode-150-逆波兰表达式求值"><a href="#leetcode-150-逆波兰表达式求值" class="headerlink" title="leetcode 150.逆波兰表达式求值"></a>leetcode 150.逆波兰表达式求值</h2><p><u><strong>题目</strong>：根据逆波兰表示法，求表达式的值。</u></p>
<p><u>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</u></p>
<p><u>注意 两个整数之间的除法只保留整数部分。</u></p>
<p><u>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</u></p>
<p><u>输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”*”]</u><br><u>输出：9</u><br><u>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</u></p>
<p><u>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]</u><br><u>输出：6</u><br><u>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(s))&#123;</span><br><span class="line">                deque.push(deque.pop() + deque.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;-&quot;</span>.equals(s))&#123;</span><br><span class="line">                deque.push(-deque.pop() + deque.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;*&quot;</span>.equals(s))&#123;</span><br><span class="line">                deque.push(deque.pop() * deque.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;/&quot;</span>.equals(s))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">                deque.push(deque.pop() / temp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                deque.push(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deque.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题需要注意的易错点，我们很容易去定义一个ans去记录最后的结果值，但是我们要注意：数组是String类型的数组，所以我们必然要在每次计算之前，将字符串数组中的每个字符串转换成数字，也就是说我们可以<strong>每次压栈的时候就将压入栈的字符串转换成数字</strong>，这是最关键的一步。</p>
<p>字符串转换成数字之后，我们会发现：每次遍历到运算符的时候，我们要将该运算符前面的栈顶元素和次栈顶元素进行相应的运算操作，但是这个结果存在哪呢？存给专门的变量ans？不行，我们<strong>后面还需要对这个运算结果进一步运算</strong>啊！所以一定要将运算结果继续压栈操作，这是另一个容易犯错的位置。</p>
<p>上面两个问题都避免了，那么正确的答案很容易写出来了，<strong>最后栈中一定只剩一个元素了</strong>，就是最终答案，我们把它弹出栈即可。</p>
<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><h2 id="leetcode-347-前K个高频元素"><a href="#leetcode-347-前K个高频元素" class="headerlink" title="leetcode 347.前K个高频元素"></a>leetcode 347.前K个高频元素</h2><p><u><strong>题目</strong>：给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</u></p>
<p><u>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</u><br><u>输出: [1,2]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries= map.entrySet();</span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue());</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : entries)&#123;</span><br><span class="line">            queue.offer(entry);</span><br><span class="line">            <span class="keyword">if</span>(queue.size() &gt; k)&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            res[i] = queue.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题<strong>采用优先队列</strong>的数据结构，这里的优先级我们定义的是每个数字的出现频率，<strong>出现频率越小，优先级越高</strong>，出现频率最小的先出队列。至于原因，往下看就明白了。</p>
<p>既然谈到出现频率，又是老生常谈的HashMap了，key存入每个数字，value是他们对应的出现频率；</p>
<p>为了方便遍历map中的每个key和其value值，我们选用Map的一个内部接口，Map.Entry&lt;Integer, Integer&gt;，<strong>其代表每个key-value键值对组成的一个个实体</strong>，因为有多个键值对，所以用Set来存储，这里泛型要写准确，Set的泛型是Map.Entry&lt;Integer, Integer&gt;，<strong>这个步骤容易出错！！！</strong></p>
<p>接下来定义优先级队列，因为我们要根据每个key-value键值对中的value进行从小到大的排列，所以用Lamada表达式为o1.getValue() - o2.getValue()，<strong>o1和o2分别对应着entry实体（key-value键值对）</strong>。</p>
<p>接下来开始一个个入栈排队，进入队列的是每个entry实体的key还是value？<strong>是两者组成的entry入栈！！！</strong>因为，我们排队的时候虽然只用到value，但是<strong>后面真正返回的值是value较大的前几个key</strong>，所以我们的优先级队列要存入整个实体才可以。</p>
<p>如果队列中实体的个数大于k个，那么我们就<strong>让队头出队</strong>即可，这个对头是当前队列value最小的key。</p>
<p>最后我们定义一个长度为k的数组，存储队列中的<strong>k个entry实体的key值</strong>即可。</p>
<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><h2 id="leetcode-239-滑动窗口最大值（单调队列）"><a href="#leetcode-239-滑动窗口最大值（单调队列）" class="headerlink" title="leetcode 239.滑动窗口最大值（单调队列）"></a>leetcode 239.滑动窗口最大值（单调队列）</h2><p><u><strong>题目</strong>：给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</u></p>
<p><u>返回 滑动窗口中的最大值 。</u></p>
<p><u>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</u><br><u>输出：[3,3,5,5,6,7]</u><br><u>解释：</u><br><u>滑动窗口的位置                最大值</u></p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">MyQueue</span> <span class="variable">myQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length - k + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//定义一个随时存放窗口最大值的数组，作为返回结果</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先把第一个窗口里面的元素按照myQueue的方法入队，即形成一个队头到队尾由大到小排列的k个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            myQueue.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将第一个窗口对应的单调队列的队头弹出，即为第一个窗口的最大值，记录到数组中。</span></span><br><span class="line">        ans[num++] = myQueue.peek();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//先让单调队列弹出窗口最左边的元素，这里很可能在offer添加的过程中就被弹出了</span></span><br><span class="line">            myQueue.poll(nums[i - k]);</span><br><span class="line">            <span class="comment">//再让单调队列添加窗口最右边的元素</span></span><br><span class="line">            myQueue.offer(nums[i]);</span><br><span class="line">            <span class="comment">//弹出当前单调队列的队头，即当前窗口的最大值，记录到ans数组中</span></span><br><span class="line">            ans[num++] = myQueue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个双端队列，用于存放从队头到队尾由大到小排列的双端队列</span></span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//弹出队列的队头元素，只有当前队头元素与val相等时才弹出，否则就说明val太小了，早就被谈出去了，所以当前队列不用弹出任何元素</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!deque.isEmpty() &amp;&amp; val == deque.peek())&#123;</span><br><span class="line">            deque.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向队尾添加元素，如果队尾的元素比当前val小，就一直弹出队尾元素，直到val &lt;= 当前队尾元素才停止弹出，并将当前val添加到队尾，实现队头到队尾由大到小排列</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; val &gt; deque.getLast())&#123;</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.offer(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出队头元素，即取当前队列的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个题要慢慢来，首先我们先确定一个思路：</p>
<p>用队列装每个窗口的元素，怎么装呢？队头我们要保留当前窗口的最大值，这样<strong>每次我们弹出队头就是我们想要的结果</strong>；</p>
<p>队头后面的元素呢？我们<strong>让这些元素由大到小排列，队头最大，队尾最小</strong>。</p>
<p>所以我们要设计一个单调队列，上面的代码顺序先写的弹出队头的操作，其实先写添加队尾操作更简单一些。添加队尾操作，即把每次滑动窗口最右边val添加到队尾，但是我们要求队头到队尾始终是由大到小排列，所以<strong>val如果比当前队尾元素大，那么这个队尾元素就没用了</strong>，我们直接把<strong>队尾元素弹出</strong>，直到val &lt;&#x3D; 队尾元素，我们就把val添加到队尾。</p>
<p>上面的添加队尾操作存在一个问题，你添加就添加，干嘛删元素，要知道被删的元素可能正是一会要被删的“当前滑动窗口的最左边的元素val”。从这句话也可以看出，我们在添加队尾的时候<strong>可能就把现在才要删的元素提前删掉</strong>了。</p>
<p>所以我们在写弹出操作的时候，<strong>只需要看看这个val是不是等于当前的队头元素</strong>，如果是，那么不好意思，刚刚在添加过程中还没真没把这个值删了，因为这个是上一个窗口的最大值，添加操作不可能把它删了的。如果val不等于当前队头元素，说明刚刚添加元素的时候已经把它删了。</p>
<p>最后写的是取队头的操作，这个简单，<strong>弹出的就是队头也就是当前队列（窗口）的最大值</strong>。</p>
<p>主方法比较简单，看着注释就能明白。</p>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="leetcode-739-每日温度"><a href="#leetcode-739-每日温度" class="headerlink" title="leetcode 739.每日温度"></a>leetcode 739.每日温度</h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; temperatures.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temperatures[i] &lt;= temperatures[stack.peek()])&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()])&#123;</span><br><span class="line">                    ans[stack.peek()] = i - stack.peek();</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);<span class="comment">//栈空了，或者当前元素小于等于栈顶元素对应的温度才走到这一步</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题采用单调栈，意思是我们自己构造一个栈，<strong>栈中的元素对应的温度始终是由小到大（栈顶到栈底）排列的</strong>。</p>
<p>一旦要入栈的元素对应的温度 &gt; 当前栈顶元素对应的温度，那么就开始出栈，<strong>一直出一直出</strong>，直到入栈元素对应的温度 &lt;&#x3D; 当前栈顶元素对应的温度，就把这个元素入栈，当作最新的栈顶。</p>
<h2 id="leetcode-496-下一个更大元素-I"><a href="#leetcode-496-下一个更大元素-I" class="headerlink" title="leetcode 496.下一个更大元素 I"></a>leetcode 496.下一个更大元素 I</h2><p><u><strong>题目</strong>：nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</u></p>
<p><u>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。</u></p>
<p><u>对于每个 0 &lt;&#x3D; i &lt; nums1.length ，找出满足 nums1[i] &#x3D;&#x3D; nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</u></p>
<p><u>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素</u> </p>
<p><u>输入：nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</u><br><u>输出：[-1,3,-1]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">//先用map把nums1的元素和其对应的下标存起来</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums1.length;i++)&#123;</span><br><span class="line">            map.put(nums1[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="comment">//这一步初始化很容易忘记</span></span><br><span class="line">        Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums2.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums2[i] &lt;= nums2[stack.peek()])&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()])&#123;</span><br><span class="line">                    <span class="comment">//如果当前栈顶元素比nums2[i]小，就去看看map中的key有没有存栈顶元素</span></span><br><span class="line">                    <span class="keyword">if</span>(map.containsKey(nums2[stack.peek()]))&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(nums2[stack.peek()]);</span><br><span class="line">                        ans[index] = nums2[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题是从一个数组找与另一个数组相关联的数字，这个关联性就是比大小。</p>
<p>所以我们可以用上一题的每日温度的思路，继续依次将nums2的元素压栈，当然，压栈是有前提的，必须在<strong>栈为空</strong>或者栈顶元素<strong>大于等于</strong>当前遍历的nums2[i]元素才可以。</p>
<p>一旦找到了不能压栈的元素，那么我们就说明当前栈顶元素小于nums2[i]，<strong>这不就找到了满足后者比前者大的两个数了嘛</strong>。</p>
<p>那么我就看看nums1中有没有这个数，哪个数？当然是较小的那个数了！所以我们需要<strong>用一个map来存储每个nums1中的元素</strong>。为什么用map，因为我们还要利用nums1中每个元素对应的下标，别忘了最后我们要返回的是一个数组。<strong>数组中每个元素都是：比nums1相应位置大的nums2数</strong>，所以这个位置我们还是需要nums1的下标的，就和每日温度题目也需要温度数组的下标一个道理。</p>
<p><strong>最后不要忘了ans的初始化！！！！</strong>找不到比相应位置元素大的话，当前位置为-1</p>
<h2 id="leetcode-503-下一个更大元素-II"><a href="#leetcode-503-下一个更大元素-II" class="headerlink" title="leetcode 503.下一个更大元素 II"></a>leetcode 503.下一个更大元素 II</h2><p><u><strong>题目</strong>：给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。</u></p>
<p><u>数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。</u></p>
<p><u>输入: nums &#x3D; [1,2,1]</u><br><u>输出: [2,-1,2]</u></p>
<p><u>输入: nums &#x3D; [1,2,3,4,3]</u><br><u>输出: [2,3,4,-1,4]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size * <span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i % size] &gt; nums[stack.peek()])&#123;</span><br><span class="line">                ans[stack.peek()] = nums[i % size];</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i % size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这道题虽说是循环数组，但其实就是让每个元素都与数组中所有元素进行比较。与自己比也没事，因为我们只记录有没有比自己大的元素。</p>
<p>题解给的是遍历两个长度的nums数组，那自然就会遍历到包括自己的每个元素，而且ans会出现赋值之后再被重复赋值的情况。</p>
<h2 id="leetcode-42-接雨水"><a href="#leetcode-42-接雨水" class="headerlink" title="leetcode 42.接雨水"></a>leetcode 42.接雨水</h2><p><u><strong>题目</strong>：给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</u></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p>
<p><u>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</u><br><u>输出：6</u><br><u>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：双指针法（官方题解，时间复杂度为o(n)）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;<span class="comment">//定义左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> <span class="number">0</span>, rightMax = <span class="number">0</span>;<span class="comment">//定义左右最大值</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            leftMax = Math.max(leftMax, height[left]);<span class="comment">//每次都记录当前的最大左边界</span></span><br><span class="line">            rightMax = Math.max(rightMax, height[right]);<span class="comment">//每次都记录当前的最大右边界</span></span><br><span class="line">            <span class="keyword">if</span>(leftMax &lt; rightMax)&#123;<span class="comment">//哪边的边界小，就算哪边，这里是重点！！！</span></span><br><span class="line">                ans += leftMax - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += rightMax - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从双指针法，我们可以看出，首先我们要先定义一个从头和尾分别向中间走的两个指针，即left和right，然后我们在指针移动的过程中，随时记录左边最大值leftMAX和右边最大值rightMAX。</p>
<p>我们要特别重视这个leftMAX和rightMax的变化过程：</p>
<p>首先<strong>只有指针移动，这俩值才会发生变化</strong>；</p>
<p>其次这俩值一定是<strong>他们各自指针经过的最大高度</strong>。</p>
<p>接着进入判断语句：我们看到这个if语句肯定有疑惑，为什么左边最大值比右边最大值   小的时候，我们就要算左边的呢，算右边不行吗？还真不行！因为当前指针移动的位置下，左边最大值如果比当前右边最大值小，那么肯定<strong>现在左指针所处的位置右边有比自己高的</strong>，这是因为<strong>右边最大值随着右指针向左移动会逐渐变大</strong>。我们接雨水一定要取最短的那条边，就是木桶效应，要找自己的短板。</p>
<p>同理当前指针移动的位置下，右边的最大值如果比左边最大值 小的话，那么当前右指针所处的位置，其左边肯定有比自己高的，最起码<strong>还有现在leftMax充数呢</strong>是不是？所以我们要取短边，计算短边的接雨水量。</p>
<p>接下来的难点就是实际的雨水量的计算。左右指针的算法一样，我们以左指针为例，leftMax - height[left]是什么？我们知道leftMax是height[left]的最大值，所以就有两种情况，一种是leftMax就是当前左指针下的height[left]，那么<strong>自然这个差值就是0了</strong>，不影响我们计算，无非就是<strong>ans +&#x3D; 0</strong>嘛。还有一种情况，就是leftMax 与height[left]差着至少一个位置，这个时候算出来的差值，就是<strong>当前left指针位置（一个单位的）左右最小边界下积累的雨水量了</strong>。比如图示中间那部分雨水，按照双指针法就要分成三个纵向的计算，也就是<strong>左指针移动三次</strong>，<strong>右指针不动</strong>（因为右边最大值始终比左边最大值大），直到左指针与右指针碰撞，所以雨水积累完毕，跳出循环。</p>
<p><img src="https://img-blog.csdnimg.cn/20210402091208445.png" alt="42.接雨水1"></p>
<p>图中就是双指针解法每次计算的雨水量，全部都是按列计算的。</p>
<p>接下来看看单调栈解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二：单调栈（Carl题解，时间复杂度为o(n)）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; height.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i] == height[stack.peek()])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(height[i], height[left]) - height[mid];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> i - left - <span class="number">1</span>;</span><br><span class="line">                        ans += len * h;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种解法else里边的while循环里的if语句是很重要的一个判断，为什么这么说呢，先看看第一个左边界凹槽的情况：</p>
<p>左边界凹槽的高度是0，默认入栈的。下一个高度是1，比凹槽高，说明进入了while循环，也就是开始接雨水。那么我们就要思考，接雨水需要什么条件，凹槽左边和右边都要有比凹槽高的点，我们才可以接水。但是左边界凹槽的左边是没有点的，那么我们怎么避免这种情况的计算呢？</p>
<p>代码给出的就是进入while循环后，<strong>先保存我们要计算的凹槽对应的位置，然后将该位置弹出</strong>。这是<u>非常重要且关键的一步</u>，这个凹槽是我们当前唯一要接水的位置，记录该位置是必然的操作，而将该位置弹出栈是为了后面对左边界的有无进行判断的前提。</p>
<p>像左边界这种情况，由于前面的弹出栈操作，现在栈为空了，<strong>对于空栈，我们只能把height[i]入栈了</strong>。这就有效弹出了左边界凹槽，并且没有将其进行接雨水的操作。</p>
<p>接下来就依次向后遍历，第二个注意的点就是相同高度的判断，对于相同高度，我们只需要保留最右边的位置即可，所以有一个先弹出前面的高度，再添加后面高度的操作。其实不弹出，直接添加也行。但是<strong>接雨水的时候过程是不一样的，最后计算结果一样</strong>。我们来具体看一下：</p>
<p>我们把示例中的图，中间的那个凹槽填平，这样就有三个相同高度的平台，接下来按照左边那个高台向右走我们看看代码是怎么实现的：</p>
<p>1）不弹出，直接一个个添加相同高度的平台：</p>
<p>第一个平台比左边高台要低，添加第一个平台位置，第二个平台和第一个平台等高，继续添加，第三个和第二个等高，继续添加，直到右边很高的台子了，这个时候进入while循环，弹出第一个平台，结果发现我们在给h赋值的时候，h为0，<strong>这样就白白让ans计空了一次</strong>。还好，我们已经把这个平台弹出了，但是还有第二个平台，能怎么办，接着弹出，ans又白白计空了一次。第三次，弹出最左边的平台，这个时候h就是左高平台减去当前最左边的等高平台了，这样ans才有记录的意义。</p>
<p>所以我们可以在进入while循环就避免这些无意义的ans计算</p>
<p>2）一等高就弹出，只保留最右边的：</p>
<p>也就是如上的代码，只保留最右边的平台的下标值，这样只有一个平台，一旦弹出，left就是左边高台的下标了。我们ans每次计算就都是有效的。这种方式在数据量特别大，且等高平台特别多的时候，是非常省时的。</p>
<p>所以这俩操作计算过程不一样，但结果是一样的。原因在于：前者在做了<strong>很多无效的ans计算</strong>之后，最后用了<strong>最左边的等高平台</strong>进行了有效的ans计算；而后者直接利用了<strong>最右边的等高平台</strong>进行了有且<strong>仅有一次的有效ans计算</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20210223092629946.png" alt="42.接雨水2"></p>
<p>可以看出单调栈解法是按行进行计算的，代码中的len &#x3D; Math.max(height[i], height[left]) - height[stack.peek()]就可以看出。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/14/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E9%A2%98%E8%A7%A3/" data-id="cl35vggaa0000swv66rwn2pde" data-title="栈与队列题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-我的项目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/13/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2022-05-13T12:30:20.000Z" itemprop="datePublished">2022-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/13/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/">我的项目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="开发社区首页——分页查询帖子功能"><a href="#开发社区首页——分页查询帖子功能" class="headerlink" title="开发社区首页——分页查询帖子功能"></a>开发社区首页——分页查询帖子功能</h1><h2 id="1-创建实体类对象DiscussPost"><a href="#1-创建实体类对象DiscussPost" class="headerlink" title="1.创建实体类对象DiscussPost"></a>1.创建实体类对象DiscussPost</h2><p>先创建一个DiscussPost的实体类对象，与之对应的数据库数据是discuss_post</p>
<p>分别把id, userId, title, content, type, status, createTime, commentCount, score变量及其get, set方法, toString()方法定义出来。</p>
<h2 id="2-开发DAO层——DiscussPostMapper"><a href="#2-开发DAO层——DiscussPostMapper" class="headerlink" title="2.开发DAO层——DiscussPostMapper"></a>2.开发DAO层——DiscussPostMapper</h2><p>首先定义一个查询帖子信息的方法selectDiscussPosts，形参包括userId, offset, limit，其中userId在后面个人主页的帖子才需要，offset是每一页起始行的行号，limit是每一页最多显示多少数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;DiscussPost&gt; <span class="title function_">selectDiscussPosts</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> <span class="type">int</span> userId, <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit)</span>;</span><br></pre></td></tr></table></figure>

<p>为了方便显示页码，还要定义一个方法selectDiscussPostRows来查询一共多少行帖子，只有一个形参userId，同理，也是在后面个人主页帖子的时候才需要这个userId</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">selectDiscussPostRows</span><span class="params">(<span class="type">int</span> userId)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-配置文件——discusspost-mapper-xml"><a href="#3-配置文件——discusspost-mapper-xml" class="headerlink" title="3.配置文件——discusspost-mapper.xml"></a>3.配置文件——discusspost-mapper.xml</h2><p>在mapper配置文件里定义一个discusspost-mapper.xml，在&lt;mapper 标签里的namespace参数写上配置文件<strong>为具体哪个接口服务</strong>的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.nowcoder.community.dao.DiscussPostMapper&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体sql语句如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span></span><br><span class="line">       id, user_id, title, content, type, status, create_time, comment_count, score</span><br><span class="line">   <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDiscussPosts&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;DiscussPost&quot;</span>&gt;</span></span><br><span class="line">       select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">       from discuss_post</span><br><span class="line">       where status != 2</span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId!=0&quot;</span>&gt;</span></span><br><span class="line">           and user_id = #&#123;userId&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       order by type desc, create_time desc</span><br><span class="line">       limit #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDiscussPostRows&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">       select count(id)</span><br><span class="line">       from discuss_post</span><br><span class="line">       where status != 2</span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId!=0&quot;</span>&gt;</span></span><br><span class="line">           and user_id = #&#123;userId&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-开发Service层——DiscussPostService和UserService"><a href="#4-开发Service层——DiscussPostService和UserService" class="headerlink" title="4.开发Service层——DiscussPostService和UserService"></a>4.开发Service层——DiscussPostService和UserService</h2><p>DiscussPostService很简单，直接调用DAO层的DiscussPostMapper的两个方法即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscussPostService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostMapper discussPostMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;DiscussPost&gt; <span class="title function_">findDiscussPosts</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.selectDiscussPosts(userId, offset, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDiscussPostRows</span><span class="params">(<span class="type">int</span> userId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.selectDiscussPostRows(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserService是用来开发<strong>根据用户id来查询用户的功能</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;<span class="comment">//用于管理User类方法的dao层Mapper组件</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-开发Controller层——HomeController"><a href="#5-开发Controller层——HomeController" class="headerlink" title="5.开发Controller层——HomeController"></a>5.开发Controller层——HomeController</h2><p>因为这一层要用到SpringMVC，方法需要用@RequestMapping()编写访问路径，因为访问的是首页，所以路径是&#x2F;index，请求方式因为是查询，所以是RequestMethod.GET，<strong>返回的是相应的网页，所以不要加ResponseBody</strong>，直接返回String，即视图的名字。</p>
<p>形参写入Model model，因为我们要通过model携带数据传给模板，最终返回的也是模板的路径，即Templates下的index.html</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> <span class="keyword">implements</span> <span class="title class_">CommunityConstant</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/index&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getIndexPage</span><span class="params">(Model model, Page page)</span>&#123;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//方法调用前，SpringMVC会自动实例化Model和Page，并将Page注入Model，所以在thymeleaf中可以直接访问Page对象的数据</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取帖子的总行数</span></span><br><span class="line">        page.setRows(discussPostService.findDiscussPostRows(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//页面index就可以复用这个路径了</span></span><br><span class="line">        page.setPath(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//页码offset和limit就可以根据上面的数据和Page类来获取了</span></span><br><span class="line">        List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(<span class="number">0</span>, page.getOffset(), page.getLimit());<span class="comment">//list只有id和userId，没有User的具体信息，所以我们通过定义一个map来存放每个帖子的具体信息和User对象</span></span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; discussPosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(list != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(DiscussPost post : list)&#123;<span class="comment">//要一个个遍历帖子内容</span></span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                map.put(<span class="string">&quot;post&quot;</span>, post);<span class="comment">//先存放帖子信息</span></span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(post.getUserId());</span><br><span class="line">                map.put(<span class="string">&quot;user&quot;</span>, user);<span class="comment">//再存放User信息</span></span><br><span class="line">                discussPosts.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//DispatcherServlet会自动将page装到model里面，所以不用单独添加page了</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;discussPosts&quot;</span>, discussPosts);<span class="comment">//要把数据传给model</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index&quot;</span>;<span class="comment">//返回模板路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-创建实体类Page封装分页相关信息"><a href="#6-创建实体类Page封装分页相关信息" class="headerlink" title="6.创建实体类Page封装分页相关信息"></a>6.创建实体类Page封装分页相关信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">    <span class="comment">//当前页码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//显示上限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//数据总数(用于计算总页数)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rows;</span><br><span class="line">    <span class="comment">//查询路径(用于复用分页链接)</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCurrent</span><span class="params">()</span> &#123;<span class="keyword">return</span> current;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurrent</span><span class="params">(<span class="type">int</span> current)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(current &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.current = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLimit</span><span class="params">()</span> &#123;<span class="keyword">return</span> limit;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLimit</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(limit &gt;= <span class="number">1</span> &amp;&amp; limit &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRows</span><span class="params">()</span> &#123;<span class="keyword">return</span> rows;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRows</span><span class="params">(<span class="type">int</span> rows)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(rows &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.rows = rows;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span> &#123;<span class="keyword">return</span> path;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPath</span><span class="params">(String path)</span> &#123;<span class="built_in">this</span>.path = path;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前页的起始行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOffset</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//current * limit - limit</span></span><br><span class="line">        <span class="keyword">return</span> (current - <span class="number">1</span>) * limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取总页数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTotal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//rows / limit [+1]</span></span><br><span class="line">        <span class="keyword">if</span>(rows % limit == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rows / limit;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rows / limit + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取起始页码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFrom</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> current - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> from &lt; <span class="number">1</span> ? <span class="number">1</span> : from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取结束页码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> current + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> getTotal();</span><br><span class="line">        <span class="keyword">return</span> to &gt; total ? total : to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要<strong>查询帖子就要访问数据库</strong>，与数据库打交道，那就是业务层干的活，<strong>业务层其实就是实现查询数据库的操作</strong>，所以直接调用持久层的查询方法，所以重点是DAO层写出查询方法，mapper.xml要写几个sql语句查询数据库的帖子详情。查询逻辑写好之后，DAO层直接调用mapper.xml的逻辑，然后业务层调DAO层，这样就来到了控制层。控制层其实就是调用业务层，<strong>把从数据库中查询到的帖子数据和用户数据传给model</strong>。因为帖子需要分页，所以我们最好专门写个实体类来实现分页功能，分页功能主要让起始行和每页帖子数量上限是一个变量，否则每次数据库变动了还得重新计算并填入到控制层方法的形参中。</p>
<h1 id="2-1开发邮件发送功能"><a href="#2-1开发邮件发送功能" class="headerlink" title="2.1开发邮件发送功能"></a>2.1开发邮件发送功能</h1><h2 id="1-设置邮箱，导入SpringBoot的Mail包"><a href="#1-设置邮箱，导入SpringBoot的Mail包" class="headerlink" title="1.设置邮箱，导入SpringBoot的Mail包"></a>1.设置邮箱，导入SpringBoot的Mail包</h2><p>新浪邮箱的设置里POP3&#x2F;SMTP功能开启，并启用授权码。</p>
<p>通过Maven导入spring-boot-starter-mail的包</p>
<h2 id="2-书写配置文件参数"><a href="#2-书写配置文件参数" class="headerlink" title="2.书写配置文件参数"></a>2.书写配置文件参数</h2><p>然后配置邮箱参数，在resources-application.properties中配置参数，具体参数如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MailProperties</span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.sina.com</span></span><br><span class="line"><span class="comment">#spring.mail.port=465</span></span><br><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">ryn2020@sina.com</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=<span class="string">21ad95cfc6c4b05e    #这里是新浪邮箱的授权码</span></span><br><span class="line"><span class="comment">#spring.mail.protocol=smtps</span></span><br><span class="line"><span class="comment">#spring.mail.properties.mail.smtp.ssl.enable=true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtl.auth</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtl.starttls.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtl.starttls.required</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h2 id="3-创建工具类MailClient"><a href="#3-创建工具类MailClient" class="headerlink" title="3.创建工具类MailClient"></a>3.创建工具类MailClient</h2><p>然后去util包下创建一个工具类MailClient，该工具类将发邮件的任务委托给新浪邮箱去完成，相当于客户端</p>
<p>该类我们要加上@Component注解，成为一个Bean。</p>
<p>先声明一个日志，后面操作要记录日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MailClient.class);</span><br></pre></td></tr></table></figure>

<p>然后注入Spring的核心组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JavaMailSender mailSender;</span><br></pre></td></tr></table></figure>

<p>因为每次系统邮箱，也就是发件人都是一样的，所以我们将发件人地址注入Spring中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span><span class="comment">//这里是配置文件中参数</span></span><br><span class="line"><span class="keyword">private</span> String from;</span><br></pre></td></tr></table></figure>

<p>接下来定义发送的方法，我们只需要收件人，邮件主题和内容即可，所以形参只有它们三个。</p>
<p>发邮件的关键就是把组件JavaMailSender中的MimeMessage邮件主体构建出来，用谁构建呢？帮助类MimeMessageHelper</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMail</span><span class="params">(String to, String subject, String content)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用核心组件JavaMailSender构建邮件主体message</span></span><br><span class="line">            <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">            <span class="comment">//用帮助类构建message</span></span><br><span class="line">            <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message);</span><br><span class="line">            <span class="comment">//向帮助类传入发件人，收件人，主体和html格式的内容</span></span><br><span class="line">            helper.setFrom(from);</span><br><span class="line">            helper.setTo(to);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            helper.setText(content, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//再回到核心组件JavaMailSender执行Send方法发送邮件</span></span><br><span class="line">            mailSender.send(helper.getMimeMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;发送邮件失败：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-7开发注册功能"><a href="#2-7开发注册功能" class="headerlink" title="2.7开发注册功能"></a>2.7开发注册功能</h1><h2 id="1-开发Controller层——访问注册页面"><a href="#1-开发Controller层——访问注册页面" class="headerlink" title="1.开发Controller层——访问注册页面"></a>1.开发Controller层——访问注册页面</h2><p>直接开发控制层，设置一个跳转页面。跳转到site下的register</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518210741410.png" alt="image-20220518210741410"></p>
<h2 id="2-开发随机字符生成和加密方法——CommunityUtil工具类"><a href="#2-开发随机字符生成和加密方法——CommunityUtil工具类" class="headerlink" title="2.开发随机字符生成和加密方法——CommunityUtil工具类"></a>2.开发随机字符生成和加密方法——CommunityUtil工具类</h2><p>导入这个包，主要目的是<strong>判断一些数据、字符串、集合空值的</strong>情况，后面会用到。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518211922078.png" alt="image-20220518211922078"></p>
<p>接下来去配置文件把域名配置好，其实现在就是本机地址，因为发邮件要写上目标地址要作为链接地址</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518212611807.png" alt="image-20220518212611807"></p>
<p>因为注册要生成激活码，所以我们最好定义一个<strong>专门的方法用来生成随机字符串</strong>。而且将来上传头像，上传文件等，也要给这些资源生成随机名字，也需要这个工具。UUID.randomUUID就是Java自带的生成随机字符的方法，不过可能有“-”，所以要用空格替换。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518213026318.png" alt="image-20220518213026318"></p>
<p>另外注册的时候上传的<strong>密码是明文的，我们需要MD5加密</strong>。</p>
<p>为了防止一些简单字符串每次加密后的字符都一样，所以我们也可以看到数据库表中有盐salt，也就是<strong>每次给密码加盐</strong>，也就是加随机字符串，这样就避免密码的盗取。</p>
<p>加密是<strong>Spring自带的工具类DigestUtils</strong>的方法，加密前，我们用前面导入的lang3包对字符串先进性判空操作，非空字符串我们再加密（要求16进制的byte类型，所以要转一下）。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518213714266.png" alt="image-20220518213714266"></p>
<h2 id="3-开发Service层——UserService实现注册业务逻辑"><a href="#3-开发Service层——UserService实现注册业务逻辑" class="headerlink" title="3.开发Service层——UserService实现注册业务逻辑"></a>3.开发Service层——UserService实现注册业务逻辑</h2><p>因为注册要发邮件，所以把邮件注入进来，也注入模板引擎，后面要用。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518214006254.png" alt="image-20220518214006254"></p>
<p>然后还需要用到<strong>域名和项目名</strong>，也注入进来</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518214038726.png" alt="image-20220518214038726"></p>
<p>开始写注册业务方法，因为返回值要<strong>包括好多“报错信息”，所以我们用Map</strong>，注册需要用户传入账号，密码和邮箱，所以我们传入一个User。</p>
<p>首先对形参user进行空值判断，如果<strong>是空则报异常（注意不是报错</strong>）。然后是user的具体信息，如果哪个空了，就把哪个错误记录在map里面，返回给用户看。</p>
<p>如果都不空，还要验证邮箱和用户名是不是数据库里面已经有了，所以还要<strong>有验证操作</strong>。</p>
<p>然后才开始注册用户：</p>
<p>1）先<strong>设置盐</strong>，用随机生成字符串的方法</p>
<p>2）给密码<strong>加盐</strong></p>
<p>3）设置<strong>用户类型，激活状态</strong>，然后<strong>设置激活码</strong>（还是随机生成）</p>
<p>4）给用户<strong>设置默认头像</strong>，用牛客网默认的1000个头像中随机一个</p>
<p>5）最后给用户设置一个<strong>账号创建时间</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">register</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空值处理</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不能为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(user.getUsername()))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;账号不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(user.getPassword()))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;passwordMsg&quot;</span>, <span class="string">&quot;密码不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(user.getEmail()))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;emailMsg&quot;</span>, <span class="string">&quot;邮箱不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;<span class="comment">//这个地方第一次忘记写了，导致邮箱重复仍旧注册账户，注册后才提示邮箱重复</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证账号</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> userMapper.selectByName(user.getUsername());</span><br><span class="line">    <span class="keyword">if</span>(u != <span class="literal">null</span>)&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;该账号已存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证邮箱</span></span><br><span class="line">    u = userMapper.selectByEmail(user.getEmail());</span><br><span class="line">    <span class="keyword">if</span>(u != <span class="literal">null</span>)&#123;</span><br><span class="line">        map.put(<span class="string">&quot;emailMsg&quot;</span>, <span class="string">&quot;该邮箱已被注册&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册用户</span></span><br><span class="line">    user.setSalt(CommunityUtil.generateUUID().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">    user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt()));</span><br><span class="line">    user.setType(<span class="number">0</span>);</span><br><span class="line">    user.setStatus(<span class="number">0</span>);</span><br><span class="line">    user.setActivationCode(CommunityUtil.generateUUID());</span><br><span class="line">    user.setHeaderUrl(String.format(<span class="string">&quot;http://images.nowcoder.com/head/%dt.png&quot;</span>, <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>)));</span><br><span class="line">    user.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">    userMapper.insertUser(user);<span class="comment">//这里因为我们配置文件要求mybatis自动生成id，所以不需要我们显示为id赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//激活邮件</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();<span class="comment">//这里的Context类属于org.thymeleaf.context的Context</span></span><br><span class="line">    context.setVariable(<span class="string">&quot;email&quot;</span>, user.getEmail());</span><br><span class="line">    <span class="comment">// http://localhost:8080/community/activation/101/code</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> domain + contextPath + <span class="string">&quot;/activation/&quot;</span> + user.getId() + <span class="string">&quot;/&quot;</span> + user.getActivationCode();</span><br><span class="line">    context.setVariable(<span class="string">&quot;url&quot;</span>, url);</span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> templateEngine.process(<span class="string">&quot;/mail/activation&quot;</span>, context);</span><br><span class="line">    mailClient.sendMail(user.getEmail(), <span class="string">&quot;激活账号&quot;</span>, content);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-开发Controller层——LoginController处理注册请求"><a href="#4-开发Controller层——LoginController处理注册请求" class="headerlink" title="4.开发Controller层——LoginController处理注册请求"></a>4.开发Controller层——LoginController处理注册请求</h2><p>先把前面开发的UserService业务层注入进来</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220518221058302.png" alt="image-20220518221058302"></p>
<p>定义一个方法<strong>处理注册请求</strong>，浏览器要向服务器提交数据，肯定是POST请求</p>
<p>其实就是用业务层的map，如果<strong>map为空我们就可以发激活码</strong>了，表明成功，跳转到成功页面，然后过8秒跳到首页；如果map不为空，说明验证失败，就重新跳转到注册页面，并<strong>通过前端提示后端map传来的错误信息</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/register&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(Model model,User user)</span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = userService.register(user);</span><br><span class="line">    <span class="keyword">if</span>(map == <span class="literal">null</span> || map.isEmpty())&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;注册成功，我们已经向您的邮箱发送了一封激活邮件，请尽快激活！&quot;</span>);</span><br><span class="line">        <span class="comment">//倒计时之后要跳转到首页</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;target&quot;</span>, <span class="string">&quot;/index&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/operate-result&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;usernameMsg&quot;</span>, map.get(<span class="string">&quot;usernameMsg&quot;</span>));</span><br><span class="line">        model.addAttribute(<span class="string">&quot;passwordMsg&quot;</span>, map.get(<span class="string">&quot;passwordMsg&quot;</span>));</span><br><span class="line">        model.addAttribute(<span class="string">&quot;emailMsg&quot;</span>, map.get(<span class="string">&quot;emailMsg&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/register&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-定义常量接口——CommunityConstant"><a href="#5-定义常量接口——CommunityConstant" class="headerlink" title="5.定义常量接口——CommunityConstant"></a>5.定义常量接口——CommunityConstant</h2><p>该接口专门定义一些常量，后面哪个类需要用到这些常量直接实现这些接口即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommunityConstant</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 激活成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ACTIVATION_SUCCESS</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重复激活</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ACTIVATION_REPEAT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 激活失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ACTIVATION_FAILURE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-开发Service层——还是UserService处理激活账号业务"><a href="#6-开发Service层——还是UserService处理激活账号业务" class="headerlink" title="6.开发Service层——还是UserService处理激活账号业务"></a>6.开发Service层——还是UserService处理激活账号业务</h2><p>一共有三种结果：激活成功，重复激活，激活失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">activation</span><span class="params">(<span class="type">int</span> userId, String code)</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(userId);</span><br><span class="line">    <span class="keyword">if</span>(user.getStatus() == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ACTIVATION_REPEAT;<span class="comment">//如果用户状态已经为1，说明当前是重复激活</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(user.getActivationCode().equals(code))&#123;</span><br><span class="line">        userMapper.updateStatus(userId, <span class="number">1</span>);<span class="comment">//如果用户状态不为1，而且当前激活码满足条件，就把状态设为1</span></span><br><span class="line">        <span class="keyword">return</span> ACTIVATION_SUCCESS;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ACTIVATION_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-开发激活控制层Controller——还是LoginController"><a href="#7-开发激活控制层Controller——还是LoginController" class="headerlink" title="7.开发激活控制层Controller——还是LoginController"></a>7.开发激活控制层Controller——还是LoginController</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://localhost:8080/community/activation/101/code</span></span><br><span class="line">  <span class="meta">@RequestMapping(path = &quot;/activation/&#123;userId&#125;/&#123;code&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">activation</span><span class="params">(Model model, <span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="type">int</span> userId, <span class="meta">@PathVariable(&quot;code&quot;)</span> String code)</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userService.activation(userId, code);</span><br><span class="line">      <span class="comment">//激活成功了就返回登录页面</span></span><br><span class="line">      <span class="keyword">if</span>(result == ACTIVATION_SUCCESS)&#123;</span><br><span class="line">          model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;激活成功，您的账号已经可以正常使用了！&quot;</span>);</span><br><span class="line">          model.addAttribute(<span class="string">&quot;target&quot;</span>, <span class="string">&quot;/login&quot;</span>);</span><br><span class="line">      <span class="comment">//重复激活或失败了都返回主页</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result == ACTIVATION_REPEAT)&#123;</span><br><span class="line">          model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;无效操作，该账号已经激活过了！&quot;</span>);</span><br><span class="line">          model.addAttribute(<span class="string">&quot;target&quot;</span>, <span class="string">&quot;/index&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;激活失败，您提供的激活码不正确！&quot;</span>);</span><br><span class="line">          model.addAttribute(<span class="string">&quot;target&quot;</span>, <span class="string">&quot;/index&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;/site/operate-result&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>因为激活方法中返回登陆页面，我们还没写登陆页面的方法，所以下面写getLogin方法</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519161309172.png" alt="image-20220519161309172"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>注册功能的实现肯定底层逻辑是先验证当前的用户名，密码和邮箱<strong>是否合法</strong>（包括空值和是否在库的情况）。通过了这些合法性验证，我们就可以<strong>给用户的信息存储到数据库</strong>中，但是存储过程中，我们需要<strong>给用户的密码加密</strong>，否则很容易被盗。所以我们需要写个工具专门给字符串进行加密。但是加密入md5对简单字符串加密是对称加密，所以我们还需要在这些<strong>密码的基础上加点salt</strong>，这些salt我们用随机字符串来表示。所以还需要写个生成随机字符串的方法，我们<strong>用lang3包下的工具类</strong>实现。注册完成之后，就可以通过系统邮箱发邮件和激活码了，激活码我们也用随机字符串方法生成。OK，注册业务逻辑写完（伴随工具类的开发）。</p>
<p>注册业务逻辑写完了，视图层就可以调用该方法了，业务中报的错误我们都传给model，由<strong>model传给前端</strong>，然后<strong>跳转到注册页面并报错</strong>；如果没错，我们就<strong>跳到激活页面</strong>，倒计时之后<strong>转到首页</strong>。</p>
<p>激活完了有三种情况：成功，失败和重复激活。我们把这仨情况写到常量接口中，<strong>后面业务层和控制层要复用</strong>。然后写业务逻辑，说白了就是三种情况我们分别要干什么，<strong>后面控制层收到才可以进一步操作</strong>。处理完了就可以写控制层，根据激活业务<strong>返回的激活状态</strong>，将<strong>激活信息传给model</strong>，并<strong>确定每种情况要返回的页面</strong>。</p>
<h1 id="2-17-生成验证码"><a href="#2-17-生成验证码" class="headerlink" title="2.17 生成验证码"></a>2.17 生成验证码</h1><h2 id="1-导入Kaptcha包"><a href="#1-导入Kaptcha包" class="headerlink" title="1.导入Kaptcha包"></a>1.导入Kaptcha包</h2><p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519185233228.png" alt="image-20220519185233228"></p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519185721410.png" alt="image-20220519185721410"></p>
<h2 id="2-将kaptcha注入Spring容器——KaptchaConfig"><a href="#2-将kaptcha注入Spring容器——KaptchaConfig" class="headerlink" title="2.将kaptcha注入Spring容器——KaptchaConfig"></a>2.将kaptcha注入Spring容器——KaptchaConfig</h2><p>在config包下写配置类KaptchaConfig，<strong>通过配置类Properties直接写入验证码的参数</strong>：如宽度，高度，字体大小，颜色，字符范围，字符数量，干扰项。然后把配置类信息<strong>赋予kaptcha的Config类</strong>，然后<strong>传给DefaultKaptcha类</strong>。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519190503946.png" alt="image-20220519190503946"></p>
<h2 id="3-开发Controller层——LoginController生成验证码的方法"><a href="#3-开发Controller层——LoginController生成验证码的方法" class="headerlink" title="3.开发Controller层——LoginController生成验证码的方法"></a>3.开发Controller层——LoginController生成验证码的方法</h2><p>接下来就要把验证码应用到登录功能中，没有业务逻辑（与数据库交互），所以直接写控制层逻辑。</p>
<p>写在哪呢，访问登录页面的方法会返回一个html页面（<u>&#x2F;site&#x2F;login</u>），<strong>此页面中有访问验证码的路径</strong>，浏览器<strong>通过该路径访问服务器</strong>，才获得验证码图片。</p>
<p><img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519201235211.png" alt="image-20220519201235211"></p>
<p>因为我们要访问一个特殊的数据——图片，所以不设置返回值，直接通过response手动地向浏览器输出，同时也要把验证码的字符串内容存入服务器端session（存在浏览器端cookie容易被盗取）。最后不要忘了注入刚刚写的配置类kaptchaProducer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/kaptcha&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getKaptcha</span><span class="params">(HttpServletResponse response, HttpSession session)</span>&#123;</span><br><span class="line">    <span class="comment">//生成验证码</span></span><br><span class="line">    <span class="comment">//生成验证码字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> kaptchaProducer.createText();</span><br><span class="line">    <span class="comment">//生成验证码图片</span></span><br><span class="line">    <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> kaptchaProducer.createImage(text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将验证码存入session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;kaptcha&quot;</span>, text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将图片输出给浏览器</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取response输出流（字节流）向浏览器响应</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">//用javax工具类输出图片</span></span><br><span class="line">        ImageIO.write(image, <span class="string">&quot;png&quot;</span>, os);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;响应验证码失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-23-开发登录、退出功能"><a href="#2-23-开发登录、退出功能" class="headerlink" title="2.23 开发登录、退出功能"></a>2.23 开发登录、退出功能</h1><p>大纲如下：</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519204318213.png" alt="image-20220519204318213" style="zoom:50%;" />

<h2 id="1-创建实体类entity——LoginTicket"><a href="#1-创建实体类entity——LoginTicket" class="headerlink" title="1.创建实体类entity——LoginTicket"></a>1.创建实体类entity——LoginTicket</h2><p>我们把登录的用户信息单独存在一张数据库表里，字段分别有序号id, 用户序号user_id, 登陆凭证ticket, 用户登陆状态status, 用户登录过期时间expired</p>
<h2 id="2-开发DAO数据访问层——LoginTicketMapper"><a href="#2-开发DAO数据访问层——LoginTicketMapper" class="headerlink" title="2.开发DAO数据访问层——LoginTicketMapper"></a>2.开发DAO数据访问层——LoginTicketMapper</h2><p>插入一条数据，<strong>根据登陆凭证ticket查询数据</strong>，<strong>根据ticket更新登录状态</strong>（失效，有效）</p>
<p>上次用的xml的格式写的sql，本次<strong>用注解的方式</strong>写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoginTicketMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&#123;</span></span><br><span class="line"><span class="meta">            &quot;insert into login_ticket(user_id,ticket,status,expired) &quot;,</span></span><br><span class="line"><span class="meta">            &quot;values(#&#123;userId&#125;,#&#123;ticket&#125;,#&#123;status&#125;,#&#123;expired&#125;)&quot;</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span><span class="comment">//设置id是自增的</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertLoginTicket</span><span class="params">(LoginTicket loginTicket)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&#123;</span></span><br><span class="line"><span class="meta">            &quot;select id,user_id,ticket,status,expired &quot;,</span></span><br><span class="line"><span class="meta">            &quot;from login_ticket where ticket=#&#123;ticket&#125;&quot;</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    LoginTicket <span class="title function_">selectByTicket</span><span class="params">(String ticket)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&#123;</span></span><br><span class="line"><span class="meta">            &quot;update login_ticket set status=#&#123;status&#125; where ticket=#&#123;ticket&#125;&quot;</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateStatus</span><span class="params">(<span class="meta">@Param(&quot;ticket&quot;)</span> String ticket, <span class="meta">@Param(&quot;status&quot;)</span> <span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-开发Service层——登录业务UserService"><a href="#3-开发Service层——登录业务UserService" class="headerlink" title="3.开发Service层——登录业务UserService"></a>3.开发Service层——登录业务UserService</h2><p>先把刚才的LoginTicketMapper组件注入进来，然后再开始实现登录功能。因为登录也会像注册一样，可能有很多报错，所以<strong>返回值为Map类型数据用来存储报错信息</strong>。</p>
<p>另外，登录功能可以肯定的是<strong>需要我们传入用户名和密码，还有过期时间也要传入</strong>，这个容易忘记！！！</p>
<p>具体功能和注册功能的业务逻辑很像，首先判断空值，然后验证合法性（<strong>注意密码要加salt</strong>），都通过了就生成登陆凭证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">login</span><span class="params">(String username, String password, <span class="type">int</span> expiredSeconds)</span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空值处理</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(username))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;账号不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(password))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;passwordMsg&quot;</span>, <span class="string">&quot;密码不能为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证账号</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectByName(username);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;该账号不存在！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证状态（注册后有没有激活）</span></span><br><span class="line">    <span class="keyword">if</span>(user.getStatus() == <span class="number">0</span>)&#123;</span><br><span class="line">        map.put(<span class="string">&quot;usernameMsg&quot;</span>, <span class="string">&quot;该账号未激活！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证密码</span></span><br><span class="line">    password = CommunityUtil.md5(password + user.getSalt());</span><br><span class="line">    <span class="keyword">if</span>(!user.getPassword().equals(password))&#123;</span><br><span class="line">        map.put(<span class="string">&quot;passwordMsg&quot;</span>, <span class="string">&quot;密码不正确！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成登录凭证</span></span><br><span class="line">    <span class="type">LoginTicket</span> <span class="variable">loginTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginTicket</span>();</span><br><span class="line">    loginTicket.setUserId(user.getId());</span><br><span class="line">    loginTicket.setTicket(CommunityUtil.generateUUID());</span><br><span class="line">    loginTicket.setStatus(<span class="number">0</span>);</span><br><span class="line">    loginTicket.setExpired(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expiredSeconds * <span class="number">1000</span>));</span><br><span class="line">    loginTicketMapper.insertLoginTicket(loginTicket);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以传入loginTicket整个对象，但没必要，我们只需要登陆凭证，其他的登录信息可以用凭证去库里查</span></span><br><span class="line">    map.put(<span class="string">&quot;ticket&quot;</span>, loginTicket.getTicket());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-开发Controller——login登录功能"><a href="#4-开发Controller——login登录功能" class="headerlink" title="4.开发Controller——login登录功能"></a>4.开发Controller——login登录功能</h2><p>这里返回页面也是&#x2F;login，不会与前面的返回&#x2F;login页面的方法冲突是因为，<strong>前面是get请求，当前方法是post请求。</strong></p>
<p>传入的参数分别有用户名，密码，因为<strong>要与页面直接交互</strong>了，所以还有<strong>验证码code</strong>，因为<strong>验证码要去session中取</strong>，所以要有Session session，另外还有<strong>页面上的选框“记住我”rememberme</strong>，如果登录成功，要<strong>将ticket登陆凭证存入浏览器的cookie</strong>中，所以要用response接收，最后别忘了Model <strong>model</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/login&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password, String code, <span class="type">boolean</span> rememberme,</span></span><br><span class="line"><span class="params">                    Model model, HttpSession session, HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="comment">//检查验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">kaptcha</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;kaptcha&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code))&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;codeMsg&quot;</span>, <span class="string">&quot;验证码不正确！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/login&quot;</span>;<span class="comment">//回到登录页面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查账号，密码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expiredSeconds</span> <span class="operator">=</span> rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;</span><br><span class="line">    Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds);</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(<span class="string">&quot;ticket&quot;</span>))&#123;</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;ticket&quot;</span>, map.get(<span class="string">&quot;ticket&quot;</span>).toString());</span><br><span class="line">        <span class="comment">//生成cookie有效路径</span></span><br><span class="line">        cookie.setPath(contextPath);</span><br><span class="line">        <span class="comment">//设置cookie有效时间</span></span><br><span class="line">        cookie.setMaxAge(expiredSeconds);</span><br><span class="line">        <span class="comment">//将cookie加入到response中，响应时就会将cookie发送给浏览器</span></span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;usernameMsg&quot;</span>, map.get(<span class="string">&quot;usernameMsg&quot;</span>));</span><br><span class="line">        model.addAttribute(<span class="string">&quot;passwordMsg&quot;</span>, map.get(<span class="string">&quot;passwordMsg&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/site/login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在“记住我”选框判断的时候，需要利用常量接口中的两个属性，要记得在接口中加上：</p>
<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220519215357488.png" alt="image-20220519215357488" style="zoom: 67%;" />

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/13/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/" data-id="cl34jfrpo0000agv65zyw0788" data-title="我的项目" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-05-13T06:38:33.000Z" itemprop="datePublished">2022-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/">计算机网络笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="路由器相关知识"><a href="#路由器相关知识" class="headerlink" title="路由器相关知识"></a>路由器相关知识</h2><ol>
<li>MAC头部的作用就是<strong>将包传送到路由器</strong>，其中的接收方MAC地址，就是路由器端口的MAC地址。所以，当包到达了路由器，MAC头部任务就完成了，<strong>MAC头部即被丢弃</strong>。</li>
<li>在网络包的传输过程中，<strong>源IP和目标IP始终不变</strong>，而为了两两设备在以太网中传输，必须<strong>实时变化MAC地址</strong>。</li>
<li>在发送数据包的时候，<strong>如果目标主机不是本地局域网内的主机，那MAC地址填入的是路由器地址</strong>，通过路由器的层层转发，<strong>一直转发到目标主机的路由器</strong>，发现IP地址是自己局域网内的主机，就会通过ARP请求<strong>获取目标主机的MAC地址</strong>，进而转发到这个服务器主机。</li>
</ol>
<h2 id="GET和POST区别？"><a href="#GET和POST区别？" class="headerlink" title="GET和POST区别？"></a>GET和POST区别？</h2><p>GET请求的参数一般<strong>写在URL中</strong>，URL规定<strong>只能支持ASCII</strong>，虽然HTTP协议并没有限制URL长度，但是<strong>浏览器自身会对URL长度有限制</strong>。</p>
<p>POST请求的参数一般<strong>放在请求报文（body）中</strong>，body参数<strong>没有格式限制</strong>，只要浏览器和服务器都可接受即可，而且body参数的<strong>长度没有限制</strong>。</p>
<h2 id="HTTPS和HTTP"><a href="#HTTPS和HTTP" class="headerlink" title="HTTPS和HTTP"></a>HTTPS和HTTP</h2><p>前者就是在HTTP的基础上，在TCP和HTTP之间添加了一层SSL&#x2F;TLS安全协议，使得报文能够加密传输。</p>
<p>所以HTTPS不仅要进行TCP的三次握手，还要接着进行SSL&#x2F;TLS握手判断，才可以加密传输报文。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png" alt="HTTP 与 HTTPS 网络层"  />

<h2 id="HTTP对应OSI模型哪几层？"><a href="#HTTP对应OSI模型哪几层？" class="headerlink" title="HTTP对应OSI模型哪几层？"></a>HTTP对应OSI模型哪几层？</h2><p>用来管理通信连接的会话层，转换数据格式的表示层，与对端主机交互的应用层。</p>
<h2 id="应用层各大常见协议"><a href="#应用层各大常见协议" class="headerlink" title="应用层各大常见协议"></a>应用层各大常见协议</h2><h3 id="1-TELNET：远程登陆协议"><a href="#1-TELNET：远程登陆协议" class="headerlink" title="1. TELNET：远程登陆协议"></a>1. TELNET：远程登陆协议</h3><p>建立在TCP协议之上，通过一个终端登录到其他远端的服务器。<strong>最大缺点：明文传输</strong>，所以有了SSH</p>
<h3 id="2-SSH（Secure-Shell）：安全的网络传输协议"><a href="#2-SSH（Secure-Shell）：安全的网络传输协议" class="headerlink" title="2. SSH（Secure Shell）：安全的网络传输协议"></a>2. SSH（Secure Shell）：安全的网络传输协议</h3><p>有效防止远程管理过程中的信息泄露，加密传输，也是建立在TCP协议之上的。</p>
<h3 id="3-FTP：文件传输协议"><a href="#3-FTP：文件传输协议" class="headerlink" title="3. FTP：文件传输协议"></a>3. FTP：文件传输协议</h3><p>FTP是在两个“相连”的计算机之间进行文件传输的协议</p>
<p>最大特点：<strong>两条TCP连接</strong>，一条用于<strong>传送控制信息</strong>，比如：登录验证，发送文件的名称，发送方式部署等；另一条用于<strong>专门传输数据</strong>。</p>
<h3 id="4-SMTP（Simple-Mail-Transfer-Protocol）：简单邮件传输-发送-协议"><a href="#4-SMTP（Simple-Mail-Transfer-Protocol）：简单邮件传输-发送-协议" class="headerlink" title="4. SMTP（Simple Mail Transfer Protocol）：简单邮件传输(发送)协议"></a>4. SMTP（Simple Mail Transfer Protocol）：简单邮件传输(发送)协议</h3><p><strong>用来发送</strong>邮件的协议，<strong>只支持发送端主机行为</strong>，所以不会根据接收端的请求发送，而是根据发送端请求进行发送。</p>
<p>虽然建立在TCP协议上保证了传输的可靠性，但内容不能保证可靠，因为没有身份验证功能。所以现在规定“POP before SMTP”或者“SMTP认证”。</p>
<p>以前的邮件发送需要两端都要保持插电，很不友好，现在是<strong>一端发给服务器A，A发给服务器B，另一端从B接收</strong>。</p>
<h3 id="5-POP（Post-Office-Protocol）：邮局协议"><a href="#5-POP（Post-Office-Protocol）：邮局协议" class="headerlink" title="5. POP（Post Office Protocol）：邮局协议"></a>5. POP（Post Office Protocol）：邮局协议</h3><p><strong>用来接收</strong>邮件的协议，前面发送端的邮件通过SMTP<strong>发送给一直插电的POP服务器</strong>，接收端再根据POP从POP服务器把邮件“拿过来”。</p>
<p>注意：POP就有<strong>用户验证</strong>喽！</p>
<h3 id="6-IMAP（Internet-Message-Access-Protocol）：交互邮件访问协议"><a href="#6-IMAP（Internet-Message-Access-Protocol）：交互邮件访问协议" class="headerlink" title="6. IMAP（Internet Message Access Protocol）：交互邮件访问协议"></a>6. IMAP（Internet Message Access Protocol）：交互邮件访问协议</h3><p>与POP区别就是，POP是客户端管理邮件，而IMAP是<strong>服务器管理邮件</strong>。</p>
<p>这带来了极大的方便：比如我电脑已读某个邮件，那么手机也显示我读了，因为我是<strong>在一致的服务器处理</strong>了MIME信息。所以可以<strong>实现多终端同步的效果</strong>。</p>
<h2 id="电子邮箱发送过程？"><a href="#电子邮箱发送过程？" class="headerlink" title="电子邮箱发送过程？"></a>电子邮箱发送过程？</h2><p>比如一个163邮箱向一个QQ邮箱发邮件：</p>
<p>1）通过SMTP，163邮箱将邮件发给163邮箱服务器</p>
<p>2）163服务器发给QQ服务器</p>
<p>3）QQ服务器通知该QQ邮箱来取邮件，要通过POP&#x2F;IMAP取</p>
<h2 id="如何判断邮箱真正存在？"><a href="#如何判断邮箱真正存在？" class="headerlink" title="如何判断邮箱真正存在？"></a>如何判断邮箱真正存在？</h2><p>1）通过邮箱域名查找到对应的SMTP服务器地址（你家在哪？）</p>
<p>2）尝试与该服务器建立连接（找到你家）</p>
<p>3）服务器尝试向该邮箱发送邮件（你家给你打电话）</p>
<p>4）根据该邮箱返回结果判断真假（听听是自己儿子声音不）</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>首先，<strong>IP是面向无连接的</strong>，它尽管去传输，面向连接要交给它的上层TCP。</p>
<p>一开始分为ABCDE五类，都具有两个部分：网络号和主机号。其中D类用于多播（广播无法穿透路由，所有有了多播），E还没用</p>
<p>缺点：ABC所包含的主机数相差太大，不符合实际应用。</p>
<h3 id="无分类地址CIDR"><a href="#无分类地址CIDR" class="headerlink" title="无分类地址CIDR"></a>无分类地址CIDR</h3><p>所以有了无分类地址的CIDR：灵活分配网络号和主机号（32拆成两大部分）。这里有子网掩码的概念，<strong>掩码的意思是掩盖掉主机号。将子网掩码和IP地址按位计算AND，就可以得到网络号</strong>。</p>
<p>分离网络号和主机号的目的就是：同一个网络就直接本地传输了，不同网络我们再去通过路由向外传输。</p>
<p>下面是子网划分的示意图（<u>还没搞懂它的意义</u>）：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/18.jpg" alt="img"></p>
<h3 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h3><p>其实就是主机向另一个主机传输，如果需要跨网，就要通过路由器来路由。</p>
<p>注意：<strong>环回地址</strong>是特殊的IP地址，为127.0.0.1。localhost和它意义一样，使用这俩时，<strong>数据包不会流向网络</strong>。</p>
<h3 id="IP分片与重组"><a href="#IP分片与重组" class="headerlink" title="IP分片与重组"></a>IP分片与重组</h3><p>因为IP传输过程中，数据包要通过数据链路传输，所以要根据数据链路的最大传输单元MTU来对IP分片。</p>
<p>需要注意的时：<strong>IP在路由器上不会重组，只会在目标主机才重组</strong>。</p>
<h3 id="IPv6与IPv4"><a href="#IPv6与IPv4" class="headerlink" title="IPv6与IPv4"></a>IPv6与IPv4</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/30.jpg" alt=" IPv6 中的单播通信" style="zoom:50%;" />

<p>6比4多加了个<strong>链路本地单播地址</strong>，用于不走路由器的本数据链路传播。其他的像v6的唯一本地地址相当于v4的私有IP，v6的全局单播地址相当于v4的共有IP。</p>
<h4 id="IPv6相比IPv4的首部改进："><a href="#IPv6相比IPv4的首部改进：" class="headerlink" title="IPv6相比IPv4的首部改进："></a>IPv6相比IPv4的首部改进：</h4><p>1）<strong>取消首部校验和字段</strong>：因为数据链路层和传输层都要校验，所以v6直接取消了IP校验</p>
<p>2）<strong>取消分片&#x2F;重新组装相关字段</strong>：中间路由器不准分片和重组了</p>
<p>3）<strong>取消选项字段</strong></p>
<h2 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>解析域名的</p>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>根据IP地址查询MAC地址的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" data-id="cl34efpty00001cv6d0asee9e" data-title="计算机网络笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作字符串题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/13/%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-13T03:26:25.000Z" itemprop="datePublished">2022-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/13/%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E8%A7%A3/">操作字符串题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcode-541-反转字符串II"><a href="#leetcode-541-反转字符串II" class="headerlink" title="leetcode 541.反转字符串II"></a>leetcode 541.反转字符串II</h1><p>给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p>
<p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<p>示例:</p>
<p>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “bacdfeg”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(i + k - <span class="number">1</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ch[start];</span><br><span class="line">                ch[start] = ch[end];</span><br><span class="line">                ch[end] = temp;</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环中的i，就相当于一个指针，每次走2*k个单位，走完一次，就定义当前反转字符串的起始位和终点位。</p>
<p>注意：<strong>终点位的要取i + k - 1和s.length() - 1的最小值</strong>，因为最后一次如果反转个数不够k个的时候，就直接将当前字符串从start到s.length() - 1的所有字符串翻转即可。</p>
<p>因为反转操作涉及字符串中每个字符的换位，所以最好将字符串转换为数组进行操作。最后记得再将数组转换为字符串。</p>
<h1 id="leetcode-28-实现strStr"><a href="#leetcode-28-实现strStr" class="headerlink" title="leetcode 28.实现strStr()"></a>leetcode 28.实现strStr()</h1><p><u><strong>题目</strong>：实现 strStr() 函数。</u></p>
<p><u>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</u></p>
<p><u>示例 1: 输入: haystack &#x3D; “hello”, needle &#x3D; “ll” 输出: 2</u></p>
<p><u>示例 2: 输入: haystack &#x3D; “aaaaa”, needle &#x3D; “bba” 输出: -1</u></p>
<p><u>说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i + m &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(haystack.charAt(i + j) != needle.charAt(j))&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题我暂时只会暴力解法，后续学会了KMP算法会进行更新。</p>
<p>暴力解法其实思路比较简单，让haystack数组指针依次向后递进，每递进一次，我们就从当前位置开始判断，该指针及其后面的元素是不是和needle的每个元素相同，如果都相同，那么我们就找到了needle出现的第一个位置。一旦有一个不同，那么就可以继续让haystack指针向后走了。</p>
<p>这里我们需要定义一个boolean类型的变量flag，初始值是true，一定要注意其定义的位置：<strong>每次haystack递进一位就定义一个全新的flag</strong>，而<strong>不要定义为全局变量</strong>。因为这个flag是为每次寻找needle字符串服务的，所以<strong>每次比较都要用全新的flag</strong>。</p>
<p><strong>每次寻找needle字符串的操作结束之后，都要看看flag还是不是true</strong>，如果还是true，说明找到了needle；如果是false，就说明上面的寻找过程中，出现了某个字符没匹配上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/13/%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E8%A7%A3/" data-id="cl33vz9vp0000qwv64bvmbn7e" data-title="操作字符串题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-哈希算法题目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/13/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2022-05-13T02:21:16.000Z" itemprop="datePublished">2022-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/13/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/">哈希算法题目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcode-202-快乐数"><a href="#leetcode-202-快乐数" class="headerlink" title="leetcode 202.快乐数"></a>leetcode 202.快乐数</h1><p><u><strong>题目</strong>：编写一个算法来判断一个数 n 是不是快乐数。</u></p>
<p><u>「快乐数」 定义为：</u></p>
<p><u>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</u><br><u>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</u><br><u>如果这个过程 结果为 1，那么这个数就是快乐数。</u><br><u>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</u></p>
<p><u>示例如下：</u></p>
<p><u>输入：n &#x3D; 19</u><br><u>输出：true</u><br><u>解释：</u><br><u>12 + 92 &#x3D; 82</u><br><u>82 + 22 &#x3D; 68</u><br><u>62 + 82 &#x3D; 100</u><br><u>12 + 02 + 02 &#x3D; 1</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !set.contains(n))&#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            n = getNextNum(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">n</span> <span class="operator">=</span>= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            res += temp * temp;</span><br><span class="line">            n = n / <span class="number">10</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的思路有那么一点绕，一次写对不是很容易。</p>
<p>首先我们最好单独定义一个方法，<strong>用来计算每次不断更新的n，计算的过程就是不停的记录n % 10</strong>，然后让该位乘方值记录到res中，直到n &#x3D;&#x3D; 0，也就是把n的每一位的乘方都累加到res中。</p>
<p>然后将上面记录的更新之后的n，更新到主方法的n中。</p>
<p>在<strong>更新之前我们要记得用set保存n</strong>，防止后续的循环计算。</p>
<p>循环条件要想清楚，<strong>既然你进入这个循环了，那么你肯定不等于1</strong>，因为等于1就没要计算了，所以有n !&#x3D; 1这个条件。</p>
<p><strong>另一个条件自然是为了避免重复计算</strong>，所以n更新之后必须更新为之前没有计算过的n，如果计算过，那么就直接跳出循环吧。</p>
<p>所以循环条件有两个，一定不要丢了。</p>
<h1 id="leetcode-349-两个数组的交集"><a href="#leetcode-349-两个数组的交集" class="headerlink" title="leetcode 349.两个数组的交集"></a>leetcode 349.两个数组的交集</h1><p><u><strong>题目</strong>：给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。举例：</u></p>
<p><u>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</u><br><u>输出：[2]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; resSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums1)&#123;</span><br><span class="line">            set1.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(x))&#123;</span><br><span class="line">                resSet.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[resSet.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : resSet)&#123;</span><br><span class="line">            ans[index++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路比较简单，注意审题，相同的元素我们只记录一次，所以用HashSet是一种很简单的方式。</p>
<p>注意最后用数组记录即可。</p>
<h1 id="☆leetcode-350-两个数组的交集II"><a href="#☆leetcode-350-两个数组的交集II" class="headerlink" title="☆leetcode 350.两个数组的交集II"></a>☆leetcode 350.两个数组的交集II</h1><p><u><strong>题目</strong>：给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。举例：</u></p>
<p><u>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</u><br><u>输出：[2,2]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length &gt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums1)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            map.put(x, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(x))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.get(x);</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    ans[index++] = x;</span><br><span class="line">                    count--;</span><br><span class="line">                    map.put(x, count);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.remove(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(ans, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题与上面一题的区别就是重复元素要全部记录了，所以HashSet显得力不从心了。我们选用能记录每个重复元素出现次数的HashMap，利用value来记录每个key值出现的次数。</p>
<p><strong>为了节省哈希表得空间</strong>，我们用较小得数组存储到哈希表中。</p>
<p>每次存储的时候需要注意，为了书写和判断方便，我们利用map的getOrDefault方法，这可以让我们轻松的写出统一的count值，然后执行map.put(x, count)。</p>
<p>因为<strong>交集元素个数肯定 &lt;&#x3D; 较短的数组长度</strong>，所以我们记录交集元素只需要较短的长度即可。</p>
<p>在判断长数组存不存在map元素的时候，要注意：一旦存在，<strong>我们添加后一定要判断当前的count值，并且更新count值</strong>，更重要的是，count &#x3D;&#x3D; 0了要及时<strong>删除其所对应的key值</strong>，如果还没等于0，也要<strong>及时更新map中的count值</strong>，即map.put(x, count)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/13/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/" data-id="cl33tx2240000fkv6agf0ho2c" data-title="哈希算法题目" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-个人对JVM的理解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E4%B8%AA%E4%BA%BA%E5%AF%B9JVM%E7%9A%84%E7%90%86%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T12:04:43.000Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E4%B8%AA%E4%BA%BA%E5%AF%B9JVM%E7%9A%84%E7%90%86%E8%A7%A3/">个人对JVM的理解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="☆JVM内存结构："><a href="#☆JVM内存结构：" class="headerlink" title="☆JVM内存结构："></a>☆JVM内存结构：</h2><p><img src="D:\Picgo\img\image-20220511200810603.png" alt="image-20220511200810603"></p>
<p>首先给出JVM的结构图，包括了类装载器子系统、运行时数据区、执行引擎、本地方法接口、垃圾回收（<strong>这里不确定</strong>）</p>
<p>而内存结构呢，就是运行时数据区部分，也就包括了：程序计数器、虚拟机栈、本地方法栈、堆、方法区。其中方法区在jdk8以后就变成元数据区了。</p>
<p><u>程序计数器</u>：</p>
<p>是内存中很小的一个存储空间，可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。在程序运行过程中，线程是非常多的，但是CPU的核心数却是有限的，所以我们必须要通过不断切换线程来来为处理器分配时间，进而完成程序的执行。程序计数器就是为了实现线程切换用的，<strong>每个线程都用独立的程序计数器</strong>，两两互不干扰，其生命周期也与线程保持一致。</p>
<p>垃圾回收和内存溢出都与程序计数器无关。</p>
<h2 id="☆类加载机制整个过程是怎么样的"><a href="#☆类加载机制整个过程是怎么样的" class="headerlink" title="☆类加载机制整个过程是怎么样的"></a>☆类加载机制整个过程是怎么样的</h2><p><img src="D:\Picgo\img\image-20220512150709656.png" alt="image-20220512150709656"></p>
<p>类加载机制的过程：首先Java虚拟机将描述类的数据从Class文件中<strong>加载到内存</strong>，然后对数据进行<strong>连接以及初始化</strong>的过程，最终形成了可以被JVM可以直接使用的类型。</p>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><p>加载只是整个“类加载”过程的第一步。这个过程Java虚拟机完成了三件事：</p>
<p>1）通过一个类的全限定名来<strong>获取定义此类的二进制字节流</strong>。</p>
<p>2）将这个字节流代表的静态存储结构<strong>转化</strong>为方法区的运行时数据结构（注意：这里仅仅是转化）。</p>
<p>3）在内存中生成一个代表这个类的java.lang.Class对象，<strong>作为方法区这个类的各种数据访问入口</strong>。</p>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><p>作为连接的第一步，验证的目的主要是确保加载的Class字节流不会危害到虚拟机自身安全（本步骤对应的代码如果已经在之前执行过程中反复验证过了，就可以关掉该步骤，以缩短虚拟机类加载时间）：</p>
<p>1）文件格式验证：验证字节流<strong>是否符合Class文件格式规范</strong></p>
<p>2）元数据验证：对字节码进行<strong>语义分析</strong>，比如某个类有无父类，是否继承了不允许继承的类等一些违规的语义</p>
<p>3）字节码验证：确定程序语义的<strong>合法性、逻辑性</strong>，较复杂，具体见《深入理解JVM》P270</p>
<p>4）符号引用验证：这个验证要在后面的解析阶段发生，通俗来讲，就是<strong>检验该类是否缺少或者被禁止访问它依赖的某些资源</strong>。</p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h3><p>本阶段开始正式为类中定义的<strong>静态变量分配内存</strong>并<strong>设置初始零值</strong>。注意：JDK 7之前，这部分变量分配在方法区中，而<strong>JDK 8之后，则分配到堆中</strong>。以下两点需要注意：</p>
<p>1）这里分配内存和设置零值都<strong>仅限于类变量</strong>（静态变量），实例变量将在<strong>对象实例化时随着对象一起分配到Java堆中</strong>。</p>
<p>2）注意是设置零值，<strong>一般情况不是初始化</strong>。</p>
<p>3）特殊情况就是<strong>static final定义的变量</strong>，Javac<strong>编译时</strong>就已经为该变量生成ConstantValue属性（可以理解为<strong>设置初始零值</strong>），类加载的准备阶段，就<strong>直接为其赋值</strong>了。</p>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><p>将字节码中常量池内的符号引用替换为直接引用。</p>
<p>1）符号引用：是任何形式的字面量，只要使用时能无歧义的“精准定位”即可。</p>
<p>2）直接引用：可以是<strong>直接指向</strong>目标的<strong>指针</strong>、<strong>相对偏移量</strong>或能<strong>间接定位</strong>到目标的<strong>句柄</strong>。一旦有直接引用，那么相对应的<strong>目标必定在虚拟机内存中存在</strong>。</p>
<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><p>该阶段，虚拟机才正式开始执行类中编写的Java程序代码，将主导权移交给应用程序。在前面的”准备“阶段中，我们已经为类变量进行分配内存和设置零值的操作，接下来就<strong>轮到初始化阶段真正为这些变量赋值</strong>了。</p>
<p>1）直接来讲，<strong>初始化就是执行类构造器clinit&gt;()方法的过程</strong>，clinit&gt;()是Javac编译器的自动生成物。</p>
<p>2）clinit&gt;()是编译器自动收集类中<strong>所有的静态变量的赋值动作和静态语句块中的语句</strong>合并而成的，收集顺序就是源代码书写顺序。</p>
<p>3）在子类执行clinit&gt;()方法前，**先要执行其父类clinit&gt;()**，这也是为什么父类静态语句块要先执行的原因。与类的构造函数（虚拟机视角的实例构造器init&gt;()方法）不同，不需要显示调用父类构造器。</p>
<h2 id="☆类加载器"><a href="#☆类加载器" class="headerlink" title="☆类加载器"></a>☆类加载器</h2><p><img src="D:\Picgo\img\image-20220512194439270.png" alt="image-20220512194439270"></p>
<p>前面提到，类加载机制的第一步就是加载，我们用到的工具自然是类加载器。其实类加载器分类很简单，就是C&#x2F;C++写的启动类加载器和Java写的类加载器，具体分类如下：</p>
<p><img src="D:\Picgo\img\image-20220512194934161.png" alt="image-20220512194934161"></p>
<h3 id="1-启动类加载器（引导类加载器-Bootstrap-ClassLoader）"><a href="#1-启动类加载器（引导类加载器-Bootstrap-ClassLoader）" class="headerlink" title="1.启动类加载器（引导类加载器, Bootstrap ClassLoader）"></a>1.启动类加载器（引导类加载器, Bootstrap ClassLoader）</h3><p>1）<strong>虚拟机自带</strong>，C++编写</p>
<p>2）用来<strong>加载Java核心库</strong></p>
<p>3）<strong>没有父加载器，也没有父类</strong></p>
<p>4）<strong>加载其下面的</strong>扩展类加载器和系统类加载器</p>
<h3 id="2-扩展类加载器（Extension-ClassLoader）"><a href="#2-扩展类加载器（Extension-ClassLoader）" class="headerlink" title="2.扩展类加载器（Extension ClassLoader）"></a>2.扩展类加载器（Extension ClassLoader）</h3><p>1）Java编写，**<u>独立存在于虚拟机外部</u>**</p>
<p>2）<strong>继承自抽象类</strong>java.lang.ClassLoader</p>
<p>3）父类加载器就是上边的Bootstrap ClassLoader</p>
<h3 id="3-系统类加载器（应用程序类加载器，System-ClassLoader）"><a href="#3-系统类加载器（应用程序类加载器，System-ClassLoader）" class="headerlink" title="3.系统类加载器（应用程序类加载器，System ClassLoader）"></a>3.系统类加载器（应用程序类加载器，System ClassLoader）</h3><p>1）Java编写，**<u>独立存在于虚拟机外部</u>**</p>
<p>2）<strong>继承自抽象类</strong>java.lang.ClassLoader</p>
<p>3）父类加载器就是上边的Extension ClassLoader</p>
<p>4）负责加载环境变量和系统属性指定路径下的类库</p>
<p>5）程序的默认类加载器，<strong>一般Java应用类都是它加载的</strong>。</p>
<h3 id="4-用户自定义类加载器"><a href="#4-用户自定义类加载器" class="headerlink" title="4.用户自定义类加载器"></a>4.用户自定义类加载器</h3><h2 id="☆双亲委派模型"><a href="#☆双亲委派模型" class="headerlink" title="☆双亲委派模型"></a>☆双亲委派模型</h2><p>首先我们要知道，虚拟机对class文件是<strong>按需加载</strong>的，也就是只有在需要使用该类的时候，才将其class文件加载到内存中生成class对象。</p>
<p>那么加载某个class文件的时候，具体的过程是怎么样的呢？这时候就要引入我们的一种特殊模式：双亲委派模式。工作原理如下：</p>
<p>1）一个类加载器收到类加载请求，<strong>先把请求依次委托其父类加载器去执行</strong>，请求<strong>最终到达顶层</strong>的启动类加载器。</p>
<p>2）如果父类加载器<strong>可以完成类加载的任务，就成功返回</strong>。若不能完成，<strong>才交给子加载器</strong>进行加载。</p>
<h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>其实就是利用了双亲委派模型的特点，假如我们定义一个String类，那么加载这个自定义String类的时候，<strong>会先委派到顶部的引导类加载器加载</strong>，引导类发现自己可以加载，就<strong>接着加载JDK自带的文件java.lang.String</strong>，这样就可以避免我们自定义String类对核心源代码的破坏。</p>
<h3 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h3><p>1）避免类的重复加载</p>
<p>2）保护程序安全，避免核心API被随意篡改</p>
<h2 id="☆判断两个class对象是否相同，我们需要看什么？"><a href="#☆判断两个class对象是否相同，我们需要看什么？" class="headerlink" title="☆判断两个class对象是否相同，我们需要看什么？"></a>☆判断两个class对象是否相同，我们需要看什么？</h2><p>1）类的名字首先得相同，包名也得一致</p>
<p>2）加载这个class的类加载器（<strong>ClassLoader实例对象</strong>）必须相同。</p>
<h2 id="☆Java什么时候对类进行主动引用？"><a href="#☆Java什么时候对类进行主动引用？" class="headerlink" title="☆Java什么时候对类进行主动引用？"></a>☆Java什么时候对类进行主动引用？</h2><p>1）使用new关键字实例化对象的时候</p>
<p>2）访问某个<strong>类（或接口）的静态变量</strong>，或者对该静态变量<strong>赋值</strong></p>
<p>3）调用某个类的<strong>静态方法</strong></p>
<p>4）使用java.lang.reflect包的方法对某个类进行<strong>反射调用</strong></p>
<p>5）初始化某个类，<strong>优先触发其父类初始化</strong></p>
<p>6）虚拟机启动时，用户需要<strong>指定一个要执行的主类</strong>（包括main()方法的那个类），虚拟机先初始化该类</p>
<p>7）JDK 7开始提供<strong>动态语言支持</strong>（不懂）</p>
<p>8）JDK 8在**接口中定义了默认方法(**default标识)，如果这个接口的实现类发生了初始化，那么该接口要率先初始化。</p>
<h1 id="☆虚拟机栈的作用是什么？"><a href="#☆虚拟机栈的作用是什么？" class="headerlink" title="☆虚拟机栈的作用是什么？"></a>☆虚拟机栈的作用是什么？</h1><p>栈是<strong>运行时</strong>的单位，而堆是<strong>存储的</strong>单位。栈解决的是程序如何执行，如何处理数据的问题；而堆是解决数据存储的问题。当然一些数据也会存在栈中，只能说栈的主要功能是处理数据，它<strong>是线程私有的</strong>。内部存储着一个个栈帧，<strong>每一个栈帧对应一个Java方法</strong>。</p>
<p>上面是比较泛泛的总结，虚拟机栈具体是什么作用呢？它主管程序的运行，<strong>在每个栈帧的局部变量表中保存相应方法的局部变量</strong>（8种<strong>基本数据</strong>类型、引用类型变量的<strong>引用地址</strong>），一<strong>部分结果</strong>，并参与方法的<strong>调用和返回</strong>。</p>
<p>栈操作只有两个：</p>
<p>1）执行方法的时候，<strong>进栈</strong>（入栈、压栈）</p>
<p>2）方法执行结束的时候，<strong>出栈</strong></p>
<p>所以栈<strong>没有垃圾回收机制</strong>，只<strong>存在栈溢出</strong>的现象。</p>
<h1 id="☆虚拟机栈的常见异常？如何设置栈的大小？"><a href="#☆虚拟机栈的常见异常？如何设置栈的大小？" class="headerlink" title="☆虚拟机栈的常见异常？如何设置栈的大小？"></a>☆虚拟机栈的常见异常？如何设置栈的大小？</h1><p>当<strong>某个线程请求分配的栈容量超过</strong>了Java虚拟机栈允许的最大容量，虚拟机会报<strong>StackOverflowError</strong>，即栈溢出。</p>
<p>我们可以通过-Xxx设置虚拟机栈的大小。在Idea的Run中，找到Edit Configurations，在当前程序的VM options中写入-Xxx256k即可。</p>
<p>如果Java虚拟机栈可以动态扩展，但<strong>扩展的时候无法申请到足够的内存</strong>，或者创建新线程的时候<strong>没有足够内存去创建对应的虚拟机栈</strong>，则虚拟机会报OutOfMemoryError异常，也就是我们所说的OOM。</p>
<h1 id="☆栈帧的内部结构"><a href="#☆栈帧的内部结构" class="headerlink" title="☆栈帧的内部结构"></a>☆栈帧的内部结构</h1><p>栈帧内部包括：局部变量表、操作数栈、动态链接、方法返回地址、一些附加信息。其中，<strong>局部变量表和操作数栈占的内存最大</strong>，主要影响栈帧的大小，而栈帧的大小决定了每个线程的虚拟机栈能存放多少个栈帧。</p>
<p>1）局部变量表：就是<strong>数字数组</strong>，主要用于<strong>存储方法参数和定义在方法体内的局部变量</strong>，包括基本数据类型、对象引用、returnAddress类型。<strong>slot(变量槽)<strong>是最基本的存储单元，对于byte、short、char在存储前，被</strong>转换为int</strong>,而boolean也被<strong>转换为int</strong>，false对应0，true对应非0。他们都<strong>占用一个slot</strong>。long和double类型的变量<strong>占两个slot</strong>。</p>
<p>栈帧的<strong>局部变量表与性能调优关系最为密切</strong>，因为在垃圾回收过程中，表中的变量是重要的<strong>垃圾回收根节点</strong>，只要<strong>被表中直接或间接引用的对象</strong>都不会被回收。</p>
<p>2）操作数栈：在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，例如执行<strong>复制、交换、求和</strong>等操作。主要用于<strong>保存计算过程中的中间结果</strong>，同时作为计算过程中的<strong>变量临时存储空间</strong>。</p>
<p>注意：操作数栈<strong>并非通过访问索引来进行数据访问</strong>的，它只是入栈出栈的一个实现工具。</p>
<p>3）动态链接：<strong>指向运行时常量池</strong>中的该栈帧所属<strong>方法的引用</strong>。在类加载之前，符号引用都在class文件的常量池中，类加载后，这些符号引用就被<strong>类加载阶段的“解析”过程</strong>转换为调用方法的直接引用。动态链接就是<strong>来实现这个“解析”过程的</strong>。</p>
<h1 id="☆局部变量和静态变量的对比"><a href="#☆局部变量和静态变量的对比" class="headerlink" title="☆局部变量和静态变量的对比"></a>☆局部变量和静态变量的对比</h1><p>我们知道静态变量就是类变量，是在累加载阶段就有初始化操作的，其一是<strong>“准备”阶段的初始化零值</strong>，另一阶段是<strong>”初始化“阶段为类变量赋初始值</strong>。</p>
<p>对于局部变量，<strong>因为要放在局部变量表中，表没有初始化过程</strong>，所以我们必须在写代码的时候，人为初始化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E4%B8%AA%E4%BA%BA%E5%AF%B9JVM%E7%9A%84%E7%90%86%E8%A7%A3/" data-id="cl31jc9hq00000cv6gfxp6myd" data-title="个人对JVM的理解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-双指针题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T09:01:55.000Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E8%A7%A3/">双指针题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcode-27-移除元素"><a href="#leetcode-27-移除元素" class="headerlink" title="leetcode 27.移除元素"></a>leetcode 27.移除元素</h1><p>**<u>题目</u>**：<u>给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。</u></p>
<p><u>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题因为要原地修改数组，所以必须要<strong>让元素之间换位</strong>来实现更改数组的操作。</p>
<p>所以我们采用双指针解法，既降低了空间复杂度，又实现了原位置换的好处。</p>
<p>具体操作就是让一个fast指针不停向后移动，而slow指针则必须“听从”fast指针安排，当fast没碰到val的时候，fast指针把当前位置的元素赋值给slow位置的元素，因为这些等于val的元素我们就不要了，所以不需要换位，只需要替代即可。</p>
<p>如果fast碰到val了，就让它继续向后走，这时一定不要对数组进行换位操作，因为只有碰到上面的情况，才实现换位，fast碰到的val让slow碰到了再解决。</p>
<p>可能会有以下问题：fast这样赋值，会不会打乱数组原有顺序？肯定不会。因为slow和fast是共起点的，只有当fast碰到val的那一刻，二者分开，而<strong>fast的作用就是要把不等于val的元素赋给slow</strong>，所以fast一定会依次将这些值赋给slow的，也就不会出现乱序的现象。</p>
<h1 id="leetcode-26-删除有序数组中的重复项"><a href="#leetcode-26-删除有序数组中的重复项" class="headerlink" title="leetcode 26.删除有序数组中的重复项"></a>leetcode 26.删除有序数组中的重复项</h1><p><u><strong>题目</strong>：给你一个<strong>升序排列</strong>的数组 <code>nums</code> ，请你原地删除重复出现的元素，使每个元素<strong>只出现一次</strong>，返回删除后数组的新长度。元素的<strong>相对顺序</strong>应该保持<strong>一致</strong>。不要使用额外的空间，你必须在并在使用 O(1) 额外空间的条件下完成</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>, fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[fast - <span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种解法我们可以发现：**比较的是nums[fast]和nums[fast - 1]**，也就是fast指针指向的元素和其指过的元素，直接想难度比较大，我们举例：[0,0,1,1,1,2,2,3,3,4]</p>
<p>因为我们要让fast和前面一位比，自然初始位置要从1开始，slow为1，这样可以让两者同步向后走。那么问题来了，slow为0行不行？</p>
<p>我们来看一下，如果slow为0，那么fast第一次比较的时候，发现0 &#x3D;&#x3D; 0会跳过当前位置，走到1的时候，发现1 !&#x3D; 0，这个时候，才把1赋给slow位置的0，<strong>那么slow一开始就丢掉了一个0，整个数组都会丢掉0</strong>。比如[1,1,2]答案是[2]，自己可以试一下。</p>
<p>所以slow和fast初始位置均为1，这样可以避免初始值被吞没的现象。</p>
<p>我们知道，<strong>比较重复值还可以让fast和其后面一个值比较</strong>，官方题解没有给出这种解法，但是确实是可以的，分析如下：</p>
<p>我们来比较nums[fast]和nums[fast + 1]，自然就要让fast从最初的的位置开始走起，所以初始值fast &#x3D; 0。那么slow也从0开始走吗？</p>
<p>我们假设slow也从0开始走，还是以简单的[1,1,2]为例，fast发现1和1相等，跳过，走到第二个1，发现1和2不等，肯定要把2给slow，给前面fast的就给乱了，所以要**把nums[fast + 1]赋给nums[slow]**。这个时候，我们发现slow在一开始就被赋予2，1压根不存在了。所以slow不能从最开始走，而要保留第一个值，从第二位走，也就是初始化slow &#x3D; 1。这只是我自己想到的一种向后比较的解法，纯粹是多思考一下，解法还是按照前面的思路比较简单。向后比较的题解代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[fast + <span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow] = nums[fast + <span class="number">1</span>];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-283-移动零"><a href="#leetcode-283-移动零" class="headerlink" title="leetcode 283.移动零"></a>leetcode 283.移动零</h1><p><u><strong>题目：</strong>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</u></p>
<p><u><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[slow];</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                nums[fast] = temp;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题要<strong>注意是移动0到末尾，而不是删除0</strong>，所以不能仅仅在nums[fast] !&#x3D; 0的时候进行覆盖操作，而要进行替换操作，<strong>将fast指向的非0数字赋给slow，把0转移给fast</strong>。</p>
<h1 id="leetcode-844-比较含退格的字符串"><a href="#leetcode-844-比较含退格的字符串" class="headerlink" title="leetcode 844.比较含退格的字符串"></a>leetcode 844.比较含退格的字符串</h1><p><u><strong>题目：</strong>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</u></p>
<p><u>注意：如果对空文本输入退格字符，文本继续为空。示例如下：</u></p>
<p><u>输入：s &#x3D; “ab#c”, t &#x3D; “ad#c”</u><br><u>输出：true</u><br><u>解释：s 和 t 都会变成 “ac”。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, j = t.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">skipA</span> <span class="operator">=</span> <span class="number">0</span>, skipB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    skipA++;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipA &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipA--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(j) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    skipB++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipB &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipB--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != t.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题虽然为简单题，但是想一次做对有些困难。</p>
<p>因为”#”是删除前一个字符，所以我们从后向前遍历比较好。整体的思路就是，先遍历s，如果碰到#，就计数，直到当前遍历无#，就跳出循环，然后同样的方式遍历t。</p>
<p>两个字符串的遍历走完之后，如果当前i或者j没有走完，就判断当前i和j位置对应的字符是否相等，如果不相等，那么肯定就返回false，为什么呢？因为我们<strong>同时从后向前遍历，一旦进行比较，就说明此时i和j后面的元素已经确定好了</strong>，没有一一对应的话，就没必要向前遍历了。如果有一个字符串走完了呢？一样的道理，还是没有一一对应上，因为<strong>此时连长度都对不上了</strong>，俩字符串更不可能相同了。</p>
<p>如果上述两个判断都没有问题，那么我就让两个指针都向前移动一位，继续判断。</p>
<p>什么时候跳出循环呢？一定要让两个指针都走完才可以，如果只有一个指针走完，我们就return true了。那么<u>absfds##asd##和a</u>就会误判了。</p>
<h1 id="leetcode-977-有序数组的平方"><a href="#leetcode-977-有序数组的平方" class="headerlink" title="leetcode 977.有序数组的平方"></a>leetcode 977.有序数组的平方</h1><p><u><strong>题目：</strong></u><u>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。举例如下：</u></p>
<p><u>输入：nums &#x3D; [-4,-1,0,3,10]</u><br><u>输出：[0,1,9,16,100]</u><br><u>解释：平方后，数组变为 [16,1,0,9,100]</u><br><u>排序后，数组变为 [0,1,9,16,100]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>, index = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] * nums[i] &lt; nums[j] * nums[j])&#123;</span><br><span class="line">                ans[index--] = nums[j] * nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[index--] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="img"></p>
<p>题解来自Carl大佬，这个图足够说明解题思路了。要注意的就是while的循环条件。</p>
<h1 id="leetcode-209-长度最小的子数组"><a href="#leetcode-209-长度最小的子数组" class="headerlink" title="leetcode 209.长度最小的子数组"></a>leetcode 209.长度最小的子数组</h1><p><u><strong>题目</strong>：给定一个含有 n 个正整数的数组和一个正整数 target 。</u></p>
<p><u>找出该数组中满足其和 ≥ target 的长度最小的<strong>连续子数组</strong> [numsl, numsl+1, …, numsr-1, numsr]，并返回其长度。如果不存在符合条件的子数组，返回0。</u></p>
<p><u><strong>示例 1：</strong></u></p>
<p><u>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</u><br><u>输出：2</u><br><u>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>, res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right &lt; nums.length;right++)&#123;</span><br><span class="line">            sum += nums[right];<span class="comment">//每次移动right指针都要将其所指元素添加进sum中</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;<span class="comment">//一旦总和大于目标值，就开始记录当前最短数组，并右移left指针</span></span><br><span class="line">                res = Math.min(res, right - left + <span class="number">1</span>)</span><br><span class="line">                sum -= nums[left++];<span class="comment">//记得删除left指针指向的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">res</span> <span class="operator">=</span>= Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题一定要看清楚题意，是<strong>连续子数组！</strong></p>
<p>这样我们才可以<strong>利用双指针来模拟滑动窗口</strong>，左指针就是滑动窗口的左边界，右指针对应着右边界。</p>
<p>每当我们移动一次right指针，我们就把right所指的元素添加进sum中，一旦sum &gt;&#x3D; target，我们就要<strong>开始记录当前数组长度和之前记录的res的最小值</strong>。记录之后，为了继续移动right指针，我们<strong>必须删除左指针指向的元素</strong>，同时<strong>一定不要忘了右移左指针</strong>。这样一个滑动窗口就形成了。</p>
<p>最后要<strong>记住判断res是否存在</strong>，不存在的话就是初始值Integer.MAX_VALUE。</p>
<h1 id="leetcode-904-水果成篮"><a href="#leetcode-904-水果成篮" class="headerlink" title="leetcode 904.水果成篮"></a>leetcode 904.水果成篮</h1><p><u><strong>题目</strong>：你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</u></p>
<p><u>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</u></p>
<p><u>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。</u><br><u>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</u><br><u>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</u><br><u>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</u></p>
<p><u>举例如下：</u></p>
<p><u>输入：fruits &#x3D; [0,1,2,2]</u><br><u>输出：3</u><br><u>解释：可以采摘 [1,2,2] 这三棵树。</u><br><u>如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; fruits.length;j++)&#123;</span><br><span class="line">            count.add(fruits[j], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(count.size() &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">                count.add(fruits[i], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(count.get(fruits[i]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    count.remove(fruits[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(k) ? <span class="built_in">super</span>.get(k) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">        put(k, get(k) + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题理解题意是难度比较大的，总的来说就是在一个<strong>含有重复元素的数组</strong>中，找到<strong>含有两种不同元素的最长连续子数组</strong>。这道题和前面的题的区别，就像背包问题，一个求背包重量，一个求方案数一样。这道题就是后者的情况，因为<strong>重复元素只算一种元素</strong>，所以我们必须要用HashMap来记录这个元素在数组中出现了多少次。而<strong>连续子数组的长度则由HashMap的size()来控制</strong>。</p>
<p>我们依旧是利用双指针模拟滑动窗口，让右指针j不停向右移动，移动一次就记录当前j指向的元素及其出现的次数，一旦我们的HashMap的size() &gt;&#x3D; 3了，说明当前HashMap存了3组不同种元素，要删一个，这时候，我们开始从左删，因为HashMap中记录的是重复元素的个数，<strong>所以先删key值fruits[i]对应的value，删一个就一次左指针i</strong>。直到这个value &#x3D;&#x3D; 0了，说明这个重复元素删干净了，就可以把当前fruits[i]删掉了。</p>
<p><strong>不管是删fruits[i]还是删其value值，都要进行i++，所以这个i++的位置一定要放对</strong>。</p>
<p>上述的操作因为与HashMap的原始方法有一些出入，所以我们可以看到官方题解又<strong>另写了一个继承HashMap的类来重写HashMap的方法</strong>，方便我们主方法进行重复元素的增删改查。</p>
<p>最后需要注意的是，每次向右移动一次指针j，不仅要记录当前的fruits[j]和其出现次数，还要累计当前的长度ans,别忘了，我们需要返回的最终结果，就是这个每次累计的ans值。如果当前HashMap的size() &gt;&#x3D; 3，那就先进入while循环，直到size() &lt; 3了，我们再更新ans的值。<strong>所以ans和while循环的顺序一定要写对</strong>。</p>
<p>总的来说，<strong>容易出现问题的地方</strong>，首先是：</p>
<p>​		①左指针i向右移动的时机</p>
<p>​		②更新ans的时机。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E8%A7%A3/" data-id="cl31ednen0000bgv69yxwh7fl" data-title="双指针题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-二分法题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/11/%E4%BA%8C%E5%88%86%E6%B3%95%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-11T06:01:09.000Z" itemprop="datePublished">2022-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/11/%E4%BA%8C%E5%88%86%E6%B3%95%E9%A2%98%E8%A7%A3/">二分法题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="leetcode-704-二分查找"><a href="#leetcode-704-二分查找" class="headerlink" title="leetcode 704.二分查找"></a>leetcode 704.二分查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种二分查找的题，我们首先要看数组是不是<strong>有序的</strong>，因为我们要逐步缩小查找区间，如果数组不是有序的，那么就无法用二分法。</p>
<p>其次数组<strong>不能有重复元素</strong>，如果有重复元素我们只能找到符合条件的某一个元素，必须用一些其他手段才能找到所有符合条件的元素。</p>
<p>好了，本题自然是很简单的数组，满足有序且不重复的条件。</p>
<p>难点就是：边界条件比较难确定，即中点值大于target的时候，左边界和右边界如何收缩。</p>
<p>根据Carl大佬给的思路，我们将l和r的范围区间确定为左闭右闭的闭区间[l,r]，这样我们在while循环的时候，循环条件自然是l &lt;&#x3D; r了，<strong>因为l &#x3D;&#x3D; r也是符合闭区间的范围的</strong>。</p>
<p>进入循环后，如果nums[mid] &lt; target，说明当前mid位置的元素不符合条件，而且在target的左边，我们自然要将左边界l收缩，l &#x3D; mid还是l &#x3D; mid + 1呢？我们<strong>一定要看区间</strong>，我们确定的是闭区间，所以[mid, r]这个mid不是我们想要的范围为，[mid + 1, r]才是。</p>
<p>同理，nums[mid] &gt; target时，我们要收缩右边界r，所以[l, mid - 1]才是我们想要的范围。</p>
<p>其实，还可以将区间定义为左闭右开的区间[l, r)，这样循环体则时l &lt; r，if判断的边界条件也有区别。具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-35-搜索插入位置"><a href="#leetcode-35-搜索插入位置" class="headerlink" title="leetcode 35.搜索插入位置"></a>leetcode 35.搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。数组中无重复元素，请必须使用时间复杂度为 <code>O(log n)</code> 的算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题具体思路和上一题一样，但是难点是插入位置，也就是数组中可能不存在目标值，我们要将这个值插入到哪里是有讲究的。</p>
<p>通过二分法闭区间的思路，我们可以看出：<strong>只有跳出while循环之后return的值才是最终插入的位置</strong>，也就是没查找到目标值的情况。这个时候自然满足l &gt; r，也就是<strong>l &#x3D; r + 1</strong>。</p>
<p>既然确定了插入位置是return语句的返回值，我们就得考虑什么时候跳出循环的：走完最后一个if或者else if语句。</p>
<p>如果最后走的if语句，那么当前的l &#x3D; mid + 1，nums[mid]比target要小，我们肯定要把target插入到mid之后，也就是mid + 1，那么自然我们返回l即可。</p>
<p>如果最后走的是else if语句呢？当前r &#x3D; mid - 1，当前nums[mid]比target大，我们肯定要把target插入到mid的位置，进而把当前的mid位置的元素向后挤一位，为什么不插到mid - 1，因为mid - 1位置的元素肯定比target小，<strong>假设nums[mid - 1] &#x3D;&#x3D; 3, target &#x3D;&#x3D; 4, nums[mid] &#x3D;&#x3D; 5</strong>，就成了[4,3,5]了。所以必须要插在5的位置，形成[3, 4, 5]。因为r &#x3D; mid - 1，所以最后返回r + 1。因为跳出循环后，肯定满足前面说的l &#x3D; r + 1这个等式，所以上述分析的两种情况，即返回l或r + 1是一样的。</p>
<h2 id="leetcode-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#leetcode-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="leetcode 34.在排序数组中查找元素的第一个和最后一个位置"></a>leetcode 34.在排序数组中查找元素的第一个和最后一个位置</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBoard</span> <span class="operator">=</span> findLeftBoard(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBoard</span> <span class="operator">=</span> findRightBoard(nums, target);</span><br><span class="line">        <span class="keyword">if</span>(leftBoard == -<span class="number">2</span> || rightBoard == - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(rightBoard - leftBoard &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftBoard + <span class="number">1</span>, rightBoard - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLeftBoard</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBoard</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                leftBoard = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBoard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRightBoard</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBoard</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                rightBoard = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightBoard;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题明显有重复元素，用二分法难度陡增。</p>
<p>代码很长，所以思路一定要清晰。</p>
<p>可以看到代码分别找了左边界和右边界，两个寻找边界的方法都是采用的二分法，我们**<u>以findLeftBoard()为例</u>**。</p>
<p>我们首先定义了leftBoard的初始值，为什么是-2，这个得留到最后解释。</p>
<p>可以看到代码的if分了两部分，一部分是nums[mid] &lt; target这一部分，如果满足这个条件，那么我们让左边界</p>
<p>右移，这个没什么疑问。</p>
<p>但是else if这部分，为什么既包括了nums[mid] &gt; target的部分，又包括了nums[mid] &#x3D;&#x3D; target部分。</p>
<p>我们需要举个例子，比如当前数组是[1,2,3,3,3,3,3,3,3,3,3,3,3,3,4,5,5,6,6,7]，target是3，一上来二分法就能定位到3，但是我们要确定左边界，所以必须要通过循环体不断让mid逼近左边界，我们可以看到当确定闭区间[l, r]的时候，right是不断由mid - 1确定的，也就是<strong>真正不断向左移动的是right</strong>，所以我们的左边界一定要<strong>利用好区间[l, r]的右边界不断向左移动的这一个特点</strong>。</p>
<p>这样一来，我们就可以理解为什么每次right &#x3D; mid - 1的时候，还要更新leftBoard。right什么时候停止左移呢，答案是找到最后一个满足target &#x3D;&#x3D; 3的位置，跳出循环，返回leftBoard，这个左边界值我们可以用上一题的插入位置来考虑，因为<strong>最后的leftBoard &#x3D;&#x3D; right，而right &#x3D; mid - 1，mid这个位置是最后一个满足target的点，所以mid - 1自然是左边界的前一个值了</strong>。那么它就自然有等于-1的风险，所以我们初始化leftBoard为-2。</p>
<p>对于寻找右边界，我们的思路是一样的，只不过rightBoard最后没有等于-1的风险，所以我们可以为其初始化为-1或-2都可。</p>
<h2 id="leetcode-69-x的平方根"><a href="#leetcode-69-x的平方根" class="headerlink" title="leetcode 69.x的平方根"></a>leetcode 69.x的平方根</h2><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根。</p>
<p>由于返回类型是整数，结果只保留 整数部分，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = x, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &lt;= x)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案很简单，但是要注意用long型变量，因为mid + 1之后，其自身的平方很可能比Integer的最大范围还大，容易溢出报错，所以要用long型。</p>
<h2 id="leetcode-367-有效的完全平方数"><a href="#leetcode-367-有效的完全平方数" class="headerlink" title="leetcode 367.有效的完全平方数"></a>leetcode 367.有效的完全平方数</h2><p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = num;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &gt; num)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &lt; num)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与上一题需要注意的地方一样。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/11/%E4%BA%8C%E5%88%86%E6%B3%95%E9%A2%98%E8%A7%A3/" data-id="cl319inhr0000jgv6anb7cgxu" data-title="二分法题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/">二叉树题解</a>
          </li>
        
          <li>
            <a href="/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/">Java基础知识点</a>
          </li>
        
          <li>
            <a href="/2022/05/14/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E9%A2%98%E8%A7%A3/">栈与队列题解</a>
          </li>
        
          <li>
            <a href="/2022/05/13/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/">我的项目</a>
          </li>
        
          <li>
            <a href="/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/">计算机网络笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>