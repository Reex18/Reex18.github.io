<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Reex</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Reex">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Reex">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Reex" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Reex</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2022-07-25T03:38:56.000Z" itemprop="datePublished">2022-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">SINGLETON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意不要写final,volatile是为了防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类（饿汉式）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerClass.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">innerClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">SINGLETON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品实现类——BYD</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BYD</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;比亚迪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品实现类——Tesla</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tesla</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;特斯拉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">getCar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;比亚迪&quot;</span>.equals(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BYD</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;特斯拉&quot;</span>.equals(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tesla</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        //获得对象的传统方法</span></span><br><span class="line"><span class="comment">//        Car car1 = new BYD();</span></span><br><span class="line"><span class="comment">//        Car car2 = new Tesla();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        car1.name();</span></span><br><span class="line"><span class="comment">//        car2.name();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//简单工厂</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> CarFactory.getCar(<span class="string">&quot;比亚迪&quot;</span>);</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car2</span> <span class="operator">=</span> CarFactory.getCar(<span class="string">&quot;特斯拉&quot;</span>);</span><br><span class="line"></span><br><span class="line">        car1.name();</span><br><span class="line">        car2.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品实现类——BYD</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BYD</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;比亚迪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品实现类——Tesla</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tesla</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;特斯拉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------以下代表与简单工厂不一样的地方----------------------------</span></span><br><span class="line"><span class="comment">//产品工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    Car <span class="title function_">getCar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品工厂实现类——BYDFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BYDFactory</span> <span class="keyword">implements</span> <span class="title class_">CarFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BYD</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品工厂实现类——TeslaFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeslaFactory</span> <span class="keyword">implements</span> <span class="title class_">CarFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tesla</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者——Consumer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BYDFactory</span>().getCar();</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeslaFactory</span>().getCar();</span><br><span class="line"></span><br><span class="line">        car1.name();</span><br><span class="line">        car2.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>

<p>简单工厂与工厂方法的区别：</p>
<p>前者是一个工厂生产多个产品，我们需要获得哪个产品，就去<strong>统一的工厂</strong>求购即可；优势是代码量简洁，但不易横向扩展产品数量（需要改动<strong>工厂内部代码逻辑</strong>）</p>
<p>后者是多个工厂生产各自产品，我们需要获得哪个产品，就去<strong>相应的工厂</strong>求购即可。优势是利于横向扩展产品数量，但<strong>代码量繁杂</strong>。</p>
<p>根据设计原则，我们开发出了工厂方法模式，但是一般根据实际业务，还是简单工厂更贴合应用。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><ul>
<li>先构造抽象的<strong>产品的接口</strong></li>
<li>再实现接口的<strong>具体实现类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//———————————————————————————产品：手机接口及实现类—————————————————————————————————————</span></span><br><span class="line"><span class="comment">//产品接口——PhoneProduct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PhoneProduct</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品实现类——XiaomiPhone</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaomiPhone</span> <span class="keyword">implements</span> <span class="title class_">PhoneProduct</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品实现类——HuaweiPhone</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiPhone</span> <span class="keyword">implements</span> <span class="title class_">PhoneProduct</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为手机打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为手机发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//———————————————————————————产品：路由器接口及实现类—————————————————————————————————————</span></span><br><span class="line"><span class="comment">//产品接口——RouterProduct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RouterProduct</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shut</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品实现类——XiaomiRouter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaomiRouter</span> <span class="keyword">implements</span> <span class="title class_">RouterProduct</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米路由器连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米路由器关机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品实现类——HuaweiRouter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiRouter</span> <span class="keyword">implements</span> <span class="title class_">RouterProduct</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为路由器连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为路由器关机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>先构造抽象的工厂接口，工厂内部的方法<strong>只与前面的抽象的产品接口相关</strong>，所以该工厂是抽象的抽象（工厂和产品均不能确定，所以是抽象产品的抽象工厂）</li>
<li>再实现工厂的实现类，工厂生产产品的每个方法，对外暴露的<strong>返回形式是抽象的产品接口</strong>，而<strong>内部返回的是具体的产品</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//———————————————————工厂：生产抽象产品的抽象工厂接口+抽象工厂的实现类———————————————————</span></span><br><span class="line"><span class="comment">//生产产品的工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">    <span class="comment">//生产手机</span></span><br><span class="line">    PhoneProduct <span class="title function_">phoneProduct</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//生产路由器</span></span><br><span class="line">    RouterProduct <span class="title function_">routerProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂的实现类——XiaomiFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaomiFactory</span> <span class="keyword">implements</span> <span class="title class_">ProductFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PhoneProduct <span class="title function_">phoneProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaomiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RouterProduct <span class="title function_">routerProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaomiRouter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂的实现类——HuaweiFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiFactory</span> <span class="keyword">implements</span> <span class="title class_">ProductFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PhoneProduct <span class="title function_">phoneProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RouterProduct <span class="title function_">routerProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiRouter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">XiaomiFactory</span> <span class="variable">xiaomiFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XiaomiFactory</span>();</span><br><span class="line">        <span class="type">HuaweiFactory</span> <span class="variable">huaweiFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuaweiFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">PhoneProduct</span> <span class="variable">phoneProduct</span> <span class="operator">=</span> xiaomiFactory.phoneProduct();</span><br><span class="line">        <span class="type">RouterProduct</span> <span class="variable">routerProduct</span> <span class="operator">=</span> xiaomiFactory.routerProduct();</span><br><span class="line"></span><br><span class="line">        phoneProduct.call();<span class="comment">//小米手机打电话</span></span><br><span class="line">        phoneProduct.send();<span class="comment">//小米手机发短信</span></span><br><span class="line">        routerProduct.connect();<span class="comment">//小米路由器连接</span></span><br><span class="line">        routerProduct.shut();<span class="comment">//小米路由器关机</span></span><br><span class="line"></span><br><span class="line">        phoneProduct = huaweiFactory.phoneProduct();</span><br><span class="line">        routerProduct = huaweiFactory.routerProduct();</span><br><span class="line"></span><br><span class="line">        phoneProduct.send();<span class="comment">//华为手机打电话</span></span><br><span class="line">        phoneProduct.send();<span class="comment">//华为手机发短信</span></span><br><span class="line">        routerProduct.connect();<span class="comment">//华为路由器连接</span></span><br><span class="line">        routerProduct.shut();<span class="comment">//华为路由器关机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>架构如图所示：</p>
<p><img src="D:\ProcessOn\设计模式\抽象工厂.png" alt="抽象工厂"></p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>代理模式就像生活中屋主出租房子，但是出租需要繁杂的手续和宣传手段，这大大增加了出租房屋的难度，所以有了中间商，这样一来，所有的繁琐事项都交由中介（代理）来完成，大大简化了屋主出租房屋的难度。如果有客户打算租房，也不必直接找到屋主，而是直接找到中介完成租房。</p>
<p>在这个故事中，中介就是我们要介绍的代理，具体代码如下所示：</p>
<p>既然要代理，首先要确定代理人和被代理对象都有同样的任务，即出租房屋，所以我们先定义：</p>
<ul>
<li>出租房屋的接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出租房屋</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Rent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>被代理人实现Rent接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//屋主实现rent()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Host</span> <span class="keyword">implements</span> <span class="title class_">Rent</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东出租房屋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代理人实现Rent接口。</li>
</ul>
<p>(注意：繁杂的手续都由代理人来处理，但<strong>租房仍是被代理人执行</strong>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Rent</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">(Host host)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span> &#123;</span><br><span class="line">        fee();</span><br><span class="line">        see();</span><br><span class="line">        host.rent();</span><br><span class="line">        sign();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中介带客户看房</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">see</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中介带客户看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//签合同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中介与客户签合同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收中介费</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fee</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中介收取中介费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Host</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(host);</span><br><span class="line"></span><br><span class="line">        proxy.rent();</span><br><span class="line">        <span class="comment">//中介收取中介费</span></span><br><span class="line">		<span class="comment">//中介带客户看房</span></span><br><span class="line">		<span class="comment">//房东出租房屋</span></span><br><span class="line">		<span class="comment">//中介与客户签合同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态代理的好处：</p>
<p>1、<strong>被代理对象</strong>不需要处理公共的繁杂业务，使得其操作流程更加纯粹</p>
<p>2、公共业务均交给<strong>代理类</strong>，实现的明确的业务分工</p>
<p>3、公共业务一旦有<u>扩展</u>，可直接在<strong>代理类</strong>中扩展，不改变<strong>被代理类</strong>逻辑。</p>
<p><u>缺点</u>：</p>
<p>每个被代理类<strong>需要专门的代理类</strong>，若被代理类数量庞多，会导致代理类创建过多，开发效率反而降低。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理的出现，就是为了解决被代理的需求太多导致<strong>代理类创建过多</strong>的弊病。</p>
<p>首先还是有Rent接口和被代理类Host：</p>
<ul>
<li>出租房屋的接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Rent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>被代理人实现Rent接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//屋主实现rent()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Host</span> <span class="keyword">implements</span> <span class="title class_">Rent</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东出租房屋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点来了！因为这次我们不再根据具体的Host来单独地创建代理类了，因为如果另一个Host出租自行车，又一个出租衣服就没完没了了。我们尝试只获得一个Host来动态获取其接口，然后通过反射的方式调用其内部方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理的接口(这里抽象为任意接口)</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTarget</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成并得到代理类对象(中介)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理代理实例(中介)并返回结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        fee();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fee</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理人收中介费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Host</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ProxyInvocationHandler</span> <span class="variable">pih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyInvocationHandler</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置需要被代理的对象</span></span><br><span class="line">        pih.setTarget(host);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getProxy()第二个参数获取target的接口，也就是host的接口</span></span><br><span class="line">        <span class="comment">//生成代理类对象</span></span><br><span class="line">        <span class="type">Rent</span> <span class="variable">proxy</span> <span class="operator">=</span> (Rent) pih.getProxy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理类对象通过反射，执行rent()</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">        <span class="comment">//代理人收中介费</span></span><br><span class="line">		<span class="comment">//房东出租房屋</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="cl6079ni500001gv69w7qfch3" data-title="设计模式" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-动态规划基础及背包题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80%E5%8F%8A%E8%83%8C%E5%8C%85%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-07-06T07:43:12.000Z" itemprop="datePublished">2022-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80%E5%8F%8A%E8%83%8C%E5%8C%85%E9%A2%98%E8%A7%A3/">动态规划基础及背包题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="leetcode-509-斐波那契数"><a href="#leetcode-509-斐波那契数" class="headerlink" title="leetcode 509.斐波那契数"></a>leetcode 509.斐波那契数</h2><p><u><strong>题目</strong>：斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</u></p>
<p><u>F(0) &#x3D; 0，F(1) &#x3D; 1</u><br><u>F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</u><br><u>给定 n ，请计算 F(n) 。</u></p>
<ul>
<li><code>0 &lt;= n &lt;= 30</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//n的取值从0开始，一定要注意</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-70-爬楼梯"><a href="#leetcode-70-爬楼梯" class="headerlink" title="leetcode 70.爬楼梯"></a>leetcode 70.爬楼梯</h2><p><u><strong>题目</strong>：假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</u></p>
<p><u>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</u></p>
<ul>
<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空间复杂度为n的动态规划方法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空间复杂度为1的滚动法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-746-使用最小花费爬楼梯"><a href="#leetcode-746-使用最小花费爬楼梯" class="headerlink" title="leetcode 746.使用最小花费爬楼梯"></a>leetcode 746.使用最小花费爬楼梯</h2><p><u><strong>题目</strong>：给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</u></p>
<p><u>你可以选择<strong>从下标为 0 或下标为 1</strong> 的台阶开始爬楼梯。</u></p>
<p><u>请你计算并返回达到楼梯顶部的最低花费。</u></p>
<ul>
<li><code>2 &lt;= cost.length &lt;= 1000</code></li>
<li><code>0 &lt;= cost[i] &lt;= 999</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cost.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= cost.length;i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意最后要走到数组最后一位的后边才可以</span></span><br><span class="line">        <span class="keyword">return</span> dp[cost.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-62-不同路径"><a href="#leetcode-62-不同路径" class="headerlink" title="leetcode 62 不同路径"></a>leetcode 62 不同路径</h2><p><u><strong>题目</strong>：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</u></p>
<p><u>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</u></p>
<p><u>问总共有多少条不同的路径？</u></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li>题目数据保证答案小于等于 <code>2 * 109</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="comment">//只沿着一条边走，只有1条路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n;j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//每个格都是上边或左边走过来，所以要把这两个位置的dp加起来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n;j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空间复杂度优化至o(n)：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n;j++) dp[j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n;j++) &#123;</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-63-不同路径-II"><a href="#leetcode-63-不同路径-II" class="headerlink" title="leetcode 63.不同路径 II"></a>leetcode 63.不同路径 II</h2><p><u><strong>题目</strong>：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</u></p>
<p><u>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</u></p>
<p><u>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</u></p>
<p><u>网格中的障碍物和空位置分别用 1 和 0 来表示。</u></p>
<ul>
<li><p>m &#x3D;&#x3D; obstacleGrid.length</p>
</li>
<li><p>n &#x3D;&#x3D; obstacleGrid[i].length</p>
</li>
<li><p>1 &lt;&#x3D; m, n &lt;&#x3D; 100</p>
</li>
<li><p>obstacleGrid[i][j] 为 0 或 1</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="comment">//只有整个边界的一行或一列都没有障碍物才为1，否则障碍物前都是1，障碍物后面都是0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>;i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>;j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//只有没有障碍物的位置可以累加前面的dp，有障碍物的位置dp[i][j] = 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空间复杂度优化至o(n)：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">//易错：初始化只有第一个值</span></span><br><span class="line">        dp[<span class="number">0</span>] = obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//易错：i和j都要从0开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">                <span class="comment">//注意这里需要控制j - 1的边界问题，j如果是0,说明取1或0，不需要走累加计算</span></span><br><span class="line">                <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这里要注意不能用else，要用if</span></span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="☆leetcode-343-整数拆分"><a href="#☆leetcode-343-整数拆分" class="headerlink" title="☆leetcode 343.整数拆分"></a>☆leetcode 343.整数拆分</h2><p><u><strong>题目</strong>：给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</u></p>
<p><u>返回 <em>你可以获得的最大乘积</em> 。</u></p>
<p><u>输入: n &#x3D; 10</u><br><u>输出: 36</u><br><u>解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。</u></p>
<ul>
<li><code>2 &lt;= n &lt;= 58</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动规解法（时间复杂度n2）:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//0和1是无法拆分的，所以dp[0]和dp[1]都是没有意义的</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= i - j;j++) &#123;</span><br><span class="line">            	<span class="comment">//j * (i - j)就是把i拆分的一种情况，而j * dp[i - j]是把j拆分成多种的情况</span></span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贪心解法（时间复杂度n）:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">4</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//只要能拆成3就拆3，最后剩下4或者比4小的，就不拆了，把这个n乘上即可</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            res *= <span class="number">3</span>;</span><br><span class="line">            n -= <span class="number">3</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        res *= n;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="☆leetcode-96-不同的二叉搜索树"><a href="#☆leetcode-96-不同的二叉搜索树" class="headerlink" title="☆leetcode 96.不同的二叉搜索树"></a>☆leetcode 96.不同的二叉搜索树</h2><p><u><strong>题目</strong>：给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</u></p>
<img src="https://img-blog.csdnimg.cn/20210113161941835.png" alt="img" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= i;j++)&#123;<span class="comment">//j就是当前遍历的根结点元素值</span></span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];<span class="comment">//以j为根节点的左子树数量dp[j - 1]与右子树数量dp[i - j]的乘积</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题虽然是中等题，代码量也很少，但除非背模板，否则很难写对。本题结合了二叉搜索树和动态规划的知识。</p>
<p>我们最需要理解的就是递推公式，为什么是这个样子的？首先确定dp[i]数组的含义：<strong>i个元素组成的二叉搜索树的数量</strong>。</p>
<p>我们假设当前元素为4，那么其根节点就可以为1，2，3，4。当根节点为1时，左子树没有比它小的，所以其只有右子树，我们会发现右子树的个数就是元素为3时二叉搜索树的个数dp[3]，所以根节点为1时，二叉搜索树的数量为dp[0] * dp[3]。以此类推，根节点为2时，dp[1] * dp[2]，根节点为3，dp[2] * dp[1]，根节点为4，dp[3] * dp[0]，最后的dp[4]就是把这四组乘积相加。</p>
<p>我们不难发现一个规律，不管元素个数是多少，我们都需要让i逐一递增，从1一直增加到i为止，每次增加的过程中，都要来计算<strong>当前值作为根节点</strong>的二叉搜索树的个数，一直加到i为止，把前面的结果加在一起才是当前i个元素的二叉树个数。</p>
<p>就比如前面的dp[4]我们需要dp[3]，dp[3]又需要dp[2]，dp[2]又需要dp[1]，dp[1]需要dp[0]。妥妥的动态规划问题，而dp[0]和dp[1]我们可以很容易的<strong>初始化为1</strong>，所以我们可以让元素个数i从2开始递增，<strong>每次递增都计算当前元素个数下二叉搜索树的数量</strong>，以便下一个i + 1利用。</p>
<p>至于为什么dp[i] +&#x3D; dp[j - 1] * dp[i - j]，j是当前元素作为根节点，dp[j - 1]就是j - 1个元素左子树的二叉搜索树数量，因为<strong>左子树肯定元素值比j要小</strong>，所以是j - 1，而右子树肯定比j元素要大，而<strong>总元素个数又限定在i个以内</strong>，所以右子树元素个数为i - j。</p>
<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><h2 id="leetcode-416-分割等和子集"><a href="#leetcode-416-分割等和子集" class="headerlink" title="leetcode 416.分割等和子集"></a>leetcode 416.分割等和子集</h2><p><u><strong>题目</strong>：给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</u></p>
<p><u>示例 1：</u></p>
<p><u>输入：nums &#x3D; [1,5,11,5]</u><br><u>输出：true</u><br><u>解释：数组可以分割成 [1, 5, 5] 和 [11] 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//依次遍历每个nums数组元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="comment">//每次从后向前遍历，如果当前背包j比物品重量nums[i]小，那就结束本层循环</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target;j &gt;= nums[i];j--) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题就是以数组元素总和的一半，即target作为背包最大容量，每次遍历一个物品nums[i]，当每层循环的背包j小于物品重量nums[i]的时候，就进行下一层循环。</p>
<img src="https://img-blog.csdnimg.cn/20210110104240545.png" alt="416.分割等和子集2" style="zoom: 60%;" />

<h2 id="leetcode-698-划分为k个相等的子集"><a href="#leetcode-698-划分为k个相等的子集" class="headerlink" title="leetcode 698.划分为k个相等的子集"></a>leetcode 698.划分为k个相等的子集</h2><h2 id="leetcode-1049-最后一块石头的重量-II"><a href="#leetcode-1049-最后一块石头的重量-II" class="headerlink" title="leetcode 1049.最后一块石头的重量 II"></a>leetcode 1049.最后一块石头的重量 II</h2><p><u><strong>题目</strong>：有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。</u></p>
<p><u>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</u></p>
<p><u>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；</u><br><u>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</u><br><u>最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。</u></p>
<p><u>输入：stones &#x3D; [2,7,4,1,8,1]</u><br><u>输出：1</u><br><u>解释：</u><br><u>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</u><br><u>组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</u><br><u>组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</u><br><u>组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> stone : stones) &#123;</span><br><span class="line">            sum += stone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不能整除，就取较小的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; stones.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target;j &gt;= stones[i];j--) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - <span class="number">2</span> * dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><h2 id="leetcode-198-打家劫舍"><a href="#leetcode-198-打家劫舍" class="headerlink" title="leetcode 198.打家劫舍"></a>leetcode 198.打家劫舍</h2><p><u><strong>题目</strong>：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</u></p>
<p><u>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额</u></p>
<p><u>输入：[2,7,9,3,1]</u><br><u>输出：12</u><br><u>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</u><br>     <u>偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12</u> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-213-打家劫舍-II（环形数组）"><a href="#leetcode-213-打家劫舍-II（环形数组）" class="headerlink" title="leetcode 213.打家劫舍 II（环形数组）"></a>leetcode 213.打家劫舍 II（环形数组）</h2><p><u><strong>题目</strong>：上面的情况成环了</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> maxRob(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> maxRob(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(result1, result2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxRob</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="comment">//注意这里的dp长度，因为start + 1有可能和end一样长，那么就不会进入for循环，dp[end]就是dp[start + 1]，如果end很长，那么dp[end]就是dp[nums.length - 2]，dp[nums.length - 1]我们没有赋值，不影响最后返回dp[end]。</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start + <span class="number">1</span>] = Math.max(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">2</span>;i &lt;= end;i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80%E5%8F%8A%E8%83%8C%E5%8C%85%E9%A2%98%E8%A7%A3/" data-id="cl5nllb9w0000uwv63y6k3lmx" data-title="动态规划基础及背包题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SQL题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/06/SQL%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-07-06T00:11:51.000Z" itemprop="datePublished">2022-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/06/SQL%E9%A2%98%E8%A7%A3/">SQL题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="SQL-15-查看学校名称中含北京的用户"><a href="#SQL-15-查看学校名称中含北京的用户" class="headerlink" title="SQL 15.查看学校名称中含北京的用户"></a>SQL 15.查看学校名称中含北京的用户</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id,age,university</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"><span class="keyword">where</span> university <span class="keyword">like</span> <span class="string">&#x27;%北京%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="SQL-16-查找GPA最高值"><a href="#SQL-16-查找GPA最高值" class="headerlink" title="SQL 16.查找GPA最高值"></a>SQL 16.查找GPA最高值</h2><p>题目：运营想要知道复旦大学学生gpa最高值是多少，请你取出相应数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#方法一</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(gpa) <span class="keyword">as</span> gpa</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"><span class="keyword">where</span> university <span class="operator">=</span> <span class="string">&#x27;复旦大学&#x27;</span>;</span><br><span class="line">#方法二</span><br><span class="line"><span class="keyword">select</span> gpa</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"><span class="keyword">where</span> university <span class="operator">=</span> <span class="string">&#x27;复旦大学&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> gpa <span class="keyword">desc</span> limit <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="SQL-17-计算男生人数及平均GPA"><a href="#SQL-17-计算男生人数及平均GPA" class="headerlink" title="SQL 17.计算男生人数及平均GPA"></a>SQL 17.计算男生人数及平均GPA</h2><p>根据输入，你的查询应返回以下结果，结果保留到小数点后面1位(1位之后的四舍五入)：</p>
<table>
<thead>
<tr>
<th>male_num</th>
<th>avg_gpa</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>3.6</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(gender) <span class="keyword">as</span> male_sum, round(<span class="built_in">avg</span>(gpa), <span class="number">1</span>) <span class="keyword">as</span> avg_gpa</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"><span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;male&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>因为where已经限制了gender &#x3D; ‘male’，所以count(gender)自然计算的是gender &#x3D; ‘male’的数量，同样avg(gpa)也仅计算gender &#x3D; ‘male’的gpa的平均值</p>
<h2 id="SQL-18-分组计算练习"><a href="#SQL-18-分组计算练习" class="headerlink" title="SQL 18.分组计算练习"></a>SQL 18.分组计算练习</h2><p><strong>题目</strong>：现在运营想要对每个学校不同性别的用户活跃情况和发帖数量进行分析，请分别计算出每个学校每种性别的用户数、30天内平均活跃天数和平均发帖数量。</p>
<p>用户信息表：user_profile</p>
<p>30天内活跃天数字段（active_days_within_30）</p>
<p>发帖数量字段（question_cnt）</p>
<p>回答数量字段（answer_cnt）</p>
<table>
<thead>
<tr>
<th>id</th>
<th>device_id</th>
<th>gender</th>
<th>age</th>
<th>university</th>
<th>gpa</th>
<th>active_days_within_30</th>
<th>question_cnt</th>
<th>answer_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2138</td>
<td>male</td>
<td>21</td>
<td>北京大学</td>
<td>3.4</td>
<td>7</td>
<td>2</td>
<td>12</td>
</tr>
<tr>
<td>2</td>
<td>3214</td>
<td>male</td>
<td></td>
<td>复旦大学</td>
<td>4.0</td>
<td>15</td>
<td>5</td>
<td>25</td>
</tr>
<tr>
<td>3</td>
<td>6543</td>
<td>female</td>
<td>20</td>
<td>北京大学</td>
<td>3.2</td>
<td>12</td>
<td>3</td>
<td>30</td>
</tr>
<tr>
<td>4</td>
<td>2315</td>
<td>female</td>
<td>23</td>
<td>浙江大学</td>
<td>3.6</td>
<td>5</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>5432</td>
<td>male</td>
<td>25</td>
<td>山东大学</td>
<td>3.8</td>
<td>20</td>
<td>15</td>
<td>70</td>
</tr>
<tr>
<td>6</td>
<td>2131</td>
<td>male</td>
<td>28</td>
<td>山东大学</td>
<td>3.3</td>
<td>15</td>
<td>7</td>
<td>13</td>
</tr>
<tr>
<td>7</td>
<td>4321</td>
<td>male</td>
<td>26</td>
<td>复旦大学</td>
<td>3.6</td>
<td>9</td>
<td>6</td>
<td>52</td>
</tr>
</tbody></table>
<p>你的查询返回结果需要对<strong>性别和学校分组</strong>，示例如下，结果保留1位小数，1位小数之后的四舍五入：</p>
<table>
<thead>
<tr>
<th>gender</th>
<th>university</th>
<th>user_num</th>
<th>avg_active_day</th>
<th>avg_question_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>male</td>
<td>北京大学</td>
<td>1</td>
<td>7.0</td>
<td>2.0</td>
</tr>
<tr>
<td>male</td>
<td>复旦大学</td>
<td>2</td>
<td>12.0</td>
<td>5.5</td>
</tr>
<tr>
<td>female</td>
<td>北京大学</td>
<td>1</td>
<td>12.0</td>
<td>3.0</td>
</tr>
<tr>
<td>female</td>
<td>浙江大学</td>
<td>1</td>
<td>5.0</td>
<td>1.0</td>
</tr>
<tr>
<td>male</td>
<td>山东大学</td>
<td>2</td>
<td>17.5</td>
<td>11.0</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> gender, university, <span class="built_in">count</span>(device_id), <span class="built_in">avg</span>(active_days_within_30) <span class="keyword">as</span> avg_active_day,</span><br><span class="line">    <span class="built_in">avg</span>(question_cnt) <span class="keyword">as</span> avg_question_cnt</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> university, gender;</span><br></pre></td></tr></table></figure>

<h2 id="SQL-19-分组过滤练习"><a href="#SQL-19-分组过滤练习" class="headerlink" title="SQL 19.分组过滤练习"></a>SQL 19.分组过滤练习</h2><p><u>还是SQL18的表格</u></p>
<p><strong>题目</strong>：现在运营想查看<strong>每个学校</strong>用户的<strong>平均发贴和回帖情况</strong>，寻找低活跃度学校进行重点运营，请取出平均发贴数低于5的学校或平均回帖数小于20的学校。</p>
<p>根据示例，你的查询应返回以下结果，请你保留3位小数(系统后台也会自动校正)，3位之后四舍五入：</p>
<table>
<thead>
<tr>
<th>university</th>
<th>avg_question_cnt</th>
<th>avg_answer_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>北京大学</td>
<td>2.5000</td>
<td>21.000</td>
</tr>
<tr>
<td>浙江大学</td>
<td>1.000</td>
<td>2.000</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> university, round(<span class="built_in">avg</span>(question_cnt), <span class="number">3</span>) <span class="keyword">as</span> avg_question_cnt, </span><br><span class="line">round(<span class="built_in">avg</span>(answer_cnt), <span class="number">3</span>) <span class="keyword">as</span> avg_answer_cnt</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> university</span><br><span class="line"><span class="keyword">having</span> avg_question_cnt <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">or</span></span><br><span class="line">avg_answer_cnt <span class="operator">&lt;</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>这里初学容易将having写成where，记住avg聚合函数<strong>生成了新的字段</strong>，且group by后面需要用having，所以不能用where，而要用having。</p>
<h2 id="SQL-20-分组排序练习"><a href="#SQL-20-分组排序练习" class="headerlink" title="SQL 20.分组排序练习"></a>SQL 20.分组排序练习</h2><p><u>还是SQL18的表格</u></p>
<p><strong>题目</strong>：现在运营想要查看<strong>不同大学</strong>的用户平均发帖情况，并期望结果<strong>按照平均发帖情况进行升序排列</strong>，请你取出相应数据。</p>
<p>根据示例，你的查询应返回以下结果：</p>
<table>
<thead>
<tr>
<th>university</th>
<th>avg_question_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>浙江大学</td>
<td>1.0000</td>
</tr>
<tr>
<td>北京大学</td>
<td>2.5000</td>
</tr>
<tr>
<td>复旦大学</td>
<td>5.5000</td>
</tr>
<tr>
<td>山东大学</td>
<td>11.0000</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> university, round(<span class="built_in">avg</span>(question_cnt), <span class="number">4</span>) <span class="keyword">as</span> avg_question_cnt</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> university</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> avg_question_cnt;</span><br></pre></td></tr></table></figure>

<h2 id="SQL-21-浙江大学用户题目回答情况"><a href="#SQL-21-浙江大学用户题目回答情况" class="headerlink" title="SQL 21.浙江大学用户题目回答情况"></a>SQL 21.浙江大学用户题目回答情况</h2><p>题目：现在运营想要查看所有<strong>来自浙江大学的</strong>用户题目回答明细情况，请你取出相应数据</p>
<p>示例 ：question_practice_detail</p>
<table>
<thead>
<tr>
<th>id</th>
<th>device_id</th>
<th>question_id</th>
<th>result</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2138</td>
<td>111</td>
<td>wrong</td>
</tr>
<tr>
<td>2</td>
<td>3214</td>
<td>112</td>
<td>wrong</td>
</tr>
<tr>
<td>3</td>
<td>3214</td>
<td>113</td>
<td>wrong</td>
</tr>
<tr>
<td>4</td>
<td>6543</td>
<td>114</td>
<td>right</td>
</tr>
<tr>
<td>5</td>
<td>2315</td>
<td>115</td>
<td>right</td>
</tr>
<tr>
<td>6</td>
<td>2315</td>
<td>116</td>
<td>right</td>
</tr>
<tr>
<td>7</td>
<td>2315</td>
<td>117</td>
<td>wrong</td>
</tr>
</tbody></table>
<p>示例：user_profile</p>
<table>
<thead>
<tr>
<th>id</th>
<th>device_id</th>
<th>gender</th>
<th>age</th>
<th>university</th>
<th>gpa</th>
<th>active_days_within_30</th>
<th>question_cnt</th>
<th>answer_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2138</td>
<td>male</td>
<td>21</td>
<td>北京大学</td>
<td>3.4</td>
<td>7</td>
<td>2</td>
<td>12</td>
</tr>
<tr>
<td>2</td>
<td>3214</td>
<td>male</td>
<td></td>
<td>复旦大学</td>
<td>4.0</td>
<td>15</td>
<td>5</td>
<td>25</td>
</tr>
<tr>
<td>3</td>
<td>6543</td>
<td>female</td>
<td>20</td>
<td>北京大学</td>
<td>3.2</td>
<td>12</td>
<td>3</td>
<td>30</td>
</tr>
<tr>
<td>4</td>
<td>2315</td>
<td>female</td>
<td>23</td>
<td>浙江大学</td>
<td>3.6</td>
<td>5</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>5432</td>
<td>male</td>
<td>25</td>
<td>山东大学</td>
<td>3.8</td>
<td>20</td>
<td>15</td>
<td>70</td>
</tr>
<tr>
<td>6</td>
<td>2131</td>
<td>male</td>
<td>28</td>
<td>山东大学</td>
<td>3.3</td>
<td>15</td>
<td>7</td>
<td>13</td>
</tr>
<tr>
<td>7</td>
<td>4321</td>
<td>female</td>
<td>26</td>
<td>复旦大学</td>
<td>3.6</td>
<td>9</td>
<td>6</td>
<td>52</td>
</tr>
</tbody></table>
<p>根据示例，你的查询应返回以下结果，查询结果<strong>根据question_id升序排序</strong>：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210825/999991344_1629872498861/D9E601E7A15464E123E07993B5B38512" alt="img"></p>
<p>解释:</p>
<p>根据题目的数据只有1个浙江大学的用户，那么把浙江大学这个用户所有答题数据查询出来就行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#内连</span><br><span class="line"><span class="keyword">select</span> a.device_id, a.question_id, a.result</span><br><span class="line"><span class="keyword">from</span> question_practice_detail a</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> user_profile b</span><br><span class="line"><span class="keyword">on</span> a.device_id <span class="operator">=</span> b.device_id <span class="keyword">and</span> university <span class="operator">=</span> <span class="string">&#x27;浙江大学&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> question_id;</span><br><span class="line">#左连</span><br><span class="line"><span class="keyword">select</span> a.device_id, a.question_id, a.result</span><br><span class="line"><span class="keyword">from</span> question_practice_detail a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> user_profile b</span><br><span class="line"><span class="keyword">on</span> a.device_id <span class="operator">=</span> b.device_id <span class="keyword">where</span> university <span class="operator">=</span> <span class="string">&#x27;浙江大学&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> question_id;</span><br></pre></td></tr></table></figure>

<p>注意：左右内连接之后，形成了一个新的表，用on的时候，and条件满足和不满足的结果都会显示出来，所以内连接不会有问题，但是左连接就会使非浙江大学的用户也显示出来。这时候用where就可以过滤掉其他非浙江大学的用户。</p>
<h2 id="SQL-22-统计每个学校的答过题的用户的平均答题数"><a href="#SQL-22-统计每个学校的答过题的用户的平均答题数" class="headerlink" title="SQL 22.统计每个学校的答过题的用户的平均答题数"></a>SQL 22.统计每个学校的答过题的用户的平均答题数</h2><p> 运营想要了解每个学校<strong>答过题的</strong>用户<strong>平均答题数量</strong>情况，请你取出数据。</p>
<table>
<thead>
<tr>
<th>device_id</th>
<th>gender</th>
<th>age</th>
<th>university</th>
<th>gpa</th>
<th>active_days_within_30</th>
</tr>
</thead>
<tbody><tr>
<td>2138</td>
<td>male</td>
<td>21</td>
<td>北京大学</td>
<td>3.4</td>
<td>7</td>
</tr>
<tr>
<td>3214</td>
<td>male</td>
<td>NULL</td>
<td>复旦大学</td>
<td>4</td>
<td>15</td>
</tr>
<tr>
<td>6543</td>
<td>female</td>
<td>20</td>
<td>北京大学</td>
<td>3.2</td>
<td>12</td>
</tr>
<tr>
<td>2315</td>
<td>female</td>
<td>23</td>
<td>浙江大学</td>
<td>3.6</td>
<td>5</td>
</tr>
<tr>
<td>5432</td>
<td>male</td>
<td>25</td>
<td>山东大学</td>
<td>3.8</td>
<td>20</td>
</tr>
<tr>
<td>2131</td>
<td>male</td>
<td>28</td>
<td>山东大学</td>
<td>3.3</td>
<td>15</td>
</tr>
<tr>
<td>4321</td>
<td>male</td>
<td>28</td>
<td>复旦大学</td>
<td>3.6</td>
<td>9</td>
</tr>
</tbody></table>
<p>答题情况明细表 question_practice_detail，其中question_id是题目编号，result是答题结果。</p>
<table>
<thead>
<tr>
<th>device_id</th>
<th>question_id</th>
<th>result</th>
</tr>
</thead>
<tbody><tr>
<td>2138</td>
<td>111</td>
<td>wrong</td>
</tr>
<tr>
<td>3214</td>
<td>112</td>
<td>wrong</td>
</tr>
<tr>
<td>3214</td>
<td>113</td>
<td>wrong</td>
</tr>
<tr>
<td>6543</td>
<td>111</td>
<td>right</td>
</tr>
<tr>
<td>2315</td>
<td>115</td>
<td>right</td>
</tr>
<tr>
<td>2315</td>
<td>116</td>
<td>right</td>
</tr>
<tr>
<td>2315</td>
<td>117</td>
<td>wrong</td>
</tr>
<tr>
<td>5432</td>
<td>118</td>
<td>wrong</td>
</tr>
<tr>
<td>5432</td>
<td>112</td>
<td>wrong</td>
</tr>
<tr>
<td>2131</td>
<td>114</td>
<td>right</td>
</tr>
<tr>
<td>5432</td>
<td>113</td>
<td>wrong</td>
</tr>
</tbody></table>
<p>请你写SQL查找每个学校用户的平均答题数目(说明：某学校用户平均答题数量计算方式为该学校用户答题总次数除以答过题的不同用户个数)根据示例，你的查询应返回以下结果（结果保留4位小数），注意：<strong>结果按照university升序排序！！！</strong></p>
<table>
<thead>
<tr>
<th>university</th>
<th>avg_answer_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>北京大学</td>
<td>1.0000</td>
</tr>
<tr>
<td>复旦大学</td>
<td>2.0000</td>
</tr>
<tr>
<td>山东大学</td>
<td>2.0000</td>
</tr>
<tr>
<td>浙江大学</td>
<td>3.0000</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.university, round(<span class="built_in">count</span>(b.question_id) <span class="operator">/</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> b.device_id), <span class="number">4</span>) <span class="keyword">as</span> avg_answer_cnt</span><br><span class="line"><span class="keyword">from</span> user_profile a</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> question_practice_detail b</span><br><span class="line"><span class="keyword">on</span> a.device_id <span class="operator">=</span> b.device_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> university</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> university;</span><br></pre></td></tr></table></figure>

<p>注意计算答题总人数的时候，记得要去重</p>
<h2 id="SQL-23-统计每个学校各难度的用户平均刷题数"><a href="#SQL-23-统计每个学校各难度的用户平均刷题数" class="headerlink" title="SQL 23.统计每个学校各难度的用户平均刷题数"></a>SQL 23.统计每个学校各难度的用户平均刷题数</h2><p>题目：运营想要计算一些<strong>参加了答题</strong>的不同学校、不同难度的用户平均答题量，请你写SQL取出相应数据</p>
<p>用户信息表：user_profile</p>
<table>
<thead>
<tr>
<th>id</th>
<th>device_id</th>
<th>gender</th>
<th>age</th>
<th>university</th>
<th>gpa</th>
<th>active_days_within_30</th>
<th>question_cnt</th>
<th>answer_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2138</td>
<td>male</td>
<td>21</td>
<td>北京大学</td>
<td>3.4</td>
<td>7</td>
<td>2</td>
<td>12</td>
</tr>
<tr>
<td>2</td>
<td>3214</td>
<td>male</td>
<td>NULL</td>
<td>复旦大学</td>
<td>4</td>
<td>15</td>
<td>5</td>
<td>25</td>
</tr>
<tr>
<td>3</td>
<td>6543</td>
<td>female</td>
<td>20</td>
<td>北京大学</td>
<td>3.2</td>
<td>12</td>
<td>3</td>
<td>30</td>
</tr>
<tr>
<td>4</td>
<td>2315</td>
<td>female</td>
<td>23</td>
<td>浙江大学</td>
<td>3.6</td>
<td>5</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>5432</td>
<td>male</td>
<td>25</td>
<td>山东大学</td>
<td>3.8</td>
<td>20</td>
<td>15</td>
<td>70</td>
</tr>
<tr>
<td>6</td>
<td>2131</td>
<td>male</td>
<td>28</td>
<td>山东大学</td>
<td>3.3</td>
<td>15</td>
<td>7</td>
<td>13</td>
</tr>
<tr>
<td>7</td>
<td>4321</td>
<td>male</td>
<td>28</td>
<td>复旦大学</td>
<td>3.6</td>
<td>9</td>
<td>6</td>
<td>52</td>
</tr>
</tbody></table>
<p>题库练习明细表：question_practice_detail</p>
<table>
<thead>
<tr>
<th>id</th>
<th>device_id</th>
<th>question_id</th>
<th>result</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2138</td>
<td>111</td>
<td>wrong</td>
</tr>
<tr>
<td>2</td>
<td>3214</td>
<td>112</td>
<td>wrong</td>
</tr>
<tr>
<td>3</td>
<td>3214</td>
<td>113</td>
<td>wrong</td>
</tr>
<tr>
<td>4</td>
<td>6534</td>
<td>111</td>
<td>right</td>
</tr>
<tr>
<td>5</td>
<td>2315</td>
<td>115</td>
<td>right</td>
</tr>
<tr>
<td>6</td>
<td>2315</td>
<td>116</td>
<td>right</td>
</tr>
<tr>
<td>7</td>
<td>2315</td>
<td>117</td>
<td>wrong</td>
</tr>
<tr>
<td>8</td>
<td>5432</td>
<td>117</td>
<td>wrong</td>
</tr>
<tr>
<td>9</td>
<td>5432</td>
<td>112</td>
<td>wrong</td>
</tr>
<tr>
<td>10</td>
<td>2131</td>
<td>113</td>
<td>right</td>
</tr>
<tr>
<td>11</td>
<td>5432</td>
<td>113</td>
<td>wrong</td>
</tr>
<tr>
<td>12</td>
<td>2315</td>
<td>115</td>
<td>right</td>
</tr>
<tr>
<td>13</td>
<td>2315</td>
<td>116</td>
<td>right</td>
</tr>
<tr>
<td>14</td>
<td>2315</td>
<td>117</td>
<td>wrong</td>
</tr>
<tr>
<td>15</td>
<td>5432</td>
<td>117</td>
<td>wrong</td>
</tr>
<tr>
<td>16</td>
<td>5432</td>
<td>112</td>
<td>wrong</td>
</tr>
<tr>
<td>17</td>
<td>2131</td>
<td>113</td>
<td>right</td>
</tr>
<tr>
<td>18</td>
<td>5432</td>
<td>113</td>
<td>wrong</td>
</tr>
<tr>
<td>19</td>
<td>2315</td>
<td>117</td>
<td>wrong</td>
</tr>
<tr>
<td>20</td>
<td>5432</td>
<td>117</td>
<td>wrong</td>
</tr>
<tr>
<td>21</td>
<td>5432</td>
<td>112</td>
<td>wrong</td>
</tr>
<tr>
<td>22</td>
<td>2131</td>
<td>113</td>
<td>right</td>
</tr>
<tr>
<td>23</td>
<td>5432</td>
<td>113</td>
<td>wrong</td>
</tr>
</tbody></table>
<p>表：question_detail</p>
<table>
<thead>
<tr>
<th>id</th>
<th>question_id</th>
<th>difficult_level</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>111</td>
<td>hard</td>
</tr>
<tr>
<td>2</td>
<td>112</td>
<td>medium</td>
</tr>
<tr>
<td>3</td>
<td>113</td>
<td>easy</td>
</tr>
<tr>
<td>4</td>
<td>115</td>
<td>easy</td>
</tr>
<tr>
<td>5</td>
<td>116</td>
<td>medium</td>
</tr>
<tr>
<td>6</td>
<td>117</td>
<td>easy</td>
</tr>
</tbody></table>
<p>请你写一个SQL查询，计算不同学校、不同难度的用户平均答题量，根据示例，你的查询应返回以下结果(结果在小数点位数保留4位，4位之后四舍五入)：</p>
<table>
<thead>
<tr>
<th>university</th>
<th>difficult_level</th>
<th>avg_answer_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>北京大学</td>
<td>hard</td>
<td>1.0000</td>
</tr>
<tr>
<td>复旦大学</td>
<td>easy</td>
<td>1.0000</td>
</tr>
<tr>
<td>复旦大学</td>
<td>medium</td>
<td>1.0000</td>
</tr>
<tr>
<td>山东大学</td>
<td>easy</td>
<td>4.5000</td>
</tr>
<tr>
<td>山东大学</td>
<td>medium</td>
<td>3.0000</td>
</tr>
<tr>
<td>浙江大学</td>
<td>easy</td>
<td>5.0000</td>
</tr>
<tr>
<td>浙江大学</td>
<td>medium</td>
<td>2.0000</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> university, det.difficult_level, </span><br><span class="line">round(<span class="built_in">count</span>(que.question_id) <span class="operator">/</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> que.device_id), <span class="number">4</span>) <span class="keyword">as</span> avg_answer_cnt</span><br><span class="line"><span class="keyword">from</span> question_practice_detail que</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> user_profile us</span><br><span class="line"><span class="keyword">on</span> us.device_id <span class="operator">=</span> que.device_id</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> question_detail det</span><br><span class="line"><span class="keyword">on</span> que.question_id <span class="operator">=</span> det.question_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> university, difficult_level;</span><br></pre></td></tr></table></figure>

<p>因为难度difficult_level在第三张表上，所以要内连第三张表，连接的位置便是question_id</p>
<h2 id="SQL-24-统计每个用户的平均刷题数"><a href="#SQL-24-统计每个用户的平均刷题数" class="headerlink" title="SQL 24.统计每个用户的平均刷题数"></a>SQL 24.统计每个用户的平均刷题数</h2><p>题目表格与上题一样</p>
<p>题目：运营想要查看参加了答题的<strong>山东大学的用户</strong>在<strong>不同难度下</strong>的<strong>平均答题题目数</strong>，请取出相应数据</p>
<p>请你写一个SQL查询，计算山东、不同难度的用户平均答题量，根据示例，你的查询应返回以下结果(结果在小数点位数保留4位，4位之后四舍五入)：</p>
<table>
<thead>
<tr>
<th>university</th>
<th>difficult_level</th>
<th>avg_answer_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>山东大学</td>
<td>easy</td>
<td>4.5000</td>
</tr>
<tr>
<td>山东大学</td>
<td>medium</td>
<td>3.0000</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> us.university, det.difficult_level, </span><br><span class="line">round(<span class="built_in">count</span>(que.question_id) <span class="operator">/</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> que.device_id), <span class="number">4</span>) <span class="keyword">as</span> avg_answer_cnt</span><br><span class="line"><span class="keyword">from</span> user_profile us</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> question_practice_detail que</span><br><span class="line"><span class="keyword">on</span> us.device_id <span class="operator">=</span> que.device_id</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> question_detail det</span><br><span class="line"><span class="keyword">on</span> det.question_id <span class="operator">=</span> que.question_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> university, difficult_level</span><br><span class="line"><span class="keyword">having</span> university <span class="operator">=</span> <span class="string">&#x27;山东大学&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="SQL-25-查找山东大学或者性别为男生的信息"><a href="#SQL-25-查找山东大学或者性别为男生的信息" class="headerlink" title="SQL 25.查找山东大学或者性别为男生的信息"></a>SQL 25.查找山东大学或者性别为男生的信息</h2><p>题目：现在运营想要<strong>分别查看</strong>学校为山东大学或者性别为男性的用户的device_id、gender、age和gpa数据，请取出相应结果，**<u>结果不去重</u>**。</p>
<p>示例：user_profile</p>
<table>
<thead>
<tr>
<th>id</th>
<th>device_id</th>
<th>gender</th>
<th>age</th>
<th>university</th>
<th>gpa</th>
<th>active_days_within_30</th>
<th>question_cnt</th>
<th>answer_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2138</td>
<td>male</td>
<td>21</td>
<td>北京大学</td>
<td>3.4</td>
<td>7</td>
<td>2</td>
<td>12</td>
</tr>
<tr>
<td>2</td>
<td>3214</td>
<td>male</td>
<td></td>
<td>复旦大学</td>
<td>4</td>
<td>15</td>
<td>5</td>
<td>25</td>
</tr>
<tr>
<td>3</td>
<td>6543</td>
<td>female</td>
<td>20</td>
<td>北京大学</td>
<td>3.2</td>
<td>12</td>
<td>3</td>
<td>30</td>
</tr>
<tr>
<td>4</td>
<td>2315</td>
<td>female</td>
<td>23</td>
<td>浙江大学</td>
<td>3.6</td>
<td>5</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>5432</td>
<td>male</td>
<td>25</td>
<td>山东大学</td>
<td>3.8</td>
<td>20</td>
<td>15</td>
<td>70</td>
</tr>
<tr>
<td>6</td>
<td>2131</td>
<td>male</td>
<td>28</td>
<td>山东大学</td>
<td>3.3</td>
<td>15</td>
<td>7</td>
<td>13</td>
</tr>
<tr>
<td>7</td>
<td>4321</td>
<td>male</td>
<td>26</td>
<td>复旦大学</td>
<td>3.6</td>
<td>9</td>
<td>6</td>
<td>52</td>
</tr>
</tbody></table>
<p>根据示例，你的查询应返回以下结果（注意输出的顺序，<strong>先输出学校</strong>为山东大学<strong>再输出性别</strong>为男生的信息）：</p>
<table>
<thead>
<tr>
<th>device_id</th>
<th>gender</th>
<th>age</th>
<th>gpa</th>
</tr>
</thead>
<tbody><tr>
<td>5432</td>
<td>male</td>
<td>25</td>
<td>3.8</td>
</tr>
<tr>
<td>2131</td>
<td>male</td>
<td>28</td>
<td>3.3</td>
</tr>
<tr>
<td>2138</td>
<td>male</td>
<td>21</td>
<td>3.4</td>
</tr>
<tr>
<td>3214</td>
<td>male</td>
<td>None</td>
<td>4</td>
</tr>
<tr>
<td>5432</td>
<td>male</td>
<td>25</td>
<td>3.8</td>
</tr>
<tr>
<td>2131</td>
<td>male</td>
<td>28</td>
<td>3.3</td>
</tr>
<tr>
<td>4321</td>
<td>male</td>
<td>28</td>
<td>3.6</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id, gender, age, gpa</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"><span class="keyword">where</span> university <span class="operator">=</span> <span class="string">&#x27;山东大学&#x27;</span></span><br><span class="line">#将两个表的结果进行结合，且不去重；如果去重，则需要用<span class="keyword">union</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> device_id, gender, age, gpa</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"><span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;male&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果where or，那么<strong>结果是去重的</strong>。因为既满足山东大学又满足男性的元素<strong>只会被记录一次</strong>，即完成了去重。</p>
<h2 id="SQL-156-各个视频的平均完播率"><a href="#SQL-156-各个视频的平均完播率" class="headerlink" title="SQL 156.各个视频的平均完播率"></a>SQL 156.各个视频的平均完播率</h2><p>题目描述如下:</p>
<p>用户-视频互动表tb_user_video_log</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>video_id</th>
<th>start_time</th>
<th>end_time</th>
<th>if_follow</th>
<th>if_like</th>
<th>if_retweet</th>
<th>comment_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>101</td>
<td>2001</td>
<td>2021-10-01 10:00:00</td>
<td>2021-10-01 10:00:30</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>NULL</td>
</tr>
<tr>
<td>2</td>
<td>102</td>
<td>2001</td>
<td>2021-10-01 10:00:00</td>
<td>2021-10-01 10:00:24</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>NULL</td>
</tr>
<tr>
<td>3</td>
<td>103</td>
<td>2001</td>
<td>2021-10-01 11:00:00</td>
<td>2021-10-01 11:00:34</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1732526</td>
</tr>
<tr>
<td>4</td>
<td>101</td>
<td>2002</td>
<td>2021-09-01 10:00:00</td>
<td>2021-9-01 10:00:42</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>NULL</td>
</tr>
<tr>
<td>5</td>
<td>102</td>
<td>2002</td>
<td>2021-10-01 11:00:00</td>
<td>2021-10-01 10:00:30</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>NULL</td>
</tr>
</tbody></table>
<p>（uid-用户ID, video_id-视频ID, start_time-开始观看时间, end_time-结束观看时间, if_follow-是否关注, if_like-是否点赞, if_retweet-是否转发, comment_id-评论ID）</p>
<p>短视频信息表tb_video_info</p>
<table>
<thead>
<tr>
<th>id</th>
<th>video_id</th>
<th>author</th>
<th>tag</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2001</td>
<td>901</td>
<td>影视</td>
<td>30</td>
<td>2021-01-01 07:00:00</td>
</tr>
<tr>
<td>2</td>
<td>2002</td>
<td>901</td>
<td>美食</td>
<td>60</td>
<td>2021-01-01 07:00:00</td>
</tr>
<tr>
<td>3</td>
<td>2003</td>
<td>902</td>
<td>旅游</td>
<td>90</td>
<td>2021-01-01 07:00:00</td>
</tr>
</tbody></table>
<p>（video_id-视频ID, author-创作者ID, tag-类别标签, duration-视频时长（秒）, release_time-发布时间）</p>
<p><strong>问题</strong>：计算2021年里有播放记录的每个视频的完播率(结果保留三位小数)，并按完播率降序排序</p>
<p><strong>注</strong>：视频完播率是指完成播放次数占总播放次数的比例。简单起见，结束观看时间与开始播放时间的差&gt;&#x3D;视频时长时，视为完成播放。</p>
<p><strong>输出示例</strong>：</p>
<p>示例数据的结果如下：</p>
<table>
<thead>
<tr>
<th>video_id</th>
<th>avg_comp_play_rate</th>
</tr>
</thead>
<tbody><tr>
<td>2001</td>
<td>0.667</td>
</tr>
<tr>
<td>2002</td>
<td>0.000</td>
</tr>
</tbody></table>
<p>解释：</p>
<p>视频2001在2021年10月有3次播放记录，观看时长分别为30秒、24秒、34秒，视频时长30秒，因此有两次是被认为完成播放了的，故完播率为0.667；</p>
<p>视频2002在2021年9月和10月共2次播放记录，观看时长分别为42秒、30秒，视频时长60秒，故完播率为0.000。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.video_id, </span><br><span class="line">   round(<span class="built_in">sum</span>(if(end_time <span class="operator">-</span> start_time <span class="operator">&gt;=</span> duration, <span class="number">1</span>, <span class="number">0</span>))<span class="operator">/</span><span class="built_in">count</span>(start_time), <span class="number">3</span>) <span class="keyword">as</span> avg_comp_play_rate</span><br><span class="line"><span class="keyword">from</span> tb_user_video_log a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tb_video_info b</span><br><span class="line"><span class="keyword">on</span> a.video_id <span class="operator">=</span> b.video_id</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(start_time) <span class="operator">=</span> <span class="number">2021</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> video_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> avg_comp_play_rate <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p>因为我们表格最后只有video_id和avg_comp_play_rate这两列，所以select后面只有这两个数据；</p>
<p>用left join是因为我们要以log（a）表的video_id为基准，所以该表为左表。这里因为log（a）和info（b）表都有2001和2002id字段，所以<strong>inner join的效果也是一样</strong>的。</p>
<p>因为题目要求2021年有播放记录的视频，所以不要忘了我们要<strong>以start_time中的year&#x3D;2021为限定条件</strong>。</p>
<p>最后要<strong>以video_id分组</strong>，并按照播放率降序排列</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/06/SQL%E9%A2%98%E8%A7%A3/" data-id="cl58ui2dr0000d4v6gj2ed10n" data-title="SQL题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-股票问题题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/02/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-07-02T09:04:00.000Z" itemprop="datePublished">2022-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/02/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E9%A2%98%E8%A7%A3/">股票问题题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="CodeTop-leetcode-121-买卖股票问题的最佳时机（只有一次）"><a href="#CodeTop-leetcode-121-买卖股票问题的最佳时机（只有一次）" class="headerlink" title="(CodeTop)leetcode 121.买卖股票问题的最佳时机（只有一次）"></a>(CodeTop)leetcode 121.买卖股票问题的最佳时机（只有一次）</h2><p><u><strong>题目</strong>：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</u></p>
<p><u>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 未来的<strong>某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</u></p>
<p><u>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</u></p>
<p><u>输入：[7,1,5,3,6,4]</u><br><u>输出：5</u><br><u>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划方法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//不持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">            <span class="comment">//注意这里只能买卖一次，所以不要加前面的dp[i - 1][0]</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贪心法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个变量，用来数组中的最小值，即买入股票的价钱</span></span><br><span class="line">        <span class="comment">//一定要主要初始值不能设为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">            low = Math.min(low, prices[i]);</span><br><span class="line">            max = Math.max(max, prices[i] - low);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此题一定要注意审题，是只能买卖一次。</p>
<h2 id="leetcode-122-买卖股票的最佳时机-II（无限次）"><a href="#leetcode-122-买卖股票的最佳时机-II（无限次）" class="headerlink" title="leetcode 122.买卖股票的最佳时机 II（无限次）"></a>leetcode 122.买卖股票的最佳时机 II（无限次）</h2><p><u><strong>题目</strong>：给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</u></p>
<p><u>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多 只能持有 一股</strong> 股票。你也可以先购买，然后在 <strong>同一天 出售。</strong></u></p>
<p><u>返回 你能获得的 最大 利润 。</u></p>
<p><u>输入：prices &#x3D; [7,1,5,3,6,4]</u><br><u>输出：7</u><br><u>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; <strong>5 - 1 &#x3D; 4</strong> 。随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; <strong>6 - 3 &#x3D; 3</strong> 。总利润为 4 + 3 &#x3D; 7 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//持有股票的最大利润</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//不持有股票的最大利润</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">            <span class="comment">//这里因为可多次购买股票，所以要不论是买入还是卖出，都要累加前面的利润</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贪心法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">            <span class="comment">//只要有利润，就算进来，最后看总利润res，即为结果</span></span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                ans += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-123-买卖股票的最佳时机-III（只有两次）"><a href="#leetcode-123-买卖股票的最佳时机-III（只有两次）" class="headerlink" title="leetcode 123.买卖股票的最佳时机 III（只有两次）"></a>leetcode 123.买卖股票的最佳时机 III（只有两次）</h2><p><u>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</u></p>
<p><u>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</u></p>
<p><u>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</u></p>
<p><u>输入：prices &#x3D; [3,3,5,0,0,3,1,4]</u><br><u>输出：6</u><br><u>解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</u><u>随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//第一次持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//第一次不持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第二次持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//第二次不持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">            <span class="comment">//这里是关键，第一次购入股票不能累加前面的dp[i - 1][1]</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="☆leetcode-188-买卖股票的最佳时机-IV（有K次）"><a href="#☆leetcode-188-买卖股票的最佳时机-IV（有K次）" class="headerlink" title="☆leetcode 188.买卖股票的最佳时机 IV（有K次）"></a>☆leetcode 188.买卖股票的最佳时机 IV（有K次）</h2><p><u>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</u></p>
<p><u>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</u></p>
<p><u>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</u></p>
<p><u><strong>提示：</strong></u></p>
<ul>
<li><u><code>0 &lt;= k &lt;= 100</code></u></li>
<li><u><code>0 &lt;= prices.length &lt;= 1000</code></u></li>
<li><u><code>0 &lt;= prices[i] &lt;= 1000&lt;/u&gt;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span> * k + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//0表示不操作，奇数是持有股票，偶数是不持有股票</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; <span class="number">2</span> * k;i += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">2</span> * k - <span class="number">1</span>;j += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//最后j遍历到2 * k - 2,然后j + 2 正好等于2 * k</span></span><br><span class="line">                dp[i][j + <span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                dp[i][j + <span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="★-leetcode-309-最佳买卖股票时机含冷冻时间（卖出第二天不能买）"><a href="#★-leetcode-309-最佳买卖股票时机含冷冻时间（卖出第二天不能买）" class="headerlink" title="★ leetcode 309.最佳买卖股票时机含冷冻时间（卖出第二天不能买）"></a>★ leetcode 309.最佳买卖股票时机含冷冻时间（卖出第二天不能买）</h2><p><u>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。</u></p>
<p><u>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</u></p>
<p><u>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</u><br><u>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</u></p>
<p><u>输入: prices &#x3D; [1,2,3,0,2]</u><br><u>输出: 3</u><br><u>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">            <span class="comment">//第i天持有股票的最大收益</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]) - prices[i]);</span><br><span class="line">            <span class="comment">//第i天不持有股票，且早就不持有，不在冷冻期</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            <span class="comment">//第i天不持有股票，且这一天卖出股票</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            <span class="comment">//第i天不持有股票，且这一天在冷冻期</span></span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后，这三种情况都有可能存在最大收益，所以取三者的最大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">1</span>], Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">2</span>], dp[prices.length - <span class="number">1</span>][<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分为四个情况：</p>
<p>情况1：<strong>持有</strong>股票的时候。那么有可能前一天也持有股票（情况1）；又可能前一天是早就把股票卖了（情况2）；有可能前一天是冷冻期（情况3）</p>
<p>情况2：<strong>不持有</strong>股票，但是<strong>今天也不是冷冻期</strong>，说明早就把股票卖了。那么有可能前面一天也是这种情况（情况2）；也有可能昨天是冷冻期（情况4）</p>
<p>情况3：<strong>不持有</strong>股票，且<strong>今天刚卖</strong>了股票，<strong>明天是冷冻期</strong>。那么只有一种可能，就是昨天持有股票（情况1）</p>
<p>情况4：<strong>不持有</strong>股票，且<strong>今天是冷冻期</strong>。那么昨天必然卖了股票（情况3）</p>
<h2 id="leetcode-714-买卖股票的最佳时机含手续费（卖出就要手续费）"><a href="#leetcode-714-买卖股票的最佳时机含手续费（卖出就要手续费）" class="headerlink" title="leetcode 714.买卖股票的最佳时机含手续费（卖出就要手续费）"></a>leetcode 714.买卖股票的最佳时机含手续费（卖出就要手续费）</h2><p><u>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</u></p>
<p><u>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</u></p>
<p><u>返回获得利润的最大值。</u></p>
<p><u>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</u></p>
<p><u>输入：prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</u><br><u>输出：8</u><br><u>解释：能够达到的最大利润:<br>在此处买入 prices[0] &#x3D; 1</u><br><u>在此处卖出 prices[3] &#x3D; 8</u><br><u>在此处买入 prices[4] &#x3D; 4</u><br><u>在此处卖出 prices[5] &#x3D; 9</u><br><u>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这道题就是在买卖股票 II的基础上多减了一个手续费fee。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/02/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E9%A2%98%E8%A7%A3/" data-id="cl53nr1pu00002kv6hs8i35of" data-title="股票问题题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-十大排序算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/01/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2022-07-01T01:58:17.000Z" itemprop="datePublished">2022-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/01/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">十大排序算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="CodeTop-leetcode-912-排序数组"><a href="#CodeTop-leetcode-912-排序数组" class="headerlink" title="(CodeTop) leetcode 912.排序数组"></a>(CodeTop) leetcode 912.排序数组</h1><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="img" style="zoom: 75%;" />

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//i的取值范围是难点！受j的取值范围影响，当i取最大值nums.length - 2时，j &lt; 1,即j可取最小值0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="comment">//每次定义一个标志，一旦该标志在下层循环中没有发生变化，则说明已经排序好了，不需要再排了</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//第二个难点依旧是取值范围，j的取值范围每次都要随着i的增加而减小，因为每次最后位置的元素已经排好</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length - <span class="number">1</span> - i;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="img" style="zoom: 67%;" />

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//确定好左闭右闭区间</span></span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//确定基准</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> randomizedPartition(nums, left, right);</span><br><span class="line">            <span class="comment">//递归地进行快排（这里很容易写错）</span></span><br><span class="line">            quickSort(nums, left, pivot - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, pivot + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在范围内随机找一点与即将成为pivot的left点对换，避免每次都取left值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">randomizedPartition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        <span class="comment">//将随机位置的值nums[pivot]赋给nums[left]</span></span><br><span class="line">        swap(nums, pivot, left);</span><br><span class="line">        <span class="comment">//将交换随机值之后的nums进行排列</span></span><br><span class="line">        <span class="keyword">return</span> partition(nums, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将小于nums[pivot]的值都放在pivot左边,大于nums[pivot]的值都放在pivot右边。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//取左边界为基准pivot</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">//从pivot右边第一位开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> pivot + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//一开始右指针i与左指针index重合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt;= right;i++) &#123;</span><br><span class="line">            <span class="comment">//一旦右指针i指向的元素比pivot指向的小，就把这个值赋给index，并让左指针index向右移动</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[pivot]) &#123;</span><br><span class="line">                swap(nums, i, index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后不要忘了让基准移向所有小值的右边（牺牲最右边的一个小值与pivot值进行交换），保证所有的小值在pivot左边，大值在pivot右边。</span></span><br><span class="line">        swap(nums, pivot, index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//交换的只是值，所以pivot的位置就变为index - 1</span></span><br><span class="line">        <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>切记：归并用的是分治思想，不是边分边治，而是分到不能再分，再治。比如[9,6,8,4,5]:</p>
<p>先分成[9,6,8]，然后[9,6]，然后[9]，然后[9]和[6]治成[6,9]，然后[6,9]和[8]治成[6,8,9]，然后[4,5]这边分成[4]和[5]，然后[4]和[5]治成[4,5]，最后[6,8,9]和[4,5]治成[4,5,6,8,9]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//定义全局变量数组，用于记录每次重排的数组</span></span><br><span class="line">    <span class="type">int</span>[] temp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//重排数组的长度与原始长度一致</span></span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//将nums整体传入主方法</span></span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//直到区间只剩一个元素才返回</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//只要区间多于一个元素，就寻找中点mid</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//递归的执行本方法，分别递归mid左边和右边两个区间</span></span><br><span class="line">        mergeSort(nums, left, mid);</span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//index是temp的下标，i是左区间的初始下标，j是右区间的初始下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//开始比较左区间与右区间的值，小的值赋给temp并向后移动一位</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                temp[index++] = nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当有一个区间遍历完了，就把另一个区间的元素（不用排序）依次赋值给temp</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">            temp[index++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= right) &#123;</span><br><span class="line">            temp[index++] = nums[j++]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//temp是模拟数组，我们要改变原始数组nums，注意nums的初始位置为left+0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; right - left + <span class="number">1</span>;k++) &#123;</span><br><span class="line">            nums[k + left] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>以[4,9,8,5,6]为例：</p>
<p>首先寻找数组中最大值，从8开始，发现其没有子节点（子节点下标越界），然后以9为父节点，子节点5，6都比9小，不动；然后4为父节点，9比4大，数组变为[9,4,8,5,6]然后继续以4为父节点，5比4大，数组变为[9,5,8,4,6]，这次4因为没有子节点而退出方法；然后是9为父节点，子节点没有比他大的，最终数组为[9,5,8,4,6]。这就是注解中提到的不完整的大顶堆，这只保证了最大的数字在数组nums下标为0的位置。</p>
<p>接着进入heapSort()的for循环内，首先从数组最后一个位置遍历，每次把数组最前面的元素移到i，也就是最后，然后将end–，继续排[6,5,8,4]，得到[8,5,6,4]。然后把8移到最后，继续排[5,6,4]，得到[6,5,4]。然后把6移到最后，继续排[5,4]，得到[5,4]。然后把5移到最后，此时end–&#x3D;&#x3D;0，进入maxHeap()后直接跳出，回到for循环i–也为0，则nums数组已排好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        heapSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//nums数组的最后一个位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//构造不完整的大顶堆（nums[0]是数组中的最大值）</span></span><br><span class="line">        buildMaxHeap(nums, end);</span><br><span class="line">        <span class="keyword">while</span>(end &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//不完整的大顶堆可以保证下标为0的位置是数组中的最大值</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, end);</span><br><span class="line">            <span class="comment">//最大值放到最后一位之后，end指针左移一位</span></span><br><span class="line">            end--;</span><br><span class="line">            <span class="comment">//让(0,end)区间的数组最大值上浮到nums[0]</span></span><br><span class="line">            maxHeap(nums, <span class="number">0</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">//这里的i是每个父节点，因为end / 2 之后的节点都是某个节点子节点，所以i从数组中心向左移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end / <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="comment">//每次以i为父节点，移动其他节点（第一次是i的子节点），逐步构造不完整的大顶堆</span></span><br><span class="line">            maxHeap(nums, i, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maxHeap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">//循环条件：必须保证i的左子节点存在</span></span><br><span class="line">        <span class="keyword">while</span>((i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span> &lt;= end) &#123;</span><br><span class="line">            <span class="comment">//i节点的左子节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">lson</span> <span class="operator">=</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//i节点的右子节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rson</span> <span class="operator">=</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//默认数组最大值的下标为i</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">large</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//先比较i的左子节点与自己谁大谁小</span></span><br><span class="line">            <span class="keyword">if</span>(lson &lt;= end &amp;&amp; nums[large] &lt; nums[lson]) &#123;</span><br><span class="line">                large = lson;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里注意：large可能等于lson了，所以要用large和rson比较，让large记录三者中最大的值的位置</span></span><br><span class="line">            <span class="keyword">if</span>(rson &lt;= end &amp;&amp; nums[large] &lt; nums[rson]) &#123;</span><br><span class="line">                large = rson;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果large有变动，说明i节点下沉，继续让i节点与下面的子节点比较，若还有大节点，继续下沉i节点</span></span><br><span class="line">            <span class="keyword">if</span>(large != i) &#123;</span><br><span class="line">                <span class="comment">//让大的子节点上浮，父节点下沉</span></span><br><span class="line">                swap(nums, i, large);</span><br><span class="line">                i = large;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明当前父节点比两个子节点都大，即以当前父节点为根节点的大顶堆建立完成</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![Sorting_heapsort_anim](D:\OneDrive - 东南大学\桌面\Sorting_heapsort_anim.gif)</p>
<h2 id="（CodeTop）leetcode-215-数组中的第K个最大元素"><a href="#（CodeTop）leetcode-215-数组中的第K个最大元素" class="headerlink" title="（CodeTop）leetcode 215.数组中的第K个最大元素"></a>（CodeTop）leetcode 215.数组中的第K个最大元素</h2><p><u><strong>题目</strong>：给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</u></p>
<p><u>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heapSort(nums, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//nums数组的最后一个位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//构造不完整的大顶堆（nums[0]是数组中的最大值）</span></span><br><span class="line">        buildMaxHeap(nums, end);</span><br><span class="line">        <span class="comment">//以k = 1为例，那么我们不应该进入循环交换首尾值，而应该直接返回堆顶值，即我们只需要进行k - 1次堆顶和末尾元素的交换</span></span><br><span class="line">        <span class="keyword">while</span>(end &gt;= nums.length - k + <span class="number">1</span>) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, end);</span><br><span class="line">            end--;</span><br><span class="line">            maxHeap(nums, <span class="number">0</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">//这里的i是每个父节点，因为end / 2 之后的节点都是某个节点子节点，所以i从数组中心向左移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end / <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="comment">//每次以i为父节点，移动其他节点（第一次是i的子节点），逐步构造不完整的大顶堆</span></span><br><span class="line">            maxHeap(nums, i, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maxHeap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">//循环条件：必须保证i的左子节点存在</span></span><br><span class="line">        <span class="keyword">while</span>((i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span> &lt;= end) &#123;</span><br><span class="line">            <span class="comment">//i节点的左子节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">lson</span> <span class="operator">=</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//i节点的右子节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rson</span> <span class="operator">=</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//默认数组最大值的下标为i</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">large</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//先比较i的左子节点与自己谁大谁小</span></span><br><span class="line">            <span class="keyword">if</span>(lson &lt;= end &amp;&amp; nums[large] &lt; nums[lson]) &#123;</span><br><span class="line">                large = lson;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里注意：large可能等于lson了，所以要用large和rson比较，让large记录三者中最大的值的位置</span></span><br><span class="line">            <span class="keyword">if</span>(rson &lt;= end &amp;&amp; nums[large] &lt; nums[rson]) &#123;</span><br><span class="line">                large = rson;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果large有变动，说明i节点下沉，继续让i节点与下面的子节点比较，若还有大节点，继续下沉i节点</span></span><br><span class="line">            <span class="keyword">if</span>(large != i) &#123;</span><br><span class="line">                <span class="comment">//让大的子节点上浮，父节点下沉</span></span><br><span class="line">                swap(nums, i, large);</span><br><span class="line">                i = large;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明当前父节点比两个子节点都大，即以当前父节点为根节点的大顶堆建立完成</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>这种排序方式<strong>只适合正整数</strong>，且<strong>取值范围相差不大</strong>的数组使用，本题如果数组包含负数，还必须<strong>增加一个偏移量</strong>，比较麻烦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//首先获得nums数组的最大值，用于统计构造计数数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> getMinValue(nums);</span><br><span class="line">        <span class="keyword">return</span> countingSort(nums, minValue, maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] countingSort(<span class="type">int</span>[] nums, <span class="type">int</span> minValue, <span class="type">int</span> maxValue) &#123;</span><br><span class="line">        <span class="comment">//根据最大值maxValue构造计数数组</span></span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[maxValue - minValue + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//统计每个值在nums中出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">//避免负数无法从0开始</span></span><br><span class="line">            count[num - minValue]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为了从头开始为nums数组排序，定义一个指针index</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里遍历一定要注意！不是从0到nums.length - 1，而是从0到maxValue</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= maxValue - minValue;i++) &#123;</span><br><span class="line">            <span class="comment">//计数数组从小数向大数遍历，index指针每向后进1，计数数组相应元素则减1</span></span><br><span class="line">            <span class="keyword">while</span>(count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//注意！这里为nums数组赋值时要用i！！！</span></span><br><span class="line">                <span class="comment">//因为前面计数的时候添加了偏移量，所以当前要将偏移量还回去</span></span><br><span class="line">                nums[index++] = i + minValue;</span><br><span class="line">                count[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找数组nums的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; max) &#123;</span><br><span class="line">                max = num;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找数组nums的最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num &lt; min) &#123;</span><br><span class="line">                min = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" alt="img" style="zoom: 75%;" />

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/01/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-id="cl51t3ry10000r8v6ap7w4cjp" data-title="十大排序算法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/26/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-06-26T05:47:11.000Z" itemprop="datePublished">2022-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/26/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Linux学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Linux组管理和权限管理"><a href="#Linux组管理和权限管理" class="headerlink" title="Linux组管理和权限管理"></a>Linux组管理和权限管理</h2><h3 id="1-修改文件所有者"><a href="#1-修改文件所有者" class="headerlink" title="1.修改文件所有者"></a>1.修改文件所有者</h3><p>指令：chown 用户名 文件名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown tom apple.txt</span><br></pre></td></tr></table></figure>

<h3 id="2-组及用户的创建"><a href="#2-组及用户的创建" class="headerlink" title="2.组及用户的创建"></a>2.组及用户的创建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd monster</span><br><span class="line">useradd fox</span><br></pre></td></tr></table></figure>

<h3 id="3-创建用户并将其放入组中"><a href="#3-创建用户并将其放入组中" class="headerlink" title="3.创建用户并将其放入组中"></a>3.创建用户并将其放入组中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -g monster fox</span><br></pre></td></tr></table></figure>

<h3 id="4-改变用户所在组-用户已存在"><a href="#4-改变用户所在组-用户已存在" class="headerlink" title="4.改变用户所在组(用户已存在)"></a>4.改变用户所在组(用户已存在)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g monster fox</span><br></pre></td></tr></table></figure>

<h3 id="5-修改文件-x2F-目录所在组"><a href="#5-修改文件-x2F-目录所在组" class="headerlink" title="5.修改文件&#x2F;目录所在组"></a>5.修改文件&#x2F;目录所在组</h3><p>指令：chgrp 组名 文件&#x2F;目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chgrp fruit orange.text</span><br><span class="line">chgrp fruit lemon</span><br></pre></td></tr></table></figure>

<h3 id="6-权限介绍"><a href="#6-权限介绍" class="headerlink" title="6.权限介绍"></a>6.权限介绍</h3><p>ls -l 显示内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc</span><br></pre></td></tr></table></figure>

<p>第0位是文件类型：-是普通文件，l是链接，d是目录，c是字符设备文件如鼠标键盘，b是块设备如硬盘</p>
<ul>
<li><p>1-3位是<strong>所有者</strong>对文件的权限-User</p>
</li>
<li><p>4-6位是<strong>所属组</strong>对文件的权限-Group</p>
</li>
<li><p>7-9位是<strong>其他用户</strong>对文件的权限-Other</p>
</li>
<li><p>1代表文件的<strong>硬链接数</strong>（文件副本）或者目录的<strong>子目录数</strong>；前面的root代表<strong>所属用户</strong>；后面的root代表<strong>所属组</strong></p>
</li>
<li><p>1213代表<strong>文件大小</strong>（字节）；Feb 2 09:39代表<strong>最后修改时间</strong>；abc代表<strong>文件&#x2F;目录名</strong></p>
<ul>
<li><p>对于普通文件来说：rwx分别是可读取；可修改（不代表可删除）；可被执行（execute）</p>
</li>
<li><p>对于目录来说：rwx分别代表可读取目录内容；可修改包括对目录内部进行创建+删除+重命名操作；可以进入目录</p>
</li>
<li><p>rwx也可以用数字表示，r&#x3D;4,w&#x3D;2,x&#x3D;1</p>
</li>
</ul>
</li>
</ul>
<p>这里的可被执行x权限，对于目录来说是至关重要的：1.因为<strong>目录只有赋予了x执行权限，才可以进入</strong>，否则读r和写w都是空谈；2.有了执行x权限，只能进入目录，<strong>必须有可读r权限才可以看到目录的内容</strong>；3.目录的文件能不能删除，<strong>只取决于文件所在目录是否有写w权限</strong>，没有对目录的w权限就无法删除目录内的任意文件（<em>文件所有者除外</em>  <u>存疑？</u>）。</p>
<p>对于<strong>普通文件</strong>，可执行x权限没什么用。</p>
<p>对于<strong>shell脚本</strong>，如果没有x权限，则无法执行。</p>
<h3 id="7-修改权限"><a href="#7-修改权限" class="headerlink" title="7.修改权限"></a>7.修改权限</h3><p><strong>chmod</strong>(change mode)可修改文件&#x2F;目录的权限       </p>
<p>1.给abc的user读写执行权限，group读和执行权限，other读和执行权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rwx,g=rx,o=rx abc</span><br><span class="line">chmod 755 abc</span><br></pre></td></tr></table></figure>

<p>2.给abc文件user<strong>去除</strong>执行权限，group<strong>增加</strong>写权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u-x,g+w abc</span><br></pre></td></tr></table></figure>

<p>3.给abc文件<strong>所有用户添加</strong>读的权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+r abc</span><br></pre></td></tr></table></figure>

<h3 id="8-修改文件-x2F-目录所有者"><a href="#8-修改文件-x2F-目录所有者" class="headerlink" title="8.修改文件&#x2F;目录所有者"></a>8.修改文件&#x2F;目录所有者</h3><p>指令：chown newowner 文件&#x2F;目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown tom /home/abc.txt</span><br><span class="line">目录及目录下所有文件都改成tom所属，需要用递归-R</span><br><span class="line">chown -R tom /home/test</span><br></pre></td></tr></table></figure>

<h3 id="9-修改文件-x2F-目录所在组"><a href="#9-修改文件-x2F-目录所在组" class="headerlink" title="9.修改文件&#x2F;目录所在组"></a>9.修改文件&#x2F;目录所在组</h3><p>指令：chgrp newgroup 文件&#x2F;目录 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chgrp shaolin /home/abc.text</span><br><span class="line">目录及目录下所有文件都改成shaolin所属，需要用递归-R</span><br><span class="line">chgrp -R shaolin /home/test</span><br></pre></td></tr></table></figure>

<h2 id="Linux定时任务调度"><a href="#Linux定时任务调度" class="headerlink" title="Linux定时任务调度"></a>Linux定时任务调度</h2><h3 id="crond-任务调度"><a href="#crond-任务调度" class="headerlink" title="crond 任务调度"></a>crond 任务调度</h3><p>整个过程就是设置etc&#x2F;crontab任务调度文件：</p>
<p>1.执行crontab -e来编辑定时任务</p>
<p>2.写入具体的定时任务语句</p>
<p><strong>具体实例</strong>：</p>
<p>每隔一分钟，将当前date时间追加到&#x2F;tmp&#x2F;mydate文件中</p>
<p><strong>指令</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e ---&gt; */1**** date &gt;&gt; /tmp/mydate</span><br></pre></td></tr></table></figure>

<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220704155829183.png" alt="image-20220704155829183" style="zoom:70%;" />

<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220704195049537.png" alt="image-20220704195049537" style="zoom:70%;" />

<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220704195205184.png" alt="image-20220704195205184" style="zoom:70%;" />

<h3 id="crond相关指令"><a href="#crond相关指令" class="headerlink" title="crond相关指令"></a>crond相关指令</h3><p>crontab -r : 终止任务调度</p>
<p>crontab -l : 列出当前有哪些任务调度（相当于查看etc&#x2F;crontab文件）</p>
<p>service crond restart : 重启任务调度</p>
<h3 id="at定时任务"><a href="#at定时任务" class="headerlink" title="at定时任务"></a>at定时任务</h3><p>at命令是定时执行一次的命令，必须要求<strong>守护进程atd</strong>在后台进程运行，每60s检查作业队列的运行情况。</p>
<p>可以通过以下命令查看at的守护进程atd是否启动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep atd</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong>：</p>
<p>1.两天后的下午五点执行&#x2F;bin&#x2F;ls &#x2F;home</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">at 5pm + 2days</span><br><span class="line">//输入回车后显示at&gt;，然后在后面输入具体要执行的命令</span><br><span class="line">/bin/ls /home</span><br></pre></td></tr></table></figure>

<p>2.两分钟后，输出指定时间到&#x2F;root&#x2F;date200.log</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">at now + 2 minutes</span><br><span class="line">date &gt; /root/date200.log</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/26/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cl4uw2rde0000w4v6fju620ds" data-title="Linux学习笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-链表题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/24/%E9%93%BE%E8%A1%A8%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-06-24T10:54:39.000Z" itemprop="datePublished">2022-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/24/%E9%93%BE%E8%A1%A8%E9%A2%98%E8%A7%A3/">链表题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="leetcode-203-移除链表元素"><a href="#leetcode-203-移除链表元素" class="headerlink" title="leetcode 203.移除链表元素"></a>leetcode 203.移除链表元素</h2><p><u><strong>题目</strong>：给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</u></p>
<img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img" style="zoom:50%;" />

<p><u>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6</u><br><u>输出：[1,2,3,4,5]&lt;&#x2F;u</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CodeTop-leetcode-206-反转链表"><a href="#CodeTop-leetcode-206-反转链表" class="headerlink" title="(CodeTop) leetcode 206.反转链表"></a>(CodeTop) leetcode 206.反转链表</h2><p><u><strong>题目</strong>：给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表</u>。</p>
<img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img" style="zoom:50%;" />

<p><u>输入：head &#x3D; [1,2,3,4,5]</u><br><u>输出：[5,4,3,2,1]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//只有最后一次递归才会走if语句</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重点：newHead在多次递归中，始终不变</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CodeTop-★leetcode-92-反转链表-II"><a href="#CodeTop-★leetcode-92-反转链表-II" class="headerlink" title="(CodeTop) ★leetcode 92.反转链表 II"></a>(CodeTop) ★leetcode 92.反转链表 II</h2><p><u><strong>题目</strong>：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</u></p>
<img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rightEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="comment">//cur指针走到需要反转的链表的左节点的左边节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; left - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录左节点的左边节点和左节点</span></span><br><span class="line">        leftEdge = cur;</span><br><span class="line">        leftNode = cur.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; right - left + <span class="number">1</span>;i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录右节点和右节点的右边节点</span></span><br><span class="line">        rightNode = cur;</span><br><span class="line">        rightEdge = cur.next;</span><br><span class="line">        <span class="comment">//断开链表</span></span><br><span class="line">        leftEdge.next = <span class="literal">null</span>;</span><br><span class="line">        rightNode.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//反转链表</span></span><br><span class="line">        reverse(leftNode);</span><br><span class="line">        <span class="comment">//重新连接链表</span></span><br><span class="line">        leftEdge.next = rightNode;</span><br><span class="line">        leftNode.next = rightEdge;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转链表的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="☆leetcode-24-两两交换链表中的节点"><a href="#☆leetcode-24-两两交换链表中的节点" class="headerlink" title="☆leetcode 24.两两交换链表中的节点"></a>☆leetcode 24.两两交换链表中的节点</h2><p><u><strong>题目</strong>：给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</u></p>
<img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单指针pre</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="literal">null</span> &amp;&amp; pre.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获得第三个节点（后面的第一个节点）</span></span><br><span class="line">            temp = head.next.next;</span><br><span class="line">            <span class="comment">//将前面的节点与第二个节点相连</span></span><br><span class="line">            pre.next = head.next;</span><br><span class="line">            <span class="comment">//第二个节点与第一个节点相连</span></span><br><span class="line">            head.next.next = head;</span><br><span class="line">            <span class="comment">//第一个节点与第三个节点</span></span><br><span class="line">            head.next = temp;</span><br><span class="line">            <span class="comment">//将前指针指向第一个节点（改之后的第二个节点）</span></span><br><span class="line">            pre = head;</span><br><span class="line">            <span class="comment">//后指针指向第三个节点（下一组节点的首个节点）</span></span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三指针node1,node2,pre</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="literal">null</span> &amp;&amp; pre.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//分别保存第一个节点和第二个节点的位置(避免直接对head进行操作)</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> pre.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> pre.next.next;</span><br><span class="line">            node1.next = node2.next;</span><br><span class="line">            pre.next = node2;</span><br><span class="line">            node2.next = node1;</span><br><span class="line">            pre = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//如果本次不够两个节点，就不需要反转，直接返回该组节点head即可</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存第二个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//当前头结点指向后面反转后的头结点（重点！）</span></span><br><span class="line">        head.next = swapPairs(temp.next);</span><br><span class="line">        <span class="comment">//当前第二个节点指向头结点</span></span><br><span class="line">        temp.next = head;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CodeTop-leetcode-19-删除链表的倒数第N个结点"><a href="#CodeTop-leetcode-19-删除链表的倒数第N个结点" class="headerlink" title="(CodeTop) leetcode 19.删除链表的倒数第N个结点"></a>(CodeTop) leetcode 19.删除链表的倒数第N个结点</h2><p><u><strong>题目</strong>：给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</u></p>
<img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以倒数第二个节点n&#x3D;2为例，我们发现：只要让后指针cur从dummy向右走n个节点，那么cur和pre始终相隔n个节点。这样，当cur和pre同时向后走的时候，cur走到了最后一个节点时pre正好走到<strong>待删除节点的前面一个节点</strong>。</p>
<h2 id="CodeTop-剑指Offer-22-链表中倒数第K个节点"><a href="#CodeTop-剑指Offer-22-链表中倒数第K个节点" class="headerlink" title="(CodeTop) 剑指Offer 22.链表中倒数第K个节点"></a>(CodeTop) 剑指Offer 22.链表中倒数第K个节点</h2><p><u><strong>题目</strong>：输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</u></p>
<p><u>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</u></p>
<p><u>示例：</u><br><u>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</u><br><u>返回链表 4-&gt;5</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy, cur = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CodeTop-leetcode-142-环形链表-II"><a href="#CodeTop-leetcode-142-环形链表-II" class="headerlink" title="(CodeTop) leetcode 142 环形链表 II"></a>(CodeTop) leetcode 142 环形链表 II</h2><p><u><strong>题目</strong>：给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</u></p>
<p><u>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</u></p>
<p><u>不允许修改链表。</u></p>
<img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针-复杂度：时间o(n),空间o(1)</span></span><br><span class="line"><span class="comment">//时间复杂度这里按slow算，一共只会走一个链表长度，因为当slow入环的时候，slow相对fast静止，fast每次走一个位置，肯定会在小于一个圈的距离追上slow</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">//一旦两指针相遇，就定义一个从head头指针出发的init指针，slow指针默认向后走</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">init</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span>(init != slow) &#123;</span><br><span class="line">                    init = init.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//哈希法-复杂度：时间o(n),空间o(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(cur)) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CodeTop-leetcode-160-x2F-面试题02-07-链表相交"><a href="#CodeTop-leetcode-160-x2F-面试题02-07-链表相交" class="headerlink" title="(CodeTop) leetcode 160&#x2F;面试题02.07.链表相交"></a>(CodeTop) leetcode 160&#x2F;面试题02.07.链表相交</h2><p><u><strong>题目</strong>：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</u></p>
<p><u>图示两个链表在节点 c1 开始相交：</u></p>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img" style="zoom:50%;" />

<p><u>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</u></p>
<p><u><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一：时间o(m + n),空间o(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA, curB = headB;</span><br><span class="line">        <span class="keyword">while</span>(curA != curB) &#123;</span><br><span class="line">            <span class="comment">//这里第一个=后面一定要是cur而不能是cur.next，否则会陷入死循环</span></span><br><span class="line">            curA = curA != <span class="literal">null</span> ? curA.next : headB;</span><br><span class="line">            curB = curB != <span class="literal">null</span> ? curB.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法二：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA, curB = headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">1</span>, lenB = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//1.先把AB链表的长度求出来</span></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">null</span>) &#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(curB != <span class="literal">null</span>) &#123;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.易错！！！：一定要先归位，否则后面两两交换的指针curA,curB是null</span></span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">//3.判断谁大，B大就把A换成B</span></span><br><span class="line">        <span class="keyword">if</span>(lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> lenA;</span><br><span class="line">            lenA = lenB;</span><br><span class="line">            lenB = temp;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> curA;</span><br><span class="line">            curA = curB;</span><br><span class="line">            curB = tempNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.计算两链表差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> lenA - lenB;</span><br><span class="line">        <span class="comment">//5.让长链表的指针指向与短链表等长的位置</span></span><br><span class="line">        <span class="keyword">while</span>(len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.让A和B在相等长度的起点同时向后走</span></span><br><span class="line">        <span class="keyword">while</span>(curA != curB) &#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法三：时间o(m + n),空间o(m)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">null</span>) &#123;</span><br><span class="line">            set.add(curA);</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span>(curB != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(curB)) &#123;</span><br><span class="line">                <span class="keyword">return</span> curB;</span><br><span class="line">            &#125;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题法一的思路就是：我们假设AB有公共部分长度为c，A总长度为a，那么非公共长度就是a - c；同理，B总长度为b，非公共长度为b - c。那么当A从头走到尾的时候（curA &#x3D;&#x3D; null），再继续从B的头结点headB继续向后走，直到走到公共节点时，一共走了a + (b - c)；而B从头走到尾，再从headA走到公共节点，一共走了b + (a - c)；我们发现这两个长度是相等的。</p>
<p>如果没有公共交点，那么两个指针curA和curB最多走完a + b（最少就是两链表长度相等，各自走完自己的长度就同时等于零了）最后到null的时候就可以返回null了。双方一定是同时走到null的。</p>
<p>所以总的来说循环条件就是curA !&#x3D; curB。</p>
<h2 id="leetcode-141-环形链表"><a href="#leetcode-141-环形链表" class="headerlink" title="leetcode 141.环形链表"></a>leetcode 141.环形链表</h2><p><u><strong>题目</strong>：给你一个链表的头节点 head ，判断链表中是否有环。</u></p>
<p><u>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</u></p>
<p><u>如果链表中存在环 ，则返回 true 。 否则，返回 false</u> </p>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针-复杂度：时间o(n),空间o(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//哈希表-复杂度：时间o(n),空间o(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(cur)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CodeTop-leetcode-21-合并两个有序链表"><a href="#CodeTop-leetcode-21-合并两个有序链表" class="headerlink" title="(CodeTop) leetcode 21.合并两个有序链表"></a>(CodeTop) leetcode 21.合并两个有序链表</h2><p><u><strong>题目</strong>：将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</u></p>
<img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="literal">null</span>) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val) &#123;</span><br><span class="line">            list1.next = mergeTwoLists(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            list2.next = mergeTwoLists(list1, list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代法 复杂度：时间o(n)，空间o(1)：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">//只要有一个链表节点不为空，就进入循环</span></span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//谁小我们就让cur指向谁</span></span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt; list2.val) &#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记住每次cur要向后移动一位</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后最多只有一个链表未合并，谁不空，就把cur.next连上这个链表</span></span><br><span class="line">        cur.next = list1 == <span class="literal">null</span> ? list2 : list1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CodeTop-leetcode-2-两数相加"><a href="#CodeTop-leetcode-2-两数相加" class="headerlink" title="(CodeTop) leetcode 2,两数相加"></a>(CodeTop) leetcode 2,两数相加</h2><p><u><strong>题目</strong>：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</u><u>请你将两个数相加，并以相同形式返回一个表示和的链表。</u></p>
<p><u>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</u></p>
<p><u>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</u><br><u>输出：[7,0,8]</u><br><u>解释：342 + 465 &#x3D; 807.</u></p>
<p><u>输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</u><br><u>输出：[8,9,9,9,0,0,0,1]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>, cur = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">extra</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l1 != <span class="literal">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> l2 != <span class="literal">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            sum = m + n + extra;</span><br><span class="line">            <span class="comment">//头结点特殊处理</span></span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">                head = cur = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//头结点后面的节点</span></span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每次记录进位制extra</span></span><br><span class="line">            extra = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//因为当前while循环只能保证一个节点非空，所以l1和l2向后移动的时候都需要判断一下</span></span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后l1和l2都为空，可能还有进位制未处理</span></span><br><span class="line">        <span class="keyword">if</span>(extra &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(extra);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回头结点head</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CodeTop-leetcode-23-合并K个有序链表-优先队列未完成"><a href="#CodeTop-leetcode-23-合并K个有序链表-优先队列未完成" class="headerlink" title="(CodeTop) leetcode 23.合并K个有序链表(优先队列未完成)"></a>(CodeTop) leetcode 23.合并K个有序链表(优先队列未完成)</h2><p><u><strong>题目</strong>：给你一个链表数组，每个链表都已经按<strong>升序</strong>排列。</u></p>
<p><u>请你将所有链表合并到一个升序链表中，返回合并后的链表。</u></p>
<p><u>输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</u><br><u>输出：[1,1,2,3,4,4,5,6]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序合并(逐个迭代)-复杂度(k个链表)：时间o(k2n),空间o(1)：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; lists.length;i++) &#123;</span><br><span class="line">            ans = mergeTwoLists(ans, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt; list2.val) &#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1 == <span class="literal">null</span> ? list2 : list1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分治法（迭代）-复杂度：时间o(kn × logk),空间o(logk)递归栈空间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="keyword">return</span> lists[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//这里的分治，会占用栈空间，所以空间复杂度为o(logk)，k为链表个数</span></span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(merge(lists, left, mid), merge(lists, mid + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt; list2.val) &#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1 == <span class="literal">null</span> ? list2 : list1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆/优先队列法：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="leetcode-61-旋转链表"><a href="#leetcode-61-旋转链表" class="headerlink" title="leetcode 61.旋转链表"></a>leetcode 61.旋转链表</h2><p><u><strong>题目</strong>：给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</u></p>
<img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//1.首先要判空</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//2.让cur指针走到最后一个节点，并计算链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.链接尾指针与头指针</span></span><br><span class="line">        cur.next = head;</span><br><span class="line">        <span class="comment">//4.关键！！！：计算cur指针要走的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">path</span> <span class="operator">=</span> len - k % len;</span><br><span class="line">        <span class="comment">//5.让cur指针走向&quot;新头结点&quot;的前面一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(path-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.断开链表，返回新头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-83-删除排序链表中的重复元素"><a href="#leetcode-83-删除排序链表中的重复元素" class="headerlink" title="leetcode 83.删除排序链表中的重复元素"></a>leetcode 83.删除排序链表中的重复元素</h2><p><u><strong>题目</strong>：给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</u></p>
<img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == cur.next.val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（CodeTop）leetcode-82-删除排序链表中的重复元素-II"><a href="#（CodeTop）leetcode-82-删除排序链表中的重复元素-II" class="headerlink" title="（CodeTop）leetcode 82.删除排序链表中的重复元素 II"></a>（CodeTop）leetcode 82.删除排序链表中的重复元素 II</h2><p><u>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</u></p>
<img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">200</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">//1.这里cur是从哑节点开始的，所以要判断cur.next和cur.next.next</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">                <span class="comment">//2.一旦相等，就要把所有相等的元素一个一个的删除</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">delNum</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="comment">//3.每次一个个删除的时候，要避免空指针操作</span></span><br><span class="line">                <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == delNum) &#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//4.不相等就继续向后走</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-86-分割链表"><a href="#leetcode-86-分割链表" class="headerlink" title="leetcode 86.分割链表"></a>leetcode 86.分割链表</h2><p><u>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</u></p>
<p><u>你应当 保留 两个分区中每个节点的初始相对位置。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">smallDummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">small</span> <span class="operator">=</span> smallDummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">largeDummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">large</span> <span class="operator">=</span> largeDummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val &lt; x) &#123;</span><br><span class="line">                small.next = cur;</span><br><span class="line">                small = small.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                large.next = cur;</span><br><span class="line">                large = large.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里一定要让large指向null，否则链表会有环</span></span><br><span class="line">        large.next = <span class="literal">null</span>;</span><br><span class="line">        small.next = largeDummy.next;</span><br><span class="line">        <span class="keyword">return</span> smallDummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CodeTop-leetcode-143-重排链表"><a href="#CodeTop-leetcode-143-重排链表" class="headerlink" title="(CodeTop) leetcode 143.重排链表"></a>(CodeTop) leetcode 143.重排链表</h2><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>
<p>L0 → L1 → … → Ln - 1 → Ln</p>
<p>请将其重新排列后变为：</p>
<p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</p>
<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。13407197451</p>
<img src="https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftEnd</span> <span class="operator">=</span> getMid(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rightHead</span> <span class="operator">=</span> leftEnd.next;</span><br><span class="line">        leftEnd.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newRightHead</span> <span class="operator">=</span> reverse(rightHead);</span><br><span class="line">        reorder(head, newRightHead);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取中点，取两中点的前一个</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getMid</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转链表</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorder</span><span class="params">(ListNode left, ListNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> left.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> right.next;</span><br><span class="line">            left.next = right;</span><br><span class="line">            left = node1;</span><br><span class="line">            right.next = left;</span><br><span class="line">            right = node2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线性表法：空间o(n),时间o(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            list.get(i).next = list.get(j);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.get(j).next = list.get(i);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最关键的一步，一定不能丢</span></span><br><span class="line">        list.get(i).next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-234-回文链表"><a href="#leetcode-234-回文链表" class="headerlink" title="leetcode 234.回文链表"></a>leetcode 234.回文链表</h2><p><u>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</u></p>
<img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//主方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftHead</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftEnd</span> <span class="operator">=</span> getMid(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rightHead</span> <span class="operator">=</span> leftEnd.next;</span><br><span class="line">        leftEnd.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newRightHead</span> <span class="operator">=</span> reverse(rightHead);</span><br><span class="line">        <span class="keyword">return</span> compare(leftHead, newRightHead);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取中间节点（该方法注意细节，4个节点的中间节点是第2个节点）</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getMid</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转链表，并返回新的头结点</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断两个链表的每个节点是否一一相等</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(ListNode left, ListNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left.val == right.val) &#123;</span><br><span class="line">                left = left.next;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-237-删除链表中的节点"><a href="#leetcode-237-删除链表中的节点" class="headerlink" title="leetcode 237.删除链表中的节点"></a>leetcode 237.删除链表中的节点</h2><p><u><strong>题目</strong>：请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。</u></p>
<p><u>题目数据保证需要删除的节点 不是末尾节点 。</u></p>
<img src="https://assets.leetcode.com/uploads/2020/09/01/node1.jpg" alt="img" style="zoom: 33%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">        node.val = next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-876-链表的中间结点"><a href="#leetcode-876-链表的中间结点" class="headerlink" title="leetcode 876.链表的中间结点"></a>leetcode 876.链表的中间结点</h2><p><u><strong>题目</strong>：给定一个头结点为 <code>head</code> 的非空单链表，返回链表的中间结点。</u></p>
<p><u>如果有两个中间结点，则返回第二个中间结点。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/24/%E9%93%BE%E8%A1%A8%E9%A2%98%E8%A7%A3/" data-id="cl4uw2rdm0001w4v680s74f42" data-title="链表题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-acm输入输出练习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/20/acm%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2022-06-20T08:36:04.000Z" itemprop="datePublished">2022-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/20/acm%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/">acm输入输出练习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="A-B-1"><a href="#A-B-1" class="headerlink" title="A+B(1)"></a>A+B(1)</h2><p><u>题目：输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 1000)，输入的数据包括多组，输出a+b的结果</u></p>
<p><u>输入</u>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 5</span><br><span class="line">10 20</span><br></pre></td></tr></table></figure>

<p><u>输出</u>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//sc.next()默认返回字符串，所以要转型，sc.nextInt()返回int型变量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(sc.next());<span class="comment">//或者写sc.nextInt()</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(sc.next());</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-2"><a href="#A-B-2" class="headerlink" title="A+B(2)"></a>A+B(2)</h2><p><u>题目：第一行输入数据组数t，第二行及以后输入a，b，输出每行a+b的结果</u></p>
<p><u>输入</u>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 5</span><br><span class="line">10 20</span><br></pre></td></tr></table></figure>

<p><u>输出</u>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//就比上面一题多了一个明确的行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-3"><a href="#A-B-3" class="headerlink" title="A+B(3)"></a>A+B(3)</h2><p><u>题目：输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据有多组, 如果输入为0 0则结束输入，输出a+b的结果</u></p>
<p><u>输入</u>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 5</span><br><span class="line">10 20</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>

<p><u>输出</u>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//break也行，效果一样</span></span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-4"><a href="#A-B-4" class="headerlink" title="A+B(4)"></a>A+B(4)</h2><p><u>题目：输入的每行数据的开头第一个数字是本行需要求和的数字个数n，当n为0时，代表本行没有要求和的数字，即结束输入，请输出每组数据求和的结果。</u></p>
<p><u>输入</u>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 1 2 3 4</span><br><span class="line">5 1 2 3 4 5</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><u>输出</u>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="comment">//每行头部的n为0则跳出循环，结束本方法</span></span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                ans += a;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-5"><a href="#A-B-5" class="headerlink" title="A+B(5)"></a>A+B(5)</h2><p><u>题目：输入的第一行包括一个正整数t(1 &lt;&#x3D; t &lt;&#x3D; 100), 表示数据组数。</u><br><u>接下来t行, 每行一组数据。</u><br><u>每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。</u><br><u>接下来n个正整数, 即需要求和的每个正整数。</u></p>
<p><u>输入</u>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4 1 2 3 4</span><br><span class="line">5 1 2 3 4 5</span><br></pre></td></tr></table></figure>

<p><u>输出</u>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">        	<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; size;j++) &#123;</span><br><span class="line">            	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                ans += a;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-6"><a href="#A-B-6" class="headerlink" title="A+B(6)"></a>A+B(6)</h2><p><u>题目：输入数据有多组, 每行表示一组输入数据。</u><br><u>每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。</u><br><u>接下来n个正整数, 即需要求和的每个正整数。</u></p>
<p><u>输入</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 1 2 3 4</span><br><span class="line">5 1 2 3 4 5</span><br></pre></td></tr></table></figure>

<p><u>输出</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                ans += a;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-7"><a href="#A-B-7" class="headerlink" title="A+B(7)"></a>A+B(7)</h2><p><u>题目：输入数据有多组, 每行表示一组输入数据。</u></p>
<p><u>每行不定有n个整数，空格隔开。(1 &lt;&#x3D; n &lt;&#x3D; 100)。</u></p>
<p><u>输入</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5</span><br><span class="line">0 0 0 0 0</span><br></pre></td></tr></table></figure>

<p><u>输出</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">9</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//将每一个回车分割的每行用空格分开的字符串打包成字符串数组</span></span><br><span class="line">            String[] str = sc.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(String s : str) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line">                ans += a;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串排序-1"><a href="#字符串排序-1" class="headerlink" title="字符串排序(1)"></a>字符串排序(1)</h2><p><u>题目：输入有两行，第一行n</u></p>
<p><u>第二行是n个字符串，字符串之间用空格隔开</u></p>
<p><u>输出一行排序后的字符串，空格隔开，无结尾空格</u>                  </p>
<p><u>输入</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">c d a bb e</span><br></pre></td></tr></table></figure>

<p><u>输出</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a bb c d e</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">//也可以用sc.nextLine().split(&quot; &quot;)获得字符串数组strs，然后Arrays.sort(strs)</span></span><br><span class="line">        PriorityQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            queue.offer(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; num - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            System.out.print(queue.poll() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串排序-2"><a href="#字符串排序-2" class="headerlink" title="字符串排序(2)"></a>字符串排序(2)</h2><p><u><strong>题目</strong>：多个测试用例，每个测试用例一行。</u></p>
<p><u>每行通过空格隔开，有n个字符，n＜100</u></p>
<p><u>对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开</u>            </p>
<p><u>输入</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a c bb</span><br><span class="line">f dddd</span><br><span class="line">nowcoder</span><br></pre></td></tr></table></figure>

<p><u>输出</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a bb c</span><br><span class="line">dddd f</span><br><span class="line">nowcoder</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNextLine()) &#123;</span><br><span class="line">            String[] strs = sc.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            Arrays.sort(strs);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strs.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">                System.out.print(strs[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(strs[strs.length - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串排序-3"><a href="#字符串排序-3" class="headerlink" title="字符串排序(3)"></a>字符串排序(3)</h2><p><u><strong>题目</strong>：多个测试用例，每个测试用例一行。</u><br><u>每行通过,隔开，有n个字符，n＜100</u></p>
<p><u>对于每组用例输出一行排序后的字符串，用’,’隔开，无结尾空格</u>          </p>
<p><u>输入</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a,c,bb</span><br><span class="line">f,dddd</span><br><span class="line">nowcoder</span><br></pre></td></tr></table></figure>

<p><u>输出</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a,bb,c</span><br><span class="line">dddd,f</span><br><span class="line">nowcoder</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNextLine()) &#123;</span><br><span class="line">            String[] strs = sc.nextLine().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            Arrays.sort(strs);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strs.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">                System.out.print(strs[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(strs[strs.length - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String的split-使用场景"><a href="#String的split-使用场景" class="headerlink" title="String的split()使用场景"></a>String的split()使用场景</h2><p>摘自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/take-it-easy/p/14631012.html">笔试：处理输入基础 - 将来的事 - 博客园 (cnblogs.com)</a></p>
<p>预热：将下列输入存入数组中</p>
<p><img src="https://img2020.cnblogs.com/blog/1826667/202104/1826667-20210408101623074-1249320484.png" alt="img" style="zoom: 67%;" /><img src="https://img2020.cnblogs.com/blog/1826667/202104/1826667-20210408101647981-1168655401.png" alt="img" style="zoom: 80%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        String[][] tables = <span class="keyword">new</span> <span class="title class_">String</span>[num][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">            tables[i][<span class="number">0</span>] = sc.next();</span><br><span class="line">            tables[i][<span class="number">1</span>] = sc.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将下列输入存储到数组或集合中</p>
<p><img src="https://img2020.cnblogs.com/blog/1826667/202104/1826667-20210408101739403-2108315231.png" alt="img" style="zoom: 67%;" /><img src="https://img2020.cnblogs.com/blog/1826667/202104/1826667-20210408101755781-1529841151.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//用存放Integer类型的集合存放第一行数据</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        String[] strs = sc.nextLine().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str : strs) &#123;</span><br><span class="line">            list.add(Integer.parseInt(str));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用存放Integer数组的集合存放第二行数据</span></span><br><span class="line">        String[] strs2 = sc.nextLine().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        List&lt;Integer[]&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str : strs2) &#123;</span><br><span class="line">            Integer[] nums = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">2</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = Integer.parseInt(str.split(<span class="string">&quot;-&gt;&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">            nums[<span class="number">1</span>] = Integer.parseInt(str.split(<span class="string">&quot;-&gt;&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">            list2.add(nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将下列数据存放到数组中</p>
<p><img src="https://img2020.cnblogs.com/blog/1826667/202104/1826667-20210408101835317-177328839.png" alt="img" style="zoom: 80%;" /><img src="https://img2020.cnblogs.com/blog/1826667/202104/1826667-20210408101928499-1327331187.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] tables = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; row;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; col;j++) &#123;</span><br><span class="line">                tables[i][j] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/20/acm%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/" data-id="cl4mhgufq00006gv67liz9zsx" data-title="acm输入输出练习" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-贪心系列题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/04/%E8%B4%AA%E5%BF%83%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-06-04T03:14:58.000Z" itemprop="datePublished">2022-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/04/%E8%B4%AA%E5%BF%83%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/">贪心系列题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="leetcode-455-分发饼干"><a href="#leetcode-455-分发饼干" class="headerlink" title="leetcode 455.分发饼干"></a>leetcode 455.分发饼干</h2><p><u><strong>题目</strong>：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</u></p>
<p><u>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</u></p>
<p><u>输入: g &#x3D; [1,2,3], s &#x3D; [1,1]</u><br><u>输出: 1</u><br><u>输入: g &#x3D; [1,2], s &#x3D; [1,2,3]</u><br><u>输出: 2</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小饼干先喂饱小胃口，饼干从小到大遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length &amp;&amp; start &lt; g.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= g[start]) &#123;</span><br><span class="line">                start++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大饼干先喂饱大胃口，胃口从大到小遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> g.length - <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; start &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start] &gt;= g[i]) &#123;</span><br><span class="line">                start--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们肯定先想到的是两层for循环，实际上有一层for循环可以随着count的增加而变化，那么是小饼干还是胃口呢？对于<u>小胃口优先吃饱</u>的思路，如果饼干喂不饱胃口最小的人，肯定要<strong>逐一寻找更大的饼干</strong>，所以一直增大的指针是饼干的数组，而胃口数组的指针必须<strong>喂饱一个再向后走</strong>一个。</p>
<p>对于大胃口优先吃饱的思路，我们知道，最大的胃口一般都满足不了，所以这个时候我们要<strong>逐一去减小胃口</strong>，直到找到能满足最大饼干的<strong>最大胃口的位置</strong>，所以饼干的指针要等到<strong>能喂饱人了再向前走</strong>。</p>
<h2 id="★-leetcode-376-摆动序列"><a href="#★-leetcode-376-摆动序列" class="headerlink" title="★ leetcode 376.摆动序列"></a>★ leetcode 376.摆动序列</h2><p><u><strong>题目</strong>：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</u></p>
<p><u>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</u></p>
<p><u>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</u><br><u>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</u></p>
<p><u>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//假设最左边还有一个nums[0]，构造一个假的preDiff初始化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//随时用来记录当前节点与前一个节点的差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从第二个数开始算起，所以默认第一个元素一定算进来</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从第二个元素开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="comment">//每次都与前一个元素计算差值</span></span><br><span class="line">            curDiff = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//preDiff == 0的情况只出现在第一次</span></span><br><span class="line">            <span class="keyword">if</span>((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                preDiff = curDiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题就是每次遍历到一个元素，都与前一个做差值，然后比较一下本次差值和上一次差值是不是符号相反，如果相反就累加一个数，如果相同就继续下次循环。</p>
<p>但是第一个元素没有与之做差的元素，所以就<strong>假装最前面还有一个nums[0]<strong>，这样，第一个差值我们就默认为0，所以判断条件里边写的是</strong>preDiff大于等于或小于等于0</strong>。其实这个等号只是最开始的preDiff会等于0，后面随着每次preDiff &#x3D; curDiff，preDiff没有机会再等于0了。</p>
<h2 id="leetcode-53-最大子序和"><a href="#leetcode-53-最大子序和" class="headerlink" title="leetcode 53.最大子序和"></a>leetcode 53.最大子序和</h2><p><u><strong>题目</strong>：给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</u></p>
<p><u><strong>子数组</strong> 是数组中的一个连续部分。</u></p>
<p><u>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</u><br><u>输出：6</u><br><u>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//注意res的初始化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>, res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            pre = Math.max(x, pre + x);</span><br><span class="line">            res = Math.max(pre, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里res很容易初始化为0，如果nums数组中只有{-1}，那么res &#x3D; 0是错的，所以既然res一定是记录nums中一个或几个数字之和，而且nums中含有负数，就让res初始化为nums[0]即可。</p>
<h2 id="leetcode-122-买卖股票的最佳时机-II"><a href="#leetcode-122-买卖股票的最佳时机-II" class="headerlink" title="leetcode 122.买卖股票的最佳时机 II"></a>leetcode 122.买卖股票的最佳时机 II</h2><p><u><strong>题目</strong>：给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</u></p>
<p><u>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</u></p>
<p><u>返回 你能获得的 最大 利润 。</u></p>
<p><u>输入：prices &#x3D; [7,1,5,3,6,4]</u><br><u>输出：7</u><br><u>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 总利润为 4 + 3 &#x3D; 7 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心法，有一点利润就算数：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                sum += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态规划：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//第一天持有股票时的最大利润</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//第一天不持有股票时的最大利润</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>贪心法其实就是<strong>累计利润</strong>的思路</p>
<h2 id="leetcode-55-跳跃游戏"><a href="#leetcode-55-跳跃游戏" class="headerlink" title="leetcode 55.跳跃游戏"></a>leetcode 55.跳跃游戏</h2><p><u><strong>题目</strong>：给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</u></p>
<p><u>数组中的每个元素代表你在该位置可以跳跃的<strong>最大长度</strong>。</u></p>
<p><u>判断你是否能够到达最后一个下标。</u></p>
<p><u>输入：nums &#x3D; [2,3,1,1,4]</u><br><u>输出：true</u><br><u>输入：nums &#x3D; [3,2,1,0,4]</u><br><u>输出：false</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误解法1：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            cover = Math.max(cover, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cover &gt;= nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误解法2：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= cover;i++) &#123;</span><br><span class="line">            cover = Math.max(cover, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cover &gt;= nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确的贪心解法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= cover;i++) &#123;</span><br><span class="line">            cover = Math.max(cover, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(cover &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实本题只要始终记录当前节点能覆盖到的最大范围即可。</p>
<p>但是<u>错误解法1</u>就是犯了每个节点<strong>不停地</strong>算最大cover的错误，我们要知道，<strong>不是每个节点都能遍历到的</strong>，比如[3,2,1,0,4]中的0就永远走不到，那就谈不上计算最后4位置的覆盖范围了。</p>
<p>错误解法2将nums.length范围缩小到<strong>一直变化的cover</strong>了，但是还是有很大问题，比如某个节点的<strong>覆盖范围非常大</strong>，那么接下来i就需要遍历非常大的长度才可以，但是nums可能根本没有这么大长度。</p>
<p>所以<strong>每次</strong>得到当前最大覆盖范围的时候，都要判断<strong>当前的覆盖范围能不能走到最后一个位置</strong>，如果可以的话，就直接返回true了。</p>
<h2 id="☆leetcode-45-跳跃游戏-II"><a href="#☆leetcode-45-跳跃游戏-II" class="headerlink" title="☆leetcode 45.跳跃游戏 II"></a>☆leetcode 45.跳跃游戏 II</h2><p><u><strong>题目</strong>：给你一个非负整数数组 nums ，你<strong>最初</strong>位于数组的<strong>第一个位置</strong>。</u></p>
<p><u>数组中的每个元素代表你在该位置可以跳跃的<strong>最大长度</strong>。</u></p>
<p><u>你的目标是使用<strong>最少的跳跃次数</strong>到达数组的最后一个位置。</u></p>
<p><u>假设你<strong>总是可以</strong>到达数组的最后一个位置</u></p>
<p><u>输入: nums &#x3D; [2,3,1,1,4]</u><br><u>输出: 2</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curRange</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//当前的最大覆盖的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextRange</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//下一步最大覆盖的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录当前走的最大步数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++) &#123;<span class="comment">//注意这里时走到nums.length - 2的位置</span></span><br><span class="line">            nextRange = Math.max(nextRange, nums[i] + i);<span class="comment">//随时下一步最大的覆盖的下标</span></span><br><span class="line">            <span class="keyword">if</span>(i == curRange) &#123;<span class="comment">//一旦当前下标与当前最大覆盖的下标重合</span></span><br><span class="line">                curRange = nextRange;<span class="comment">//更新当前最大覆盖下标为下一个最大覆盖的下标</span></span><br><span class="line">                res++;<span class="comment">//最大步数+1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的贪心策略比较难懂：从一开始先记录第一个最大覆盖范围curRange，然后每次遍历当前节点都记录下一步的最大覆盖范围下标nextRange，这个值是一直变化的，<strong>目的是</strong>等到下标i走到与当前最大覆盖范围下标重合的时候，<strong>更新curRange</strong>。</p>
<p>所以每次只有在当前下标i与当前最大覆盖范围的下标curRange重合的时候，才算一次步数，即ans++。而且只有在这个时候，才更新curRange。</p>
<p>最后的重点就是：<strong>i最后一步是走到nums.length - 2的位置</strong>，下图给出了很明显的解释。如果走到nums.length - 2了，但<strong>没有与curRange重合</strong>，说明当前的覆盖范围已经<strong>足够走到</strong>最后一位了，即nums.length - 1的位置，没有必要再增加步数了；如果<strong>与curRange重合</strong>了，说民当前还<strong>需要再走一步</strong>才可以到达nums.length - 1的位置，所以正好<strong>最后一次循环</strong>还需要进行**ans++**。</p>
<p><img src="https://img-blog.csdnimg.cn/20201201232338693.png" alt="45.跳跃游戏II1" style="zoom: 50%;" /><img src="https://img-blog.csdnimg.cn/20201201232445286.png" alt="45.跳跃游戏II2" style="zoom: 50%;" /></p>
<h2 id="leetcode-1005-K次取反后最大化的数组和"><a href="#leetcode-1005-K次取反后最大化的数组和" class="headerlink" title="leetcode 1005.K次取反后最大化的数组和"></a>leetcode 1005.K次取反后最大化的数组和</h2><p><u><strong>题目</strong>：给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</u></p>
<p><u>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。</u><br><u>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</u></p>
<p><u>以这种方式修改数组后，返回数组 可能的最大和 。</u></p>
<p><u>输入：nums &#x3D; [4,2,3], k &#x3D; 1</u><br><u>输出：5</u><br><u>解释：选择下标 1 ，nums 变为 [4,-2,3] 。</u><br><u>输入：nums &#x3D; [3,-1,0,2], k &#x3D; 3</u><br><u>输出：6</u><br><u>解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] *= -<span class="number">1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为有些负数变成正数之后，比原来的正数还要小，所以一旦k为奇数，还需要对他们进行转为负数的操作</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">1</span>) nums[<span class="number">0</span>] *= -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题就是先对数组排序，然后将数组中的负数全部转换为正数，一旦跳出循环，有三种可能：<u>一种可能就是k还不等于0且数组中也没有负数了</u>，那么就要看<strong>k是不是奇数</strong>，如果是奇数，还需要对数组中最小的非负数进行转为负数的操作，但是这个时候，我们<strong>不知道谁是最小的非负数</strong>，所以还需要对数组再进行排列。<u>另一种可能是k为0，数组中还有负数</u>，那没办法，这些负数因为比较小，被转换为正数的优先级也小，轮不到他们被转换为正数，直接求和即可。</p>
<p>最后一种可能就是<u>k等于0了，而数组中的元素已经没有负数</u>了，这种情况最好了，把k都用了，负数也全部转换成正数了，直接求和即可。</p>
<h2 id="leetcode-134-加油站"><a href="#leetcode-134-加油站" class="headerlink" title="leetcode 134.加油站"></a>leetcode 134.加油站</h2><p><u><strong>题目</strong>：在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</u></p>
<p><u>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</u></p>
<p><u>给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</u></p>
<p><u>输入: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]</u><br><u>输出: 3</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录一段区域差值的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录从0到尾的整个区域的差值最大和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录当前合理的出发点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; gas.length;i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//一旦当前差值的和 &lt; 0，就置零，并将索引向后移动一位</span></span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">                index = (i + <span class="number">1</span>) % gas.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//总的差值总和小于零，说明没有合适的出发点</span></span><br><span class="line">        <span class="keyword">if</span>(totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的思路就是：每次从0位置开始累加当前（加油-耗油的差值），一旦这个差值小于0，说明<strong>这一段区间都不能作为出发点</strong>，所以要从<strong>下一个位置</strong>开始出发，并将刚刚<strong>累加的差值归零</strong>。不要忘了定义一个totalSum用来记录整个过程中的差值累计，如果这个累计最后是负的，说明<strong>加油的量还没有耗油的量多</strong>，又因为出发点车没有油，所以totalSum&lt;0必然没有可靠的出发点。</p>
<h2 id="leetcode-135-分发糖果"><a href="#leetcode-135-分发糖果" class="headerlink" title="leetcode 135.分发糖果"></a>leetcode 135.分发糖果</h2><p><u><strong>题目</strong>：n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</u></p>
<p><u>你需要按照以下要求，给这些孩子分发糖果：</u></p>
<p><u>每个孩子至少分配到 1 个糖果。</u><br><u>相邻两个孩子评分更高的孩子会获得更多的糖果。</u><br><u>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</u></p>
<p><u>输入：ratings &#x3D; [1,0,2]</u><br><u>输出：5 (2、1、2)</u></p>
<p><u>输入：ratings &#x3D; [1,2,2]</u><br><u>输出：4 (1、2、1)</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] candy = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        candy[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; ratings.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//本次循环，只保证右边比左边评分高时，右边比左边多一个糖果</span></span><br><span class="line">                candy[i] = candy[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//初始化</span></span><br><span class="line">                candy[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//本次循环，保证左边比右边评分高时，当前糖果既比左边多，也比右边多</span></span><br><span class="line">                candy[i] = Math.max(candy[i], candy[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : candy) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的思路就是先从左到右遍历，比较后面的比前面评分高的学生，只保证<u>右边比左边评分高时</u>，<strong>右边比左边多一个糖果</strong>，记住，一定要初始化（右边评分等于或小于左边评分时，要给1颗糖果）。第二次遍历就是从右向左遍历，保证<u>左边比右边评分高时</u>，当前糖果<strong>既比左边多，也比右边多</strong>。</p>
<h2 id="leetcode-860-柠檬水找零"><a href="#leetcode-860-柠檬水找零" class="headerlink" title="leetcode 860.柠檬水找零"></a>leetcode 860.柠檬水找零</h2><p><u><strong>题目</strong>：在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</u></p>
<p><u>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</u></p>
<p><u>注意，一开始你手头没有任何零钱。</u></p>
<p><u>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</u></p>
<p><u>输入：bills &#x3D; [5,5,5,10,20]</u><br><u>输出：true</u></p>
<p><u>输入：bills &#x3D; [5,5,10,10,20]</u><br><u>输出：false</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">five</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ten</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; bills.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bills[i] == <span class="number">5</span>) &#123;</span><br><span class="line">                five++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(five == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                five--;</span><br><span class="line">                ten++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(five &gt; <span class="number">0</span> &amp;&amp; ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个题就是看碰到谁给出相应的对策，碰到5，就five++；碰到10，就five–，ten++，当然要<strong>判断five够不够减</strong>的；碰到20，就先看看<strong>ten和five够不够</strong>，够就各减一个，不够就看看<strong>five够不够3个</strong>，都不够就return false。</p>
<h2 id="☆leetcode-406-根据身高重建队列"><a href="#☆leetcode-406-根据身高重建队列" class="headerlink" title="☆leetcode 406.根据身高重建队列"></a>☆leetcode 406.根据身高重建队列</h2><p><u><strong>题目</strong>：假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</u></p>
<p><u>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</u></p>
<p><u>输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</u><br><u>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        <span class="comment">//根据身高从大到小排序，身高相等的，按照数组第二个元素从小到大排序</span></span><br><span class="line">        Arrays.sort(people, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//以数组的第二元素为下标，按照数组的顺序，即按照身高从大到小依次插入队列中</span></span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] p : people) &#123;</span><br><span class="line">            queue.add(p[<span class="number">1</span>], p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将队列返回成数组形式</span></span><br><span class="line">        <span class="keyword">return</span> queue.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下面的排列方式就明白了：</p>
<p><strong>排序完</strong>的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]</p>
<ul>
<li>插入[7,0]：[[7,0]]</li>
<li>插入[7,1]：[[7,0],[7,1]]</li>
<li>插入[6,1]：[[7,0],[6,1],[7,1]]</li>
<li>插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]</li>
<li>插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]</li>
<li>插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li>
</ul>
<h2 id="☆leetcode-452-用最少数量的箭引爆气球"><a href="#☆leetcode-452-用最少数量的箭引爆气球" class="headerlink" title="☆leetcode 452.用最少数量的箭引爆气球"></a>☆leetcode 452.用最少数量的箭引爆气球</h2><p><u><strong>题目</strong>：有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</u></p>
<p><u>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  <strong>xstart ≤ x ≤ xend</strong>，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</u></p>
<p><u>给你一个数组 points ，返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="comment">//按照每个区间的左边界由小到大排列，因为测试用例中有边界值，所以不能用a[0] - b[0]</span></span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">//因为从第二个区间开始与前面的区间比较，所以从一只箭开始计数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; points.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//说明当前区间与前面记录的最小右边界没有重合，所以必须要增加一支箭</span></span><br><span class="line">                <span class="comment">//注意这里的最小右边界就默认是当前区间的右边界了</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明当前区间与前面记录的最小右边界有重合，继续保持当前最小的右边界</span></span><br><span class="line">                points[i][<span class="number">1</span>] = Math.min(points[i - <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先让数组按照每个区间的左边界从小到大排序，这样就可以保证后面的区间左边界一定不比前面的区间左边界小，这样我们只需要比较右边界就可以了。依次向后遍历，如果后面的区间的左边界比前面记录的最小右边界大，也就是<strong>没有重合</strong>，那么自然就需要<strong>增加</strong>一只箭；如果左边界比前面的最小右边界小或相等，也就是<strong>有重合部分</strong>，那么就要记录当前的最小右边界，因为当前区间有可能<strong>包含</strong>在前一个区间内，也就是不仅左边界比最小右边界小，而且<strong>右边界也比最小右边界小</strong>，这样的话，我们必须缩小右边界到<strong>满足所有不增加箭的区间</strong>。</p>
<h2 id="leetcode-435-无重叠区间"><a href="#leetcode-435-无重叠区间" class="headerlink" title="leetcode 435.无重叠区间"></a>leetcode 435.无重叠区间</h2><p><u><strong>题目</strong>：给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</u></p>
<p><u>输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]</u><br><u>输出: 1</u><br><u>解释: 移除 [1,3] 后，剩下的区间没有重叠。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="comment">//改动1，其实不改动也可以，即按左边界由小到大也可以</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">1</span>],b[<span class="number">1</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++) &#123;</span><br><span class="line">            <span class="comment">//改动2</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= intervals[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                intervals[i][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>], intervals[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//改动3</span></span><br><span class="line">        <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题和前面的452题非常像，因为射箭击穿某些重合区间，几只箭就证明有几个不重合的区间，只不过本题[1,2]和[2,3]不算重叠区间，所以在<strong>改动2的if</strong>判断位置<strong>加上了等号</strong>。</p>
<p>其次我们是要获得<strong>移除</strong>区间的<strong>最小数量</strong>，所以最后<strong>改动3</strong>的位置，也就是最后需要返回区间总个数-最大非重叠区间</p>
<p>那么问题是怎么才可以获得最多的非重叠区间呢，本题解给的思路是将每个区间的***<u>右边界从小到大</u><em><strong>排列，这样每个区间给右边的区间留下的空间是最大的，</strong>最大程度避免重叠</em>*，从而获得最大非重叠区间。</p>
<p>其实不改动也可以，即<strong>按左边界由小到大</strong>也可以。</p>
<h2 id="CodeTop-leetcode-56-合并区间"><a href="#CodeTop-leetcode-56-合并区间" class="headerlink" title="(CodeTop) leetcode 56.合并区间"></a>(CodeTop) leetcode 56.合并区间</h2><p><u><strong>题目</strong>：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</u></p>
<p><u>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</u><br><u>输出：[[1,6],[8,10],[15,18]]</u><br><u>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        res.add(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++) &#123;</span><br><span class="line">            <span class="comment">//当前的区间左边界小于前面的区间右边界</span></span><br><span class="line">            <span class="keyword">if</span>(res.getLast()[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> res.getLast()[<span class="number">0</span>];<span class="comment">//因为左边界从小到大排列，所以start肯定取前面的</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.max(intervals[i][<span class="number">1</span>], res.getLast()[<span class="number">1</span>]);<span class="comment">//右边界不确定谁大，需要比一下</span></span><br><span class="line">                res.removeLast();<span class="comment">//记得删除当前最后一个区间</span></span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;);<span class="comment">//用start,end构建新区间</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//区间没重合，说明可以把当前的区间添加进去</span></span><br><span class="line">                res.add(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意res的长度是size()</span></span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的思路是：先将每个区间按照左区间由小到大排列，构造一个链表用于把合适的区间添加进来，先把第一个区间加进来，然后判断第二个区间的左区间和第一个区间的右区间是不是<strong>有重合的地方</strong>，如果重合，那就取两个区间的<strong>最小左区间和最大右区间</strong>，不要忘记<strong>删除前面</strong>的区间，然后将新构造的<strong>更大的区间</strong>添加进去。</p>
<p>如果<strong>没有重合</strong>的地方，就直接将该区间添加进去即可。</p>
<p>后面的区间以此类推，最后将链表转换为数组的形式，要注意LinkedList链表的长度是**size()**，不要写成length()。</p>
<h2 id="leetcode-738-单调递增的数字"><a href="#leetcode-738-单调递增的数字" class="headerlink" title="leetcode 738.单调递增的数字"></a>leetcode 738.单调递增的数字</h2><p><u><strong>题目</strong>：当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。</u></p>
<p><u>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。</u></p>
<p><u>输入: n &#x3D; 10</u><br><u>输出: 9</u></p>
<p><u>输入: n &#x3D; 1234</u><br><u>输出: 1234</u></p>
<p><u>输入: n &#x3D; 332</u><br><u>输出: 299</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//先将数字转换为字符数组，便于遍历</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="comment">//定义一个start指针，记录需要改为9的起始点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> ch.length;</span><br><span class="line">        <span class="comment">//从后向前遍历，因为修改的是前面的字符，如果从前向后遍历会出现问题</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ch.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="comment">//凡是前一个元素比后面大的，就将该元素-1，并将后面的元素置为9</span></span><br><span class="line">            <span class="keyword">if</span>(ch[i] &gt; ch[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                ch[i]--;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将指针及其后面的元素全部置为9</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i &lt; ch.length;i++) &#123;</span><br><span class="line">            ch[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//字符数组-&gt;字符串-&gt;数字</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(String.valueOf(ch));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先把数字转换为方便遍历的字符数组，具体贪心的思路就是：每相邻的字符进行比较，前面比后面大则不满足递增规律，所以要让<strong>当前ch[i]–<strong>，同时让后面的元素</strong>ch[i + 1]置为9</strong>，这一点很关键。</p>
<p>但是如果从前向后遍历，就会造成后面的元素<strong>在自减后又比前面的元素小</strong>了，所以为了避免这种情况，我们<strong>从后向前遍历</strong>。但是不一定要让ch[i + 1]全部置为9，也许前面的元素<strong>自减之后，就满足递增了</strong>。所以要定义一个指针start，<strong>随时记录</strong>目前需要置为9的位置，直到最后数组遍历完成。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/04/%E8%B4%AA%E5%BF%83%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/" data-id="cl3zgzig90000v8v6bzm0gp9d" data-title="贪心系列题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Redis知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2022-06-02T05:43:35.000Z" itemprop="datePublished">2022-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/">Redis知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><h2 id="缓存数据的处理流程及优势"><a href="#缓存数据的处理流程及优势" class="headerlink" title="缓存数据的处理流程及优势"></a>缓存数据的处理流程及优势</h2><p><u>高性能</u>：一个业务要请求数据库中的数据，<u>先从缓存中查询，如果没有再去库里边查询</u>。从库中查询数据是读取硬盘的操作，效率比较低。我们可以将<strong>访问频率比较高</strong>的数据放入缓存中，达到高性能的目的。</p>
<p><u>高并发</u>：MySQL的QPS大概在<strong>1w</strong>左右（4核8g），但是Redis缓存后很容易达到10w+，单机少一些，Redis<strong>集群更高</strong>。（QPS：Query Per Second，服务器每秒可以执行的查询次数）</p>
<h2 id="SDS（Simple-Dynamic-String）简单动态字符串"><a href="#SDS（Simple-Dynamic-String）简单动态字符串" class="headerlink" title="SDS（Simple Dynamic String）简单动态字符串"></a>SDS（Simple Dynamic String）简单动态字符串</h2><h3 id="C语言字符串的弊端："><a href="#C语言字符串的弊端：" class="headerlink" title="C语言字符串的弊端："></a>C语言字符串的弊端：</h3><img src="https://img-blog.csdnimg.cn/img_convert/376128646c75a893ad47914858fa2131.png" alt="img" style="zoom: 67%;" />

<ul>
<li>获取字符串长度，必须要从头到尾遍历到\0才可以，所以<strong>复杂度是o(n)</strong></li>
<li>字符串里不能存\0，所以是<strong>二进制不安全</strong>的</li>
<li>字符串操作时有<strong>缓存区溢出</strong>的风险</li>
</ul>
<h3 id="SDS结构设计"><a href="#SDS结构设计" class="headerlink" title="SDS结构设计"></a>SDS结构设计</h3><img src="https://img-blog.csdnimg.cn/img_convert/516738c4058cdf9109e40a7812ef4239.png" alt="img" style="zoom: 67%;" />

<p>len：SDS直接记录了字符串的长度，所以<strong>复杂度降为o(1)</strong></p>
<p>alloc：记录了<strong>分配</strong>给字符数组的空间长度，在修改字符串的时候，首先<strong>计算alloc - len</strong>够不够用，不够的话<strong>自动扩展</strong>空间长度(小于1MB翻倍扩容，大于1MB按1MB扩容)，所以<strong>无缓存区溢出的风险</strong></p>
<p>flags：记录了五种类型的sds</p>
<p>buf[]：不仅可以保存字符串，也可以<strong>保存任意格式的二进制数据</strong></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><img src="https://img-blog.csdnimg.cn/img_convert/cadf797496816eb343a19c2451437f1e.png" alt="img" style="zoom:50%;" />

<ul>
<li>每个节点都有pre和next指针，而且这两个指针都可以指向NULL，所以链表是<strong>无环链表</strong></li>
<li>list结构存储了表头指针head和表尾指针tail，所以<strong>获得头尾节点</strong>的复杂度是o(1)</li>
<li>和SDS一样，list结构也存储了长度len，所以<strong>查询链表长度</strong>的复杂度也是o(1)</li>
<li>链表节点可以<strong>保存各种不同类型</strong>的值</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>内存不连续</strong>，无法很好利用CPU缓存（与数组相比）</li>
<li>保存每个节点都需要分配一个链表节点结构头，<strong>内存开销大</strong></li>
</ul>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p><strong>Redis3.0</strong>的产物，为了设计一个<strong>内存紧凑型</strong>的数据结构，节省内存开销，创造了压缩列表，它是由<strong>连续内存块</strong>组成的<strong>顺序型</strong>数据结构，<u>类似数组</u>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/ab0b44f557f8b5bc7acb3a53d43ebfcb.png" alt="img" style="zoom: 67%;" />

<p>表头前三个字段分别记录了[整个压缩列表<strong>占用的内存字节数</strong>]，[尾部节点距离起始地址的字节数（<strong>尾部偏移量</strong>）]，[包含的<strong>节点数量</strong>]。最后的[zlend]相当于\0，代表<strong>结束点</strong>。</p>
<p>通过这三个字段可以容易的查到表头和表尾（复杂度为o(1)），但是查找其他元素就是o(n)</p>
<p>压缩列表节点entry包含了三部分：</p>
<p><strong>prevlen</strong>:前一个节点的长度</p>
<p><strong>encoding</strong>:当前节点实际数据类型及长度</p>
<p><strong>data</strong>:当前节点的实际数据</p>
<img src="https://img-blog.csdnimg.cn/img_convert/a3b1f6235cf0587115b21312fe60289c.png" alt="img" style="zoom:50%;" />

<p>**<u>缺点明显</u>**：</p>
<ul>
<li>不能保存过多元素，会导致查询效率降低</li>
<li>新增或修改某个元素，内存空间需要重新分配，很可能导致<strong>连锁更新</strong>（由于存在prevlen多米诺效应）</li>
</ul>
<p>**<u>使用场景</u>**：</p>
<p><strong>节点数量足够小</strong>，即使发生连锁更新，代价也很小。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>与JDK1.8之前的哈希表很相似，都是数组+链表的数据结构，数组里每一个元素就是一个<strong>哈希桶</strong>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/85f597f7851b90d6c78bb0d8e39690fc.png" alt="img" style="zoom: 67%;" />

<p>当负载因子 &gt;&#x3D; 1的时候，Redis<u>没有执行RDB快照或者没有进行AOF重写</u>的时候，就会进行rehash操作；</p>
<p>当负载因子 &gt;&#x3D; 5的时候，哈希冲突会非常严重，<strong>强制rehash</strong></p>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>分三步：</p>
<ul>
<li>给表2分配空间，一般<strong>比表1大2倍</strong></li>
<li>将表1的<strong>数据迁移</strong>到表2</li>
<li>把表1表2<strong>身份互换</strong>，在表2新创建一个空白的哈希表，用于下次rehash</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/cabce0ce7e320bc9d9b5bde947b6811b.png" alt="img" style="zoom:50%;" />

<h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>上面问题就处在数据迁移过程中会引发<strong>大量数据拷贝</strong>，导致<strong>请求阻塞</strong>，所以采用渐进式rehash。</p>
<p>将一次拷贝<strong>分成多次进行</strong>，而且进行的时机是：对哈希表元素<strong>进行CRUD的时候</strong>，顺便将表1中索引位置上的所有key-value<strong>顺序迁移到表2</strong>，随着请求增多，渐进式完成了迁移操作。</p>
<p>如果渐进式rehash期间，新增一个key-value，只会保存在哈希表2中，而<strong>哈希表1只减不增</strong>。</p>
<h3 id="rehash触发条件"><a href="#rehash触发条件" class="headerlink" title="rehash触发条件"></a>rehash触发条件</h3><img src="https://img-blog.csdnimg.cn/img_convert/85f597f7851b90d6c78bb0d8e39690fc.png" alt="img" style="zoom: 67%;" />

<p>负载因子**&gt;&#x3D;1<strong>，Redis没有进行</strong>RDB快照<strong>或没有进行</strong>AOF重写**时，就进行rehash；</p>
<p>负载因子**&gt;&#x3D;5<strong>，哈希冲突严重，</strong>强制进行**rehash。</p>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合时<strong>Set对象的底层实现之一</strong>，当一个Set对象<strong>只包含</strong>整数元素，并且元素<strong>数量不大</strong>时，就会使用整数集合这个数据结构。</p>
<p>本质上是一块<strong>连续内存空间</strong>：保存数据的<strong>容器</strong>是contents数组，但是<strong>数据类型取决于encoding属性</strong>的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<h3 id="整数集合的升级"><a href="#整数集合的升级" class="headerlink" title="整数集合的升级"></a>整数集合的升级</h3><p>当整数集合中全是int16_t类型的数据，突然<strong>来了一个较长的</strong>int32_t类型数据，那么就会发生整数集合的升级操作。这样的好处是：尽可能地<strong>节省内存资源</strong>，有大的再扩容，没有就维持当前数据类型。</p>
<p>整数集合<strong>只升级不降级</strong>。</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>Zset对象的底层实现用到了<strong>跳表</strong>和哈希表，其优势是能支持**平均o(logN)**的节点查找。</p>
<p><strong>跳表</strong>支持Zset对象的<strong>范围查询</strong>，而哈希表支持其<strong>常数复杂度</strong>获得<strong>元素权重</strong>。</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="AOF持久化-Append-Only-File"><a href="#AOF持久化-Append-Only-File" class="headerlink" title="AOF持久化(Append Only File)"></a>AOF持久化(Append Only File)</h2><p>AOF就是<strong>保存写操作命令到日志</strong>中，<u>不保存读操作</u>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/6f0ab40396b7fc2c15e6f4487d3a0ad7.png" alt="img" style="zoom: 67%;" />



<h3 id="写在前，日志在后优势与风险"><a href="#写在前，日志在后优势与风险" class="headerlink" title="写在前，日志在后优势与风险"></a>写在前，日志在后优势与风险</h3><p>注意执行写命令和写AOF日志是一个进程中的两个任务，所以要分先后，<u>先执行写命令，后写日志的原因</u>是：</p>
<ul>
<li><strong>避免额外的检查开销</strong>，避免写操作的语法等有问题，所以先执行写操作，没问题了再写日志</li>
<li><strong>不会阻塞当前写</strong>操作命令</li>
</ul>
<p><u>先执行写命令，后写日志潜在风险</u>：</p>
<ul>
<li>写操作执行完，还没来得及写日志或者日志没来得及写入硬盘，服务器就宕机了，会导致<strong>数据丢失</strong></li>
<li>虽然不阻塞当前写操作，但是会<strong>阻塞下一个命令操作</strong></li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/28afd536c57a46447ddab0a2062abe84.png" alt="img" style="zoom:50%;" />

<p>上面说的风险其实就是AOF传入硬盘的时机问题。这里注意，AOF还没有存入硬盘，真正将AOF写入硬盘有三个策略。</p>
<h3 id="三种写回策略-与MySQL相似）"><a href="#三种写回策略-与MySQL相似）" class="headerlink" title="三种写回策略(与MySQL相似）"></a>三种写回策略(与MySQL相似）</h3><p>写操作-&gt;AOF-&gt;硬盘具体步骤</p>
<ol>
<li><p>实际上，执行完写操作后，先把写操作的命令追加到<strong>server.aof_buf缓冲区</strong>中</p>
</li>
<li><p>通过<strong>write()系统调用</strong>，将缓冲区的数据写入AOF文件，此时数据被拷贝到了<strong>内核缓冲区page cache</strong></p>
</li>
<li><p>接着就<strong>等待内核</strong>将page cache中的数据写入硬盘</p>
<img src="https://img-blog.csdnimg.cn/img_convert/4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png" alt="img" style="zoom:50%;" /></li>
</ol>
<p>redis.conf配置文件中的appendfsync配置项可以设置3种参数：</p>
<p><strong><u>Always</u><strong>：每次写操作和AOF日志写回硬盘是</strong>同步</strong>进行的，<u>写一个存一个</u>。</p>
<p><strong><u>Everysec</u><strong>：写操作执行完，先把命令</strong>写入内核缓冲区</strong>，每隔1秒写回一次硬盘，<u>每隔1秒存一个</u>。</p>
<p><strong><u>No</u><strong>：写操作执行完，先把命令</strong>写入内核缓冲区</strong>，写回时机完全转交给<u>操作系统控制</u></p>
<p>不同业务需要使用不同的参数，Always追求<u>高可靠</u>，Everysec追求<u>折中</u>，No追求<u>高性能</u></p>
<img src="https://img-blog.csdnimg.cn/img_convert/98987d9417b2bab43087f45fc959d32a.png" alt="img" style="zoom: 67%;" />

<h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>为了避免AOF越写越大，提供AOF重写机制，<strong>每个键值对只保留一条命令</strong>，用于<u>压缩</u>AOF的大小。</p>
<p>这一点与MySQL不一样，每个键值的<strong>历史记录</strong>对Redis来说没有意义，所以只保留<strong>最近的一次写操作</strong>。所以具体的方式是：根据每个键值的最新状态，用一条命令记录这个键值对。</p>
<p>重写的方式是：重写的过程要与原始AOF<strong>隔离</strong>，写完后<strong>覆盖</strong>原始AOF文件，这样<strong>不会</strong>对原始AOF文件<strong>造成污染</strong>。</p>
<h3 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h3><p>为了不影响主进程写AOF机制，重写AOF过程由<strong>后台子进程<em>bgrewriteaof</em></strong>来完成，好处是：</p>
<ul>
<li>AOF重写期间，<strong>不影响主进程</strong>，避免阻塞</li>
<li>子进程带有主进程的<strong>数据副本</strong>。<u>不使用线程</u>是因为：线程间操作共享内存必须<strong>加锁</strong>-&gt;性能降低；<u>使用子进程</u>是因为：父子进程共享内存是<strong>只读</strong>的，所以当有一方操作了共享内存，就发生[<strong>写时复制</strong>]，这样父子进程各自有了<strong>独立</strong>的数据副本，不需加锁。</li>
</ul>
<h4 id="数据副本的来由"><a href="#数据副本的来由" class="headerlink" title="数据副本的来由"></a>数据副本的来由</h4><p>主进程通过<strong>fork系统调用</strong>生成子进程时，OS会把主进程的<strong>页表</strong>复制给子进程，这样父子进程的虚拟内存指向了<strong>同一块物理内存</strong>（只读）</p>
<img src="https://img-blog.csdnimg.cn/img_convert/5a1f2a90b5f3821c19bea3b7a5f27fa1.png" alt="img" style="zoom:50%;" />

<h4 id="写时复制-Copy-On-Write"><a href="#写时复制-Copy-On-Write" class="headerlink" title="写时复制(Copy On Write)"></a>写时复制(Copy On Write)</h4><p>当父进程对这块内存发起写操作时，CPU会发起<strong>缺页中断</strong>（违反权限导致），OS会在[<strong>缺页异常处理函数</strong>]进行物理内存的复制（注意<strong>只是被执行写操作的这部分内存</strong>），然后重新设置内存映射关系，将父子进程的<strong>这部分内存</strong>读写权限设置为<strong>可读写</strong>，最后才对内存进行写操作，这个过程称为<u>写时复制</u>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/d4cfac545377b54dd035c775603b4936.png" alt="img" style="zoom:50%;" />

<p>其实写时复制就是为了防止fork创建子进程的时候，<strong>物理内存复制时间过长</strong>，页表要比物理内存小的多，所以<strong>尽可能减少</strong>了<u>子进程创建时对父进程的阻塞</u>。</p>
<p>三个阶段会<u>阻塞父进程</u>：</p>
<ul>
<li>创建子进程复制的<strong>页表</strong>如果特别大，肯定阻塞时间长</li>
<li>写时复制的时候，<strong>被主进程修改的内存</strong>越大，阻塞越长</li>
<li>后面要写的执行<strong>信号处理函数</strong></li>
</ul>
<p>写时复制带来的问题其实就是父子进程的<strong>时间差</strong>问题：子进程重写了一个key-value，主进程又修改了这对键值对，这次父子进程的<strong>内存数据不一致</strong>了怎么办？</p>
<h4 id="时间差导致数据不一致问题"><a href="#时间差导致数据不一致问题" class="headerlink" title="时间差导致数据不一致问题"></a>时间差导致数据不一致问题</h4><p>在<strong>创建子进程之后</strong>，Redis开始使用其专门设置的**[<u>AOF重写缓冲区</u>]<strong>，当主进程进行</strong>写操作后**，不仅将命令写入AOF缓冲区中，还写入了AOF重写缓冲区。</p>
<img src="https://img-blog.csdnimg.cn/202105270918298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:45%;" />

<p>为了解决时间差问题，最后在AOF重写完成时必须还要阻塞一下，以便<strong>让子进程追上父进程</strong>：</p>
<p>当子进程<strong>完成AOF重写工作后</strong>（扫描数据库所有数据。逐一把内存数据的键值对转换成一条命令，写入重写日志），向主进程发送信号（异步）。</p>
<p>主进程<strong>调用信号处理函数</strong>，将AOF重写缓冲区的所有内容追加到新的AOF中，然后让新的AOF文件改名，覆盖旧的AOF文件。调用函数的时候一定要<strong>阻塞主进程</strong>，否则时间差还会存在。</p>
<h2 id="RDB快照-Redis-Database"><a href="#RDB快照-Redis-Database" class="headerlink" title="RDB快照(Redis Database)"></a>RDB快照(Redis Database)</h2><p>如果说AOF相当于MySQL中的binlog，那么redolog就是Redis中的RDB快照了，两种技术存了不同的日志信息：</p>
<p>AOF：日志内容是<strong>操作命令</strong></p>
<p>RDB：日志内容是<strong>二进制数据</strong></p>
<p>这就带来了二者<u>恢复数据上的差异性</u>：Redis恢复数据的时候，直接<strong>将RDB读入内存即可</strong>；而AOF读入内存后，需要<strong>逐条执行操作命令</strong>才可以恢复。</p>
<h3 id="生成RDB快照的命令"><a href="#生成RDB快照的命令" class="headerlink" title="生成RDB快照的命令"></a>生成RDB快照的命令</h3><p>save和bgsave，save是<strong>直接在主线程中生成RDB文件</strong>，如果写入时间太长，会<strong>阻塞</strong>主线程；bgsave则是创建子进程，<strong>避免了阻塞</strong>问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>虽然是save，但实际执行的是bgsave，表明在多少秒内，对数据库<strong>至少</strong>进行了多少次<strong>修改</strong>。<strong>满足任意一个</strong>就会执行bgsave。</p>
<p>注意：RDB快照是**<u>全量快照</u><strong>，也就是每次快照都把</strong>内存中所有数据**存入硬盘中。</p>
<h3 id="写时复制-Copy-On-Write-1"><a href="#写时复制-Copy-On-Write-1" class="headerlink" title="写时复制(Copy On Write)"></a>写时复制(Copy On Write)</h3><p>与AOF一样，RDB快照也采用[<strong>写时复制技术</strong>]，即当父进程对共享内存执行写操作的时候，CPU先发生缺页中断，然后被执行写操作的内存则被OS复制一份，然后父进程就可以<strong>对复制的这部分内存进行写操作</strong>了。（这里注意：<u>主进程写的是复制后的内存，子进程读取的是原内存区域</u>）</p>
<img src="https://img-blog.csdnimg.cn/img_convert/ebd620db8a1af66fbeb8f4d4ef6adc68.png" alt="图片" style="zoom:50%;" />

<h3 id="混合持久化（AOF-RDB）"><a href="#混合持久化（AOF-RDB）" class="headerlink" title="混合持久化（AOF+RDB）"></a>混合持久化（AOF+RDB）</h3><p>RDB快照刚执行完，肯定会有一部分写操作还会执行，那么在下次快照执行之前，这一部分写操作会导致父子进程的<strong>数据不一致</strong>。解决的方法就是<strong>混合使用AOF日志和内存快照</strong>（混合持久化）。<u>开启方式</u>就是将下面的参数设为yes。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<p><strong>Redis 4.0</strong>提出的混合持久化，具体工作<strong>只发生</strong>在<u>AOF日志的重写过程</u>：</p>
<ul>
<li>首先fork出来的子进程先把共享内存中的数据<strong>以RDB方式</strong>写入AOF中</li>
<li>然后重写缓冲区中的<strong>增量命令以AOF方式</strong>写入AOF文件中</li>
<li>写入完成，通知主进程将这个混合持久化的AOF文件<strong>替换旧</strong>的AOF文件</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/f67379b60d151262753fec3b817b8617.png" alt="图片" style="zoom:50%;" />

<p>这样，AOF文件<u>前半部分</u>是RDB格式的<strong>全量数据</strong>，<u>后半部分</u>是AOF格式的<strong>增量数据</strong></p>
<p>好处是：重启Redis加载数据的时候，<strong>加载速度很快</strong>（RDB直接加载到内存即可），加载完了再加载AOF内容，保证<strong>数据尽可能少的丢失</strong>。</p>
<h1 id="缓存雪崩、击穿、穿透"><a href="#缓存雪崩、击穿、穿透" class="headerlink" title="缓存雪崩、击穿、穿透"></a>缓存雪崩、击穿、穿透</h1><p>雪崩和击穿都是缓存中的数据没法提供给用户了，用户只好去数据库中找了，一旦这个请求是<strong>大批量的</strong>，那么就会造成雪崩。如果数据批量不大，但是数据<strong>热度特别高</strong>，那么就是击穿，注意不是穿透，因为库上有数据。</p>
<p>而穿透则是<strong>缓存找不到，数据库也找不到</strong>，相当于一个攻击层层穿透两个库，最后给<strong>打透了</strong>。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>大批量数据访问缓存访不到，只能去库中找，有两个原因：</p>
<ul>
<li>大量数据同时过期</li>
<li>Redis故障宕机</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/717343a0da7a1b05edab1d1cdf8f28e5.png" alt="图片" style="zoom: 45%;" />

<h3 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h3><p>对于大量数据过期可以采用以下几种办法应对：</p>
<p>1）**<u>均匀设置过期时间</u><strong>：可以在设置过期时间的时候，</strong>加上一个随机数**，保证不会发生同时过期的现象。</p>
<p>2）**<u>互斥锁</u><strong>：如果发现缓存中数据没有了，那肯定得去库里面找到然后重新构建缓存，这个时候可以加个互斥锁，保证</strong>同一时间只有一个请求<strong>在构建缓存，当然锁要</strong>设置超时时间**，防止意外出现导致阻塞。</p>
<p>3）**<u>双key策略</u><strong>：即设置主key和备key，主key设置过期时间，而</strong>备key不设置<strong>，这样主key找不到了就去读备key的value。不过，更新缓存的时候要</strong>同时更新**主备key的value。</p>
<p>4）<u><strong>后台更新缓存</strong></u>：<strong>不设置有效期</strong>，业务线程也不负责更新缓存。更新的工作交给<strong>后台线程定时更新</strong>。</p>
<p>不过，缓存并不是永久有效，系统内存紧张还是会淘汰一部分数据。解决的方式有二：</p>
<p>①后台线程不仅定时更新缓存，也<strong>定时检测缓存的有效性</strong>。不过总会在两个检测<strong>间隔内</strong>出现被淘汰但还没更新的</p>
<p>②当业务线程发现数据失效后，通过<strong>消息队列</strong>发送消息<strong>通知后台线程</strong>更新缓存，用户体验较好</p>
<p>所以虽说业务线不负责更新，还是<strong>间接的</strong>利用了业务线来完成缓存的更新</p>
<p>对于<u>刚上线的业务</u>，我们有必要先进行<strong>缓存预热</strong>，即把一些数据提前存入缓存中。</p>
<h3 id="Redis故障宕机"><a href="#Redis故障宕机" class="headerlink" title="Redis故障宕机"></a>Redis故障宕机</h3><p>Redis故障宕机引起的雪崩问题采用以下两种办法应对：</p>
<p>1）<u><strong>服务熔断或请求限流机制</strong></u>：服务熔断就是<strong>暂停业务访问缓存</strong>，直接返回错误。直到缓存恢复正常，再进行访问；这种方式保证了数据库的正常运行，但是极大的阻塞了业务进行，所以可以启用请求限流，让<strong>少部分请求发送到数据库</strong>中。</p>
<p>2）**<u>构建Redis缓存高可靠集群</u><strong>：通过</strong>主从节点**的方式构建可靠集群，当主节点宕机，直接切换为从节点。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>就是<strong>热点数据过期</strong>了，数据库很容易被这个<strong>高并发量</strong>冲垮。</p>
<p>可以认为击穿是雪崩的<strong>子集</strong></p>
<p>应对方案有如下两种：</p>
<ul>
<li>**<u>互斥锁</u>**：保证同一时间只有一个业务线程更新缓存</li>
<li><strong><u>不给热点数据设置过期时间</u><strong>：后台异步更新缓存，或者过期前，</strong>提前通知</strong>后台线程更新缓存和重设过期时间</li>
</ul>
<p>要知道，*<u>不设过期时间不代表缓存一直存在</u>*，很可能因为系统内存紧张而被淘汰，所以还是要做好反馈机制。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存和数据库<strong>都没有请求的数据</strong>，导致数据库压力骤增。</p>
<p>一般<strong>业务误操作</strong>，也就是缓存和数据库的这部分数据被误删除了导致穿透现象；还有就是<strong>黑客恶意攻击</strong>，即故意访问大量不存在的数据业务。</p>
<p>应对方案有三（<em>宗旨：避免访问数据库</em>）：</p>
<p>1）<u><strong>非法请求限制</strong></u>：在API入口处判断请求参数<strong>是否合理</strong>，是否含有<strong>非法值</strong>，字段<strong>是否存在</strong>，判断出是非法请求就直接返回错误。</p>
<p>2）**<u>缓存控制或默认值</u><strong>：可以专门</strong>针对出现缓存穿透的数据<strong>，在缓存中</strong>设置**一个空值或者默认值，这样可以避免访问数据库。</p>
<p>3）**<u>布隆过滤器</u><strong>快速判断：在</strong>数据库写入数据时<strong>，使用布隆过滤器进行标记，一旦请求在缓存中找不到数据，</strong>先来到布隆过滤器**这里进行数据的存在性判断，避免了访问数据库。</p>
<p>布隆过滤器基于<strong>哈希函数</strong>查找，存在<strong>哈希碰撞</strong>的可能性，所以布隆过滤器说数据存在，数据<strong>不一定存在</strong>，但是说数据不存在，就<strong>一定不存在</strong>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/061e2c04e0ebca3425dd75dd035b6b7b.png" alt="图片" style="zoom:60%;" />

<h1 id="主从复制的实现"><a href="#主从复制的实现" class="headerlink" title="主从复制的实现"></a>主从复制的实现</h1><p>如果数据只存在一台服务器上，一旦服务器宕机或故障，会导致严重的业务中断甚至数据丢失。所以为了避免<strong>单点故障</strong>，就需要将服务器的数据保存在多台服务器上，这也是<strong>避免缓存雪崩（服务器宕机）</strong>的一种方式。</p>
<p>这就带来了一个重要的问题——数据一致性如何保证？Redis给出的是<strong>主从复制模式</strong>，主从服务器遵从<strong>读写分离</strong></p>
<p>如下图所示，主服务器可以<strong>读写</strong>，而从服务器一般是<strong>只读</strong>，一旦主服务器发生<strong>写操作</strong>，就把该操作<strong>同步</strong>给从服务器。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/2b7231b6aabb9a9a2e2390ab3a280b2d.png" alt="图片" style="zoom:50%;" />

<h2 id="第一次同步"><a href="#第一次同步" class="headerlink" title="第一次同步"></a>第一次同步</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 服务器 B 执行这条命令</span><br><span class="line">replicaof &lt;服务器 A 的 IP 地址&gt; &lt;服务器 A 的 Redis 端口号&gt;</span><br></pre></td></tr></table></figure>

<p>在服务器B上执行该命令，B就会变成A的<strong>从服务器</strong>，然后开始与A进行<strong>第一次同步</strong></p>
<p><u>第一次同步</u>有如下三阶段：</p>
<img src="https://img-blog.csdnimg.cn/img_convert/ea4f7e86baf2435af3999e5cd38b6a26.png" alt="图片" style="zoom: 50%;" />

<p>一、<u><strong>建立链接</strong>，协商同步</u>：</p>
<p><u>1.1-1.2</u>：可以从图中看出来，执行完replicaof命令后，从服务器就<strong>发送psync命令</strong>，表示自己要进行数据同步。</p>
<p>psync包含<strong>主服务器</strong>的<strong>runID</strong>（随机ID且唯一，但第一次不知道主服务器的runID，所以<strong>设为？</strong>）和复制进度<strong>offset</strong>（第一次是-1）。</p>
<p><u>1.3-1.4</u>：主服务器收到psync会回应<strong>FULLRESYNC</strong>，包含了主服务器的runID和主服务器的<strong>复制进度offset</strong>，从服务器<strong>保存记录</strong>这俩信息。此命令目的是<strong>全量复制</strong>，即把所有数据赋值给从服务器。</p>
<p>二、<u>主向从<strong>同步数据</strong></u>：</p>
<p><u>2.1-2.3</u>：主服务器执行bgsave生成RDB文件，然后发给从服务器；</p>
<p><u>2.4</u>：从服务器收到RDB文件后，<strong>先清空自己的数据再载入RDB</strong>；</p>
<p>上述操作中，主服务器生成RDB<strong>不会很大程度阻塞主线程</strong>的进行(因为是子进程<strong>复制页表</strong>)，但是在<strong>生成、发送、载入RDB</strong>的三个阶段，主服务器都有新的写操作执行的可能性，为了保证数据一致性，就要把这三个时间段的写操作命令写入到<strong>replication buffer缓冲区</strong>中。</p>
<p>三、<u>主向从发送新的<strong>写操作</strong>命令</u></p>
<p><u>3.1-3.2</u>：从服务器加载完RDB之后，主服务器将<strong>replication buffer</strong>中的写操作命令<strong>发送</strong>给从服务器，然后从服务器<strong>执行</strong>这些操作。</p>
<p>至此，第一次同步结束~</p>
<h2 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h2><p>为了<strong>避免</strong>频繁的TCP连接和断开带来<strong>性能开销</strong>，第一次同步后维持长连接，持续<strong>传播写操作</strong>，保证数据的一致性。</p>
<p>即<strong>基于长连接的命令传播</strong>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/03eacec67cc58ff8d5819d0872ddd41e.png" alt="图片" style="zoom:50%;" />

<h2 id="分摊服务器压力"><a href="#分摊服务器压力" class="headerlink" title="分摊服务器压力"></a>分摊服务器压力</h2><p>一个从服务器还好，如果是一个服务器集群，那么在主服务器<strong>创建</strong>RDB的时候，务必会<strong>复制大量页表</strong>，从而对主线程造成<strong>阻塞</strong>；而在<strong>传播</strong>RDB的时候又会<strong>占用主服务器的网络带宽</strong>。</p>
<p>如何解决这个压力集中的问题？</p>
<p>在某个从服务器上执行如下的命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;目标服务器的IP&gt; 6379</span><br></pre></td></tr></table></figure>

<p>如果目标服务器也是<strong>从服务器</strong>，那么<strong>目标服务器</strong>就是当前服务器的“<strong>经理</strong>”。那么它就有向下传播写操作的能力了。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/4d850bfe8d712d3d67ff13e59b919452.png" alt="图片" style="zoom: 45%;" />

<h2 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h2><p>主从服务器在第一次同步之后虽然保持长连接，但是网络连接还是有可能中断，一旦<strong>网络中断</strong>，客户端在从服务器中读到的就是<strong>旧数据</strong>了。</p>
<p>网络断开后再恢复，如何*<u>保证主从服务器的一致性</u>*呢？</p>
<p>Redis 2.8之前，一直采用<strong>全量复制</strong>，开销非常大。</p>
<p><strong>Redis 2.8开始</strong>，主服务器只会把网络断开期间的<strong>相差</strong>的这一部分写操作传播给从服务器，即<strong>增量复制</strong>。</p>
<ul>
<li>再次建立连接后，还是和第一次同步一样，传一个psync，但是这次的<strong>offset不是-1</strong>了，而是断开时自己的<strong>复制偏移量</strong></li>
<li>主服务器收到psync命令后，响应<strong>CONTINUE命令</strong>来告诉从服务器接下来采用增量复制</li>
<li>然后主把这部分<strong>增量传给</strong>从服务器</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/e081b470870daeb763062bb873a4477e.png" alt="图片" style="zoom:50%;" />

<p>主服务器如何获知<u><em>这部分增量</em></u>的？</p>
<p>主服务器在命令传播的时候，不仅把写操作传播给从服务器，也同时将写命令<strong>写入repl_backlog_buffer</strong>（<u>主从同步也用的这个</u>）这个环形缓冲区，环形意味着<strong>超过容量即覆盖</strong>。</p>
<p>当从服务器断开重连的时候，向主服务器发送的<strong>fsync</strong>命令包含了其<strong>复制偏移量slave_repl_offset</strong>，主服务器根据自己的<strong>master_repl_offset</strong>与其差值，来决定执行增量同步还是全量同步：</p>
<p>如果<strong>差值小于</strong>一个扇形存储区域，那么就说明数据还在扇形缓冲区，然后就把扇形区的这部分增量数据<strong>写入到replication buffer</strong>，也就是第一次同步时专门负责传播增量数据的缓冲区，然后进行命令传播，即<strong>增量复制</strong>。</p>
<p>如果大于一个扇形区域，就会发生<strong>覆盖</strong>，那么就只能进行<strong>全量复制</strong>了。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/2db4831516b9a8b79f833cf0593c1f12.png" alt="图片" style="zoom:60%;" />

<p>所以一般扇形区域会设置的<strong>尽量大</strong>一些，就是为了<strong>避免全量复制</strong>这种抵消操作。</p>
<p>估算公式如下：</p>
<p>second是服务器<strong>断开后重连</strong>的平均时间</p>
<p>write_size_per_second是主服务器平均每秒产生的<strong>写命令</strong>的数据<strong>大小</strong></p>
<img src="https://img-blog.csdnimg.cn/img_convert/5e9e65a4a59b3688fa37cadbd87bb5ac.png" alt="图片" style="zoom: 90%;" />

<h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><h2 id="哨兵机制存在的意义"><a href="#哨兵机制存在的意义" class="headerlink" title="哨兵机制存在的意义"></a>哨兵机制存在的意义</h2><p>前面虽然说主服务器挂了，客户端还可以去读从服务器，但是<strong>写操作</strong>始终是主服务器向其他从服务器传播的，所以一旦主服务器挂了，还必须尽快<strong>设置新的主服务器</strong>，这就会涉及<strong>大量的工作</strong>，包括：从其它从节点选一个当主节点，通知并更新其他从节点新的主服务器IP。</p>
<p><strong>Redis 2.8</strong>开始提供了哨兵机制，目的就是<strong>实现主从节点故障转移</strong>，监控主节点是否<strong>存活</strong>，一旦主挂了，就<strong>选取</strong>新的主节点，并<strong>通知</strong>其他从节点和客户端新主节点的相关信息。</p>
<h2 id="哨兵工作机制"><a href="#哨兵工作机制" class="headerlink" title="哨兵工作机制"></a>哨兵工作机制</h2><img src="https://img-blog.csdnimg.cn/775865f6bd894dfba8d373ee54d79af1.png" alt="哨兵的职责" style="zoom: 50%;" />

<h3 id="判断主节点故障"><a href="#判断主节点故障" class="headerlink" title="判断主节点故障"></a>判断主节点故障</h3><p>哨兵会<strong>周期性</strong>地给主从节点发送<strong>PING</strong>命令，根据是否收到回应来判断是否正常运行。</p>
<p>由于一个哨兵判断有偶然性，很可能是系统压力大或网络拥塞造成未收到回应。为了减少误判，用多个节点部署成<u><em><strong>哨兵集群</strong></em></u>（最少<strong>三台</strong>机器），一旦有一个哨兵判断主节点<strong>主观下线</strong>了，就开始”参考“其他哨兵的“观点”，相当于投票机制。</p>
<p>在哨兵配置文件中有一个<strong>quorum配置项</strong>（一般设置为哨兵个数的1&#x2F;2 + 1），如果投票数超过这个值，主节点就会被标记为<strong>客观下线</strong>。</p>
<img src="https://img-blog.csdnimg.cn/13e4361407ba46979e802eaa654dcf67.png" alt="img" style="zoom:45%;" />

<h3 id="选新的主节点"><a href="#选新的主节点" class="headerlink" title="选新的主节点"></a>选新的主节点</h3><p>选择新的主节点，必然要在从节点中选择，一定不能随机选，因为有些从节点可能网络连接不太好，选了它相当于选择了”残疾人”，所以要<strong>避开连接状态不好</strong>的节点。</p>
<p>Redis中有一个down-after-milliseconds * 10的配置项，意为主从节点<strong>断后重连</strong>的最大超时时间，如果在<strong>这个时间内</strong>没连上，那就认为主从节点断连了，如果次数超过10次，说明这个<strong>从节点网络状况</strong>不好。</p>
<p>过滤掉离线的和网络不好的节点后，开始三轮考察：</p>
<p>第一轮：先选<strong>优先级最高</strong>的从服务器作为主服务器。配置项slave-priority可以设置</p>
<p>第二轮：选<strong>复制进度最靠前</strong>的从节点。比较谁的slave_repl_offset最接近master_repl_offset</p>
<p>第三轮：前面都一样，就<strong>选ID小的</strong>从节点</p>
<p><u>总结</u>：<em>先过滤离线的和网络不好的，然后进行三轮考察</em>，每一轮考察中，如果有胜出的节点，直接作为新主节点。</p>
<h3 id="哨兵竞争主从故障转移"><a href="#哨兵竞争主从故障转移" class="headerlink" title="哨兵竞争主从故障转移"></a>哨兵竞争主从故障转移</h3><p>选定了哪个从节点作为接下来的主节点之后，就要决定哪个哨兵节点<strong>负责故障转移</strong>这项工作。</p>
<p>首先要确定<strong>候选者</strong>：只有判断主节点是<strong>客观下线</strong>的哨兵才可以成为候选者。</p>
<p>候选者如何成为leader？通过所有节点（包括自己）投票选举。所有节点只可以投给候选者赞成票，而且<strong>机会只有一次</strong>，这就意味着候选者可以投给自己（<strong>其实候选者都投给自己，然后向其他哨兵发起投票请求</strong>）。</p>
<p>当候选者满足以下两个条件就可以成为leader：</p>
<ul>
<li>拿到<strong>一半以上</strong>数量（<strong>所有</strong>哨兵数量的一半 + 1）的赞成票；</li>
<li>拿到的票数要 <strong>&gt;&#x3D;</strong> 哨兵配置文件中的<strong>quorum</strong>值</li>
</ul>
<p><u><em>问</em></u>：假如当前Redis 1主4从，5个哨兵，挂了2个，quorum设为3，判断主节点宕机能否判断其“<strong>客观下线</strong>”？主从能否<strong>自动切换</strong>？</p>
<p><u><em>答</em></u>：还有3个哨兵，全部投“主观下线”，就<strong>可以判断“客观下线”</strong>了。对于主从故障转移，就要判断投票数能不能超过半数（<strong>5&#x2F;2 + 1 &#x3D; 3</strong>），能。再判断能不能超过quorum &#x3D; 3，前面判断过了，也能。所以<strong>可以自动切换</strong>。</p>
<p><u><em>问</em></u>：还是5个哨兵，挂了3，quorum设为2呢？</p>
<p>挂了3还有两个可以投票，而quorum正好改为2，所以<strong>可以判断“客观下线”</strong>。而（5&#x2F;2 + 1 &#x3D; 3），但是哨兵只有俩，赞成票数无法超过半数，所以<strong>无法自动切换</strong></p>
<p><u><em>问</em>：</u>：还是5个哨兵，还是挂了3，但是quorum设为3？</p>
<p>*<u>答</u>*：这个时候两票已经超不过quorum了，所以<strong>既无法判读“客观下线”，又无法自动切换</strong>。</p>
<p>这里面我们故意把quorum随意调整了，就是为了证明<strong>quorum</strong>不是随便设置的，其最好设置为<strong>哨兵个数 &#x2F; 2 + 1</strong>，同时保证<strong>哨兵数量为奇数</strong>。</p>
<h3 id="通知客户端新的主节点信息"><a href="#通知客户端新的主节点信息" class="headerlink" title="通知客户端新的主节点信息"></a>通知客户端新的主节点信息</h3><p>主从切换之后，新的主节点迫切需要被客户端知道，否则客户端都不知道该找谁进行写操作。</p>
<p>Redis采用<strong>发布者&#x2F;订阅者机制</strong>来实现信息的通知的。每个哨兵节点提供发布者&#x2F;订阅者机制，客户端可以<strong>从哨兵订阅消息</strong>。</p>
<p>假如客户端<strong>订阅了主从切换的事件</strong>，当哨兵选好了新的主节点，就会<strong>发布</strong>新主节点的<strong>IP和端口信息</strong>，客户端就<strong>收到</strong>了这个信息，就自然可以与新主节点通信了。</p>
<h2 id="哨兵集群如何组成的"><a href="#哨兵集群如何组成的" class="headerlink" title="哨兵集群如何组成的"></a>哨兵集群如何组成的</h2><p>其实搭建哨兵并配置信息的时候，只需要设置<strong>主节点</strong>名字、IP和端口号以及quorum值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; </span><br></pre></td></tr></table></figure>

<p>既没有填其他<strong>哨兵节点</strong>信息，也没有填其他的<strong>从节点</strong>信息。</p>
<p>其实哨兵节点之间是通过<u><em><strong>Redis的发布者&#x2F;订阅者机制</strong></em></u>来<strong>相互发现</strong>的。</p>
<p>主节点上有一个订阅频道，名为_sentinel_:hello，比如下图的A把自己的IP和端口发到这个频道上，B、C订阅了这个频道，B、C就可以获取A的位置，进而形成哨兵集群。</p>
<img src="https://img-blog.csdnimg.cn/a6286053c6884cf58bf397d01674fe80.png" alt="img" style="zoom: 40%;" />

<p>那么哨兵又是<strong>如何监控</strong>从节点的呢？</p>
<p>哨兵会向主节点发送INFO命令来获取从节点的信息，主节点就返回从节点列表。然后哨兵根据这个列表的信息，与每个从节点建立连接。</p>
<img src="https://img-blog.csdnimg.cn/fdd5f695bb3643258662886f9fba0aab.png" alt="img" style="zoom:40%;" />

<h1 id="过期删除与内存淘汰策略"><a href="#过期删除与内存淘汰策略" class="headerlink" title="过期删除与内存淘汰策略"></a>过期删除与内存淘汰策略</h1><p>过期删除策略一共有三种：</p>
<p><u>定时删除</u>：在设置key的过期时间时，同时创建一个过期时间。保证过期的key被及时删除，所以<strong>对内存友好</strong>，但是过多的过期key会<strong>对CPU不友好</strong>。</p>
<p><u>惰性删除</u>：不主动删除过期key，而是当数据库访问到key时，检测key有无过期，过期了就删除。这对CPU非常友好，但是会<strong>造成内存空间浪费</strong>。</p>
<p><u>定期删除</u>：每隔一段时间从数据库随机取出一定数量的key，删除过期key。相比定时和惰性，定时删除策略是一种较为居中的方案。</p>
<h2 id="Redis过期删除策略"><a href="#Redis过期删除策略" class="headerlink" title="Redis过期删除策略"></a>Redis过期删除策略</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5.jpg" alt="img"></p>
<p>Redis采用<strong>惰性删除+定期删除策略</strong></p>
<p>惰性删除由<strong>db.c文件的expireIfNeeded</strong>函数实现，如果被访问的key过期，在Redis4.0之后提供了<strong>lazyfree_lazy_expire</strong>参数配置，<strong>1为异步删除，反之同步删除</strong>，返回null。如果没过期，就返回数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 key 是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/* 删除过期键 */</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除；</span></span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4.jpg" alt="img" style="zoom: 33%;" />

<p>定期删除策略：</p>
<p><strong>间隔时间</strong>：Redis配置文件redis.config默认为10hz，即<strong>每秒10次检查一次数据库</strong>，这个检查是<strong>随机</strong>抽查，而且<strong>数量一定</strong>，而不是数据库全部。</p>
<p><strong>抽查数量</strong>：数量是写死的，为20。在expire.c文件中的activeExpireCycle函数的ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP参数定义为20。</p>
<p>具体流程就是：</p>
<p>1.从库中**<u>随机取20个</u>**key，即从过期字典(expires dict)中随机取20个</p>
<p>2.检查这20个**<u>是否过期</u>**，过期了删除即可；</p>
<p>3.删除后，查看**<u>是否超时</u>**，超时直接退出；</p>
<p>4.未超时，还要看删除的数据是否大于20个的**<u>25%</u>**，也就是是否超过4个，如果超过，则继续随机取20，进行循环</p>
<p>伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//已过期的数量</span></span><br><span class="line">    expired = <span class="number">0</span>；</span><br><span class="line">    <span class="comment">//随机抽取的数量</span></span><br><span class="line">    num = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        <span class="comment">//1. 从过期字典中随机抽取 1 个 key</span></span><br><span class="line">        <span class="comment">//2. 判断该 key 是否过期，如果已过期则进行删除，同时对 expired++</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 超过时间限制则退出</span></span><br><span class="line">    <span class="keyword">if</span> (timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果本轮检查的已过期 key 的数量，超过 25%，则继续随机抽查，否则退出本轮检查 */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (expired &gt; <span class="number">20</span>/<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B.jpg" alt="img" style="zoom:33%;" />

<h2 id="Redis内存淘汰策略"><a href="#Redis内存淘汰策略" class="headerlink" title="Redis内存淘汰策略"></a>Redis内存淘汰策略</h2><p>redis.conf可通过maxmemory &lt; bytes &gt;设置最大内存，当Redis运行内存<strong>超过设置的最大内存</strong>时，就会触发内存淘汰策略。</p>
<p>64位操作系统的maxmemory默认为0，即没有最大内存限制</p>
<p>32位操作系统默认为3G，因为运行内存最大就支持4G</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.jpg" alt="img"></p>
<p>Redis的内存淘汰策略有两类（共8种）：</p>
<ol>
<li>第一类就是不淘汰策略：noevication，这时Redis3.0之后默认的内存淘汰策略。表示超过内存<strong>不再提供服务</strong>，直接<strong>返回错误</strong>。</li>
<li>第二类是进行淘汰：分为 对设置了过期时间的数据进行淘汰 以及 所有数据范围的淘汰</li>
</ol>
<p>前者有4种：</p>
<ul>
<li>volatile-random:随机淘汰任意键值</li>
<li>volatile-ttl:优先淘汰最早过期的key（头进尾出淘汰尾端）</li>
<li>volatile-lru:优先淘汰最久未使用的key（时间间隔最久）</li>
<li>volatile_lfu:优先淘汰最少使用的key（频率最低）</li>
</ul>
<p>后者有3种：</p>
<ul>
<li>allkeys-random:和上边一样</li>
<li>allkeys-lru:和上边一样</li>
<li>allkeys-lfu:和上边一样</li>
</ul>
<h3 id="查看当前的内存淘汰策略"><a href="#查看当前的内存淘汰策略" class="headerlink" title="查看当前的内存淘汰策略"></a>查看当前的内存淘汰策略</h3><ul>
<li>通过命令config get maxmemory-policy</li>
</ul>
<h3 id="设置内存淘汰策略"><a href="#设置内存淘汰策略" class="headerlink" title="设置内存淘汰策略"></a>设置内存淘汰策略</h3><ul>
<li>方式1：config set maxmemory-policy &lt;策略&gt;，设置后立即生效，不需重启Redis，但重启就失效；</li>
<li>方式2：修改Redis配置文件，设置maxmemory-policy &lt;策略&gt;，必须重启，配置永久生效。</li>
</ul>
<h2 id="LRU和LFU"><a href="#LRU和LFU" class="headerlink" title="LRU和LFU"></a>LRU和LFU</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><ul>
<li>LRU-Least Recently Used即<strong>最近最少使用</strong>（时间层面）。</li>
</ul>
<p>传统LRU是基于链表的，新的key放链表头，最久未使用的就在链表尾。但是链表存储本身就带来<strong>额外的空间开销</strong>，而且每个节点被访问时都要将节点放到链表头部，当链表移动操作过多（key访问次数多）时，<strong>时间开销</strong>也不小。</p>
<p>Redis的LRU是<strong>近似的LRU算法</strong>，<strong>随机取5个值（可设置）</strong>，然后<strong>淘汰最久没用的key</strong>。没有链表就没有了上面提到的额外的<u>空间</u>和<u>时间</u>的开销，但是无法避免**<u>缓存污染</u>**问题。</p>
<p><strong>缓存污染</strong>指的是：某个应用<strong>一次读取了大量数据</strong>，那么这些数据会在内存中<strong>存放很久</strong>，所以这间接告诉我们要用key的使用频率来进行淘汰。</p>
<h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>LFU-Least Frequently Used即<strong>最近不常使用</strong>（频率）。</p>
<ul>
<li><p>在LRU算法中：在Redis对象头中，24bits的lru字段用来记录key的访问时间戳，可以对lru字段进行比较来直接淘汰最久未被使用的key.</p>
</li>
<li><p>在LFU算法中：在Redis对象头中，24bits的lru字段分成两段，<strong>高16bits存储ldt</strong>（），<strong>低8bit存储logc</strong>（Logistic Counter）</p>
</li>
</ul>
<p>ldt是key的<strong>最后一次的访问时间戳</strong>；logc是<strong>key的访问频次</strong>，越小代表频次越低，初始值为5</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/lru%E5%AD%97%E6%AE%B5.png" alt="img" style="zoom: 40%;" />

<p>每次key被访问都会先对logc进行<strong>衰减操作</strong>，衰减程度与当前时间和ldt的差值成正相关，也就是<strong>间隔时间越长，ldt衰减越大</strong>。</p>
<p>衰减完了要做<strong>增加操作</strong>，按概率增加，logc越大，增加越难。</p>
<p>redis.conf提供两个配置项：</p>
<ul>
<li>lfu-decay-time用于调整logc衰减速度，以分钟为单位，数值越大，衰减越慢</li>
<li>lfu-log-facter用于调整logc的增长速度，数值越大，衰减越慢</li>
</ul>
<h1 id="数据库和缓存如何保证一致性"><a href="#数据库和缓存如何保证一致性" class="headerlink" title="数据库和缓存如何保证一致性"></a>数据库和缓存如何保证一致性</h1><h2 id="双库更新策略"><a href="#双库更新策略" class="headerlink" title="双库更新策略"></a>双库更新策略</h2><p><u>先更新数据库，再更新缓存</u>：数据库肯定更新正确，但是<strong>缓存更新是后置的并发线程</strong>，很难保证所有更新缓存的线程按顺序执行。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/8febac10b14bed16cb96d1d944cd08da.png" alt="图片" style="zoom:50%;" />

<p><u>先更新缓存，再更新数据库</u>：这次缓存更新没问题，但是<strong>数据库更新是后置的并发线程</strong>，也同样难以保证按顺序进行。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/454a8228a6549176ad7e0484fba3c92b.png" alt="图片" style="zoom:50%;" />

<h2 id="更新数据库删除缓存策略"><a href="#更新数据库删除缓存策略" class="headerlink" title="更新数据库删除缓存策略"></a>更新数据库删除缓存策略</h2><p>这次不通过写操作更新缓存了，而是通过读操作的缓存未命中，来从数据库中<strong>读取并回写</strong>到缓存中，从而实现缓存的更新。这也叫<strong>Cache Aside 策略</strong>——旁路缓存策略。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/6e3db3ba2f829ddc14237f5c7c00e7ce.png" alt="图片" style="zoom:50%;" />

<p><u>先删除缓存，再更新数据库</u>：有可能出现删除缓存的写操作执行后，<strong>立刻来了读操作</strong>，这样用户在缓存中读取不到数据，数据库就会<strong>把旧数据更新到缓存</strong>，而数据库的写操作线程最后才执行，导致数据库和缓存数据不一致。</p>
<p>有种办法叫延迟双删，也就是为了避免数据库更新前，缓存已经完成删除又更新。<strong>数据库更新时，其他请求睡眠一段时间</strong>，这是为了保证数据库更新完成。<strong>睡眠过后，再删除一次缓存</strong>，但是极端情况可能还是会出现不一致，所以不是很推荐。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/cc208c2931b4e889d1a58cb655537767.png" alt="图片" style="zoom:50%;" />

<p><u>先更新数据库，再删除缓存</u>：可能会出现在<strong>数据库更新数据前，来了个读请求</strong>，查询到缓存没数据，就去库里读旧数据，读完还未更新缓存，数据库执行了写操作将数据更新，然后删除缓存，最后旧数据写到了缓存中，<strong>造成刚刚删除缓存的写操作正好为旧数据”腾了个位置“</strong>。此时缓存是旧数据，数据库是新数据。</p>
<p>不过这种现象可能性较小，因为缓存的写入远远快于数据库的写入，<strong>通常数据库更新前，前面的缓存写操作就执行完了</strong>。那么最后的缓存删除就有效了。</p>
<p>为了以防万一，会为缓存的数据设置过期时间，防止数据不一致持续太久。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/1cc7401143e79383ead96582ac11b615.png" alt="图片" style="zoom:50%;" />

<h2 id="业务对缓存命中率要求很高怎么办？"><a href="#业务对缓存命中率要求很高怎么办？" class="headerlink" title="业务对缓存命中率要求很高怎么办？"></a>业务对缓存命中率要求很高怎么办？</h2><p>那就不能用删除缓存的办法了，还是得用双库更新策略——更新数据库再更新缓存。</p>
<p>为了解决并发问题：</p>
<p>可以在<strong>缓存更新前上分布式锁</strong>，这样同一时间只运行一个更新缓存的写操作，这会<strong>对业务写入性能造成影响</strong>。</p>
<p>给缓存加上较短的<strong>过期时间</strong>，这会比直接删除缓存好一些。</p>
<h2 id="缓存删除失败怎么办？-异步操作缓存"><a href="#缓存删除失败怎么办？-异步操作缓存" class="headerlink" title="缓存删除失败怎么办？(异步操作缓存)"></a>缓存删除失败怎么办？(异步操作缓存)</h2><p>以下方案都是针对<u>先更新数据库，再删缓存策略</u>——<strong>异步操作缓存</strong></p>
<p><u>方案一：消息队列</u></p>
<p>如果应用删除缓存失败，就从消息队列中重新读取数据，再次删除缓存。这样的重试超过一定次数，就向业务层报错。如果删除成功，就从消息队列中移除数据。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a4440f0d572612e0832b903e4a62bd2b.png" alt="图片"></p>
<p><u>方案二：订阅 MySQL binlog，再操作缓存</u></p>
<p>数据库更新成功就会产生一个变更日志，<strong>通过订阅该日志，拿到具体要操作的数据</strong>，然后再执行删除缓存的操作。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/2ee2280e9f59b6b4879ebdec6eb0cf52.png" alt="图片" style="zoom: 60%;" />

<p>Canal中间件<strong>伪装成从库向主库索要binlog</strong>，然后解析binlog为便于读取的结构化数据，供下游程序订阅使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="cl3yfz0zx0000b8v6elnn24sa" data-title="Redis知识点" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/2022/07/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80%E5%8F%8A%E8%83%8C%E5%8C%85%E9%A2%98%E8%A7%A3/">动态规划基础及背包题解</a>
          </li>
        
          <li>
            <a href="/2022/07/06/SQL%E9%A2%98%E8%A7%A3/">SQL题解</a>
          </li>
        
          <li>
            <a href="/2022/07/02/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E9%A2%98%E8%A7%A3/">股票问题题解</a>
          </li>
        
          <li>
            <a href="/2022/07/01/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">十大排序算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>