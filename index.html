<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Reex</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Reex">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Reex">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Reex" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Reex</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-十大排序算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/01/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2022-07-01T01:58:17.000Z" itemprop="datePublished">2022-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/01/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">十大排序算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/01/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-id="cl51t3ry10000r8v6ap7w4cjp" data-title="十大排序算法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/26/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-06-26T05:47:11.000Z" itemprop="datePublished">2022-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/26/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Linux学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Linux组管理和权限管理"><a href="#Linux组管理和权限管理" class="headerlink" title="Linux组管理和权限管理"></a>Linux组管理和权限管理</h2><h3 id="1-修改文件所有者"><a href="#1-修改文件所有者" class="headerlink" title="1.修改文件所有者"></a>1.修改文件所有者</h3><p>指令：chown 用户名 文件名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown tom apple.txt</span><br></pre></td></tr></table></figure>

<h3 id="2-组及用户的创建"><a href="#2-组及用户的创建" class="headerlink" title="2.组及用户的创建"></a>2.组及用户的创建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd monster</span><br><span class="line">useradd fox</span><br></pre></td></tr></table></figure>

<h3 id="3-创建用户并将其放入组中"><a href="#3-创建用户并将其放入组中" class="headerlink" title="3.创建用户并将其放入组中"></a>3.创建用户并将其放入组中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -g monster fox</span><br></pre></td></tr></table></figure>

<h3 id="4-改变用户所在组-用户已存在"><a href="#4-改变用户所在组-用户已存在" class="headerlink" title="4.改变用户所在组(用户已存在)"></a>4.改变用户所在组(用户已存在)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g monster fox</span><br></pre></td></tr></table></figure>

<h3 id="5-修改文件-x2F-目录所在组"><a href="#5-修改文件-x2F-目录所在组" class="headerlink" title="5.修改文件&#x2F;目录所在组"></a>5.修改文件&#x2F;目录所在组</h3><p>指令：chgrp 组名 文件&#x2F;目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chgrp fruit orange.text</span><br><span class="line">chgrp fruit lemon</span><br></pre></td></tr></table></figure>

<h3 id="6-权限介绍"><a href="#6-权限介绍" class="headerlink" title="6.权限介绍"></a>6.权限介绍</h3><p>ls -l 显示内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc</span><br></pre></td></tr></table></figure>

<p>第0位是文件类型：l是链接，d是目录，c是字符设备文件如鼠标键盘，b是块设备如硬盘</p>
<ul>
<li><p>1-3位是<strong>所有者</strong>对文件的权限-User</p>
</li>
<li><p>4-6位是<strong>所属组</strong>对文件的权限-Group</p>
</li>
<li><p>7-9位是<strong>其他用户</strong>对文件的权限-Other</p>
</li>
<li><p>1代表文件的<strong>硬链接数</strong>或者目录的<strong>子目录数</strong>；前面的root代表<strong>所属用户</strong>；后面的root代表<strong>所属组</strong></p>
</li>
<li><p>1213代表<strong>文件大小</strong>（字节）；Feb 2 09:39代表<strong>最后修改时间</strong>；abc代表<strong>文件&#x2F;目录名</strong></p>
<ul>
<li><p>对于普通文件来说：rwx分别是可读取，查看；可修改（不代表可删除）；可被执行（execute）</p>
</li>
<li><p>对于目录来说：rwx分别代表可读取目录内容；可修改包括对目录内部进行创建+删除+重命名操作；可以进入目录</p>
</li>
<li><p>rwx也可以用数字表示，r&#x3D;4,w&#x3D;2,x&#x3D;1</p>
</li>
</ul>
</li>
</ul>
<p>这里的可被执行x权限，对于目录来说是至关重要的：1.因为<strong>目录只有赋予了x执行权限，才可以进入</strong>，否则读r和写w都是空谈；2.有了执行x权限，只能进入目录，<strong>必须有可读r权限才可以看到目录的内容</strong>；3.目录的文件能不能删除，<strong>只取决于文件所在目录是否有写w权限</strong>，没有对目录的w权限就无法删除目录内的所有文件（<em>文件所有者除外</em>  <u>存疑？</u>）。</p>
<p>对于<strong>普通文件</strong>，可执行x权限没什么用。</p>
<p>对于<strong>shell脚本</strong>，如果没有x权限，则无法执行。</p>
<h3 id="7-修改权限"><a href="#7-修改权限" class="headerlink" title="7.修改权限"></a>7.修改权限</h3><p><strong>chmod</strong>(change mode)可修改文件&#x2F;目录的权限</p>
<p>1.给abc的user读写执行权限，group读和执行权限，other读和执行权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rwx,g=rx,o=rx abc</span><br><span class="line">chmod 755 abc</span><br></pre></td></tr></table></figure>

<p>2.给abc文件user<strong>去除</strong>执行权限，group<strong>增加</strong>写权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u-x,g+w abc</span><br></pre></td></tr></table></figure>

<p>3.给abc文件<strong>所有用户添加</strong>读的权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+r abc</span><br></pre></td></tr></table></figure>

<h3 id="8-修改文件-x2F-目录所有者"><a href="#8-修改文件-x2F-目录所有者" class="headerlink" title="8.修改文件&#x2F;目录所有者"></a>8.修改文件&#x2F;目录所有者</h3><p>指令：chown newowner 文件&#x2F;目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown tom /home/abc.txt</span><br><span class="line">目录及目录下所有文件都改成tom所属，需要用递归-R</span><br><span class="line">chown -R tom /home/test</span><br></pre></td></tr></table></figure>

<h3 id="9-修改文件-x2F-目录所在组"><a href="#9-修改文件-x2F-目录所在组" class="headerlink" title="9.修改文件&#x2F;目录所在组"></a>9.修改文件&#x2F;目录所在组</h3><p>指令：chgrp newgroup 文件&#x2F;目录 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chgrp shaolin /home/abc.text</span><br><span class="line">目录及目录下所有文件都改成shaolin所属，需要用递归-R</span><br><span class="line">chgrp -R shaolin /home/test</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/26/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cl4uw2rde0000w4v6fju620ds" data-title="Linux学习笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-链表题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/24/%E9%93%BE%E8%A1%A8%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-06-24T10:54:39.000Z" itemprop="datePublished">2022-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/24/%E9%93%BE%E8%A1%A8%E9%A2%98%E8%A7%A3/">链表题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="leetcode-203-移除链表元素"><a href="#leetcode-203-移除链表元素" class="headerlink" title="leetcode 203.移除链表元素"></a>leetcode 203.移除链表元素</h2><p><u><strong>题目</strong>：给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</u></p>
<img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img" style="zoom:50%;" />

<p><u>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6</u><br><u>输出：[1,2,3,4,5]&lt;&#x2F;u</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-206-反转链表"><a href="#leetcode-206-反转链表" class="headerlink" title="leetcode 206.反转链表"></a>leetcode 206.反转链表</h2><p><u><strong>题目</strong>：给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表</u>。</p>
<img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img" style="zoom:50%;" />

<p><u>输入：head &#x3D; [1,2,3,4,5]</u><br><u>输出：[5,4,3,2,1]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="☆leetcode-24-两两交换链表中的节点"><a href="#☆leetcode-24-两两交换链表中的节点" class="headerlink" title="☆leetcode 24.两两交换链表中的节点"></a>☆leetcode 24.两两交换链表中的节点</h2><p><u><strong>题目</strong>：给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</u></p>
<img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单指针pre</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="literal">null</span> &amp;&amp; pre.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获得第三个节点（后面的第一个节点）</span></span><br><span class="line">            temp = head.next.next;</span><br><span class="line">            <span class="comment">//将前面的节点与第二个节点相连</span></span><br><span class="line">            pre.next = head.next;</span><br><span class="line">            <span class="comment">//第二个节点与第一个节点相连</span></span><br><span class="line">            head.next.next = head;</span><br><span class="line">            <span class="comment">//第一个节点与第三个节点</span></span><br><span class="line">            head.next = temp;</span><br><span class="line">            <span class="comment">//将前指针指向第一个节点（改之后的第二个节点）</span></span><br><span class="line">            pre = head;</span><br><span class="line">            <span class="comment">//后指针指向第三个节点（下一组节点的首个节点）</span></span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三指针node1,node2,pre</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="literal">null</span> &amp;&amp; pre.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//分别保存第一个节点和第二个节点的位置(避免直接对head进行操作)</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> pre.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> pre.next.next;</span><br><span class="line">            node1.next = node2.next;</span><br><span class="line">            pre.next = node2;</span><br><span class="line">            node2.next = node1;</span><br><span class="line">            pre = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//如果本次不够两个节点，就不需要反转，直接返回该组节点head即可</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存第二个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//当前头结点指向后面反转后的头结点（重点！）</span></span><br><span class="line">        head.next = swapPairs(temp.next);</span><br><span class="line">        <span class="comment">//当前第二个节点指向头结点</span></span><br><span class="line">        temp.next = head;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-19-删除链表的倒数第N个结点"><a href="#leetcode-19-删除链表的倒数第N个结点" class="headerlink" title="leetcode 19.删除链表的倒数第N个结点"></a>leetcode 19.删除链表的倒数第N个结点</h2><p><u><strong>题目</strong>：给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</u></p>
<img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以倒数第二个节点n&#x3D;2为例，我们发现：只要让后指针cur从dummy向右走n个节点，那么cur和pre始终相隔n个节点。这样，当cur和pre同时向后走的时候，cur走到了最后一个节点时pre正好走到<strong>待删除节点的前面一个节点</strong>。</p>
<h2 id="leetcode-142-环形链表-II"><a href="#leetcode-142-环形链表-II" class="headerlink" title="leetcode 142 环形链表 II"></a>leetcode 142 环形链表 II</h2><p><u><strong>题目</strong>：给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</u></p>
<p><u>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</u></p>
<p><u>不允许修改链表。</u></p>
<img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">//一旦两指针相遇，就定义一个从head头指针出发的init指针，slow指针默认向后走</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">init</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span>(init != slow) &#123;</span><br><span class="line">                    init = init.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-面试题02-07-链表相交"><a href="#leetcode-面试题02-07-链表相交" class="headerlink" title="leetcode 面试题02.07.链表相交"></a>leetcode 面试题02.07.链表相交</h2><p><u><strong>题目</strong>：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</u></p>
<p><u>图示两个链表在节点 c1 开始相交：</u></p>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img" style="zoom:50%;" />

<p><u>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</u></p>
<p><u><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA, curB = headB;</span><br><span class="line">        <span class="keyword">while</span>(curA != curB) &#123;</span><br><span class="line">            <span class="comment">//这里第一个=后面一定要是cur而不能是cur.next，否则会陷入死循环</span></span><br><span class="line">            curA = curA != <span class="literal">null</span> ? curA.next : headB;</span><br><span class="line">            curB = curB != <span class="literal">null</span> ? curB.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法二：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA, curB = headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">1</span>, lenB = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//1.先把AB链表的长度求出来</span></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">null</span>) &#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(curB != <span class="literal">null</span>) &#123;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.易错！！！：一定要先归位，否则后面两两交换的指针curA,curB是null</span></span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">//3.判断谁大，B大就把A换成B</span></span><br><span class="line">        <span class="keyword">if</span>(lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> lenA;</span><br><span class="line">            lenA = lenB;</span><br><span class="line">            lenB = temp;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> curA;</span><br><span class="line">            curA = curB;</span><br><span class="line">            curB = tempNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.计算两链表差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> lenA - lenB;</span><br><span class="line">        <span class="comment">//5.让长链表的指针指向与短链表等长的位置</span></span><br><span class="line">        <span class="keyword">while</span>(len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.让A和B在相等长度的起点同时向后走</span></span><br><span class="line">        <span class="keyword">while</span>(curA != curB) &#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题法一的思路就是：我们假设AB有公共部分长度为c，A总长度为a，那么非公共长度就是a - c；同理，B总长度为b，非公共长度为b - c。那么当A从头走到尾的时候（curA &#x3D;&#x3D; null），再继续从B的头结点headB继续向后走，直到走到公共节点时，一共走了a + (b - c)；而B从头走到尾，再从headA走到公共节点，一共走了b + (a - c)；我们发现这两个长度是相等的。</p>
<p>如果没有公共交点，那么两个指针curA和curB最多走完a + b（最少就是两链表长度相等，各自走完自己的长度就同时等于零了）最后到null的时候就可以返回null了。双方一定是同时走到null的。</p>
<p>所以总的来说循环条件就是curA !&#x3D; curB。</p>
<h2 id="leetcode-141-环形链表"><a href="#leetcode-141-环形链表" class="headerlink" title="leetcode 141.环形链表"></a>leetcode 141.环形链表</h2><p><u><strong>题目</strong>：给你一个链表的头节点 head ，判断链表中是否有环。</u></p>
<p><u>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</u></p>
<p><u>如果链表中存在环 ，则返回 true 。 否则，返回 false</u> </p>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-21-合并两个有序链表"><a href="#leetcode-21-合并两个有序链表" class="headerlink" title="leetcode 21.合并两个有序链表"></a>leetcode 21.合并两个有序链表</h2><p><u><strong>题目</strong>：将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</u></p>
<img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="literal">null</span>) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val) &#123;</span><br><span class="line">            list1.next = mergeTwoLists(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            list2.next = mergeTwoLists(list1, list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-61-旋转链表"><a href="#leetcode-61-旋转链表" class="headerlink" title="leetcode 61.旋转链表"></a>leetcode 61.旋转链表</h2><p><u><strong>题目</strong>：给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</u></p>
<img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//1.首先要判空</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//2.让cur指针走到最后一个节点，并计算链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.链接尾指针与头指针</span></span><br><span class="line">        cur.next = head;</span><br><span class="line">        <span class="comment">//4.关键！！！：计算cur指针要走的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">path</span> <span class="operator">=</span> len - k % len;</span><br><span class="line">        <span class="comment">//5.让cur指针走向&quot;新头结点&quot;的前面一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(path-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.断开链表，返回新头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-83-删除排序链表中的重复元素"><a href="#leetcode-83-删除排序链表中的重复元素" class="headerlink" title="leetcode 83.删除排序链表中的重复元素"></a>leetcode 83.删除排序链表中的重复元素</h2><p><u><strong>题目</strong>：给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</u></p>
<img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == cur.next.val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-82-删除排序链表中的重复元素-II"><a href="#leetcode-82-删除排序链表中的重复元素-II" class="headerlink" title="leetcode 82.删除排序链表中的重复元素 II"></a>leetcode 82.删除排序链表中的重复元素 II</h2><p><u>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</u></p>
<img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">200</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">//1.这里cur是从哑节点开始的，所以要判断cur.next和cur.next.next</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">                <span class="comment">//2.一旦相等，就要把所有相等的元素一个一个的删除</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">delNum</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="comment">//3.每次一个个删除的时候，要避免空指针操作</span></span><br><span class="line">                <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == delNum) &#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//4.不相等就继续向后走</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-86-分割链表"><a href="#leetcode-86-分割链表" class="headerlink" title="leetcode 86.分割链表"></a>leetcode 86.分割链表</h2><p><u>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</u></p>
<p><u>你应当 保留 两个分区中每个节点的初始相对位置。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">smallDummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">small</span> <span class="operator">=</span> smallDummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">largeDummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">large</span> <span class="operator">=</span> largeDummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val &lt; x) &#123;</span><br><span class="line">                small.next = cur;</span><br><span class="line">                small = small.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                large.next = cur;</span><br><span class="line">                large = large.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里一定要让large指向null，否则链表会有环</span></span><br><span class="line">        large.next = <span class="literal">null</span>;</span><br><span class="line">        small.next = largeDummy.next;</span><br><span class="line">        <span class="keyword">return</span> smallDummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="★leetcode-92-反转链表-II"><a href="#★leetcode-92-反转链表-II" class="headerlink" title="★leetcode 92.反转链表 II"></a>★leetcode 92.反转链表 II</h2><p><u><strong>题目</strong>：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</u></p>
<img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rightEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="comment">//cur指针走到需要反转的链表的左节点的左边节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; left - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录左节点的左边节点和左节点</span></span><br><span class="line">        leftEdge = cur;</span><br><span class="line">        leftNode = cur.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; right - left + <span class="number">1</span>;i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录右节点和右节点的右边节点</span></span><br><span class="line">        rightNode = cur;</span><br><span class="line">        rightEdge = cur.next;</span><br><span class="line">        <span class="comment">//断开链表</span></span><br><span class="line">        leftEdge.next = <span class="literal">null</span>;</span><br><span class="line">        rightNode.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//反转链表</span></span><br><span class="line">        reverse(leftNode);</span><br><span class="line">        <span class="comment">//重新连接链表</span></span><br><span class="line">        leftEdge.next = rightNode;</span><br><span class="line">        leftNode.next = rightEdge;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转链表的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-143-重排链表"><a href="#leetcode-143-重排链表" class="headerlink" title="leetcode 143.重排链表"></a>leetcode 143.重排链表</h2><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>
<p>L0 → L1 → … → Ln - 1 → Ln</p>
<p>请将其重新排列后变为：</p>
<p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</p>
<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<img src="https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftEnd</span> <span class="operator">=</span> getMid(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rightHead</span> <span class="operator">=</span> leftEnd.next;</span><br><span class="line">        leftEnd.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newRightHead</span> <span class="operator">=</span> reverse(rightHead);</span><br><span class="line">        reorder(head, newRightHead);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取中点，取两中点的前一个</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getMid</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转链表</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorder</span><span class="params">(ListNode left, ListNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> left.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> right.next;</span><br><span class="line">            left.next = right;</span><br><span class="line">            left = node1;</span><br><span class="line">            right.next = left;</span><br><span class="line">            right = node2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线性表法：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="leetcode-234-回文链表"><a href="#leetcode-234-回文链表" class="headerlink" title="leetcode 234.回文链表"></a>leetcode 234.回文链表</h2><p><u>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</u></p>
<img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//主方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftHead</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftEnd</span> <span class="operator">=</span> getMid(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rightHead</span> <span class="operator">=</span> leftEnd.next;</span><br><span class="line">        leftEnd.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newRightHead</span> <span class="operator">=</span> reverse(rightHead);</span><br><span class="line">        <span class="keyword">return</span> compare(leftHead, newRightHead);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取中间节点（该方法注意细节，4个节点的中间节点是第2个节点）</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getMid</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转链表，并返回新的头结点</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断两个链表的每个节点是否一一相等</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(ListNode left, ListNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left.val == right.val) &#123;</span><br><span class="line">                left = left.next;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-237-删除链表中的节点"><a href="#leetcode-237-删除链表中的节点" class="headerlink" title="leetcode 237.删除链表中的节点"></a>leetcode 237.删除链表中的节点</h2><p><u><strong>题目</strong>：请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。</u></p>
<p><u>题目数据保证需要删除的节点 不是末尾节点 。</u></p>
<img src="https://assets.leetcode.com/uploads/2020/09/01/node1.jpg" alt="img" style="zoom: 33%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">        node.val = next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-876-链表的中间结点"><a href="#leetcode-876-链表的中间结点" class="headerlink" title="leetcode 876.链表的中间结点"></a>leetcode 876.链表的中间结点</h2><p><u><strong>题目</strong>：给定一个头结点为 <code>head</code> 的非空单链表，返回链表的中间结点。</u></p>
<p><u>如果有两个中间结点，则返回第二个中间结点。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/24/%E9%93%BE%E8%A1%A8%E9%A2%98%E8%A7%A3/" data-id="cl4uw2rdm0001w4v680s74f42" data-title="链表题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-acm输入输出练习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/20/acm%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2022-06-20T08:36:04.000Z" itemprop="datePublished">2022-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/20/acm%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/">acm输入输出练习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="A-B-1"><a href="#A-B-1" class="headerlink" title="A+B(1)"></a>A+B(1)</h2><p><u>题目：输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 1000)，输入的数据包括多组，输出a+b的结果</u></p>
<p><u>输入</u>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 5</span><br><span class="line">10 20</span><br></pre></td></tr></table></figure>

<p><u>输出</u>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//sc.next()默认返回字符串，所以要转型，sc.nextInt()返回int型变量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(sc.next());<span class="comment">//或者写sc.nextInt()</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(sc.next());</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-2"><a href="#A-B-2" class="headerlink" title="A+B(2)"></a>A+B(2)</h2><p><u>题目：第一行输入数据组数t，第二行及以后输入a，b，输出每行a+b的结果</u></p>
<p><u>输入</u>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 5</span><br><span class="line">10 20</span><br></pre></td></tr></table></figure>

<p><u>输出</u>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//就比上面一题多了一个明确的行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-3"><a href="#A-B-3" class="headerlink" title="A+B(3)"></a>A+B(3)</h2><p><u>题目：输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据有多组, 如果输入为0 0则结束输入，输出a+b的结果</u></p>
<p><u>输入</u>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 5</span><br><span class="line">10 20</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>

<p><u>输出</u>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//break也行，效果一样</span></span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-4"><a href="#A-B-4" class="headerlink" title="A+B(4)"></a>A+B(4)</h2><p><u>题目：输入的每行数据的开头第一个数字是本行需要求和的数字个数n，当n为0时，代表本行没有要求和的数字，即结束输入，请输出每组数据求和的结果。</u></p>
<p><u>输入</u>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 1 2 3 4</span><br><span class="line">5 1 2 3 4 5</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><u>输出</u>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="comment">//每行头部的n为0则跳出循环，结束本方法</span></span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                ans += a;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-5"><a href="#A-B-5" class="headerlink" title="A+B(5)"></a>A+B(5)</h2><p><u>题目：输入的第一行包括一个正整数t(1 &lt;&#x3D; t &lt;&#x3D; 100), 表示数据组数。</u><br><u>接下来t行, 每行一组数据。</u><br><u>每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。</u><br><u>接下来n个正整数, 即需要求和的每个正整数。</u></p>
<p><u>输入</u>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4 1 2 3 4</span><br><span class="line">5 1 2 3 4 5</span><br></pre></td></tr></table></figure>

<p><u>输出</u>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">        	<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; size;j++) &#123;</span><br><span class="line">            	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                ans += a;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-6"><a href="#A-B-6" class="headerlink" title="A+B(6)"></a>A+B(6)</h2><p><u>题目：输入数据有多组, 每行表示一组输入数据。</u><br><u>每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。</u><br><u>接下来n个正整数, 即需要求和的每个正整数。</u></p>
<p><u>输入</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 1 2 3 4</span><br><span class="line">5 1 2 3 4 5</span><br></pre></td></tr></table></figure>

<p><u>输出</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                ans += a;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-7"><a href="#A-B-7" class="headerlink" title="A+B(7)"></a>A+B(7)</h2><p><u>题目：输入数据有多组, 每行表示一组输入数据。</u></p>
<p><u>每行不定有n个整数，空格隔开。(1 &lt;&#x3D; n &lt;&#x3D; 100)。</u></p>
<p><u>输入</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5</span><br><span class="line">0 0 0 0 0</span><br></pre></td></tr></table></figure>

<p><u>输出</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">9</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//将每一个回车分割的每行用空格分开的字符串打包成字符串数组</span></span><br><span class="line">            String[] str = sc.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(String s : str) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line">                ans += a;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String的split-使用场景"><a href="#String的split-使用场景" class="headerlink" title="String的split()使用场景"></a>String的split()使用场景</h2><p>摘自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/take-it-easy/p/14631012.html">笔试：处理输入基础 - 将来的事 - 博客园 (cnblogs.com)</a></p>
<p>预热：将下列输入存入数组中</p>
<p><img src="https://img2020.cnblogs.com/blog/1826667/202104/1826667-20210408101623074-1249320484.png" alt="img" style="zoom: 67%;" /><img src="https://img2020.cnblogs.com/blog/1826667/202104/1826667-20210408101647981-1168655401.png" alt="img" style="zoom: 80%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        String[][] tables = <span class="keyword">new</span> <span class="title class_">String</span>[num][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">            tables[i][<span class="number">0</span>] = sc.next();</span><br><span class="line">            tables[i][<span class="number">1</span>] = sc.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将下列输入存储到数组或集合中</p>
<p><img src="https://img2020.cnblogs.com/blog/1826667/202104/1826667-20210408101739403-2108315231.png" alt="img" style="zoom: 67%;" /><img src="https://img2020.cnblogs.com/blog/1826667/202104/1826667-20210408101755781-1529841151.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//用存放Integer类型的集合存放第一行数据</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        String[] strs = sc.nextLine().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str : strs) &#123;</span><br><span class="line">            list.add(Integer.parseInt(str));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用存放Integer数组的集合存放第二行数据</span></span><br><span class="line">        String[] strs2 = sc.nextLine().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        List&lt;Integer[]&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str : strs2) &#123;</span><br><span class="line">            Integer[] nums = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">2</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = Integer.parseInt(str.split(<span class="string">&quot;-&gt;&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">            nums[<span class="number">1</span>] = Integer.parseInt(str.split(<span class="string">&quot;-&gt;&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">            list2.add(nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将下列数据存放到数组中</p>
<p><img src="https://img2020.cnblogs.com/blog/1826667/202104/1826667-20210408101835317-177328839.png" alt="img" style="zoom: 80%;" /><img src="https://img2020.cnblogs.com/blog/1826667/202104/1826667-20210408101928499-1327331187.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] tables = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; row;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; col;j++) &#123;</span><br><span class="line">                tables[i][j] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/20/acm%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/" data-id="cl4mhgufq00006gv67liz9zsx" data-title="acm输入输出练习" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-贪心系列题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/04/%E8%B4%AA%E5%BF%83%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-06-04T03:14:58.000Z" itemprop="datePublished">2022-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/04/%E8%B4%AA%E5%BF%83%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/">贪心系列题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="leetcode-455-分发饼干"><a href="#leetcode-455-分发饼干" class="headerlink" title="leetcode 455.分发饼干"></a>leetcode 455.分发饼干</h2><p><u><strong>题目</strong>：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</u></p>
<p><u>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</u></p>
<p><u>输入: g &#x3D; [1,2,3], s &#x3D; [1,1]</u><br><u>输出: 1</u><br><u>输入: g &#x3D; [1,2], s &#x3D; [1,2,3]</u><br><u>输出: 2</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小饼干先喂饱小胃口，饼干从小到大遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length &amp;&amp; start &lt; g.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= g[start]) &#123;</span><br><span class="line">                start++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大饼干先喂饱大胃口，胃口从大到小遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> g.length - <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; start &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start] &gt;= g[i]) &#123;</span><br><span class="line">                start--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们肯定先想到的是两层for循环，实际上有一层for循环可以随着count的增加而变化，那么是小饼干还是胃口呢？对于<u>小胃口优先吃饱</u>的思路，如果饼干喂不饱胃口最小的人，肯定要<strong>逐一寻找更大的饼干</strong>，所以一直增大的指针是饼干的数组，而胃口数组的指针必须<strong>喂饱一个再向后走</strong>一个。</p>
<p>对于大胃口优先吃饱的思路，我们知道，最大的胃口一般都满足不了，所以这个时候我们要<strong>逐一去减小胃口</strong>，直到找到能满足最大饼干的<strong>最大胃口的位置</strong>，所以饼干的指针要等到<strong>能喂饱人了再向前走</strong>。</p>
<h2 id="leetcode-376-摆动序列"><a href="#leetcode-376-摆动序列" class="headerlink" title="leetcode 376.摆动序列"></a>leetcode 376.摆动序列</h2><p><u><strong>题目</strong>：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</u></p>
<p><u>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</u></p>
<p><u>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</u><br><u>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</u></p>
<p><u>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//假设最左边还有一个nums[0]，构造一个假的preDiff初始化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//随时用来记录当前节点与前一个节点的差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从第二个数开始算起，所以默认第一个元素一定算进来</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从第二个元素开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="comment">//每次都与前一个元素计算差值</span></span><br><span class="line">            curDiff = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//preDiff == 0的情况只出现在第一次</span></span><br><span class="line">            <span class="keyword">if</span>((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                preDiff = curDiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题就是每次遍历到一个元素，都与前一个做差值，然后比较一下本次差值和上一次差值是不是符号相反，如果相反就累加一个数，如果相同就继续下次循环。</p>
<p>但是第一个元素没有与之做差的元素，所以就<strong>假装最前面还有一个nums[0]<strong>，这样，第一个差值我们就默认为0，所以判断条件里边写的是</strong>preDiff大于等于或小于等于0</strong>。其实这个等号只是最开始的preDiff会等于0，后面随着每次preDiff &#x3D; curDiff，preDiff没有机会再等于0了。</p>
<h2 id="leetcode-53-最大子序和"><a href="#leetcode-53-最大子序和" class="headerlink" title="leetcode 53.最大子序和"></a>leetcode 53.最大子序和</h2><p><u><strong>题目</strong>：给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</u></p>
<p><u><strong>子数组</strong> 是数组中的一个连续部分。</u></p>
<p><u>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</u><br><u>输出：6</u><br><u>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//注意res的初始化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>, res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            pre = Math.max(x, pre + x);</span><br><span class="line">            res = Math.max(pre, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里res很容易初始化为0，如果nums数组中只有{-1}，那么res &#x3D; 0是错的，所以既然res一定是记录nums中一个或几个数字之和，而且nums中含有负数，就让res初始化为nums[0]即可。</p>
<h2 id="leetcode-122-买卖股票的最佳时机-II"><a href="#leetcode-122-买卖股票的最佳时机-II" class="headerlink" title="leetcode 122.买卖股票的最佳时机 II"></a>leetcode 122.买卖股票的最佳时机 II</h2><p><u><strong>题目</strong>：给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</u></p>
<p><u>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</u></p>
<p><u>返回 你能获得的 最大 利润 。</u></p>
<p><u>输入：prices &#x3D; [7,1,5,3,6,4]</u><br><u>输出：7</u><br><u>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 总利润为 4 + 3 &#x3D; 7 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心法，有一点利润就算数：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                sum += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态规划：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//第一天持有股票时的最大利润</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//第一天不持有股票时的最大利润</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>贪心法其实就是<strong>累计利润</strong>的思路</p>
<h2 id="leetcode-55-跳跃游戏"><a href="#leetcode-55-跳跃游戏" class="headerlink" title="leetcode 55.跳跃游戏"></a>leetcode 55.跳跃游戏</h2><p><u><strong>题目</strong>：给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</u></p>
<p><u>数组中的每个元素代表你在该位置可以跳跃的<strong>最大长度</strong>。</u></p>
<p><u>判断你是否能够到达最后一个下标。</u></p>
<p><u>输入：nums &#x3D; [2,3,1,1,4]</u><br><u>输出：true</u><br><u>输入：nums &#x3D; [3,2,1,0,4]</u><br><u>输出：false</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误解法1：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            cover = Math.max(cover, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cover &gt;= nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误解法2：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= cover;i++) &#123;</span><br><span class="line">            cover = Math.max(cover, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cover &gt;= nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确的贪心解法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= cover;i++) &#123;</span><br><span class="line">            cover = Math.max(cover, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(cover &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实本题只要始终记录当前节点能覆盖到的最大范围即可。</p>
<p>但是<u>错误解法1</u>就是犯了每个节点<strong>不停地</strong>算最大cover的错误，我们要知道，<strong>不是每个节点都能遍历到的</strong>，比如[3,2,1,0,4]中的0就永远走不到，那就谈不上计算最后4位置的覆盖范围了。</p>
<p>错误解法2将nums.length范围缩小到<strong>一直变化的cover</strong>了，但是还是有很大问题，比如某个节点的<strong>覆盖范围非常大</strong>，那么接下来i就需要遍历非常大的长度才可以，但是nums可能根本没有这么大长度。</p>
<p>所以<strong>每次</strong>得到当前最大覆盖范围的时候，都要判断<strong>当前的覆盖范围能不能走到最后一个位置</strong>，如果可以的话，就直接返回true了。</p>
<h2 id="☆leetcode-45-跳跃游戏-II"><a href="#☆leetcode-45-跳跃游戏-II" class="headerlink" title="☆leetcode 45.跳跃游戏 II"></a>☆leetcode 45.跳跃游戏 II</h2><p><u><strong>题目</strong>：给你一个非负整数数组 nums ，你<strong>最初</strong>位于数组的<strong>第一个位置</strong>。</u></p>
<p><u>数组中的每个元素代表你在该位置可以跳跃的<strong>最大长度</strong>。</u></p>
<p><u>你的目标是使用<strong>最少的跳跃次数</strong>到达数组的最后一个位置。</u></p>
<p><u>假设你<strong>总是可以</strong>到达数组的最后一个位置</u></p>
<p><u>输入: nums &#x3D; [2,3,1,1,4]</u><br><u>输出: 2</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curRange</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//当前的最大覆盖的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextRange</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//下一步最大覆盖的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录当前走的最大步数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++) &#123;<span class="comment">//注意这里时走到nums.length - 2的位置</span></span><br><span class="line">            nextRange = Math.max(nextRange, nums[i] + i);<span class="comment">//随时下一步最大的覆盖的下标</span></span><br><span class="line">            <span class="keyword">if</span>(i == curRange) &#123;<span class="comment">//一旦当前下标与当前最大覆盖的下标重合</span></span><br><span class="line">                curRange = nextRange;<span class="comment">//更新当前最大覆盖下标为下一个最大覆盖的下标</span></span><br><span class="line">                res++;<span class="comment">//最大步数+1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的贪心策略比较难懂：从一开始先记录第一个最大覆盖范围curRange，然后每次遍历当前节点都记录下一步的最大覆盖范围下标nextRange，这个值是一直变化的，<strong>目的是</strong>等到下标i走到与当前最大覆盖范围下标重合的时候，<strong>更新curRange</strong>。</p>
<p>所以每次只有在当前下标i与当前最大覆盖范围的下标curRange重合的时候，才算一次步数，即ans++。而且只有在这个时候，才更新curRange。</p>
<p>最后的重点就是：<strong>i最后一步是走到nums.length - 2的位置</strong>，下图给出了很明显的解释。如果走到nums.length - 2了，但<strong>没有与curRange重合</strong>，说明当前的覆盖范围已经<strong>足够走到</strong>最后一位了，即nums.length - 1的位置，没有必要再增加步数了；如果<strong>与curRange重合</strong>了，说民当前还<strong>需要再走一步</strong>才可以到达nums.length - 1的位置，所以正好<strong>最后一次循环</strong>还需要进行**ans++**。</p>
<p><img src="https://img-blog.csdnimg.cn/20201201232338693.png" alt="45.跳跃游戏II1" style="zoom: 50%;" /><img src="https://img-blog.csdnimg.cn/20201201232445286.png" alt="45.跳跃游戏II2" style="zoom: 50%;" /></p>
<h2 id="leetcode-1005-K次取反后最大化的数组和"><a href="#leetcode-1005-K次取反后最大化的数组和" class="headerlink" title="leetcode 1005.K次取反后最大化的数组和"></a>leetcode 1005.K次取反后最大化的数组和</h2><p><u><strong>题目</strong>：给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</u></p>
<p><u>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。</u><br><u>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</u></p>
<p><u>以这种方式修改数组后，返回数组 可能的最大和 。</u></p>
<p><u>输入：nums &#x3D; [4,2,3], k &#x3D; 1</u><br><u>输出：5</u><br><u>解释：选择下标 1 ，nums 变为 [4,-2,3] 。</u><br><u>输入：nums &#x3D; [3,-1,0,2], k &#x3D; 3</u><br><u>输出：6</u><br><u>解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] *= -<span class="number">1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为有些负数变成正数之后，比原来的正数还要小，所以一旦k为奇数，还需要对他们进行转为负数的操作</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">1</span>) nums[<span class="number">0</span>] *= -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题就是先对数组排序，然后将数组中的负数全部转换为正数，一旦跳出循环，有三种可能：<u>一种可能就是k还不等于0且数组中也没有负数了</u>，那么就要看<strong>k是不是奇数</strong>，如果是奇数，还需要对数组中最小的非负数进行转为负数的操作，但是这个时候，我们<strong>不知道谁是最小的非负数</strong>，所以还需要对数组再进行排列。<u>另一种可能是k为0，数组中还有负数</u>，那没办法，这些负数因为比较小，被转换为正数的优先级也小，轮不到他们被转换为正数，直接求和即可。</p>
<p>最后一种可能就是<u>k等于0了，而数组中的元素已经没有负数</u>了，这种情况最好了，把k都用了，负数也全部转换成正数了，直接求和即可。</p>
<h2 id="leetcode-134-加油站"><a href="#leetcode-134-加油站" class="headerlink" title="leetcode 134.加油站"></a>leetcode 134.加油站</h2><p><u><strong>题目</strong>：在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</u></p>
<p><u>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</u></p>
<p><u>给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</u></p>
<p><u>输入: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]</u><br><u>输出: 3</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录一段区域差值的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录从0到尾的整个区域的差值最大和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录当前合理的出发点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; gas.length;i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//一旦当前差值的和 &lt; 0，就置零，并将索引向后移动一位</span></span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">                index = (i + <span class="number">1</span>) % gas.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//总的差值总和小于零，说明没有合适的出发点</span></span><br><span class="line">        <span class="keyword">if</span>(totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的思路就是：每次从0位置开始累加当前（加油-耗油的差值），一旦这个差值小于0，说明<strong>这一段区间都不能作为出发点</strong>，所以要从<strong>下一个位置</strong>开始出发，并将刚刚<strong>累加的差值归零</strong>。不要忘了定义一个totalSum用来记录整个过程中的差值累计，如果这个累计最后是负的，说明<strong>加油的量还没有耗油的量多</strong>，又因为出发点车没有油，所以totalSum&lt;0必然没有可靠的出发点。</p>
<h2 id="leetcode-135-分发糖果"><a href="#leetcode-135-分发糖果" class="headerlink" title="leetcode 135.分发糖果"></a>leetcode 135.分发糖果</h2><p><u><strong>题目</strong>：n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</u></p>
<p><u>你需要按照以下要求，给这些孩子分发糖果：</u></p>
<p><u>每个孩子至少分配到 1 个糖果。</u><br><u>相邻两个孩子评分更高的孩子会获得更多的糖果。</u><br><u>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</u></p>
<p><u>输入：ratings &#x3D; [1,0,2]</u><br><u>输出：5 (2、1、2)</u></p>
<p><u>输入：ratings &#x3D; [1,2,2]</u><br><u>输出：4 (1、2、1)</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] candy = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        candy[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; ratings.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//本次循环，只保证右边比左边评分高时，右边比左边多一个糖果</span></span><br><span class="line">                candy[i] = candy[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//初始化</span></span><br><span class="line">                candy[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//本次循环，保证左边比右边评分高时，当前糖果既比左边多，也比右边多</span></span><br><span class="line">                candy[i] = Math.max(candy[i], candy[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : candy) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的思路就是先从左到右遍历，比较后面的比前面评分高的学生，只保证<u>右边比左边评分高时</u>，<strong>右边比左边多一个糖果</strong>，记住，一定要初始化（右边评分等于或小于左边评分时，要给1颗糖果）。第二次遍历就是从右向左遍历，保证<u>左边比右边评分高时</u>，当前糖果<strong>既比左边多，也比右边多</strong>。</p>
<h2 id="leetcode-860-柠檬水找零"><a href="#leetcode-860-柠檬水找零" class="headerlink" title="leetcode 860.柠檬水找零"></a>leetcode 860.柠檬水找零</h2><p><u><strong>题目</strong>：在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</u></p>
<p><u>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</u></p>
<p><u>注意，一开始你手头没有任何零钱。</u></p>
<p><u>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</u></p>
<p><u>输入：bills &#x3D; [5,5,5,10,20]</u><br><u>输出：true</u></p>
<p><u>输入：bills &#x3D; [5,5,10,10,20]</u><br><u>输出：false</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">five</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ten</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; bills.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bills[i] == <span class="number">5</span>) &#123;</span><br><span class="line">                five++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(five == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                five--;</span><br><span class="line">                ten++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(five &gt; <span class="number">0</span> &amp;&amp; ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个题就是看碰到谁给出相应的对策，碰到5，就five++；碰到10，就five–，ten++，当然要<strong>判断five够不够减</strong>的；碰到20，就先看看<strong>ten和five够不够</strong>，够就各减一个，不够就看看<strong>five够不够3个</strong>，都不够就return false。</p>
<h2 id="☆leetcode-406-根据身高重建队列"><a href="#☆leetcode-406-根据身高重建队列" class="headerlink" title="☆leetcode 406.根据身高重建队列"></a>☆leetcode 406.根据身高重建队列</h2><p><u><strong>题目</strong>：假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</u></p>
<p><u>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</u></p>
<p><u>输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</u><br><u>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        <span class="comment">//根据身高从大到小排序，身高相等的，按照数组第二个元素从小到大排序</span></span><br><span class="line">        Arrays.sort(people, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//以数组的第二元素为下标，按照数组的顺序，即按照身高从大到小一次插入队列中</span></span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] p : people) &#123;</span><br><span class="line">            queue.add(p[<span class="number">1</span>], p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将队列返回成数组形式</span></span><br><span class="line">        <span class="keyword">return</span> queue.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下面的排列方式就明白了：</p>
<p><strong>排序完</strong>的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]</p>
<ul>
<li>插入[7,0]：[[7,0]]</li>
<li>插入[7,1]：[[7,0],[7,1]]</li>
<li>插入[6,1]：[[7,0],[6,1],[7,1]]</li>
<li>插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]</li>
<li>插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]</li>
<li>插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li>
</ul>
<h2 id="☆leetcode-452-用最少数量的箭引爆气球"><a href="#☆leetcode-452-用最少数量的箭引爆气球" class="headerlink" title="☆leetcode 452.用最少数量的箭引爆气球"></a>☆leetcode 452.用最少数量的箭引爆气球</h2><p><u><strong>题目</strong>：有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</u></p>
<p><u>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  <strong>xstart ≤ x ≤ xend</strong>，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</u></p>
<p><u>给你一个数组 points ，返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="comment">//按照每个区间的左边界由小到大排列，因为测试用例中有边界值，所以不能用a[0] - b[0]</span></span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">//因为从第二个区间开始与前面的区间比较，所以从一只箭开始计数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; points.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//说明当前区间与前面记录的最小右边界没有重合，所以必须要增加一支箭</span></span><br><span class="line">                <span class="comment">//注意这里的最小右边界就默认是当前区间的右边界了</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明当前区间与前面记录的最小右边界有重合，继续保持当前最小的右边界</span></span><br><span class="line">                points[i][<span class="number">1</span>] = Math.min(points[i - <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先让数组按照每个区间的左边界从小到大排序，这样就可以保证后面的区间左边界一定不比前面的区间左边界小，这样我们只需要比较右边界就可以了。依次向后遍历，如果后面的区间的左边界比前面记录的最小右边界大，也就是<strong>没有重合</strong>，那么自然就需要<strong>增加</strong>一只箭；如果左边界比前面的最小右边界小或相等，也就是<strong>有重合部分</strong>，那么就要记录当前的最小右边界，因为当前区间有可能<strong>包含</strong>在前一个区间内，也就是不仅左边界比最小右边界小，而且<strong>右边界也比最小右边界小</strong>，这样的话，我们必须缩小右边界到<strong>满足所有不增加箭的区间</strong>。</p>
<h2 id="leetcode-435-无重叠区间"><a href="#leetcode-435-无重叠区间" class="headerlink" title="leetcode 435.无重叠区间"></a>leetcode 435.无重叠区间</h2><p><u><strong>题目</strong>：给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</u></p>
<p><u>输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]</u><br><u>输出: 1</u><br><u>解释: 移除 [1,3] 后，剩下的区间没有重叠。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="comment">//改动1，其实不改动也可以，即按左边界由小到大也可以</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">1</span>],b[<span class="number">1</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++) &#123;</span><br><span class="line">            <span class="comment">//改动2</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= intervals[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                intervals[i][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>], intervals[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//改动3</span></span><br><span class="line">        <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题和前面的452题非常像，因为射箭击穿某些重合区间，几只箭就证明有几个不重合的区间，只不过本题[1,2]和[2,3]不算重叠区间，所以在<strong>改动2的if</strong>判断位置<strong>加上了等号</strong>。</p>
<p>其次我们是要获得<strong>移除</strong>区间的<strong>最小数量</strong>，所以最后<strong>改动3</strong>的位置，也就是最后需要返回区间总个数-最大非重叠区间</p>
<p>那么问题是怎么才可以获得最多的非重叠区间呢，本题解给的思路是将每个区间的***<u>右边界从小到大</u><em><strong>排列，这样每个区间给右边的区间留下的空间是最大的，</strong>最大程度避免重叠</em>*，从而获得最大非重叠区间。</p>
<p>其实不改动也可以，即<strong>按左边界由小到大</strong>也可以。</p>
<h2 id="leetcode-56-合并区间"><a href="#leetcode-56-合并区间" class="headerlink" title="leetcode 56.合并区间"></a>leetcode 56.合并区间</h2><p><u><strong>题目</strong>：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</u></p>
<p><u>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</u><br><u>输出：[[1,6],[8,10],[15,18]]</u><br><u>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        res.add(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++) &#123;</span><br><span class="line">            <span class="comment">//当前的区间左边界小于前面的区间右边界</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= res.getLast()[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> res.getLast()[<span class="number">0</span>];<span class="comment">//因为左边界从小到大排列，所以start肯定取前面的</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.max(intervals[i][<span class="number">1</span>], res.getLast()[<span class="number">1</span>]);<span class="comment">//右边界不确定谁大，需要比一下</span></span><br><span class="line">                res.removeLast();<span class="comment">//记得删除当前最后一个区间</span></span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;);<span class="comment">//用start,end构建新区间</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//区间没重合，说明可以把当前的区间添加进去</span></span><br><span class="line">                res.add(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意res的长度是size()</span></span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的思路是：先将每个区间按照左区间由小到大排列，构造一个链表用于把合适的区间添加进来，先把第一个区间加进来，然后判断第二个区间的左区间和第一个区间的右区间是不是<strong>有重合的地方</strong>，如果重合，那就取两个区间的<strong>最小左区间和最大右区间</strong>，不要忘记<strong>删除前面</strong>的区间，然后将新构造的<strong>更大的区间</strong>添加进去。</p>
<p>如果<strong>没有重合</strong>的地方，就直接将该区间添加进去即可。</p>
<p>后面的区间以此类推，最后将链表转换为数组的形式，要注意LinkedList链表的长度是**size()**，不要写成length()。</p>
<h2 id="leetcode-738-单调递增的数字"><a href="#leetcode-738-单调递增的数字" class="headerlink" title="leetcode 738.单调递增的数字"></a>leetcode 738.单调递增的数字</h2><p><u><strong>题目</strong>：当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。</u></p>
<p><u>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。</u></p>
<p><u>输入: n &#x3D; 10</u><br><u>输出: 9</u></p>
<p><u>输入: n &#x3D; 1234</u><br><u>输出: 1234</u></p>
<p><u>输入: n &#x3D; 332</u><br><u>输出: 299</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//先将数字转换为字符数组，便于遍历</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="comment">//定义一个start指针，记录需要改为9的起始点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> ch.length;</span><br><span class="line">        <span class="comment">//从后向前遍历，因为修改的是前面的字符，如果从前向后遍历会出现问题</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ch.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="comment">//凡是前一个元素比后面大的，就将该元素-1，并将后面的元素置为9</span></span><br><span class="line">            <span class="keyword">if</span>(ch[i] &gt; ch[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                ch[i]--;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将指针及其后面的元素全部置为9</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i &lt; ch.length;i++) &#123;</span><br><span class="line">            ch[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//字符数组-&gt;字符串-&gt;数字</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(String.valueOf(ch));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先把数字转换为方便遍历的字符数组，具体贪心的思路就是：每相邻的字符进行比较，前面比后面大则不满足递增规律，所以要让<strong>当前ch[i]–<strong>，同时让后面的元素</strong>ch[i + 1]置为9</strong>，这一点很关键。</p>
<p>但是如果从前向后遍历，就会造成后面的元素<strong>在自减后又比前面的元素小</strong>了，所以为了避免这种情况，我们<strong>从后向前遍历</strong>。但是不一定要让ch[i + 1]全部置为9，也许前面的元素<strong>自减之后，就满足递增了</strong>。所以要定义一个指针start，<strong>随时记录</strong>目前需要置为9的位置，直到最后数组遍历完成。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/04/%E8%B4%AA%E5%BF%83%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/" data-id="cl3zgzig90000v8v6bzm0gp9d" data-title="贪心系列题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Redis知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2022-06-02T05:43:35.000Z" itemprop="datePublished">2022-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/">Redis知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><h2 id="缓存数据的处理流程及优势"><a href="#缓存数据的处理流程及优势" class="headerlink" title="缓存数据的处理流程及优势"></a>缓存数据的处理流程及优势</h2><p><u>高性能</u>：一个业务要请求数据库中的数据，<u>先从缓存中查询，如果没有再去库里边查询</u>。从库中查询数据是读取硬盘的操作，效率比较低。我们可以将<strong>访问频率比较高</strong>的数据放入缓存中，达到高性能的目的。</p>
<p><u>高并发</u>：MySQL的QPS大概在<strong>1w</strong>左右（4核8g），但是Redis缓存后很容易达到10w+，单机少一些，Redis<strong>集群更高</strong>。（QPS：Query Per Second，服务器每秒可以执行的查询次数）</p>
<h2 id="SDS（Simple-Dynamic-String）简单动态字符串"><a href="#SDS（Simple-Dynamic-String）简单动态字符串" class="headerlink" title="SDS（Simple Dynamic String）简单动态字符串"></a>SDS（Simple Dynamic String）简单动态字符串</h2><h3 id="C语言字符串的弊端："><a href="#C语言字符串的弊端：" class="headerlink" title="C语言字符串的弊端："></a>C语言字符串的弊端：</h3><img src="https://img-blog.csdnimg.cn/img_convert/376128646c75a893ad47914858fa2131.png" alt="img" style="zoom: 67%;" />

<ul>
<li>获取字符串长度，必须要从头到尾遍历到\0才可以，所以<strong>复杂度是o(n)</strong></li>
<li>字符串里不能存\0，所以是<strong>二进制不安全</strong>的</li>
<li>字符串操作时有<strong>缓存区溢出</strong>的风险</li>
</ul>
<h3 id="SDS结构设计"><a href="#SDS结构设计" class="headerlink" title="SDS结构设计"></a>SDS结构设计</h3><img src="https://img-blog.csdnimg.cn/img_convert/516738c4058cdf9109e40a7812ef4239.png" alt="img" style="zoom: 67%;" />

<p>len：SDS直接记录了字符串的长度，所以<strong>复杂度降为o(1)</strong></p>
<p>alloc：记录了<strong>分配</strong>给字符数组的空间长度，在修改字符串的时候，首先<strong>计算alloc - len</strong>够不够用，不够的话<strong>自动扩展</strong>空间长度(小于1MB翻倍扩容，大于1MB按1MB扩容)，所以<strong>无缓存区溢出的风险</strong></p>
<p>flags：记录了五种类型的sds</p>
<p>buf[]：不仅可以保存字符串，也可以<strong>保存任意格式的二进制数据</strong></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><img src="https://img-blog.csdnimg.cn/img_convert/cadf797496816eb343a19c2451437f1e.png" alt="img" style="zoom:50%;" />

<ul>
<li>每个节点都有pre和next指针，而且这两个指针都可以指向NULL，所以链表是<strong>无环链表</strong></li>
<li>list结构存储了表头指针head和表尾指针tail，所以<strong>获得头尾节点</strong>的复杂度是o(1)</li>
<li>和SDS一样，list结构也存储了长度len，所以<strong>查询链表长度</strong>的复杂度也是o(1)</li>
<li>链表节点可以<strong>保存各种不同类型</strong>的值</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>内存不连续</strong>，无法很好利用CPU缓存（与数组相比）</li>
<li>保存每个节点都需要分配一个链表节点结构头，<strong>内存开销大</strong></li>
</ul>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p><strong>Redis3.0</strong>的产物，为了设计一个<strong>内存紧凑型</strong>的数据结构，节省内存开销，创造了压缩列表，它是由<strong>连续内存块</strong>组成的<strong>顺序型</strong>数据结构，<u>类似数组</u>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/ab0b44f557f8b5bc7acb3a53d43ebfcb.png" alt="img" style="zoom: 67%;" />

<p>表头前三个字段分别记录了[整个压缩列表<strong>占用的内存字节数</strong>]，[尾部节点距离起始地址的字节数（<strong>尾部偏移量</strong>）]，[包含的<strong>节点数量</strong>]。最后的[zlend]相当于\0，代表<strong>结束点</strong>。</p>
<p>通过这三个字段可以容易的查到表头和表尾（复杂度为o(1)），但是查找其他元素就是o(n)</p>
<p>压缩列表节点entry包含了三部分：</p>
<p><strong>prevlen</strong>:前一个节点的长度</p>
<p><strong>encoding</strong>:当前节点实际数据类型及长度</p>
<p><strong>data</strong>:当前节点的实际数据</p>
<img src="https://img-blog.csdnimg.cn/img_convert/a3b1f6235cf0587115b21312fe60289c.png" alt="img" style="zoom:50%;" />

<p>**<u>缺点明显</u>**：</p>
<ul>
<li>不能保存过多元素，会导致查询效率降低</li>
<li>新增或修改某个元素，内存空间需要重新分配，很可能导致<strong>连锁更新</strong>（由于存在prevlen多米诺效应）</li>
</ul>
<p>**<u>使用场景</u>**：</p>
<p><strong>节点数量足够小</strong>，即使发生连锁更新，代价也很小。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>与JDK1.8之前的哈希表很相似，都是数组+链表的数据结构，数组里每一个元素就是一个<strong>哈希桶</strong>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/85f597f7851b90d6c78bb0d8e39690fc.png" alt="img" style="zoom: 67%;" />

<p>当负载因子 &gt;&#x3D; 1的时候，Redis<u>没有执行RDB快照或者没有进行AOF重写</u>的时候，就会进行rehash操作；</p>
<p>当负载因子 &gt;&#x3D; 5的时候，哈希冲突会非常严重，<strong>强制rehash</strong></p>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>分三步：</p>
<ul>
<li>给表2分配空间，一般<strong>比表1大2倍</strong></li>
<li>将表1的<strong>数据迁移</strong>到表2</li>
<li>把表1表2<strong>身份互换</strong>，在表2新创建一个空白的哈希表，用于下次rehash</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/cabce0ce7e320bc9d9b5bde947b6811b.png" alt="img" style="zoom:50%;" />

<h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>上面问题就处在数据迁移过程中会引发<strong>大量数据拷贝</strong>，导致<strong>请求阻塞</strong>，所以采用渐进式rehash。</p>
<p>将一次拷贝<strong>分成多次进行</strong>，而且进行的时机是：对哈希表元素<strong>进行CRUD的时候</strong>，顺便将表1中索引位置上的所有key-value<strong>顺序迁移到表2</strong>，随着请求增多，渐进式完成了迁移操作。</p>
<p>如果渐进式rehash期间，新增一个key-value，只会保存在哈希表2中，而<strong>哈希表1只减不增</strong>。</p>
<h3 id="rehash触发条件"><a href="#rehash触发条件" class="headerlink" title="rehash触发条件"></a>rehash触发条件</h3><img src="https://img-blog.csdnimg.cn/img_convert/85f597f7851b90d6c78bb0d8e39690fc.png" alt="img" style="zoom: 67%;" />

<p>负载因子**&gt;&#x3D;1<strong>，Redis没有进行</strong>RDB快照<strong>或没有进行</strong>AOF重写**时，就进行rehash；</p>
<p>负载因子**&gt;&#x3D;5<strong>，哈希冲突严重，</strong>强制进行**rehash。</p>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合时<strong>Set对象的底层实现之一</strong>，当一个Set对象<strong>只包含</strong>整数元素，并且元素<strong>数量不大</strong>时，就会使用整数集合这个数据结构。</p>
<p>本质上是一块<strong>连续内存空间</strong>：保存数据的<strong>容器</strong>是contents数组，但是<strong>数据类型取决于encoding属性</strong>的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<h3 id="整数集合的升级"><a href="#整数集合的升级" class="headerlink" title="整数集合的升级"></a>整数集合的升级</h3><p>当整数集合中全是int16_t类型的数据，突然<strong>来了一个较长的</strong>int32_t类型数据，那么就会发生整数集合的升级操作。这样的好处是：尽可能地<strong>节省内存资源</strong>，有大的再扩容，没有就维持当前数据类型。</p>
<p>整数集合<strong>只升级不降级</strong>。</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>Zset对象的底层实现用到了<strong>跳表</strong>和哈希表，其优势是能支持**平均o(logN)**的节点查找。</p>
<p><strong>跳表</strong>支持Zset对象的<strong>范围查询</strong>，而哈希表支持其<strong>常数复杂度</strong>获得<strong>元素权重</strong>。</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="AOF持久化-Append-Only-File"><a href="#AOF持久化-Append-Only-File" class="headerlink" title="AOF持久化(Append Only File)"></a>AOF持久化(Append Only File)</h2><p>AOF就是<strong>保存写操作命令到日志</strong>中，<u>不保存读操作</u>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/6f0ab40396b7fc2c15e6f4487d3a0ad7.png" alt="img" style="zoom: 67%;" />



<h3 id="写在前，日志在后优势与风险"><a href="#写在前，日志在后优势与风险" class="headerlink" title="写在前，日志在后优势与风险"></a>写在前，日志在后优势与风险</h3><p>注意执行写命令和写AOF日志是一个进程中的两个任务，所以要分先后，<u>先执行写命令，后写日志的原因</u>是：</p>
<ul>
<li><strong>避免额外的检查开销</strong>，避免写操作的语法等有问题，所以先执行写操作，没问题了再写日志</li>
<li><strong>不会阻塞当前写</strong>操作命令</li>
</ul>
<p><u>先执行写命令，后写日志潜在风险</u>：</p>
<ul>
<li>写操作执行完，还没来得及写日志或者日志没来得及写入硬盘，服务器就宕机了，会导致<strong>数据丢失</strong></li>
<li>虽然不阻塞当前写操作，但是会<strong>阻塞下一个命令操作</strong></li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/28afd536c57a46447ddab0a2062abe84.png" alt="img" style="zoom:50%;" />

<p>上面说的风险其实就是AOF传入硬盘的时机问题。这里注意，AOF还没有存入硬盘，真正将AOF写入硬盘有三个策略。</p>
<h3 id="三种写回策略-与MySQL相似）"><a href="#三种写回策略-与MySQL相似）" class="headerlink" title="三种写回策略(与MySQL相似）"></a>三种写回策略(与MySQL相似）</h3><p>写操作-&gt;AOF-&gt;硬盘具体步骤</p>
<ol>
<li><p>实际上，执行完写操作后，先把写操作的命令追加到<strong>server.aof_buf缓冲区</strong>中</p>
</li>
<li><p>通过<strong>write()系统调用</strong>，将缓冲区的数据写入AOF文件，此时数据被拷贝到了<strong>内核缓冲区page cache</strong></p>
</li>
<li><p>接着就<strong>等待内核</strong>将page cache中的数据写入硬盘</p>
<img src="https://img-blog.csdnimg.cn/img_convert/4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png" alt="img" style="zoom:50%;" /></li>
</ol>
<p>redis.conf配置文件中的appendfsync配置项可以设置3种参数：</p>
<p><strong><u>Always</u><strong>：每次写操作和AOF日志写回硬盘是</strong>同步</strong>进行的，<u>写一个存一个</u>。</p>
<p><strong><u>Everysec</u><strong>：写操作执行完，先把命令</strong>写入内核缓冲区</strong>，每隔1秒写回一次硬盘，<u>每隔1秒存一个</u>。</p>
<p><strong><u>No</u><strong>：写操作执行完，先把命令</strong>写入内核缓冲区</strong>，写回时机完全转交给<u>操作系统控制</u></p>
<p>不同业务需要使用不同的参数，Always追求<u>高可靠</u>，Everysec追求<u>折中</u>，No追求<u>高性能</u></p>
<img src="https://img-blog.csdnimg.cn/img_convert/98987d9417b2bab43087f45fc959d32a.png" alt="img" style="zoom: 67%;" />

<h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>为了避免AOF越写越大，提供AOF重写机制，<strong>每个键值对只保留一条命令</strong>，用于<u>压缩</u>AOF的大小。</p>
<p>这一点与MySQL不一样，每个键值的<strong>历史记录</strong>对Redis来说没有意义，所以只保留<strong>最近的一次写操作</strong>。所以具体的方式是：根据每个键值的最新状态，用一条命令记录这个键值对。</p>
<p>重写的方式是：重写的过程要与原始AOF<strong>隔离</strong>，写完后<strong>覆盖</strong>原始AOF文件，这样<strong>不会</strong>对原始AOF文件<strong>造成污染</strong>。</p>
<h3 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h3><p>为了不影响主进程写AOF机制，重写AOF过程由<strong>后台子进程<em>bgrewriteaof</em></strong>来完成，好处是：</p>
<ul>
<li>AOF重写期间，<strong>不影响主进程</strong>，避免阻塞</li>
<li>子进程带有主进程的<strong>数据副本</strong>。<u>不使用线程</u>是因为：线程间操作共享内存必须<strong>加锁</strong>-&gt;性能降低；<u>使用子进程</u>是因为：父子进程共享内存是<strong>只读</strong>的，所以当有一方操作了共享内存，就发生[<strong>写时复制</strong>]，这样父子进程各自有了<strong>独立</strong>的数据副本，不需加锁。</li>
</ul>
<h4 id="数据副本的来由"><a href="#数据副本的来由" class="headerlink" title="数据副本的来由"></a>数据副本的来由</h4><p>主进程通过<strong>fork系统调用</strong>生成子进程时，OS会把主进程的<strong>页表</strong>复制给子进程，这样父子进程的虚拟内存指向了<strong>同一块物理内存</strong>（只读）</p>
<img src="https://img-blog.csdnimg.cn/img_convert/5a1f2a90b5f3821c19bea3b7a5f27fa1.png" alt="img" style="zoom:50%;" />

<h4 id="写时复制-Copy-On-Write"><a href="#写时复制-Copy-On-Write" class="headerlink" title="写时复制(Copy On Write)"></a>写时复制(Copy On Write)</h4><p>当父进程对这块内存发起写操作时，CPU会发起<strong>缺页中断</strong>（违反权限导致），OS会在[<strong>缺页异常处理函数</strong>]进行物理内存的复制（注意<strong>只是被执行写操作的这部分内存</strong>），然后重新设置内存映射关系，将父子进程的<strong>这部分内存</strong>读写权限设置为<strong>可读写</strong>，最后才对内存进行写操作，这个过程称为<u>写时复制</u>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/d4cfac545377b54dd035c775603b4936.png" alt="img" style="zoom:50%;" />

<p>其实写时复制就是为了防止fork创建子进程的时候，<strong>物理内存复制时间过长</strong>，页表要比物理内存小的多，所以<strong>尽可能减少</strong>了<u>子进程创建时对父进程的阻塞</u>。</p>
<p>三个阶段会<u>阻塞父进程</u>：</p>
<ul>
<li>创建子进程复制的<strong>页表</strong>如果特别大，肯定阻塞时间长</li>
<li>写时复制的时候，<strong>被主进程修改的内存</strong>越大，阻塞越长</li>
<li>后面要写的执行<strong>信号处理函数</strong></li>
</ul>
<p>写时复制带来的问题其实就是父子进程的<strong>时间差</strong>问题：子进程重写了一个key-value，主进程又修改了这对键值对，这次父子进程的<strong>内存数据不一致</strong>了怎么办？</p>
<h4 id="时间差导致数据不一致问题"><a href="#时间差导致数据不一致问题" class="headerlink" title="时间差导致数据不一致问题"></a>时间差导致数据不一致问题</h4><p>在<strong>创建子进程之后</strong>，Redis开始使用其专门设置的**[<u>AOF重写缓冲区</u>]<strong>，当主进程进行</strong>写操作后**，不仅将命令写入AOF缓冲区中，还写入了AOF缓冲区。</p>
<img src="https://img-blog.csdnimg.cn/202105270918298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:45%;" />

<p>为了解决时间差问题，最后在AOF重写完成时必须还要阻塞一下，以便<strong>让子进程追上父进程</strong>：</p>
<p>当子进程<strong>完成AOF重写工作后</strong>（扫描数据库所有数据。逐一把内存数据的键值对转换成一条命令，写入重写日志），向主进程发送信号（异步）。</p>
<p>主进程<strong>调用信号处理函数</strong>，将AOF重写缓冲区的所有内容追加到新的AOF中，然后让新的AOF文件改名，覆盖旧的AOF文件。调用函数的时候一定要<strong>阻塞主进程</strong>，否则时间差还会存在。</p>
<h2 id="RDB快照-Redis-Database"><a href="#RDB快照-Redis-Database" class="headerlink" title="RDB快照(Redis Database)"></a>RDB快照(Redis Database)</h2><p>如果说AOF相当于MySQL中的binlog，那么redolog就是Redis中的RDB快照了，两种技术存了不同的日志信息：</p>
<p>AOF：日志内容是<strong>操作命令</strong></p>
<p>RDB：日志内容是<strong>二进制数据</strong></p>
<p>这就带来了二者<u>恢复数据上的差异性</u>：Redis恢复数据的时候，直接<strong>将RDB读入内存即可</strong>；而AOF读入内存后，需要<strong>逐条执行操作命令</strong>才可以恢复。</p>
<h3 id="生成RDB快照的命令"><a href="#生成RDB快照的命令" class="headerlink" title="生成RDB快照的命令"></a>生成RDB快照的命令</h3><p>save和bgsave，save是<strong>直接在主线程中生成RDB文件</strong>，如果写入时间太长，会<strong>阻塞</strong>主线程；bgsave则是创建子进程，<strong>避免了阻塞</strong>问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>虽然是save，但实际执行的是bgsave，表明在多少秒内，对数据库<strong>至少</strong>进行了多少次<strong>修改</strong>。<strong>满足任意一个</strong>就会执行bgsave。</p>
<p>注意：RDB快照是**<u>全量快照</u><strong>，也就是每次快照都把</strong>内存中所有数据**存入硬盘中。</p>
<h3 id="写时复制-Copy-On-Write-1"><a href="#写时复制-Copy-On-Write-1" class="headerlink" title="写时复制(Copy On Write)"></a>写时复制(Copy On Write)</h3><p>与AOF一样，RDB快照也采用[<strong>写时复制技术</strong>]，即当父进程对共享内存执行写操作的时候，CPU先发生缺页中断，然后被执行写操作的内存则被OS复制一份，然后父进程就可以对这部分内存进行写操作了。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/ebd620db8a1af66fbeb8f4d4ef6adc68.png" alt="图片" style="zoom:50%;" />

<h3 id="混合持久化（AOF-RDB）"><a href="#混合持久化（AOF-RDB）" class="headerlink" title="混合持久化（AOF+RDB）"></a>混合持久化（AOF+RDB）</h3><p>RDB快照刚执行完，肯定会有一部分写操作还会执行，那么在下次快照执行之前，这一部分写操作会导致父子进程的<strong>数据不一致</strong>。解决的方法就是<strong>混合使用AOF日志和内存快照</strong>（混合持久化）。<u>开启方式</u>就是将下面的参数设为yes。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<p><strong>Redis 4.0</strong>提出的混合持久化，具体工作<strong>只发生</strong>在<u>AOF日志的重写过程</u>：</p>
<ul>
<li>首先fork出来的子进程先把共享内存中的数据<strong>以RDB方式</strong>写入AOF中</li>
<li>然后重写缓冲区中的<strong>增量命令以AOF方式</strong>写入AOF文件中</li>
<li>写入完成，通知主进程将这个混合持久化的AOF文件<strong>替换旧</strong>的AOF文件</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/f67379b60d151262753fec3b817b8617.png" alt="图片" style="zoom:50%;" />

<p>这样，AOF文件<u>前半部分</u>是RDB格式的<strong>全量数据</strong>，<u>后半部分</u>是AOF格式的<strong>增量数据</strong></p>
<p>好处是：重启Redis加载数据的时候，<strong>加载速度很快</strong>（RDB直接加载到内存即可），加载完了再加载AOF内容，保证<strong>数据尽可能少的丢失</strong>。</p>
<h1 id="缓存雪崩、击穿、穿透"><a href="#缓存雪崩、击穿、穿透" class="headerlink" title="缓存雪崩、击穿、穿透"></a>缓存雪崩、击穿、穿透</h1><p>雪崩和击穿都是缓存中的数据没法提供给用户了，用户只好去数据库中找了，一旦这个请求是<strong>大批量的</strong>，那么就会造成雪崩。如果数据批量不大，但是数据<strong>热度特别高</strong>，那么就是击穿，注意不是穿透，因为库上有数据。</p>
<p>而穿透则是<strong>缓存找不到，数据库也找不到</strong>，相当于一个攻击层层穿透两个库，最后给<strong>打透了</strong>。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>大批量数据访问缓存访不到，只能去库中找，有两个原因：</p>
<ul>
<li>大量数据同时过期</li>
<li>Redis故障宕机</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/717343a0da7a1b05edab1d1cdf8f28e5.png" alt="图片" style="zoom: 45%;" />

<h3 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h3><p>对于大量数据过期可以采用以下几种办法应对：</p>
<p>1）**<u>均匀设置过期时间</u><strong>：可以在设置过期时间的时候，</strong>加上一个随机数**，保证不会发生同时过期的现象。</p>
<p>2）**<u>互斥锁</u><strong>：如果发现缓存中数据没有了，那肯定得去库里面找到然后重新构建缓存，这个时候可以加个互斥锁，保证</strong>同一时间只有一个请求<strong>在构建缓存，当然锁要</strong>设置超时时间**，防止意外出现导致阻塞。</p>
<p>3）**<u>双key策略</u><strong>：即设置主key和备key，主key设置过期时间，而</strong>备key不设置<strong>，这样主key找不到了就去读备key的value。不过，更新缓存的时候要</strong>同时更新**主备key的value。</p>
<p>4）<u><strong>后台更新缓存</strong></u>：<strong>不设置有效期</strong>，业务线程也不负责更新缓存。更新的工作交给<strong>后台线程定时更新</strong>。</p>
<p>不过，缓存并不是永久有效，系统内存紧张还是会淘汰一部分数据。解决的方式有二：</p>
<p>①后台线程不仅定时更新缓存，也<strong>定时检测缓存的有效性</strong>。不过总会在两个检测<strong>间隔内</strong>出现被淘汰但还没更新的</p>
<p>②当业务线程发现数据失效后，通过<strong>消息队列</strong>发送消息<strong>通知后台线程</strong>更新缓存，用户体验较好</p>
<p>所以虽说业务线不负责更新，还是<strong>间接的</strong>利用了业务线来完成缓存的更新</p>
<p>对于<u>刚上线的业务</u>，我们有必要先进行<strong>缓存预热</strong>，即把一些数据提前存入缓存中。</p>
<h3 id="Redis故障宕机"><a href="#Redis故障宕机" class="headerlink" title="Redis故障宕机"></a>Redis故障宕机</h3><p>Redis故障宕机引起的雪崩问题采用以下两种办法应对：</p>
<p>1）<u><strong>服务熔断或请求限流机制</strong></u>：服务熔断就是<strong>暂停业务访问缓存</strong>，直接返回错误。直到缓存恢复正常，再进行访问；这种方式保证了数据库的正常运行，但是极大的阻塞了业务进行，所以可以启用请求限流，让<strong>少部分请求发送到数据库</strong>中。</p>
<p>2）**<u>构建Redis缓存高可靠集群</u><strong>：通过</strong>主从节点**的方式构建可靠集群，当主节点宕机，直接切换为从节点。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>就是<strong>热点数据过期</strong>了，数据库很容易被这个<strong>高并发量</strong>冲垮。</p>
<p>可以认为击穿是雪崩的<strong>子集</strong></p>
<p>应对方案有如下两种：</p>
<ul>
<li>**<u>互斥锁</u>**：保证同一时间只有一个业务线程更新缓存</li>
<li><strong><u>不给热点数据设置过期时间</u><strong>：后台异步更新缓存，或者过期前，</strong>提前通知</strong>后台线程更新缓存和重设过期时间</li>
</ul>
<p>要知道，*<u>不设过期时间不代表缓存一直存在</u>*，很可能因为系统内存紧张而被淘汰，所以还是要做好反馈机制。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存和数据库<strong>都没有请求的数据</strong>，导致数据库压力骤增。</p>
<p>一般<strong>业务误操作</strong>，也就是缓存和数据库的这部分数据被误删除了导致穿透现象；还有就是<strong>黑客恶意攻击</strong>，即故意访问大量不存在的数据业务。</p>
<p>应对方案有三（<em>宗旨：避免访问数据库</em>）：</p>
<p>1）<u><strong>非法请求限制</strong></u>：在API入口处判断请求参数<strong>是否合理</strong>，是否含有<strong>非法值</strong>，字段<strong>是否存在</strong>，判断出是非法请求就直接返回错误。</p>
<p>2）**<u>缓存控制或默认值</u><strong>：可以专门</strong>针对出现缓存穿透的数据<strong>，在缓存中</strong>设置**一个空值或者默认值，这样可以避免访问数据库。</p>
<p>3）**<u>布隆过滤器</u><strong>快速判断：在</strong>数据库写入数据时<strong>，使用布隆过滤器进行标记，一旦请求在缓存中找不到数据，</strong>先来到布隆过滤器**这里进行数据的存在性判断，避免了访问数据库。</p>
<p>布隆过滤器基于<strong>哈希函数</strong>查找，存在<strong>哈希碰撞</strong>的可能性，所以布隆过滤器说数据存在，数据<strong>不一定存在</strong>，但是说数据不存在，就<strong>一定不存在</strong>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/061e2c04e0ebca3425dd75dd035b6b7b.png" alt="图片" style="zoom:60%;" />

<h1 id="主从复制的实现"><a href="#主从复制的实现" class="headerlink" title="主从复制的实现"></a>主从复制的实现</h1><p>如果数据只存在一台服务器上，一旦服务器宕机或故障，会导致严重的业务中断甚至数据丢失。所以为了避免<strong>单点故障</strong>，就需要将服务器的数据保存在多台服务器上，这也是<strong>避免缓存雪崩（服务器宕机）</strong>的一种方式。</p>
<p>这就带来了一个重要的问题——数据一致性如何保证？Redis给出的是<strong>主从复制模式</strong>，主从服务器遵从<strong>读写分离</strong></p>
<p>如下图所示，主服务器可以<strong>读写</strong>，而从服务器一般是<strong>只读</strong>，一旦主服务器发生<strong>写操作</strong>，就把该操作<strong>同步</strong>给从服务器。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/2b7231b6aabb9a9a2e2390ab3a280b2d.png" alt="图片" style="zoom:50%;" />

<h2 id="第一次同步"><a href="#第一次同步" class="headerlink" title="第一次同步"></a>第一次同步</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 服务器 B 执行这条命令</span><br><span class="line">replicaof &lt;服务器 A 的 IP 地址&gt; &lt;服务器 A 的 Redis 端口号&gt;</span><br></pre></td></tr></table></figure>

<p>在服务器B上执行该命令，B就会变成A的<strong>从服务器</strong>，然后开始与A进行<strong>第一次同步</strong></p>
<p><u>第一次同步</u>有如下三阶段：</p>
<img src="https://img-blog.csdnimg.cn/img_convert/ea4f7e86baf2435af3999e5cd38b6a26.png" alt="图片" style="zoom: 50%;" />

<p>一、<u><strong>建立链接</strong>，协商同步</u>：</p>
<p><u>1.1-1.2</u>：可以从图中看出来，执行完replicaof命令后，从服务器就<strong>发送psync命令</strong>，表示自己要进行数据同步。</p>
<p>psync包含<strong>主服务器</strong>的<strong>runID</strong>（随机ID且唯一，但第一次不知道主服务器的runID，所以<strong>设为？</strong>）和复制进度<strong>offset</strong>（第一次是-1）。</p>
<p><u>1.3-1.4</u>：主服务器收到psync会回应<strong>FULLRESYNC</strong>，包含了主服务器的runID和主服务器的<strong>复制进度offset</strong>，从服务器<strong>保存记录</strong>这俩信息。此命令目的是<strong>全量复制</strong>，即把所有数据赋值给从服务器。</p>
<p>二、<u>主向从<strong>同步数据</strong></u>：</p>
<p><u>2.1-2.3</u>：主服务器执行bgsave生成RDB文件，然后发给从服务器；</p>
<p><u>2.4</u>：从服务器收到RDB文件后，<strong>先清空自己的数据再载入RDB</strong>；</p>
<p>上述操作中，主服务器生成RDB<strong>不会很大程度阻塞主线程</strong>的进行(因为是子进程<strong>复制页表</strong>)，但是在<strong>生成、发送、载入RDB</strong>的三个阶段，主服务器都有新的写操作执行的可能性，为了保证数据一致性，就要把这三个时间段的写操作命令写入到<strong>replication buffer缓冲区</strong>中。</p>
<p>三、<u>主向从发送新的<strong>写操作</strong>命令</u></p>
<p><u>3.1-3.2</u>：从服务器加载完RDB之后，主服务器将<strong>replication buffer</strong>中的写操作命令<strong>发送</strong>给从服务器，然后从服务器<strong>执行</strong>这些操作。</p>
<p>至此，第一次同步结束~</p>
<h2 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h2><p>为了<strong>避免</strong>频繁的TCP连接和断开带来<strong>性能开销</strong>，第一次同步后维持长连接，持续<strong>传播写操作</strong>，保证数据的一致性。</p>
<p>即<strong>基于长连接的命令传播</strong>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/03eacec67cc58ff8d5819d0872ddd41e.png" alt="图片" style="zoom:50%;" />

<h2 id="分摊服务器压力"><a href="#分摊服务器压力" class="headerlink" title="分摊服务器压力"></a>分摊服务器压力</h2><p>一个从服务器还好，如果是一个服务器集群，那么在主服务器<strong>创建</strong>RDB的时候，务必会<strong>复制大量页表</strong>，从而对主线程造成<strong>阻塞</strong>；而在<strong>传播</strong>RDB的时候又会<strong>占用主服务器的网络带宽</strong>。</p>
<p>如何解决这个压力集中的问题？</p>
<p>在某个从服务器上执行如下的命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;目标服务器的IP&gt; 6379</span><br></pre></td></tr></table></figure>

<p>如果目标服务器也是<strong>从服务器</strong>，那么<strong>目标服务器</strong>就是当前服务器的“<strong>经理</strong>”。那么它就有向下传播写操作的能力了。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/4d850bfe8d712d3d67ff13e59b919452.png" alt="图片" style="zoom: 45%;" />

<h2 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h2><p>主从服务器在第一次同步之后虽然保持长连接，但是网络连接还是有可能中断，一旦<strong>网络中断</strong>，客户端在从服务器中读到的就是<strong>旧数据</strong>了。</p>
<p>网络断开后再恢复，如何*<u>保证主从服务器的一致性</u>*呢？</p>
<p>Redis 2.8之前，一直采用<strong>全量复制</strong>，开销非常大。</p>
<p><strong>Redis 2.8开始</strong>，主服务器只会把网络断开期间的<strong>相差</strong>的这一部分写操作传播给从服务器，即<strong>增量复制</strong>。</p>
<ul>
<li>再次建立连接后，还是和第一次同步一样，传一个psync，但是这次的<strong>offset不是-1</strong>了，而是断开时自己的<strong>复制偏移量</strong></li>
<li>主服务器收到psync命令后，响应<strong>CONTINUE命令</strong>来告诉从服务器接下来采用增量复制</li>
<li>然后主把这部分<strong>增量传给</strong>从服务器</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/e081b470870daeb763062bb873a4477e.png" alt="图片" style="zoom:50%;" />

<p>主服务器如何获知<u><em>这部分增量</em></u>的？</p>
<p>主服务器在命令传播的时候，不仅把写操作传播给从服务器，也同时将写命令<strong>写入repl_backlog_buffer</strong>这个环形缓冲区，环形意味着<strong>超过容量即覆盖</strong>。</p>
<p>当从服务器断开重连的时候，向主服务器发送的<strong>fsync</strong>命令包含了其<strong>复制偏移量slave_repl_offset</strong>，主服务器根据自己的<strong>master_repl_offset</strong>与其差值，来决定执行增量同步还是全量同步：</p>
<p>如果<strong>差值小于</strong>一个扇形存储区域，那么就说明数据还在扇形缓冲区，然后就把扇形区的这部分增量数据<strong>写入到replication buffer</strong>，也就是第一次同步时专门负责传播增量数据的缓冲区，然后进行命令传播，即<strong>增量复制</strong>。</p>
<p>如果大于一个扇形区域，就会发生<strong>覆盖</strong>，那么就只能进行<strong>全量复制</strong>了。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/2db4831516b9a8b79f833cf0593c1f12.png" alt="图片" style="zoom:60%;" />

<p>所以一般扇形区域会设置的<strong>尽量大</strong>一些，就是为了<strong>避免全量复制</strong>这种抵消操作。</p>
<p>估算公式如下：</p>
<p>second是服务器<strong>断开后重连</strong>的平均时间</p>
<p>write_size_per_second是主服务器平均每秒产生的<strong>写命令</strong>的数据<strong>大小</strong></p>
<img src="https://img-blog.csdnimg.cn/img_convert/5e9e65a4a59b3688fa37cadbd87bb5ac.png" alt="图片" style="zoom: 90%;" />

<h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><h2 id="哨兵机制存在的意义"><a href="#哨兵机制存在的意义" class="headerlink" title="哨兵机制存在的意义"></a>哨兵机制存在的意义</h2><p>前面虽然说主服务器挂了，客户端还可以去读从服务器，但是<strong>写操作</strong>始终是主服务器向其他从服务器传播的，所以一旦主服务器挂了，还必须尽快<strong>设置新的主服务器</strong>，这就会涉及<strong>大量的工作</strong>，包括：从其它从节点选一个当主节点，通知并更新其他从节点新的主服务器IP。</p>
<p><strong>Redis 2.8</strong>开始提供了哨兵机制，目的就是<strong>实现主从节点故障转移</strong>，监控主节点是否<strong>存活</strong>，一旦主挂了，就<strong>选取</strong>新的主节点，并<strong>通知</strong>其他从节点和客户端新主节点的相关信息。</p>
<h2 id="哨兵工作机制"><a href="#哨兵工作机制" class="headerlink" title="哨兵工作机制"></a>哨兵工作机制</h2><img src="https://img-blog.csdnimg.cn/775865f6bd894dfba8d373ee54d79af1.png" alt="哨兵的职责" style="zoom: 50%;" />

<h3 id="判断主节点故障"><a href="#判断主节点故障" class="headerlink" title="判断主节点故障"></a>判断主节点故障</h3><p>哨兵会<strong>周期性</strong>地给主从节点发送<strong>PING</strong>命令，根据是否收到回应来判断是否正常运行。</p>
<p>由于一个哨兵判断有偶然性，很可能是系统压力大或网络拥塞造成未收到回应。为了减少误判，用多个节点部署成<u><em><strong>哨兵集群</strong></em></u>（最少<strong>三台</strong>机器），一旦有一个哨兵判断主节点<strong>主观下线</strong>了，就开始”参考“其他哨兵的“观点”，相当于投票机制。</p>
<p>在哨兵配置文件中有一个<strong>quorum配置项</strong>（一般设置为哨兵个数的1&#x2F;2 + 1），如果投票数超过这个值，主节点就会被标记为<strong>客观下线</strong>。</p>
<img src="https://img-blog.csdnimg.cn/13e4361407ba46979e802eaa654dcf67.png" alt="img" style="zoom:45%;" />

<h3 id="选新的主节点"><a href="#选新的主节点" class="headerlink" title="选新的主节点"></a>选新的主节点</h3><p>选择新的主节点，必然要在从节点中选择，一定不能随机选，因为有些从节点可能网络连接不太好，选了它相当于选择了”残疾人”，所以要<strong>避开连接状态不好</strong>的节点。</p>
<p>Redis中有一个down-after-milliseconds * 10的配置项，意为主从节点<strong>断后重连</strong>的最大超时时间，如果在<strong>这个时间内</strong>没连上，那就认为主从节点断连了，如果次数超过10次，说明这个<strong>从节点网络状况</strong>不好。</p>
<p>过滤掉离线的和网络不好的节点后，开始三轮考察：</p>
<p>第一轮：先选<strong>优先级最高</strong>的从服务器作为主服务器。配置项slava-priority可以设置</p>
<p>第二轮：选<strong>复制进度最靠前</strong>的从节点。比较谁的slave_repl_offset最接近master_repl_offset</p>
<p>第三轮：前面都一样，就<strong>选ID小的</strong>从节点</p>
<p><u>总结</u>：<em>先过滤离线的和网络不好的，然后进行三轮考察</em>，每一轮考察中，如果有胜出的节点，直接作为新主节点。</p>
<h3 id="哨兵竞争主从故障转移"><a href="#哨兵竞争主从故障转移" class="headerlink" title="哨兵竞争主从故障转移"></a>哨兵竞争主从故障转移</h3><p>选定了哪个从节点作为接下来的主节点之后，就要决定哪个哨兵节点<strong>负责故障转移</strong>这项工作。</p>
<p>首先要确定<strong>候选者</strong>：只有判断主节点是<strong>客观下线</strong>的哨兵才可以成为候选者。</p>
<p>候选者如何成为leader？通过所有节点（包括自己）投票选举。所有节点只可以投给候选者赞成票，而且<strong>机会只有一次</strong>，这就意味着候选者可以投给自己（<strong>其实候选者都投给自己，然后向其他哨兵发起投票请求</strong>）。</p>
<p>当候选者满足以下两个条件就可以成为leader：</p>
<ul>
<li>拿到<strong>一半以上</strong>数量（<strong>所有</strong>哨兵数量的一半 + 1）的赞成票；</li>
<li>拿到的票数要 <strong>&gt;&#x3D;</strong> 哨兵配置文件中的<strong>quorum</strong>值</li>
</ul>
<p><u><em>问</em></u>：假如当前Redis 1主4从，5个哨兵，挂了2个，quorum设为3，判断主节点宕机能否判断其“<strong>客观下线</strong>”？主从能否<strong>自动切换</strong>？</p>
<p><u><em>答</em></u>：还有3个哨兵，全部投“主观下线”，就<strong>可以判断“客观下线”</strong>了。对于主从故障转移，就要判断投票数能不能超过半数（<strong>5&#x2F;2 + 1 &#x3D; 3</strong>），能。再判断能不能超过quorum &#x3D; 3，前面判断过了，也能。所以<strong>可以自动切换</strong>。</p>
<p><u><em>问</em></u>：还是5个哨兵，挂了3，quorum设为2呢？</p>
<p>挂了3还有两个可以投票，而quorum正好改为2，所以<strong>可以判断“客观下线”</strong>。而（5&#x2F;2 + 1 &#x3D; 3），但是哨兵只有俩，赞成票数无法超过半数，所以<strong>无法自动切换</strong></p>
<p><u><em>问</em>：</u>：还是5个哨兵，还是挂了3，但是quorum设为3？</p>
<p>*<u>答</u>*：这个时候两票已经超不过quorum了，所以<strong>既无法判读“客观下线”，又无法自动切换</strong>。</p>
<p>这里面我们故意把quorum随意调整了，就是为了证明<strong>quorum</strong>不是随便设置的，其最好设置为<strong>哨兵个数 &#x2F; 2 + 1</strong>，同时保证<strong>哨兵数量为奇数</strong>。</p>
<h3 id="通知客户端新的主节点信息"><a href="#通知客户端新的主节点信息" class="headerlink" title="通知客户端新的主节点信息"></a>通知客户端新的主节点信息</h3><p>主从切换之后，新的主节点迫切需要被客户端知道，否则客户端都不知道该找谁进行写操作。</p>
<p>Redis采用<strong>发布者&#x2F;订阅者机制</strong>来实现信息的通知的。每个哨兵节点提供发布者&#x2F;订阅者机制，客户端可以<strong>从哨兵订阅消息</strong>。</p>
<p>假如客户端<strong>订阅了主从切换的事件</strong>，当哨兵选好了新的主节点，就会<strong>发布</strong>新主节点的<strong>IP和端口信息</strong>，客户端就<strong>收到</strong>了这个信息，就自然可以与新主节点通信了。</p>
<h2 id="哨兵集群如何组成的"><a href="#哨兵集群如何组成的" class="headerlink" title="哨兵集群如何组成的"></a>哨兵集群如何组成的</h2><p>其实搭建哨兵并配置信息的时候，只需要设置<strong>主节点</strong>名字、IP和端口号以及quorum值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; </span><br></pre></td></tr></table></figure>

<p>既没有填其他<strong>哨兵节点</strong>信息，也没有填其他的<strong>从节点</strong>信息。</p>
<p>其实哨兵节点之间是通过<u><em><strong>Redis的发布者&#x2F;订阅者机制</strong></em></u>来<strong>相互发现</strong>的。</p>
<p>主节点上有一个订阅频道，名为_sentinel_:hello，比如下图的A把自己的IP和端口发到这个频道上，B、C订阅了这个频道，B、C就可以获取A的位置，进而形成哨兵集群。</p>
<img src="https://img-blog.csdnimg.cn/a6286053c6884cf58bf397d01674fe80.png" alt="img" style="zoom: 40%;" />

<p>那么哨兵又是<strong>如何监控</strong>从节点的呢？</p>
<p>哨兵会向主节点发送INFO命令来获取从节点的信息，主节点就返回从节点列表。然后哨兵根据这个列表的信息，与每个从节点建立连接。</p>
<img src="https://img-blog.csdnimg.cn/fdd5f695bb3643258662886f9fba0aab.png" alt="img" style="zoom:40%;" />

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="cl3yfz0zx0000b8v6elnn24sa" data-title="Redis知识点" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-回溯系列题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/30/%E5%9B%9E%E6%BA%AF%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-30T04:52:55.000Z" itemprop="datePublished">2022-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/30/%E5%9B%9E%E6%BA%AF%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/">回溯系列题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h1><h2 id="leetcode-77-组合"><a href="#leetcode-77-组合" class="headerlink" title="leetcode 77.组合"></a>leetcode 77.组合</h2><p><u><strong>题目</strong>：给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</u></p>
<p><u>你可以按 <strong>任何顺序</strong> 返回答案。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backTracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= n - (k - path.size()) + <span class="number">1</span>;i++) &#123;<span class="comment">//剪枝</span></span><br><span class="line">            path.add(i);</span><br><span class="line">            backTracking(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-216-组合总和-III"><a href="#leetcode-216-组合总和-III" class="headerlink" title="leetcode 216.组合总和 III"></a>leetcode 216.组合总和 III</h2><p><u><strong>题目</strong>：找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</u></p>
<p><u>只使用数字1到9</u><br><u>每个数字 最多使用一次</u><br><u>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backTracking(n, k, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> k, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//这里必须要k的数量和sum的值同时满足才可以将path加入res</span></span><br><span class="line">        <span class="keyword">if</span>(k == path.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span> &amp;&amp; sum + i &lt;= target;i++) &#123;<span class="comment">//剪枝</span></span><br><span class="line">            path.add(i);</span><br><span class="line">            sum += i;<span class="comment">//因为sum要在for循环中使用多次，所以必须要对sum回溯</span></span><br><span class="line">            backTracking(target, k, i + <span class="number">1</span>, sum);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-39-组合总和"><a href="#leetcode-39-组合总和" class="headerlink" title="leetcode 39.组合总和"></a>leetcode 39.组合总和</h2><p><u><strong>题目</strong>：给你一个<strong>无重复元素</strong>的整数数组candidates和一个目标整数target，找出candidates中可以使数字和为目标数target 的所有不同组合，并以列表形式返回。你可以按任意顺序返回这些组合。</u></p>
<p><u>candidates中的同一个<strong>数字可以无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</u></p>
<p><u>对于给定的输入，保证和为 target 的不同组合数少于150个。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target;i++) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backTracking(candidates, target, i, sum);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环里的剪枝操作：sum &lt;&#x3D; target为什么不可以写成sum + candidates[i] &lt;&#x3D; target，其实是因为我<strong>忘记排序了</strong>，如果没有排序，就很可能导致很小的数在最后，<strong>剪枝后永远考虑不到</strong>，所以一定要排序之后才可以剪枝。</p>
<h2 id="leetcode-40-组合总和-II"><a href="#leetcode-40-组合总和-II" class="headerlink" title="leetcode 40.组合总和 II"></a>leetcode 40.组合总和 II</h2><p><u><strong>题目</strong>：给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</u></p>
<p><u>candidates 中的每个数字在每个组合中只能使用 一次 。</u></p>
<p><u>注意：解集不能包含重复的组合。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target;i++) &#123;</span><br><span class="line">            <span class="comment">//同层跳过重复元素</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backTracking(candidates, target, i + <span class="number">1</span>, sum);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<strong>同一层不能添加相同元素</strong>，所以在for循环里现有一个判断，判断当前层，前后两个元素是否相同，不相同再继续回溯。</p>
<h2 id="leetcode-17-电话号码的字母组合"><a href="#leetcode-17-电话号码的字母组合" class="headerlink" title="leetcode 17.电话号码的字母组合"></a>leetcode 17.电话号码的字母组合</h2><p><u><strong>题目</strong>：给定一个仅包含数字 **2-9 **的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</u></p>
<p><u>给出数字到字母的映射如下（与电话按键相同）。注意1不对应任何字母。</u></p>
<img src="https://img-blog.csdnimg.cn/2020102916424043.png" alt="17.电话号码的字母组合" style="zoom:40%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="comment">//用String数组将电话号码对应的字符串存储起来</span></span><br><span class="line">        String[] numString = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//判空</span></span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        backTracking(digits, numString, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯前创建一个全局变量sb，用于操作字符串的增删</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String digits, String[] numString, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果指针index与digits长度一致，说明遍历完成</span></span><br><span class="line">        <span class="keyword">if</span>(index == digits.length()) &#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出digits中当前指针index位置的字符所对应的数组元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> numString[digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; str.length();i++) &#123;</span><br><span class="line">            sb.append(str.charAt(i));</span><br><span class="line">            backTracking(digits, numString, index + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>先把每个按键对应的字符串存储到String数组中，每个**<u>下标对应按键的数字</u>**；</li>
<li>然后记得在回溯之前，定义一个<strong>操作字符串增删的全局变量</strong>sb；</li>
<li>回溯过程中，始终有一个指针<strong>index<u>用于指向本次回溯需要取</u>digits的第几个按键</strong>，找到该按键在字符串数组中<strong>对应的字符串</strong>，然后进入for循环依次遍历并回溯这组字符串。</li>
</ul>
<h1 id="切割问题"><a href="#切割问题" class="headerlink" title="切割问题"></a>切割问题</h1><h2 id="leetcode-131-分割回文串"><a href="#leetcode-131-分割回文串" class="headerlink" title="leetcode 131.分割回文串"></a>leetcode 131.分割回文串</h2><p><u><strong>题目</strong>：给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</u></p>
<p><u><strong>回文串</strong> 是正着读和反着读都一样的字符串。</u></p>
<p><u>输入：s &#x3D; “aab”</u><br><u>输出：[[“a”,”a”,”b”],[“aa”,”b”]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backTracking(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String s, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(index == s.length()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="comment">//在模板的基础上，多了一个判断条件，如果是回文串再添加到path，否则直接进入下一次循环</span></span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s, index, i)) &#123;<span class="comment">//左闭右闭</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(index, i + <span class="number">1</span>);<span class="comment">//左闭右开</span></span><br><span class="line">                path.add(str);</span><br><span class="line">                backTracking(s, i + <span class="number">1</span>);</span><br><span class="line">            	path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = right;i &lt; j;i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="☆leetcode-93-复原IP地址"><a href="#☆leetcode-93-复原IP地址" class="headerlink" title="☆leetcode 93.复原IP地址"></a>☆leetcode 93.复原IP地址</h2><p><u><strong>题目</strong>：有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且<strong>不能含有前导 0）</strong>，整数之间用 ‘.’ 分隔。</u></p>
<p><u>例如：”0.1.2.201” 和 “192.168.1.1” 是 <strong>有效</strong> IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#57;&#x32;&#46;&#49;&#x36;&#x38;&#x40;&#49;&#46;&#49;">&#x31;&#57;&#x32;&#46;&#49;&#x36;&#x38;&#x40;&#49;&#46;&#49;</a>“ 是 <strong>无效</strong> IP 地址。</u><br><u>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 <strong>不能</strong> 重新排序或删除 s 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; <span class="number">12</span>) <span class="keyword">return</span> res;<span class="comment">//简单的剪枝</span></span><br><span class="line">        backTracking(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String s, <span class="type">int</span> index, <span class="type">int</span> pointCount)</span> &#123;</span><br><span class="line">        <span class="comment">//逗点为3个就不用继续循环了，直接判断最后剩下的字符串符不符合条件</span></span><br><span class="line">        <span class="keyword">if</span>(pointCount == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s, index, s.length() - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//这个位置为什么可以直接添加s，可能因为s是形参，每次添加的s之间互不干扰</span></span><br><span class="line">                res.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s, index, i)) &#123;</span><br><span class="line">                <span class="comment">//注意要从0开始加</span></span><br><span class="line">                s = s.substring(<span class="number">0</span>, i + <span class="number">1</span>) + <span class="string">&quot;.&quot;</span> + s.substring(i + <span class="number">1</span>);</span><br><span class="line">                pointCount++;</span><br><span class="line">                backTracking(s, i + <span class="number">2</span>, pointCount);</span><br><span class="line">                pointCount--;</span><br><span class="line">                <span class="comment">//这里删除逗点的方式是拼接逗点左右两边的字符串，而把逗点跳过去</span></span><br><span class="line">                s = s.substring(<span class="number">0</span>, i + <span class="number">1</span>) + s.substring(i + <span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//一旦IP不合法，就没必要继续向下走了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是不是含有前导0</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(start) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i &lt;= end;i++) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h1><h2 id="leetcode-78-子集"><a href="#leetcode-78-子集" class="headerlink" title="leetcode 78.子集"></a>leetcode 78.子集</h2><p><u><strong>题目</strong>：给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</u></p>
<p><u>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</u></p>
<p><u>输入：nums &#x3D; [1,2,3]</u><br><u>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</u></p>
<p><u><strong>提示：</strong></u></p>
<ul>
<li><u><code>1 &lt;= nums.length &lt;= 10</code></u></li>
<li><u><code>-10 &lt;= nums[i] &lt;= 10</code></u></li>
<li><u><code>nums</code> 中的所有元素 <strong>互不相同</u></strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backTracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; nums.length;i++) &#123;<span class="comment">//广度遍历</span></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums, i + <span class="number">1</span>);<span class="comment">//深度遍历</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-90-子集-II（与组合总和-II-一起食用）"><a href="#leetcode-90-子集-II（与组合总和-II-一起食用）" class="headerlink" title="leetcode 90.子集 II（与组合总和 II 一起食用）"></a>leetcode 90.子集 II（与组合总和 II 一起食用）</h2><p><u><strong>题目</strong>：给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</u></p>
<p><u>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//必须要排序，便于后面去重操作</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="comment">//同层去重，前提是数组排过序了</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="☆leetcode-491-递增子序列"><a href="#☆leetcode-491-递增子序列" class="headerlink" title="☆leetcode 491.递增子序列"></a>☆leetcode 491.递增子序列</h2><p><u><strong>题目</strong>：给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 任意顺序 返回答案。</u></p>
<p><u>数组中可能含有重复元素，如出现<strong>两个整数相等</strong>，也可以视作递增序列的一种特殊情况。</u></p>
<p><u>输入：nums &#x3D; [4,6,7,7]</u><br><u>输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backTracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//一旦path中装了多于1个元素，就可以放进res中了，但是一定不要return！！！</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次树层遍历的开始，定义一个有着map功能的数组used，用于记录同层出现的数字</span></span><br><span class="line">        <span class="type">int</span>[] used = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">201</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="comment">//不满足递增或者nums[i]已经存在过都要进入下一次循环</span></span><br><span class="line">            <span class="keyword">if</span>(!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - <span class="number">1</span>) || used[nums[i] + <span class="number">100</span>] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//不要忘了记录当前的nums[i]</span></span><br><span class="line">            used[nums[i] + <span class="number">100</span>] = <span class="number">1</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="comment">//这里很容易把user[nums[i] + 100] = 0，不可以的原因是used是针对本循环的，而不是回溯的全局变量，所以不要让used归零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h1><h2 id="leetcode-46-全排列（与491递增子序列一起食用）"><a href="#leetcode-46-全排列（与491递增子序列一起食用）" class="headerlink" title="leetcode 46.全排列（与491递增子序列一起食用）"></a>leetcode 46.全排列（与491递增子序列一起食用）</h2><p><u><strong>题目</strong>：给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</u></p>
<p><u>输入：nums &#x3D; [1,2,3]</u><br><u>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backTracking(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//排列问题只有在path的长度和nums长度相等时才可以存入res，其实就是存入叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排列问题不需要指针，每一个位置都要考虑，所以i = 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="comment">//一旦之前标记过了，就说明path.contains(nums[i])，也可以用这个来判断</span></span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums);</span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="comment">//不仅要从path里删除元素，也要让数组中该位置元素的标记归零</span></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-为什么全排列的回溯过程中要让used-i-数组归位，而上一题491递增子序列不需要归位？"><a href="#1-为什么全排列的回溯过程中要让used-i-数组归位，而上一题491递增子序列不需要归位？" class="headerlink" title="1.为什么全排列的回溯过程中要让used[i]数组归位，而上一题491递增子序列不需要归位？"></a>1.为什么全排列的回溯过程中要让used[i]数组归位，而上一题491递增子序列不需要归位？</h4><p>因为全排列的used数组是全局变量，每次backTracking递归过程就是一次深度遍历，而used数组的目的就是让下一层的树枝for循环的时候，避免上面树枝中添加的元素，所以used的目的是**<u>树枝去重</u>**作用的。</p>
<p>而对于递增子序列，我们的used并不是全局变量，而是每层树枝在广度遍历之前创建的一个**<u>树层去重</u><strong>的数组，如果nums取值范围非常大，我们还要用HashMap来替代数组，因为这道题只有201个不同数值，所以可以用</strong>数组模拟HashMap去重**。所以<u><em>树层遍历的used数组不应该因为回溯深度遍历而被回溯（因为没有used数组参与深度遍历）</em></u>。</p>
<h4 id="2-为什么全排列需要used数组，而组合不需要？"><a href="#2-为什么全排列需要used数组，而组合不需要？" class="headerlink" title="2.为什么全排列需要used数组，而组合不需要？"></a>2.为什么全排列需要used数组，而组合不需要？</h4><p>因为全排列的[1,2,3]和[3,2,1]是两个不一样的结果，组合则是一样的结果。所以组合和子集问题我们都有一个指针，在每层树枝广度遍历的时候通过<strong>backTracking的形参中指针的传递</strong>就避免了重复元素。</p>
<p>而全排列则不可以有指针，每一层树枝广度遍历的时候，必须要<strong>从0到nums.length每一个元素都要遍历</strong>，而为了避免上面树层已经添加过某些元素，在本层不可以添加了，就要一个负责<strong>深度遍历去重的数组used</strong>。</p>
<h2 id="leetcode-47-全排列-II"><a href="#leetcode-47-全排列-II" class="headerlink" title="leetcode 47.全排列 II"></a>leetcode 47.全排列 II</h2><p><u><strong>题目</strong>：给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</u></p>
<p><u>输入：nums &#x3D; [1,1,2]</u><br><u>输出：[[1,1,2], [1,2,1], [2,1,1]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTracking(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;           </span><br><span class="line">            <span class="comment">//这里是重点，树层去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//树枝去重</span></span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                backTracking(nums);</span><br><span class="line">                path.removeLast();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题因为是含有重复元素的数组，所以我们去重一般选择的是<strong>同层去重</strong>，前提就是<strong>对nums数组先进行排序</strong>，这在组合题目中就练习过。</p>
<p>结合上面的全排列，我们发现used数组是为了深度遍历而创建的，那么怎么利用他来进行树层去重呢，首先因为nums排序了，所以每层遍历的时候，都要比较当前元素和前一个元素（如果有的话）是否相等。我们还得证明前一个元素在<strong>同父节点的前一个子节点</strong>已经取过了，我们知道上一个子节点取完会<strong>回溯到父节点</strong>，然后走到本节点，相应的used[i - 1]也会置为false，所以如果used[i - 1] &#x3D;&#x3D; false，说明上一个同父的子节点已经取过了，又因为这两个相邻元素相等，我们这个子节点就没必要继续取了。按照这个思路，当两个相邻元素相等，但used[i - 1] &#x3D; true的时候，就说明前面子节点没添加（其实就是<strong>前面没有子节点，本节点是当前层的第一个</strong>），也就是左下角那种情况。</p>
<img src="https://img-blog.csdnimg.cn/20201124201406192.png" alt="47.全排列II2" style="zoom:35%;" />

<p>如果我们把判断条件中的used[i - 1] &#x3D;&#x3D; false改为true其实也可以，这就是一种<strong>树枝去重</strong>的方式，要注意和全排列中used[i] &#x3D;&#x3D; true区分开，本题既要判断used[i - 1] &#x3D;&#x3D; true又要判断used[i] &#x3D;&#x3D; true，整个流程如下图所示。可以看到出现了很多冗余的判断，直到最后的右下角，才得到了答案。原因是：我们始终判断的是<strong>前一个元素有没有在整个树枝中出现</strong>，如果<u>先添加最后一个元素</u>，那么前面的元素就可以依次添加进来了。</p>
<img src="https://img-blog.csdnimg.cn/20201124201431571.png" alt="47.全排列II3" style="zoom: 33%;" />

<h1 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h1><h2 id="leetcode-51-N皇后"><a href="#leetcode-51-N皇后" class="headerlink" title="leetcode 51.N皇后"></a>leetcode 51.N皇后</h2><p><u><strong>题目</strong>：按照国际象棋的规则，皇后可以攻击与之处在<strong>同一行</strong>或<strong>同一列</strong>或<strong>同一斜线上</strong>的棋子。</u></p>
<p><u>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</u></p>
<p><u>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</u></p>
<p><u>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] chessboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="comment">//先把数组的每一个位置填上&#x27;.&#x27;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c : chessboard) &#123;</span><br><span class="line">            Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(n, <span class="number">0</span>, chessboard);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, <span class="type">char</span>[][] chessboard)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n) &#123;</span><br><span class="line">            res.add(arrayToList(chessboard));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;col &lt; n;col++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(n, row, col, chessboard)) &#123;</span><br><span class="line">                chessboard[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                backTracking(n, row + <span class="number">1</span>, chessboard);</span><br><span class="line">                chessboard[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数组转换为集合</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">arrayToList</span><span class="params">(<span class="type">char</span>[][] chessboard)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c : chessboard) &#123;</span><br><span class="line">            list.add(String.copyValueOf(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前行和列能不能添加Q</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span>[][] chessboard)</span> &#123;</span><br><span class="line">        <span class="comment">//当前列每一行是否都没有Q</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//45°有没有Q</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>;i--,j--) &#123;</span><br><span class="line">            <span class="comment">//这里写错了两次，是i,j不是row,col</span></span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//135°有没有Q</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; j &lt;= n - <span class="number">1</span>;i--,j++) &#123;</span><br><span class="line">            <span class="comment">//这里写错了两次，是i,j不是row,col</span></span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-37-解数独"><a href="#leetcode-37-解数独" class="headerlink" title="leetcode 37.解数独"></a>leetcode 37.解数独</h2><p><u><strong>题目</strong>：编写一个程序，通过填充空格来解决数独问题。</u></p>
<p><u>数独的解法需 遵循如下规则：</u></p>
<p><u>数字 1-9 在每一行只能出现一次。</u><br><u>数字 1-9 在每一列只能出现一次。</u><br><u>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</u><br><u>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</u></p>
<p><img src="https://img-blog.csdnimg.cn/202011171912586.png" alt="解数独"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        backTracking(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; board.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>;k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(isValid(k, i, j, board)) &#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        <span class="keyword">if</span>(backTracking(board)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//一旦9个数字都填不进去，就跳出循环，肯定数独是无解的了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="comment">//检查当前列的每一行有没有k</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查当前行的每一列有没有k</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">9</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][j] == k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//九宫格内检查有没有k</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startRow</span> <span class="operator">=</span> (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startRow;i &lt; startRow + <span class="number">3</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> startCol;j &lt; startCol + <span class="number">3</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>全排列问题，[1,2]和[2,1]不一样，也就是深度遍历的时候，每层都要<strong>从nums的头遍历到nums的尾</strong>，但必须要记录这一树枝上添加到path的元素，所以一定要用<strong>全局变量数组used</strong>，通过<strong>回溯过程</strong>将used归零，可以有效区分<strong>每个树枝</strong>不含重复元素。记住！每个根节点下面的子节点，都是走的根节点的backTracking()，所以子节点拥有的used<strong>一致的部分</strong>是根节点及其上面的节点，子节点与子节点之间的used互不影响。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/30/%E5%9B%9E%E6%BA%AF%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/" data-id="cl3sliw020000wkv65w08c6t5" data-title="回溯系列题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-05-29T10:54:55.000Z" itemprop="datePublished">2022-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/">操作系统笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="1-虚拟内存"><a href="#1-虚拟内存" class="headerlink" title="1.虚拟内存"></a>1.虚拟内存</h2><p>如果我们每次都直接存储绝对的物理地址，肯定会造成一定的冲突，这也是<strong>单片机的一大弊端</strong>。所以操作系统<strong>为每个进程</strong>分配了<strong>独立</strong>的虚拟地址。然后通过<strong>映射的关系</strong>来将虚拟地址于物理地址关联起来。所以有了以下两种概念：</p>
<ul>
<li><p>程序所使用的内存地址——虚拟内存地址（Virtual Memory Address）</p>
</li>
<li><p>硬件中<strong>实际的空间地址</strong>——物理内存地址（Physical Memory Address）</p>
<img src="https://img-blog.csdnimg.cn/72ab76ba697e470b8ceb14d5fc5688d9.png" alt="img" style="zoom:50%;" /></li>
</ul>
<p>进程持有的虚拟内存会通过CPU芯片中的<strong>内存管理单元（MMU）</strong>的映射关系来<strong>将虚拟内存转换为物理地址</strong>。</p>
<h2 id="2-内存分段"><a href="#2-内存分段" class="headerlink" title="2.内存分段"></a>2.内存分段</h2><p>因为程序是<strong>由若干个逻辑组成</strong>的，比如有代码段、数据段、栈段、堆段等。所以这些程序内存就可以通过分段来存储。而<strong>段表</strong>就是虚拟与物理内存之间映射的桥梁。</p>
<img src="https://img-blog.csdnimg.cn/a9ed979e2ed8414f9828767592aadc21.png" alt="img" style="zoom: 40%;" />

<img src="https://img-blog.csdnimg.cn/c5e2ab63e6ee4c8db575f3c7c9c85962.png" alt="img" style="zoom:42%;" />

<p>内存分段的缺点：</p>
<p>1）<u>内存碎片问题</u>。包括外部碎片和内部碎片：外部碎片就是物理内存产生了<strong>很多小的、不连续空间</strong>，导致新的程序无法装载；内部碎片就是程序所有的内存都被装到物理内存中，但是有一部分不常用，<strong>造成空间浪费</strong>。</p>
<p>2）<u>内存交换效率低</u>。因为<strong>分的这些段都比较大</strong>，在外部内存碎片<strong>导致新程序无法装载的情况出现时</strong>，就需要把一部分内存（比较大）<strong>随机</strong>写到硬盘上，这种<strong>较大的IO操作</strong>必然带来了性能瓶颈的问题。</p>
<h2 id="3-内存分页"><a href="#3-内存分页" class="headerlink" title="3.内存分页"></a>3.内存分页</h2><p>为了<u>解决内存碎片问题</u>，采用内存分页，分页就像微积分，把每次要处理的内存尽可能减小，变成<strong>固定大小的4KB（Linux下</strong>），这就很大程度上<strong>解决了内存碎片的问题</strong>。<strong>页表</strong>实现了虚拟与物理内存的映射，MMU实现了这个转换工作。</p>
<p>如果某个虚拟地址在页表中查不到，系统会产生**<u>缺页异常</u><strong>，然后会</strong>进入系统内核空间<strong>分配物理内存、更新进程页表，最后</strong>返回用户空间**、恢复进程运行。</p>
<img src="https://img-blog.csdnimg.cn/7884f4d8db4949f7a5bb4bbd0f452609.png" alt="img" style="zoom: 40%;" />

<h3 id="内存交换效率的提升"><a href="#内存交换效率的提升" class="headerlink" title="内存交换效率的提升"></a>内存交换效率的提升</h3><p>因为内存交换的效率与IO操作时实际交换的内存大小有关，页比段要小的多，通常分页的内存一次性IO只有少数几个页，大大提升了内存交换效率。</p>
<img src="https://img-blog.csdnimg.cn/388a29f45fe947e5a49240e4eff13538.png" alt="img" style="zoom: 35%;" />

<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>因为页表是需要占用内存空间的，所以不难想象，<strong>每个非常小的页都需要一个映射来指向物理空间</strong>，这个页表是非常庞大的（比如在32位和页大小为4KB的环境下，一个进程的页表需要装100多万个“页表项”，大概需要<strong>占用4MB</strong>大小的空间，多进程下，页表的内存占据是不可忽视的），所以就有了多级页表。</p>
<p>即每级页表有1024个页表项，依据<strong>局部性原理</strong>，虽然一级页表的1024个页表项可以覆盖整个4GB物理空间，<strong>但很多个页表项不需要创建二级页表</strong>，因为这一部分压根就没有映射。所以一般一级页表只有一定比例的页表项需要创建二级页表，假如这个比例是20%，那么多级页表占用的总内存为：</p>
<p><u>4KB（一级页表）+4MB*20% &#x3D; 0.804MB &lt; 4MB</u></p>
<img src="https://img-blog.csdnimg.cn/19296e249b2240c29f9c52be70f611d5.png" alt="img" style="zoom:35%;" />

<p>对于<strong>64位系统</strong>，为四级目录：</p>
<img src="https://img-blog.csdnimg.cn/98e1b77d34784e18a9d7cc0a57706507.png" alt="img" style="zoom:30%;" />

<h3 id="页表缓存TLB（Translation-Lookaside-Buffer）"><a href="#页表缓存TLB（Translation-Lookaside-Buffer）" class="headerlink" title="页表缓存TLB（Translation Lookaside Buffer）"></a>页表缓存TLB（Translation Lookaside Buffer）</h3><p>多级页表虽然解决了空间问题，但是<strong>增加了时间的开销</strong>（虚拟到物理的转换工序增加）。还是根据程序的<strong>局部性原理</strong>，我们可以把最常访问的几个<strong>页表项</strong>存储到<strong>CPU芯片中</strong>的TLB中，也称页表缓存、快表、转址旁路缓存。</p>
<p>CPU芯片中的<strong>MMU</strong>负责<strong>地址转换和TLB的访问与交互</strong>。</p>
<img src="https://img-blog.csdnimg.cn/a3cdf27646b24614a64cfc5d7ccffa35.png" alt="img" style="zoom:50%;" />

<h2 id="4-段页式内存管理"><a href="#4-段页式内存管理" class="headerlink" title="4.段页式内存管理"></a>4.段页式内存管理</h2><p>先将程序根据逻辑划分为多个段，然后把每个段分为多个页。</p>
<p>这样段表存的是<strong>页表的起始地址</strong>，页表存的才是物理页号。最终的物理地址是<strong>物理页号+物理地址</strong>。</p>
<img src="https://img-blog.csdnimg.cn/8904fb89ae0c49c4b0f2f7b5a0a7b099.png" alt="img" style="zoom:40%;" />

<h1 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h1><p>内核的4个基本能力：</p>
<ul>
<li><u>进程调度</u>：管理进程、线程，<strong>决定</strong>哪个进程、线程<strong>使用</strong>CPU；</li>
<li><u>内存管理</u>：<strong>决定</strong>内存的<strong>分配和回收</strong>；</li>
<li><u>硬件通信</u>：为<strong>进程与硬件设备</strong>之间提供通信能力；</li>
<li><u>系统调用</u>：如果应用程序要运行<strong>更高权限</strong>运行的服务，需要系统调用，它是<strong>用户程序与操作系统</strong>之间的<strong>接口</strong>。</li>
</ul>
<p>内核可以<strong>控制CPU、内存、硬盘</strong>等硬件内存被分为：</p>
<ul>
<li><strong>只有内核程序可以访问</strong>的内核空间</li>
<li>专门为应用程序使用的用户空间</li>
</ul>
<p>用户空间的代码只可以访问局部空间，内核空间代码<strong>可以访问所有内存空间</strong>。</p>
<p>应用程序如果<strong>要进入内核空间</strong>，就需要通过<strong>系统调用</strong>。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8/systemcall.png" alt="img" style="zoom:50%;" />

<p>当应用程序使用系统调用时，会产生一个中断，<strong>CPU会中断当前在执行的的用户程序</strong>，开始执行内核程序。处理完后，主动触发中断，把CPU执行权<strong>交还给用户程序</strong>，回到用户态继续工作。</p>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h2><p>我们写的代码不在内存里，而在外存也就是硬盘里，编译后生成二进制可执行文件，还是在硬盘里。只有运行的时候，才会被装载到内存中，这个时候就等待CPU执行程序中的指令，而这个<strong>运行中的程序</strong>就是进程。</p>
<p>关于并行与并发，我们假设只有一个CPU，却有两个任务，那么我们只能完成一件再完成另一件，或者交替的完成一部分，直到两个任务都完成了，这个就是<u>并发</u>，<strong>涉及到[运行-暂停-运行]这么一个环节</strong>；如果我们有两个CPU，那么就可以让两个CPU分别同时这两个任务，<strong>不需要暂停任何一个CPU</strong>就可以同时完成，这就是<u>并行</u>。</p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg" alt="七种状态变迁" style="zoom: 45%;" />

<p>Null -&gt; 创建：一个进程<strong>被创建时</strong>的第一个状态</p>
<p>创建 -&gt; 就绪：当进程创建完成并初始化之后，就进入就绪态</p>
<p>就绪 -&gt; 运行：处于就绪的进程被OS的<strong>进程调度器选中</strong>后，就<strong>分配给CPU</strong>运行</p>
<p>运行 -&gt; 结束：进程运行<strong>完成</strong>或<strong>出错</strong>，OS将其作为结束状态处理</p>
<p>运行 -&gt; 就绪：CPU分配给进程的<strong>时间片用完</strong>了，进程就<strong>被OS设置</strong>为就绪态</p>
<p>运行 -&gt; 阻塞：当进程<strong>请求</strong>某个事件且<strong>必须等待</strong>时，比如<strong>I&#x2F;O事件</strong></p>
<p>阻塞 -&gt; 就绪：进程<strong>等待的事件完成了</strong>，OS将其设为就绪</p>
<p>如果有<strong>大量进程阻塞</strong>，就把他们先<u>换出到硬盘</u>，对于就绪态的进程也一样：</p>
<p>阻塞挂起状态：进程在硬盘并<strong>等待某个事件出现</strong></p>
<p>就绪挂起状态：进程在硬盘，但<strong>只要进入内存</strong>就<strong>立刻运行</strong></p>
<h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><h4 id="PCB是什么？"><a href="#PCB是什么？" class="headerlink" title="PCB是什么？"></a>PCB是什么？</h4><p>进程控制块PCB（Process control block）是<strong>进程存在的唯一标识</strong>。跟随进程同生死。</p>
<p>PCB包含：</p>
<p>进程<strong>描述</strong>信息：</p>
<ul>
<li><u>进程标识符</u>：标识进程，<strong>唯一性</strong></li>
<li><u>用户标识符</u>：进程<strong>归属的用户</strong>，为了共享和保护服务</li>
</ul>
<p>进程<strong>控制和管理</strong>信息：</p>
<ul>
<li><u>进程当前状态</u>：new, ready, running, waiting, blocking等</li>
<li><u>进程优先级</u>：进程<strong>抢占CPU</strong>时的优先级</li>
</ul>
<p><strong>资源分配</strong>清单：</p>
<ul>
<li>关于<strong>内存地址空间</strong>或<strong>虚拟地址空间</strong>的信息，所打开文件的列表和所使用<strong>IO设备信息</strong></li>
</ul>
<p><strong>CPU</strong>相关信息：</p>
<ul>
<li>CPU各个寄存器的值，进程切换时需要<strong>打断点</strong>，即保存CPU状态信息，便于后续进程的继续执行。</li>
</ul>
<h4 id="PCB如何组织的？"><a href="#PCB如何组织的？" class="headerlink" title="PCB如何组织的？"></a>PCB如何组织的？</h4><p>通常通过<u><strong>链表</strong></u>，把<strong>具有相同状态</strong>的进程<strong>链在一起</strong>，组成各种队列，比如处在就绪状态的进程，组成<u>就绪队列</u>；处在阻塞状态的进程组成<u>阻塞队列</u>。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/12-PCB%E7%8A%B6%E6%80%81%E9%93%BE%E8%A1%A8%E7%BB%84%E7%BB%87.jpg" alt="就绪队列和阻塞队列" style="zoom:40%;" />

<p>进程控制包括：创建进程、终止进程、阻塞进程、唤醒进程</p>
<h4 id="1-创建进程"><a href="#1-创建进程" class="headerlink" title="1.创建进程"></a>1.创建进程</h4><ul>
<li>为新进程<strong>分配一个唯一标识号</strong>，并<strong>申请一个空白PCB</strong>，如果申请失败，则创建失败</li>
<li>为进程<strong>分配资源</strong>，资源不足则进程处于<strong>等待</strong>状态</li>
<li>初始化PCB</li>
<li>如果进程的<u>调度队列</u>能够<strong>接纳新进程</strong>，就把进程<strong>插入到就绪队列</strong>，等待被调度</li>
</ul>
<h4 id="2-终止进程"><a href="#2-终止进程" class="headerlink" title="2.终止进程"></a>2.终止进程</h4><ul>
<li>查找进程的PCB</li>
<li>如果进程还在执行中，就立即<strong>终止</strong>，并将<strong>CPU资源分配</strong>给其他进程</li>
<li>所有<strong>子进程</strong>全部终止</li>
<li>将进程拥有的全部<strong>资源归还</strong>给父进程或操作系统</li>
<li>从<strong>PCB队列</strong>删除</li>
</ul>
<h4 id="3-阻塞进程"><a href="#3-阻塞进程" class="headerlink" title="3.阻塞进程"></a>3.阻塞进程</h4><ul>
<li>找到其PCB</li>
<li>如果进程还在运行，<strong>保护现场</strong>，然后将其<strong>转为阻塞态</strong>，停止运行</li>
<li>将PCB插入<strong>阻塞队列</strong></li>
</ul>
<h4 id="4-唤醒进程（阻塞-gt-就绪）"><a href="#4-唤醒进程（阻塞-gt-就绪）" class="headerlink" title="4.唤醒进程（阻塞-&gt;就绪）"></a>4.唤醒进程（阻塞-&gt;就绪）</h4><ul>
<li>在<strong>阻塞队列</strong>找到该进程的PCB</li>
<li>从阻塞队列中移除，并置为<strong>就绪状态</strong></li>
<li>把该PCB<strong>插入到就绪队列</strong>，等待调度</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" data-id="cl3sliw040001wkv640tye5fg" data-title="操作系统笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-二叉树题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-17T03:19:44.000Z" itemprop="datePublished">2022-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/">二叉树题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;<span class="built_in">this</span>.val = val;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个很可能在二叉树面试的时候要求手撕，所以要会写！</p>
<h1 id="二叉树基本题型"><a href="#二叉树基本题型" class="headerlink" title="二叉树基本题型"></a>二叉树基本题型</h1><h2 id="leetcode-144-二叉树的前序遍历"><a href="#leetcode-144-二叉树的前序遍历" class="headerlink" title="leetcode 144.二叉树的前序遍历"></a>leetcode 144.二叉树的前序遍历</h2><p><u><strong>题目</strong>：给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//方法一：递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        preOrder(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        preOrder(root.left, ans);</span><br><span class="line">        preOrder(root.right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法一递归法，需要<strong>注意的就是我们要对什么迭代</strong>，是不是树的结点，是不是每次迭代的当前结点的值要输出来？知道了这俩条件，我们就知道要创建一个<strong>无需返回值</strong>的递归方法，而递归的参数就是上述需要递归的树结点以及需要每次记录输出值的集合（数组）。</p>
<p>递归方法的第一步写出来了，就要<strong>找到递归终止条件</strong>，自然是当前结点为空喽。</p>
<p>递归函数呢？每次先记录当前结点，然后一直递归左节点，左节点没了最后再递归右节点。</p>
<p>方法二迭代法：这个就是用栈来操作，需要注意的是：</p>
<p>1）root先进行判空，再入栈</p>
<p>2）作为前序遍历，我们每次把当前的栈顶弹出来记录，然后再加入后面的树节点</p>
<p>3）然后就是<strong>先将谁入栈</strong>的问题，因为栈是先进后出，所以我们要先入栈右结点，再入栈左节点，所以出栈就是先左后右。记住<strong>这里是if连着另一个if，千万不要写成if else if语句</strong>。</p>
<h2 id="leetcode-94-二叉树的中序遍历"><a href="#leetcode-94-二叉树的中序遍历" class="headerlink" title="leetcode 94.二叉树的中序遍历"></a>leetcode 94.二叉树的中序遍历</h2><p><u><strong>题目</strong>：给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;<span class="comment">//指针负责压栈和向左子结点遍历</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//一旦指针空了，就弹出一个，肯定能弹，否则进不了循环</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                cur = temp.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前序遍历的迭代法中，我们每次通过栈访问的结点正是我们需要处理（放入集合中）的结点。但是中序遍历没这么简单，中序遍历要先访问左节点，这就<strong>必然导致我们得先压入几个结点之后，才开始向集合中放入元素</strong>。</p>
<p>所以我们需要分别定义一个指针，和一个栈。通过指针来<strong>控制遍历的次序和弹栈的时机</strong>。</p>
<p>如果当前指针不为空，我们就一直将指针向左子节点移动，同时压入栈（先压后移动）。</p>
<p>直到指针为空了，说明我们<strong>找到了“左中右”中的左</strong>了，所以弹出该元素并添加到集合中，让指针指向这个弹出的元素的右节点，如果右节点存在，则继续向左下遍历，如果不存在，那么就可以把刚刚添加的“左节点”的父节点，<strong>即”左中右“的中</strong>添加到集合中，然后继续让指针指向此节点的右结点，以此类推，就实现了左中右的顺序。</p>
<h2 id="☆leetcode-145-二叉树的后序遍历"><a href="#☆leetcode-145-二叉树的后序遍历" class="headerlink" title="☆leetcode 145.二叉树的后序遍历"></a>☆leetcode 145.二叉树的后序遍历</h2><p><u><strong>题目</strong>：给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>后序</strong> 遍历</em> 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root , pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;<span class="comment">//因为cur为空之后还有操作，所以这里不能用if了，要用while</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur.right == <span class="literal">null</span> || cur.right == pre)&#123;<span class="comment">//这里要用pre记录上一个遍历过的右节点</span></span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = <span class="literal">null</span>;<span class="comment">//后续遍历，加完了list.add(cur.val)之后，cur不用向后走了，所以置为null，然stack弹出cur的上层元素</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历的迭代法可以说是难度最大的，还是一样没有放上递归的版本，因为太简单了。</p>
<p>首先后序遍历与前两个最大的区别就是要定义一个标记指针pre，这是为了记录上一次循环的右结点，防止循环记录。下面我会详细说明。</p>
<p>大循环条件和中序遍历一致，一进入循环，我们可以看到<strong>这次用while了，而不是if（中序遍历用的if）</strong>。为啥？因为我们这次在cur指针指向null的时候还有其他操作和判断，所以我们必须让cur指针在小循环里就一直走到最左下角的位置（其实中序遍历也是一直走到左下角，因为while里面只有if和else，所以<strong>写if还是写while不影响</strong>）。所以<strong>这一步其实和中序遍历的思路是一样的，即一直走到左下角为止</strong>。</p>
<p>当cur一旦为空，就说明到左叶子结点的左指针了，这个时候我们就把栈弹出一个位置，也就是将左叶子结点赋给cur。如果是中序遍历，我们直接把这个指针结点加入就行了。但是后序遍历我们还要看一下这个结点有没有右子节点。所以还要继续判断。</p>
<p>右节点不为空我们就继续让指针向右下走；如果为空，我们就可以真正记录现在的结点值了。最最重要的就是记录完之后怎么办？我们先看看前中序遍历都干了什么：前序遍历添加完之后继续压栈，因为他是自顶向下的遍历，所以自然<strong>加完了继续向下走</strong>就是了；中序遍历和后序遍历更像一些，<strong>中序遍历添加完元素因为其右下角还需要添加</strong>，所以要<strong>将cur指向右下角</strong>等待进入下一次循环的判断。</p>
<p>而后序遍历加完了当前元素可以确定肯定不往下走了，但是往树的上面走又要借助栈的弹出，所以索性让cur指向null（**<u>这里我们标记一下位置</u><strong>），然后交给下一次循环的判断，下一次肯定不会执行大while里的小while了，因为cur为空了嘛，所以cur一下就可以获得了栈顶元素，问题来了，我们还是会照常判断cur右结点是否为空，我们要知道刚刚是</strong>给cur指向null可不是给他所指向的结点本身赋值为空啊**（肯定不能这样做，这会改变树的结构）。所以又会继续把cur的右节点加入到list中，情景重现而且一直循环往复，出不来了！</p>
<p>所以这个时候，前面定义的pre记录指针就起到作用了，放在哪里？哪里有需要就放在哪里！刚刚发现的循环其实就是因为<strong>没有及时记录那个右节点</strong>，所以我们在上一段加粗并有下划线的位置之前，也就是<strong>cur指向null之前，先把cur指的树结点赋给pre指针</strong>，这样就记录了已经添加到list中的右节点，并在循环中加一个cur.right &#x3D;&#x3D; pre的判断。</p>
<h2 id="leetcode-102-二叉树的层序遍历"><a href="#leetcode-102-二叉树的层序遍历" class="headerlink" title="leetcode 102.二叉树的层序遍历"></a>leetcode 102.二叉树的层序遍历</h2><p><u><strong>题目</strong>：给你二叉树的根节点 <code>root</code> ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        queue.offer(root);<span class="comment">//1.先把根节点加进来</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//2.注意要每次创建一个集合记录当前行的元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();<span class="comment">//3.记录每行queue的长度，也就是该层节点的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();<span class="comment">//4.遍历一个弹出一个，不用判空</span></span><br><span class="line">                list.add(node.val);<span class="comment">//5.弹出一个记录一个</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;<span class="comment">//6.记录完了要用当前节点遍历其左右节点</span></span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>层序遍历是纯模板类题目，最需要注意的就是考虑清楚：</p>
<p>1）每次<strong>向list中加的元素</strong>是谁？是从queue中弹出的元素！</p>
<p>2）每次<strong>向queue中加的元素</strong>是谁？是每次弹出的元素的左右结点，所以每次弹出后要用一个指针记录当前结点。</p>
<h2 id="leetcode-429-N叉树的层序遍历"><a href="#leetcode-429-N叉树的层序遍历" class="headerlink" title="leetcode 429.N叉树的层序遍历"></a>leetcode 429.N叉树的层序遍历</h2><p><u><strong>题目</strong>：给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</u></p>
<p><u>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        queue.offer(cur);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                List&lt;Node&gt; children = node.children;<span class="comment">//因为每次要加的集合中的元素，所以先列出来</span></span><br><span class="line">                <span class="keyword">if</span>(children == <span class="literal">null</span>) <span class="keyword">continue</span>;<span class="comment">//先看看当前集合是不是空的</span></span><br><span class="line">                <span class="keyword">for</span>(Node child : children)&#123;<span class="comment">//集合不空就依次让child入队</span></span><br><span class="line">                    <span class="keyword">if</span>(child != <span class="literal">null</span>)&#123;<span class="comment">//child可能是null，所以要判断一下</span></span><br><span class="line">                        queue.offer(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先要注意这题不是二叉树，所以<strong>没有TreeNode了</strong>，很容易写错；</p>
<p>其次，每次必须先把children集合列出来，然后看看它空不空，<strong>不空再一个个添加</strong>，添加的时候也要一个个看看child空不空。</p>
<h2 id="leetcode-116-填充每个节点的下一个右侧节点指针"><a href="#leetcode-116-填充每个节点的下一个右侧节点指针" class="headerlink" title="leetcode 116.填充每个节点的下一个右侧节点指针"></a>leetcode 116.填充每个节点的下一个右侧节点指针</h2><p><u><strong>题目</strong>：给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</u></p>
<p><u>初始状态下，所有 next 指针都被设置为 NULL。</u></p>
<img src="https://img-blog.csdnimg.cn/20210203152044855.jpg" alt="116.填充每个节点的下一个右侧节点指针" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        Deque&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(i != size - <span class="number">1</span>)&#123;</span><br><span class="line">                    head.next = queue.peek();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(head.left != <span class="literal">null</span>) queue.offer(head.left);</span><br><span class="line">                <span class="keyword">if</span>(head.right != <span class="literal">null</span>) queue.offer(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题难度不大，注意两点：</p>
<p>1）加了一个next指针，定义树结构的时候要注意（手撕的时候要会写）</p>
<p>2）每次取当前队列中的队头元素，然后判断指针i是否走到最后一位了，如果没走到，我们<strong>就把刚刚弹出来的队头的元素指向当前的队头元素</strong>。</p>
<h2 id="☆leetcode-117-填充每个节点的下一个右侧节点指针-II"><a href="#☆leetcode-117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="☆leetcode 117.填充每个节点的下一个右侧节点指针 II"></a>☆leetcode 117.填充每个节点的下一个右侧节点指针 II</h2><p><u><strong>题目</strong>：和116题一样，只不过这次不是完美二叉树了，有些节点可能没有左节点或右节点。</u></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//第一个while循环判断的是每行是否存在至少一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);<span class="comment">//每次遍历当前行的时候都要有一个哑节点，用来定位下一层的首节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;<span class="comment">//作为下一层的遍历指针</span></span><br><span class="line">            <span class="comment">//第二个while是控制指针在同一层向右推进</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    pre.next = cur.left;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    pre.next = cur.right;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.next;<span class="comment">//每次操作完其左右节点要继续向右移动</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur = dummy.next;<span class="comment">//这一步很关键！容易忘！下次循环要遍历下一层了，cur要赋值为下一层首节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实完全可以用116的队列题解来做。但是本题的进阶要求是<strong>空间复杂度为常量级</strong>。</p>
<p>所以给出链表级解法。其实就是让指针依次在每一行向右移动，从每一行的最左边移动到最右边。但是next指针默认是指向空的啊！所以我们<strong>需要在遍历上边一层的时候，就把下边一层连接好了</strong>。因为头结点只有一个，不用连接，所以我们可以轻易的将第二层通过遍历第一层（root）的左右子节点来实现连接操作，后面的层以此类推。</p>
<p>所以我们每次遍历当前层节点时候（指针cur），要定义一个哑节点（dummy），然后让另一个指针<strong>pre来逐个连接cur的左右子节点</strong>。</p>
<h2 id="leetcode-226-翻转二叉树"><a href="#leetcode-226-翻转二叉树" class="headerlink" title="leetcode 226.翻转二叉树"></a>leetcode 226.翻转二叉树</h2><p><u>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</u></p>
<img src="https://img-blog.csdnimg.cn/20210203192644329.png" alt="226.翻转二叉树" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        root.left = invertTree(root.left);</span><br><span class="line">        root.right = invertTree(root.right);</span><br><span class="line">        swap(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">                    swap(node);</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    queue.offer(node.right); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="leetcode-101-对称二叉树"><a href="#leetcode-101-对称二叉树" class="headerlink" title="leetcode 101.对称二叉树"></a>leetcode 101.对称二叉树</h2><p><u><strong>题目</strong>：给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</u></p>
<img src="https://img-blog.csdnimg.cn/20210203144607387.png" alt="101. 对称二叉树" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> || right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> compare(left.left, right.right) &amp;&amp; compare(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//这里要注意ArrayDeque不能插入null</span></span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//注意这里不要直接return true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(leftNode.val != rightNode.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(leftNode.left);</span><br><span class="line">            queue.offer(rightNode.right);</span><br><span class="line">            queue.offer(leftNode.right);</span><br><span class="line">            queue.offer(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题可以说是考察对递归和迭代的细节把握能力。</p>
<p>先说递归，递归函数的返回值是需要我们考虑的，为什么是布尔类型？因为我们每次判断的都是当前树的子树是否对称，<strong>每次都是一个对错的判断，不涉及到任何存储数值的情况</strong>，所以用布尔类型作为返回值。每次递归，先判断对称位置的点是否都存在，如果对称位置存在情况都不一样，肯定就不对称，返回false；如果一样，我们比较对称位置的值，不一样也返回false；都一样了，说明当前是对称的，<strong>还需要继续看它的子树的对称情况</strong>。</p>
<p>再说迭代，迭代法可以单端也可以双端，思路差不多，我给出的是单端队列，每次弹出两个对称位置进行比较，思路和上面的递归法一样。如果当前对称，那么就<strong>把子节点的对称位置依次入队</strong>，要注意入队顺序。因为入队的元素可能为null，所以<strong>队列一定要定义为双向链表LinkedList而不要定义为ArrayDeque</strong>，否则会报空指针异常。</p>
<p>下面顺便给出<u>三个队列的特点</u>：</p>
<p>ArrayDeque:双端队列，线程不安全，性能高于LinkedList，支持随机访问，<strong>但不允许插入null元素</strong></p>
<p>LinkedList:双端队列，线程不安全，首尾元素插入操作效率高，<strong>不支持随机访问</strong></p>
<p>PriorityQueue:线程不安全，不允许插入null元素，动态数组默认实现最小堆。</p>
<h2 id="leetcode-104-二叉树的最大深度"><a href="#leetcode-104-二叉树的最大深度" class="headerlink" title="leetcode 104.二叉树的最大深度"></a>leetcode 104.二叉树的最大深度</h2><p><u><strong>题目</strong>：给定一个二叉树，找出其最大深度。</u></p>
<p><u>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</u></p>
<p><u><strong>说明:</strong> 叶子节点是指没有子节点的节点。</u></p>
<img src="https://img-blog.csdnimg.cn/20210203153031914.png" alt="104. 二叉树的最大深度" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span>&#123;<span class="comment">//虽然每一次递归形参depth都是0，但是不影响depth，因为depth是下一层返回值决定的</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> getDepth(root.left, depth);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> getDepth(root.right, depth);</span><br><span class="line">        depth = Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题迭代法很简单，就是套层序遍历的模板就行了。而递归法有些难度：</p>
<p>整体的思路就是后序遍历，我们利用后续遍历先把左右叶子节点找到的这个深度优先的特点，来逐层计算二叉树的高度，最后<strong>根节点处的高度就是二叉树的最大深度</strong>。</p>
<h2 id="☆leetcode-111-二叉树的最小深度"><a href="#☆leetcode-111-二叉树的最小深度" class="headerlink" title="☆leetcode 111.二叉树的最小深度"></a>☆leetcode 111.二叉树的最小深度</h2><p><u><strong>题目</strong>：给定一个二叉树，找出其最小深度。</u></p>
<p><u>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</u></p>
<p><u><strong>说明：</strong>叶子节点是指没有子节点的节点。</u></p>
<img src="https://img-blog.csdnimg.cn/20210203155800503.png" alt="111.二叉树的最小深度" style="zoom:33%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//当前节点为空，从下往上数，肯定是0</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> minDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> minDepth(root.right);</span><br><span class="line">        <span class="comment">//root必须同时不包含左右节点才算最小深度</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftDepth + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightDepth + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们必须充分理解叶子节点的含义，所谓叶子节点，是<strong>既不包含左节点也不包含右节点</strong>的，所以我们如果想按照上面求最大深度的方式求解的话，一定要先判断当前的节点是否为叶子节点，所以我们可以对比这两个题，本题明显要多一个判断子节点是否为空的条件。</p>
<h2 id="☆leetcode-222-完全二叉树的节点个数"><a href="#☆leetcode-222-完全二叉树的节点个数" class="headerlink" title="☆leetcode 222.完全二叉树的节点个数"></a>☆leetcode 222.完全二叉树的节点个数</h2><p><u><strong>题目</strong>：给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</u></p>
<p><u>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</u></p>
<img src="https://img-blog.csdnimg.cn/20201124092634138.png" alt="222.完全二叉树的节点个数1" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> getDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> getDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; leftDepth) + countNodes(root.right);<span class="comment">//在这递归</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; rightDepth) + countNodes(root.left);<span class="comment">//在这递归</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="C:\Users\Reex\AppData\Roaming\Typora\typora-user-images\image-20220521152910789.png" alt="image-20220521152910789" style="zoom: 50%;" />

<p>思路如上图所示，首先我们要明白完全二叉树的定义，如果某个节点的左节点不存在那么右节点肯定不存在，如果右节点存在，那么左节点必存在。所以我们只需要<strong>每次遍历一个树的左节点就可以知道该树的高度</strong>，所以有了getDepth()方法。</p>
<p>每个节点下面，以其左右节点作为树的根节点，如果<strong>左右子树的高度一致，那么必然左子树是完全二叉树</strong>，而右子树就不一定了；如果<strong>高度不一致，那么必然右子树比左子树高度低</strong>，就是图中1的左右子树的情况，这个时候，右子树肯定是完全二叉树，而左子树不能确定了，所以计算右子树：以3为根节点的完全二叉树的节点个数2^2 - 1还要加上③的父节点①的个数1，所以是2^2 - 1 + 1 &#x3D; 1 &lt;&lt; 2；不要忘记这个时候要递归了！加完了右子树，左子树还没加呢，所以1 &lt;&lt; 2 + countNodes(root.left)，这也是为什么前面要把根节点①加进来的原因</p>
<p>同理，下面就以2为根节点，比较其左右子树的高度，因为等高，所以左子树必然为完全二叉树，以此类推。</p>
<h2 id="☆leetcode-110-平衡二叉树"><a href="#☆leetcode-110-平衡二叉树" class="headerlink" title="☆leetcode 110.平衡二叉树"></a>☆leetcode 110.平衡二叉树</h2><p><u><strong>题目</strong>：给定一个二叉树，判断它是否是高度平衡的二叉树。</u></p>
<p><u>本题中，一棵高度平衡二叉树定义为：</u></p>
<blockquote>
<p><u>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</u>如下树，返回false</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210203155447919.png" alt="110.平衡二叉树1"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//深度优先遍历，从下向上累计高度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">        <span class="comment">//当前节点的子树不平衡</span></span><br><span class="line">        <span class="keyword">if</span>(leftHeight == -<span class="number">1</span> || rightHeight == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//当前节点左右子树各自平衡，但组合在一起就不平衡了</span></span><br><span class="line">        <span class="keyword">if</span>(Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明以当前节点为根节点所组成的树是平衡的，累加高度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要主要一点：一旦树不平衡了，或者其左右子树不平衡了，直接向上传递不平衡的信息</p>
<h2 id="☆leetcode-257-二叉树的所有路径"><a href="#☆leetcode-257-二叉树的所有路径" class="headerlink" title="☆leetcode 257.二叉树的所有路径"></a>☆leetcode 257.二叉树的所有路径</h2><p><u><strong>题目</strong>：给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</u></p>
<p><u><strong>叶子节点</strong> 是指没有子节点的节点。</u></p>
<img src="https://img-blog.csdnimg.cn/2021020415161576.png" alt="257.二叉树的所有路径1" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        traversal(root, res, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root, List&lt;String&gt; res, List&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">        <span class="comment">//这里要注意，每次进入方法体，首先将当前节点加入到可选路径path中</span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">//说明当前不是叶子节点，继续向下走</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            traversal(root.left, res, path);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明当前不是叶子节点，继续向下走</span></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            traversal(root.right, res, path);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历到叶子节点就可以添加路径了</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; path.size() - <span class="number">1</span>;i++)&#123;</span><br><span class="line">                sb.append(path.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里要注意，最后一次循环后面没有箭头了，所以要单独添加最后一个元素</span></span><br><span class="line">            sb.append(path.get(path.size() - <span class="number">1</span>));</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-404-左叶子之和"><a href="#leetcode-404-左叶子之和" class="headerlink" title="leetcode 404.左叶子之和"></a>leetcode 404.左叶子之和</h2><p><u><strong>题目</strong>：计算给定二叉树的所有左叶子之和。</u></p>
<p><u>注：如果左节点不为空，且左节点没有左右孩子，那么这个节点的左节点就是左叶子</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//深度优先遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSum</span> <span class="operator">=</span> sumOfLeftLeaves(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightSum</span> <span class="operator">=</span> sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果当前节点的左节点不为空，且左节点的左右节点均为空，该左节点记为左叶子，记录该值</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            mid = root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid + leftSum + rightSum; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我的解法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//遍历到左叶子节点，就把sum累加</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            sum += root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切记！不是所有左节点之和，左叶子必须满足其不存在左右子节点才可以。</p>
<h2 id="leetcode-96-不同的二叉搜索树"><a href="#leetcode-96-不同的二叉搜索树" class="headerlink" title="leetcode 96.不同的二叉搜索树"></a>leetcode 96.不同的二叉搜索树</h2><p><u><strong>题目</strong>：给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</u></p>
<img src="https://img-blog.csdnimg.cn/20210113161941835.png" alt="img" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= i;j++)&#123;<span class="comment">//j就是当前遍历的根结点元素值</span></span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];<span class="comment">//以j为根节点的左子树数量dp[j - 1]与右子树数量dp[i - j]的乘积</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题虽然是中等题，代码量也很少，但除非背模板，否则很难写对。本题结合了二叉搜索树和动态规划的知识。</p>
<p>我们最需要理解的就是递推公式，为什么是这个样子的？首先确定dp[i]数组的含义：<strong>i个元素组成的二叉搜索树的数量</strong>。</p>
<p>我们假设当前元素为4，那么其根节点就可以为1，2，3，4。当根节点为1时，左子树没有比它小的，所以其只有右子树，我们会发现右子树的个数就是元素为3时二叉搜索树的个数dp[3]，所以根节点为1时，二叉搜索树的数量为dp[0] * dp[3]。以此类推，根节点为2时，dp[1] * dp[2]，根节点为3，dp[2] * dp[1]，根节点为4，dp[3] * dp[0]，最后的dp[4]就是把这四组乘积相加。</p>
<p>我们不难发现一个规律，不管元素个数是多少，我们都需要让i逐一递增，从1一直增加到i为止，每次增加的过程中，都要来计算<strong>当前值作为根节点</strong>的二叉搜索树的个数，一直加到i为止，把前面的结果加在一起才是当前i个元素的二叉树个数。</p>
<p>就比如前面的dp[4]我们需要dp[3]，dp[3]又需要dp[2]，dp[2]又需要dp[1]，dp[1]需要dp[0]。妥妥的动态规划问题，而dp[0]和dp[1]我们可以很容易的<strong>初始化为1</strong>，所以我们可以让元素个数i从2开始递增，<strong>每次递增都计算当前元素个数下二叉搜索树的数量</strong>，以便下一个i + 1利用。</p>
<p>至于为什么dp[i] +&#x3D; dp[j - 1] * dp[i - j]，j是当前元素作为根节点，dp[j - 1]就是j - 1个元素左子树的二叉搜索树数量，因为<strong>左子树肯定元素值比j要小</strong>，所以是j - 1，而右子树肯定比j元素要大，而<strong>总元素个数又限定在i个以内</strong>，所以右子树元素个数为i - j。</p>
<h2 id="leetcode-112-路径总和"><a href="#leetcode-112-路径总和" class="headerlink" title="leetcode 112.路径总和"></a>leetcode 112.路径总和</h2><p><u><strong>题目</strong>：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</u></p>
<p><u>叶子节点 是指没有子节点的节点。</u></p>
<img src="https://img-blog.csdnimg.cn/2021020316051216.png" alt="112.路径总和" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        targetSum -= root.val;<span class="comment">//这一步很关键，每次递归都需要先减掉当前结点val</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">return</span> <span class="variable">targetSum</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> hasPathSum(root.left, targetSum);</span><br><span class="line">            <span class="comment">//不回溯的原因是向下递归都需要减去当前的root.val，所以为了避免回溯操作targetSum + root.val之后又要在下面的递归中执行targetSum - root.val，所以索性不回溯了。</span></span><br><span class="line">            <span class="keyword">if</span>(left) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> hasPathSum(root.right, targetSum);</span><br><span class="line">            <span class="keyword">if</span>(right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简化：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">return</span> <span class="variable">targetSum</span> <span class="operator">=</span>= root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里要用或，不能用与，很容易出错。</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经典的回溯问题，因为不需要求路径个数，所以回溯好像不明显，因为我们经常会看到path + 1之后，再path - 1。但是这道题看似没有这一步操作，这是因为我们<strong>每次在当前递归中才减掉root.val，对于上一层递归targetSum并无影响</strong>，所以上一层递归仍旧使用的是无删减的targetSum</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> targetSum - root.val == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> hasPathSum(root.left, targetSum - root.val);</span><br><span class="line">    <span class="keyword">if</span>(left) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">    <span class="keyword">if</span>(right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把中间的判断提出来，可以看到这一次是在判断之后才将root.val减掉。</p>
<p>其实这都不影响回溯，只有我们当前传递的targetSum在进入下一层递归之前就减去了某一递归才需要减去的元素，那么我们必须要进行回溯。我们当前的方法因为targetSum只减去了当前的root.val，这是每一个下层递归都需要经历的，就无需进行回溯。</p>
<h2 id="leetcode-113-路径总和-II"><a href="#leetcode-113-路径总和-II" class="headerlink" title="leetcode 113.路径总和 II"></a>leetcode 113.路径总和 II</h2><p><u><strong>题目</strong>：给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</u></p>
<p><u>叶子节点 是指没有子节点的节点。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        traversal(root, path, res, targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">//基本数据类型不需回溯</span></span><br><span class="line">        targetSum -= root.val;</span><br><span class="line">        <span class="comment">//引用数据类型全局唯一，需要回溯</span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为什么要分别判断子节点是否为空？因为先判断在递归，这样才能在回溯的时候有元素可以删。</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            traversal(root.left, path, res, targetSum);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            traversal(root.right, path, res, targetSum);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面就是先判空，再递归+回溯</span></span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">path.add(root.val);</span><br><span class="line"><span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; targetSum - root.val == <span class="number">0</span>) <span class="keyword">return</span> 。。。</span><br><span class="line">traversal(root.left, targetSum - root.val);</span><br><span class="line">path.removeLast();</span><br><span class="line">traversal(root.right, targetSum - root.val);</span><br><span class="line">path.removeLast();</span><br><span class="line"><span class="comment">//以上就会导致，两个traversal方法中的path都没有添加元素，而回溯却平白无故删了俩元素，导致报noSuchElementException</span></span><br></pre></td></tr></table></figure>

<p>我们再来看这道题为什么就需要回溯了？其实targetSum还是和上一题一样，而每次遍历到的节点添加到路径path中，这个变量就需要在递归后回溯。这是为什么？如注释所写，targetSum作为基本数据类型变量，每次递归<strong>都是全新的数值</strong>，只与传入的数值等值。<strong>而path是引用数据类型变量，传入传出始终全局唯一</strong>，所以必须进行回溯。</p>
<h2 id="leetcode-106-从中序与后序遍历序列构造二叉树"><a href="#leetcode-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="leetcode 106.从中序与后序遍历序列构造二叉树"></a>leetcode 106.从中序与后序遍历序列构造二叉树</h2><p><u><strong>题目</strong>：根据一棵树的中序遍历与后序遍历构造二叉树。</u></p>
<p><u>注意: 你可以假设树中没有重复的元素。</u></p>
<p><u>例如，给出</u></p>
<p><u>中序遍历 inorder &#x3D; [9,3,15,20,7] 后序遍历 postorder &#x3D; [9,15,7,20,3] 返回如下的二叉树：</u></p>
<img src="https://img-blog.csdnimg.cn/20210203154249860.png" alt="106.从中序与后序遍历序列构造二叉树" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.length, postorder, <span class="number">0</span>, postorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inLeft, <span class="type">int</span> inRight, <span class="type">int</span>[] postorder, <span class="type">int</span> postLeft, <span class="type">int</span> postRight)</span> &#123;</span><br><span class="line">        <span class="comment">//这里选postorder是一样的</span></span><br><span class="line">        <span class="keyword">if</span>(inRight - inLeft == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里选postorder是一样的</span></span><br><span class="line">        <span class="keyword">if</span>(inRight - inLeft == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[inLeft]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从后序遍历序列找到当前的根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postRight - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//以当前根节点的值rootVal创建当前的根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">//寻找中序序列根节点的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; inRight;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal) &#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = build(inorder, inLeft, rootIndex, postorder, postLeft, postLeft + (rootIndex - inLeft));</span><br><span class="line">        root.right = build(inorder, rootIndex + <span class="number">1</span>, inRight, postorder, postLeft + (rootIndex - inLeft), postRight - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体的思路就是：从每次<strong>从后序遍历序列中寻找根节点</strong>，然后创建当前根节点，再从中序遍历序列中找到根节点的位置，将中序序列从根节点断开，进而对树节点的左右子节点进行递归。</p>
<p>我们注意到如上的递归方式是典型的前序遍历，所以构造的树为从上至下的一颗二叉树。可能会有一个疑问，为什么每次需要返回root呢？我们先来看第一次递归，最后返回的root是给主函数的，这个返回根节点没毛病。再来看第二次递归，我们势必要创建一个根节点，这个根节点便是第一次递归的左子树或右子树的根节点，所以我们第二次递归返回的root是第一次递归的左右子树的根，所以每次我们都需要返回一个当前的根节点，就<strong>是上一次递归的根节点的一棵子树的根</strong>。</p>
<p>所以如果当前序列值不够了，说明这棵树上一次已经递归到叶子节点了，当然也有可能正好为1个了，它是当前唯一的根，当前即为叶子节点。因为中序和后序的序列长度始终一样，所以<strong>判断哪个序列长度都可以</strong>。</p>
<h2 id="leetcode-105-从前序与中序遍历序列构造二叉树"><a href="#leetcode-105-从前序与中序遍历序列构造二叉树" class="headerlink" title="leetcode 105.从前序与中序遍历序列构造二叉树"></a>leetcode 105.从前序与中序遍历序列构造二叉树</h2><p><u><strong>题目</strong>：给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length, inorder, <span class="number">0</span>, inorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preLeft, <span class="type">int</span> preRight, <span class="type">int</span>[] inorder, <span class="type">int</span> inLeft, <span class="type">int</span> inRight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(inRight - inLeft == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(inRight - inLeft == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[inLeft]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preLeft];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; inRight;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal) &#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = build(preorder, preLeft + <span class="number">1</span>, preLeft + <span class="number">1</span> + (rootIndex - inLeft), inorder, inLeft, rootIndex);</span><br><span class="line">        root.right = build(preorder, preLeft + <span class="number">1</span> + (rootIndex - inLeft), preRight, inorder, rootIndex + <span class="number">1</span>, inRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与106题如出一辙，细心一些就可以做对。</p>
<h2 id="leetcode-654-最大二叉树"><a href="#leetcode-654-最大二叉树" class="headerlink" title="leetcode 654.最大二叉树"></a>leetcode 654.最大二叉树</h2><p><u><strong>题目</strong>：给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</u></p>
<p>​	<u>1.创建一个根节点，其值为 nums 中的最大值。</u><br>​	<u>2.递归地在最大值 左边 的 子数组前缀上 构建左子树。</u><br>​	<u>3.递归地在最大值 右边 的 子数组后缀上 构建右子树。</u><br><u>返回 nums 构建的 最大二叉树 。</u></p>
<img src="https://img-blog.csdnimg.cn/20210204154534796.png" alt="654.最大二叉树" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildMax(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildMax</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(right - left == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right - left == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[left]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> <span class="number">0</span>, index = left;</span><br><span class="line">        <span class="comment">//寻找当前范围内的最大值及其下标，注意查找范围，不能从0开始，要从left开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;i &lt; right;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(rootVal &lt; nums[i]) &#123;</span><br><span class="line">                rootVal = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        root.left = buildMax(nums, left, index);</span><br><span class="line">        root.right = buildMax(nums, index + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题比三序遍历构造二叉树容易一些，区别就是<strong>从逐步缩小的区间中寻找最大值</strong>作为当前的根节点，而不像前序和后序遍历可以直接获取根节点的位置。</p>
<h2 id="leetcode-617-合并二叉树"><a href="#leetcode-617-合并二叉树" class="headerlink" title="leetcode 617.合并二叉树"></a>leetcode 617.合并二叉树</h2><p><u><strong>题目</strong>：给你两棵二叉树： root1 和 root2 。</u></p>
<p><u>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</u></p>
<p><u>返回合并后的二叉树。</u></p>
<p><u>注意: 合并过程必须从两个树的根节点开始。</u></p>
<img src="https://img-blog.csdnimg.cn/20210204153634809.png" alt="617.合并二叉树" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        <span class="comment">//一定要new一个新的根节点，不要直接返回节点，因为我们还要为该节点的子节点赋值</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.val + root2.val);</span><br><span class="line">        newRoot.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        newRoot.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">        <span class="keyword">return</span> newRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题比较容易，就记录一下。</p>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="leetcode-700-二叉搜素树中的搜索"><a href="#leetcode-700-二叉搜素树中的搜索" class="headerlink" title="leetcode 700.二叉搜素树中的搜索"></a>leetcode 700.二叉搜素树中的搜索</h2><p><u><strong>题目</strong>：给定<strong>二叉搜索树</strong>（BST）的根节点 root 和一个整数值 val。</u></p>
<p><u>你需要在 BST 中找到节点值等于 val 的节点。 返回<strong>以该节点为根的子树</strong>。 如果节点不存在，则返回 null 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val &lt; val) &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.val &gt; val) &#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="☆leetcode-98-验证二叉搜索树"><a href="#☆leetcode-98-验证二叉搜索树" class="headerlink" title="☆leetcode 98.验证二叉搜索树"></a>☆leetcode 98.验证二叉搜索树</h2><p><u><strong>题目</strong>：给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</u></p>
<p><u>有效二叉搜索树定义如下：</u></p>
<p><u>节点的<strong>左子树</strong>只包含 小于 当前节点的数。</u><br><u>节点的<strong>右子树</strong>只包含 大于 当前节点的数。</u><br><u>所有左子树和右子树自身必须也是二叉搜索树。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//题目数据范围涉及到到Integer的边界值，而我们这里的上下确界都是开区间，所以这里我们要用long型</span></span><br><span class="line">        <span class="keyword">return</span> compare(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode root, <span class="type">long</span> lower, <span class="type">long</span> upper)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次判断的都是当前结点，其条件范围由上一次递归决定。</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= lower || root.val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left, lower, root.val) &amp;&amp; compare(root.right, root.val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历递归法一：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//这个变量是全局的，一定要定义在外面</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//中序遍历第一步向左下找左叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左叶子找完来判断当前根结点与上一个结点的大小</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= cur) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//要更新cur结点值</span></span><br><span class="line">        cur = root.val;</span><br><span class="line">        <span class="comment">//中序遍历第三步</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历递归法二：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.val &gt;= root.val) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个一定要放在if判断外面，因为不管pre是什么，只要走到了这一步，就要把当前root传给pre</span></span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归法：从题意中，我们也可以看出，我们需要判断的是左子树的所有结点是不是都比根节点小，右子树所有节点是不是都比根节点大，所以我们<strong>不能每次仅仅判断当前结点的左右节点与当前结点进行比大小</strong>。</p>
<p>既然遍历到每个结点的时候，都要看它在整个左子树的内是否满足一个条件，我们自然需要在递归的时候，给递归函数确定一个范围，即上确界和下确界。这样我们可以在每次递归一个结点的时候，根据这个<strong>随着递归逐步收缩的区间，来判断当前结点是否符合条件</strong>。</p>
<p>中序遍历法：我们可以发现，二叉搜索树的结点排列顺序和中序遍历的升序顺序一致，也就是说<strong>一棵树如果中序遍历是一个升序数组，那么当前树就是二叉搜索树</strong>。</p>
<p>所以我们可以用中序遍历的递归方法来遍历二叉树的每个结点，不要忘记每次记录当前结点的值，这是为了与下一个结点的值进行比较。</p>
<h2 id="leetcode-530-二叉搜索树的最小绝对差"><a href="#leetcode-530-二叉搜索树的最小绝对差" class="headerlink" title="leetcode 530.二叉搜索树的最小绝对差"></a>leetcode 530.二叉搜索树的最小绝对差</h2><p><u><strong>题目</strong>：给你一个二叉搜索树的根节点 <code>root</code> ，返回 树中<strong>任意</strong>两不同节点值之间的最小差值 。</u></p>
<p><u>差值是一个正数，其数值等于两值之差的绝对值。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//这里有个疑问：为什么ans放入compare形参中，就无法传递了?</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        compare(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compare</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        compare(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != -<span class="number">1</span>) &#123;</span><br><span class="line">            ans = Math.min(ans, root.val - pre);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root.val;</span><br><span class="line">        compare(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题其实我们用中序遍历的递归思想很容易将二叉搜索树转换为升序数组，那么此问题就转变为升序数组中任意两值的最小值了。所以与上一题验证二叉搜索树一样，利用中序遍历的顺序，<strong>不停与上一层元素值进行比较即可</strong>。</p>
<p>由于求最小值，所以我们的ans要默认初始化为最大值。</p>
<p>难点是指针pre的初始化，因为我们无法一下子记录升序数组的头元素，所以我们初始化显得非常重要。这里我们<strong>初始化pre为树中一定不存在的值</strong>，并且在递归过程中进行一个pre的判断即可。</p>
<p>为什么递归的方法时void，因为我们无需对树的结构进行改造，也无需返回任何节点，<strong>只需要对一个与树结构无关的ans进行操作</strong>，所以无返回值。</p>
<h2 id="☆leetcode-501-二叉搜索树中的众数"><a href="#☆leetcode-501-二叉搜索树中的众数" class="headerlink" title="☆leetcode 501.二叉搜索树中的众数"></a>☆leetcode 501.二叉搜索树中的众数</h2><p><u><strong>题目</strong>：给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</u></p>
<p><u>如果树中有不止一个众数，可以按 任意顺序 返回。</u></p>
<p><u>假定 BST 满足如下定义：</u></p>
<p><u>结点左子树中所含节点的值 小于等于 当前节点的值</u><br><u>结点右子树中所含节点的值 大于等于 当前节点的值</u><br><u>左子树和右子树都是二叉搜索树</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   	<span class="comment">//定义全局变量</span></span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> base, count, maxCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//对二叉搜索树进行递归遍历</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ans.size();i++) &#123;</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="comment">//记录众数节点值</span></span><br><span class="line">        update(root.val);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//递归到了等值的结点</span></span><br><span class="line">        <span class="keyword">if</span>(val == base) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//不等值就要更新当前的指针base，并把计数器count置零</span></span><br><span class="line">            base = val;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前结点位置的计数器count等于计数器当前的最大值，则该结点base可能为众数</span></span><br><span class="line">        <span class="keyword">if</span>(count == maxCount) &#123;</span><br><span class="line">            ans.add(base);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count &gt; maxCount) &#123;<span class="comment">//一旦count大于计数器最大值，就清除前面所有记录，添加本节点，并更新计数器最大值</span></span><br><span class="line">            maxCount = count;</span><br><span class="line">            ans.clear();</span><br><span class="line">            ans.add(base);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题主要注意两点，一个是update函数，很容易错，要与全局变量的初始化相对应，比如base，我们定义它的目的是随时记录当前结点的值，那么base可以取的范围是很大的，我们该怎么初始化？因为我们每个结点不管它的值是多少，都要先看看它的数量是多少，所以base不论取多少都可以，因为<strong>它等于当前节点值就让计数器+1，如果不等，就把当前节点值赋给base</strong>，所以base取多少都不影响。对于count，因为我们<strong>每次遍历到一个结点才进行count++或count &#x3D; 1的操作</strong>，所以我们将其初始化为0。对于maxCount，<strong>肯定最小数量是0</strong>，所以初始化为0即可。</p>
<p>另外是主函数findMode的返回值是int[]，要记得将集合转化为数组。</p>
<h2 id="leetcode-236-二叉树的最近公共祖先"><a href="#leetcode-236-二叉树的最近公共祖先" class="headerlink" title="leetcode 236.二叉树的最近公共祖先"></a>leetcode 236.二叉树的最近公共祖先</h2><p><u><strong>题目</strong>：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</u></p>
<p><u>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也<strong>可以是它自己的祖先</strong>）。”</u></p>
<img src="https://img-blog.csdnimg.cn/20201016173414722.png" alt="236. 二叉树的最近公共祖先" style="zoom:50%;" />

<p><u>示例 1: 输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</u></p>
<p><u>示例 2: 输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</u></p>
<p><u>说明:</u></p>
<ul>
<li><u>所有节点的值都是唯一的。</u></li>
<li><u>p、q 为不同节点且均存在于给定的二叉树中。</u></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//一旦遍历到叶子节点或者p、q节点就向上返回，不向下走了</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们需要明确：pq节点<strong>下面的节点没有任何遍历的意义</strong>，所以一旦找到pq就立刻回溯。</p>
<p>在后续遍历的过程中，如果一个节点的左右孩子节点都返回的是空值，且节点本身也不是p或q，那么就继续向上传递空值的信息；一旦左右孩子节点有一个节点返回的不是空值，说明碰到p或q了，<strong>把这个节点继续向上传递</strong>；如果左右孩子节点都不为空，说明当前节点就是这俩节点的最近公共祖先。</p>
<h2 id="leetcode-235-二叉搜索树的最近公共祖先"><a href="#leetcode-235-二叉搜索树的最近公共祖先" class="headerlink" title="leetcode 235.二叉搜索树的最近公共祖先"></a>leetcode 235.二叉搜索树的最近公共祖先</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);<span class="comment">//搜索树的递归方式，不需遍历整棵树</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实二叉搜索树我们就没有必要搜索整棵树了，因为二叉搜索树是有方向的，当前节点与pq的值进行比较后，就可以确定这个方向是哪里。</p>
<p>最重要的一点是：当当前节点的值<strong>正好卡在p、q之间的时候</strong>，其实当前节点就是p、q的最近公共祖先了。</p>
<h2 id="★leetcode-701-二叉搜索树中的插入操作"><a href="#★leetcode-701-二叉搜索树中的插入操作" class="headerlink" title="★leetcode 701.二叉搜索树中的插入操作"></a>★leetcode 701.二叉搜索树中的插入操作</h2><p><u><strong>题目</strong>：给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</u></p>
<p><u>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</u></p>
<p><u>提示：</u></p>
<ul>
<li><u>给定的树上的节点数介于 0 和 10^4 之间</u></li>
<li><u>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</u></li>
<li><u>-10^8 &lt;&#x3D; val &lt;&#x3D; 10^8</u></li>
<li><u>新值和原始二叉搜索树中的任意节点值都不同</u></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//先让指针走到搜索树的叶子节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//每次都要记录以下当前节点，跳出循环的时候，pre正好指向的是叶子节点的位置</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span>(cur.val &lt; val) &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断插入位置在叶子节点的左节点还是右节点</span></span><br><span class="line">        <span class="keyword">if</span>(pre.val &lt; val) &#123;</span><br><span class="line">            pre.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pre.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中我们可以看出，每次递归都是单方向的，结合二叉搜索树的方向性，我们递归最后只会从根节点到需要添加的叶子节点位置画出一道<strong>唯一的路径</strong>，<strong>路径的尾端就是我们插入节点的位置</strong>。</p>
<p>一定要注意：递归法中，每个if判断后，不是return，而是root.left &#x3D;或root.right &#x3D;，要清楚这两个的区别。前者是不要root的另一侧的节点了，而后者因为每次最后要返回root，所以保留了root两侧的节点。</p>
<h2 id="☆leetcode-450-删除二叉搜索树中的节点"><a href="#☆leetcode-450-删除二叉搜索树中的节点" class="headerlink" title="☆leetcode 450.删除二叉搜索树中的节点"></a>☆leetcode 450.删除二叉搜索树中的节点</h2><p><u><strong>题目</strong>：给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</u></p>
<p><u>一般来说，删除节点可分为两个步骤：</u></p>
<p><u>首先找到需要删除的节点；</u><br><u>如果找到了，删除它。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前节点为空，则证明没找到</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//节点值小，向右下走</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; key) &#123;</span><br><span class="line">            root.right = delete(root.right, key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; key) &#123;<span class="comment">//节点值大，向左下走</span></span><br><span class="line">            root.left = delete(root.left, key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//走到这里说明当前节点需要删除</span></span><br><span class="line">            <span class="comment">//删除后，把唯一存在的节点返回即可</span></span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="comment">//该节点既拥有左节点又有右节点</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//创建指针，找到当前节点root的右子树的最左叶子节点</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">            <span class="keyword">while</span>(cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让root的右子树的最左叶子节点的左节点指向root的左子树</span></span><br><span class="line">            cur.left = root.left;</span><br><span class="line">            <span class="comment">//返回root的右节点</span></span><br><span class="line">            <span class="keyword">return</span> root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里针对的是上面两个if没有返回值的情况，构造了root的左右节点，就要返回当前root</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题情况比较多，自顶向下找要删除的节点时，如果碰到的节点值不等于要删除的值，大了向左下走，小了向右下走。</p>
<p>如果当前节点就是要删除的节点，就要看待删除的节点有几个子节点，有一个子节点，就直接把这个子节点返回即可。如果<strong>有俩子节点</strong>，我们就要思考二叉搜索树的特点。当前待删除的root节点，<strong>右子树的任意节点肯定都比root的左子树大</strong>，为了删除root后，不影响二叉搜索树的性质。我们定义一个指针cur，专门用来找到root的右子树的最小节点，也就是右子树的最左叶子节点，然后把root的左子树的根节点，也就是<strong>root.left接到这个最左叶子结点上面</strong>，最后我们把root.right返回即可。</p>
<p>不要忘了最后还要写返回值，因为<strong>当前节点不是待删除节点的时候</strong>，我们只是让root.left和root.right继续向下走，<strong>还没有向上返回</strong>，所以最后要return root。</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbj3k596mg30dq0aigyz.gif" alt="450.删除二叉搜索树中的节点" style="zoom: 67%;" />

<h2 id="☆leetcode-669-修剪二叉搜索树"><a href="#☆leetcode-669-修剪二叉搜索树" class="headerlink" title="☆leetcode 669.修剪二叉搜索树"></a>☆leetcode 669.修剪二叉搜索树</h2><p><u><strong>题目</strong>：给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。</u></p>
<p><u>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历到空节点，直接向上传null，意为告诉上面，到我这就空了</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//遍历到不该属于搜索树的节点，直接向上传可能的部分，意为告诉上面，我不行了，另一分支可能行</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历到属于搜索树的节点，直接向上传本节点root，意为告诉上面，我行，我下面行不行我不确定</span></span><br><span class="line">        root.left = trimBST(root.left, low, high);</span><br><span class="line">        root.right = trimBST(root.right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题其实就是要把原二叉搜索树变为一颗所有值都在[low, high]区间的搜索树。</p>
<p>其实主要的思想就是，每次都查看当前的节点是不是符合[low, high]区间，如果不符合，我们就直接<strong>向上传另一端分支</strong>，因为另一端可能有符合条件的。</p>
<p>如果当前节点符合[low, high]区间，那么就<strong>向上传本节点root</strong>，但是传之前我们<strong>不确定root的子树是不是都符合条件</strong>，所以还要递归下面子节点。</p>
<h2 id="leetcode-108-将有序数组转换为二叉搜索树"><a href="#leetcode-108-将有序数组转换为二叉搜索树" class="headerlink" title="leetcode 108.将有序数组转换为二叉搜索树"></a>leetcode 108.将有序数组转换为二叉搜索树</h2><p><u><strong>题目</strong>：给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</u></p>
<p><u>高度平衡 二叉树是一棵满足[每个节点的左右两个子树的高度差的绝对值不超过 1 ]的二叉树。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> traversal(nums, <span class="number">0</span>, nums.length);<span class="comment">//左闭右开</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">traversal</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//如果区间不存在，那么就向上传null</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(right - left == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[left]);</span><br><span class="line">        <span class="comment">//取中点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = traversal(nums, left, mid);</span><br><span class="line">        root.right = traversal(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到升序数组和二叉搜索树，很容易想到中序遍历，但是本题要求树是平衡的，那么这个方法就不合适了。</p>
<p>当我们每次都选择<strong>以当前数组范围的中点</strong>作为当前根节点，那么我们构造的二叉搜索树自然是平衡的。</p>
<p>取中点的时候，我们要先判断当前区间范围<strong>是否可以取中点</strong>，这里我们选用<strong>左闭右开区间</strong>。</p>
<p>所以我们每次都取当前数组的中位数来作为当前的根节点，即定义一个root，值为这个中位数，然后构造它的左右子节点，因为左右子节点的值我们需要下一次递归才知道，所以我们这里<strong>让root的左右子节点指向递归函数返回值。</strong></p>
<p>最后不要忘了，每次构造完root和它的子节点以后，<strong>要向上返回本节点</strong>。</p>
<h2 id="leetcode-538-把二叉搜索树转换为累加树"><a href="#leetcode-538-把二叉搜索树转换为累加树" class="headerlink" title="leetcode 538.把二叉搜索树转换为累加树"></a>leetcode 538.把二叉搜索树转换为累加树</h2><p><u><strong>题目</strong>：给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</u></p>
<p><u>提醒一下，二叉搜索树满足下列约束条件：</u></p>
<p><u>节点的左子树仅包含键 小于 节点键的节点。</u><br><u>节点的右子树仅包含键 大于 节点键的节点。</u><br><u>左右子树也必须是二叉搜索树。</u></p>
<img src="https://img-blog.csdnimg.cn/20201023160751832.png" alt="538.把二叉搜索树转换为累加树" style="zoom:40%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traversal(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        traversal(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        traversal(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这道题的思路就是将升序数组<strong>从大到小累加</strong>，[1,2,3,4]变为[10,9,7,4]。既然二叉搜索树的右子树的<strong>最右叶子节点是最大的</strong>，那么我们自然要<strong>用反方向的中序遍历</strong>来递归搜索树。</p>
<p>这里容易写错的一点就是将累加的sum带入形参中，这样每次累加的sum都是一个局部变量，我们需要清楚的认定sum是一个全局变化的变量，所以我们<strong>最好将sum定义在方法外</strong>。</p>
<p>因为我们递归时，每次只需要改变当前结点的值，不需要进行增删操作，所以<strong>没必要让递归函数有返回值</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/" data-id="cl39u6yto0000sgv629dfa9fk" data-title="二叉树题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java基础知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2022-05-15T09:03:41.000Z" itemprop="datePublished">2022-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/">Java基础知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><img src="https://javaguide.cn/assets/java-collection-hierarchy.1727461b.png" alt="img"  />

<h2 id="为什么要使用集合？"><a href="#为什么要使用集合？" class="headerlink" title="为什么要使用集合？"></a>为什么要使用集合？</h2><p>数组一旦声明了，长度就不可变；</p>
<p>数组存储数据类型单一，而且有序且可重复的，特点也单一；</p>
<p>集合提高了数据存储的灵活性，不仅可以不同<strong>类型</strong>、不同<strong>数量</strong>，还可以<strong>控制元素重复</strong>，并且保存具有<strong>映射关系</strong>的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  数组转换为类型一致的集合</span></span><br><span class="line">  <span class="type">int</span> [] arr1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">  <span class="comment">//  注意：这里直接传入int [] 的数组，返回的List的泛型参数为 int [],而不是Integer</span></span><br><span class="line">  List&lt;<span class="type">int</span>[]&gt; list1 = Arrays.asList(arr1);</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer [] arr2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//  传入的参数类型为 Integer时，返回泛型参数就是Integer</span></span><br><span class="line">List&lt;Integer&gt; list2 = Arrays.asList(arr2);</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList和LinkedList区别与联系？"><a href="#ArrayList和LinkedList区别与联系？" class="headerlink" title="ArrayList和LinkedList区别与联系？"></a>ArrayList和LinkedList区别与联系？</h2><p>A和L都实现了List接口，他们都是<strong>线程不安全的</strong>；</p>
<p>A底层使用的是<u>Object[]数组</u>，L底层使用的是<u>双向链表</u>；</p>
<p>A在数组中的某个位置<strong>删除，插入</strong>元素都需要让整个数组跟着移动，L虽然不会移动，但是需要先移动到那个位置才能进行插入或删除操作，所以<strong>两者复杂度都较高</strong>，L只有头和尾插入或删除时，时间复杂度时o(1)。</p>
<p><strong>A支持快速随机访问</strong>，因为数组下标。而L不行。</p>
<p>A占内存主要是因为<strong>尾部需要预留空间</strong>，L空间花费更多体现在每个结点要记录的内容。</p>
<p>A好，用A，<strong>能用L的地方都能用A</strong>。</p>
<h2 id="comparable和comparator区别？"><a href="#comparable和comparator区别？" class="headerlink" title="comparable和comparator区别？"></a>comparable和comparator区别？</h2><p>comparable接口是java.lang包下的，接口有comareTo(Object obj)方法</p>
<p>comparator接口时java.util工具包下的，接口中有compare(Object obj1, Object obj2)方法</p>
<h2 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h2><p>JDK 1.7之前，底层是<strong>数组+链表</strong>的形式存储数据的。每次存储都对数据执行扰动函数，得到hash值，如果哈希碰撞，就equals比较，若相等则覆盖，如<strong>不等则拉链法</strong>，即用链表存储。</p>
<p>JDK 1.8之后，底层是<strong>数组+链表+红黑树</strong>。还是用扰动函数，但是<strong>扰动函数有所更新</strong>，减少了哈希碰撞几率，但是如果碰撞还是equals比较，若相等则覆盖，若不等则拉链法，当链表长度大于阈值（默认8），则检查当前数组长度是否大于64，<strong>小于64则扩容数组</strong>（这里需要rehash），大于64则将超过阈值的链表<strong>转化为红黑树</strong>。</p>
<h2 id="HashMap长度为什么是2的幂次方？"><a href="#HashMap长度为什么是2的幂次方？" class="headerlink" title="HashMap长度为什么是2的幂次方？"></a>HashMap长度为什么是2的幂次方？</h2><p><strong>这个还没搞懂</strong></p>
<h2 id="ConcurrentHashMap和Hashtable的区别？"><a href="#ConcurrentHashMap和Hashtable的区别？" class="headerlink" title="ConcurrentHashMap和Hashtable的区别？"></a>ConcurrentHashMap和Hashtable的区别？</h2><p>先说Hashtable，<strong>全表锁</strong>，效率很低</p>
<p>对于<strong>JDK 1.7</strong>的cchashmap，用segment即<strong>分段锁</strong>，只要多个线程没有哈希碰撞到同一个段就没事。</p>
<p><strong>JDK 1.8</strong>以后的cchashmap，<strong>只锁当前的链表或者红黑树的首节点</strong>，只要hash冲突不到数组的同一个节点上，就没事。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="cl39jz0gd00001cv61jgv7ohf" data-title="Java基础知识点" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/01/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">十大排序算法</a>
          </li>
        
          <li>
            <a href="/2022/06/26/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Linux学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/06/24/%E9%93%BE%E8%A1%A8%E9%A2%98%E8%A7%A3/">链表题解</a>
          </li>
        
          <li>
            <a href="/2022/06/20/acm%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/">acm输入输出练习</a>
          </li>
        
          <li>
            <a href="/2022/06/04/%E8%B4%AA%E5%BF%83%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/">贪心系列题解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>