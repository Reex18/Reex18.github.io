<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>计算机网络笔记 | Reex</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="路由器相关知识 MAC头部的作用就是将包传送到路由器，其中的接收方MAC地址，就是路由器端口的MAC地址。所以，当包到达了路由器，MAC头部任务就完成了，MAC头部即被丢弃。 在网络包的传输过程中，源IP和目标IP始终不变，而为了两两设备在以太网中传输，必须实时变化MAC地址。 在发送数据包的时候，如果目标主机不是本地局域网内的主机，那MAC地址填入的是路由器地址，通过路由器的层层转发，一直转发到">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络笔记">
<meta property="og:url" content="http://example.com/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Reex">
<meta property="og:description" content="路由器相关知识 MAC头部的作用就是将包传送到路由器，其中的接收方MAC地址，就是路由器端口的MAC地址。所以，当包到达了路由器，MAC头部任务就完成了，MAC头部即被丢弃。 在网络包的传输过程中，源IP和目标IP始终不变，而为了两两设备在以太网中传输，必须实时变化MAC地址。 在发送数据包的时候，如果目标主机不是本地局域网内的主机，那MAC地址填入的是路由器地址，通过路由器的层层转发，一直转发到">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/18.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/30.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/37.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/41.jpg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzIzLmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzI2LmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzMwLmpwZw?x-oss-process=image/format,png">
<meta property="article:published_time" content="2022-05-13T06:38:33.000Z">
<meta property="article:modified_time" content="2022-05-22T06:53:59.999Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png">
  
    <link rel="alternate" href="/atom.xml" title="Reex" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Reex</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-计算机网络笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-05-13T06:38:33.000Z" itemprop="datePublished">2022-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      计算机网络笔记
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="路由器相关知识"><a href="#路由器相关知识" class="headerlink" title="路由器相关知识"></a>路由器相关知识</h2><ol>
<li>MAC头部的作用就是<strong>将包传送到路由器</strong>，其中的接收方MAC地址，就是路由器端口的MAC地址。所以，当包到达了路由器，MAC头部任务就完成了，<strong>MAC头部即被丢弃</strong>。</li>
<li>在网络包的传输过程中，<strong>源IP和目标IP始终不变</strong>，而为了两两设备在以太网中传输，必须<strong>实时变化MAC地址</strong>。</li>
<li>在发送数据包的时候，<strong>如果目标主机不是本地局域网内的主机，那MAC地址填入的是路由器地址</strong>，通过路由器的层层转发，<strong>一直转发到目标主机的路由器</strong>，发现IP地址是自己局域网内的主机，就会通过ARP请求<strong>获取目标主机的MAC地址</strong>，进而转发到这个服务器主机。</li>
</ol>
<h2 id="GET和POST区别？"><a href="#GET和POST区别？" class="headerlink" title="GET和POST区别？"></a>GET和POST区别？</h2><p>GET请求的参数一般<strong>写在URL中</strong>，URL规定<strong>只能支持ASCII</strong>，虽然HTTP协议并没有限制URL长度，但是<strong>浏览器自身会对URL长度有限制</strong>。</p>
<p>POST请求的参数一般<strong>放在请求报文（body）中</strong>，body参数<strong>没有格式限制</strong>，只要浏览器和服务器都可接受即可，而且body参数的<strong>长度没有限制</strong>。</p>
<h2 id="HTTPS和HTTP"><a href="#HTTPS和HTTP" class="headerlink" title="HTTPS和HTTP"></a>HTTPS和HTTP</h2><p>前者就是在HTTP的基础上，在TCP和HTTP之间添加了一层SSL&#x2F;TLS安全协议，使得报文能够加密传输。</p>
<p>所以HTTPS不仅要进行TCP的三次握手，还要接着进行SSL&#x2F;TLS握手判断，才可以加密传输报文。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png" alt="HTTP 与 HTTPS 网络层"  />

<h2 id="HTTP对应OSI模型哪几层？"><a href="#HTTP对应OSI模型哪几层？" class="headerlink" title="HTTP对应OSI模型哪几层？"></a>HTTP对应OSI模型哪几层？</h2><p>用来管理通信连接的会话层，转换数据格式的表示层，与对端主机交互的应用层。</p>
<h2 id="应用层各大常见协议"><a href="#应用层各大常见协议" class="headerlink" title="应用层各大常见协议"></a>应用层各大常见协议</h2><h3 id="1-TELNET：远程登陆协议"><a href="#1-TELNET：远程登陆协议" class="headerlink" title="1. TELNET：远程登陆协议"></a>1. TELNET：远程登陆协议</h3><p>建立在TCP协议之上，通过一个终端登录到其他远端的服务器。<strong>最大缺点：明文传输</strong>，所以有了SSH</p>
<h3 id="2-SSH（Secure-Shell）：安全的网络传输协议"><a href="#2-SSH（Secure-Shell）：安全的网络传输协议" class="headerlink" title="2. SSH（Secure Shell）：安全的网络传输协议"></a>2. SSH（Secure Shell）：安全的网络传输协议</h3><p>有效防止远程管理过程中的信息泄露，加密传输，也是建立在TCP协议之上的。</p>
<h3 id="3-FTP：文件传输协议"><a href="#3-FTP：文件传输协议" class="headerlink" title="3. FTP：文件传输协议"></a>3. FTP：文件传输协议</h3><p>FTP是在两个“相连”的计算机之间进行文件传输的协议</p>
<p>最大特点：<strong>两条TCP连接</strong>，一条用于<strong>传送控制信息</strong>，比如：登录验证，发送文件的名称，发送方式部署等；另一条用于<strong>专门传输数据</strong>。</p>
<h3 id="4-SMTP（Simple-Mail-Transfer-Protocol）：简单邮件传输-发送-协议"><a href="#4-SMTP（Simple-Mail-Transfer-Protocol）：简单邮件传输-发送-协议" class="headerlink" title="4. SMTP（Simple Mail Transfer Protocol）：简单邮件传输(发送)协议"></a>4. SMTP（Simple Mail Transfer Protocol）：简单邮件传输(发送)协议</h3><p><strong>用来发送</strong>邮件的协议，<strong>只支持发送端主机行为</strong>，所以不会根据接收端的请求发送，而是根据发送端请求进行发送。</p>
<p>虽然建立在TCP协议上保证了传输的可靠性，但内容不能保证可靠，因为没有身份验证功能。所以现在规定“POP before SMTP”或者“SMTP认证”。</p>
<p>以前的邮件发送需要两端都要保持插电，很不友好，现在是<strong>一端发给服务器A，A发给服务器B，另一端从B接收</strong>。</p>
<h3 id="5-POP（Post-Office-Protocol）：邮局协议"><a href="#5-POP（Post-Office-Protocol）：邮局协议" class="headerlink" title="5. POP（Post Office Protocol）：邮局协议"></a>5. POP（Post Office Protocol）：邮局协议</h3><p><strong>用来接收</strong>邮件的协议，前面发送端的邮件通过SMTP<strong>发送给一直插电的POP服务器</strong>，接收端再根据POP从POP服务器把邮件“拿过来”。</p>
<p>注意：POP就有<strong>用户验证</strong>喽！</p>
<h3 id="6-IMAP（Internet-Message-Access-Protocol）：交互邮件访问协议"><a href="#6-IMAP（Internet-Message-Access-Protocol）：交互邮件访问协议" class="headerlink" title="6. IMAP（Internet Message Access Protocol）：交互邮件访问协议"></a>6. IMAP（Internet Message Access Protocol）：交互邮件访问协议</h3><p>与POP区别就是，POP是客户端管理邮件，而IMAP是<strong>服务器管理邮件</strong>。</p>
<p>这带来了极大的方便：比如我电脑已读某个邮件，那么手机也显示我读了，因为我是<strong>在一致的服务器处理</strong>了MIME信息。所以可以<strong>实现多终端同步的效果</strong>。</p>
<h2 id="电子邮箱发送过程？"><a href="#电子邮箱发送过程？" class="headerlink" title="电子邮箱发送过程？"></a>电子邮箱发送过程？</h2><p>比如一个163邮箱向一个QQ邮箱发邮件：</p>
<p>1）通过SMTP，163邮箱将邮件发给163邮箱服务器</p>
<p>2）163服务器发给QQ服务器</p>
<p>3）QQ服务器通知该QQ邮箱来取邮件，要通过POP&#x2F;IMAP取</p>
<h2 id="如何判断邮箱真正存在？"><a href="#如何判断邮箱真正存在？" class="headerlink" title="如何判断邮箱真正存在？"></a>如何判断邮箱真正存在？</h2><p>1）通过邮箱域名查找到对应的SMTP服务器地址（你家在哪？）</p>
<p>2）尝试与该服务器建立连接（找到你家）</p>
<p>3）服务器尝试向该邮箱发送邮件（你家给你打电话）</p>
<p>4）根据该邮箱返回结果判断真假（听听是自己儿子声音不）</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>首先，<strong>IP是面向无连接的</strong>，它尽管去传输，面向连接要交给它的上层TCP。</p>
<p>一开始分为ABCDE五类，都具有两个部分：网络号和主机号。其中D类用于多播（广播无法穿透路由，所有有了多播），E还没用</p>
<p>缺点：ABC所包含的主机数相差太大，不符合实际应用。</p>
<h3 id="无分类地址CIDR"><a href="#无分类地址CIDR" class="headerlink" title="无分类地址CIDR"></a>无分类地址CIDR</h3><p>所以有了无分类地址的CIDR：灵活分配网络号和主机号（32拆成两大部分）。这里有子网掩码的概念，<strong>掩码的意思是掩盖掉主机号。将子网掩码和IP地址按位计算AND，就可以得到网络号</strong>。</p>
<p>分离网络号和主机号的目的就是：同一个网络就直接本地传输了，不同网络我们再去通过路由向外传输。</p>
<p>下面是子网划分的示意图（<u>还没搞懂它的意义</u>）：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/18.jpg" alt="img"></p>
<h3 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h3><p>其实就是主机向另一个主机传输，如果需要跨网，就要通过路由器来路由。</p>
<p>注意：<strong>环回地址</strong>是特殊的IP地址，为127.0.0.1。localhost和它意义一样，使用这俩时，<strong>数据包不会流向网络</strong>。</p>
<h3 id="IP分片与重组"><a href="#IP分片与重组" class="headerlink" title="IP分片与重组"></a>IP分片与重组</h3><p>因为IP传输过程中，数据包要通过数据链路传输，所以要根据数据链路的最大传输单元MTU来对IP分片。</p>
<p>需要注意的时：<strong>IP在路由器上不会重组，只会在目标主机才重组</strong>。</p>
<h3 id="IPv6与IPv4"><a href="#IPv6与IPv4" class="headerlink" title="IPv6与IPv4"></a>IPv6与IPv4</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/30.jpg" alt=" IPv6 中的单播通信" style="zoom:50%;" />

<p>6比4多加了个<strong>链路本地单播地址</strong>，用于不走路由器的本数据链路传播。其他的像v6的<strong>唯一本地地址</strong>相当于v4的私有IP，v6的<strong>全局单播地址</strong>相当于v4的共有IP。</p>
<h4 id="IPv6相比IPv4的首部改进："><a href="#IPv6相比IPv4的首部改进：" class="headerlink" title="IPv6相比IPv4的首部改进："></a>IPv6相比IPv4的首部改进：</h4><p>1）<strong>取消首部校验和字段</strong>：因为数据链路层和传输层都要校验，所以v6直接取消了IP校验</p>
<p>2）<strong>取消分片&#x2F;重新组装相关字段</strong>：中间路由器不准分片和重组了</p>
<p>3）<strong>取消选项字段</strong></p>
<h2 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>解析域名的</p>
<h3 id="ARP（有缓存）"><a href="#ARP（有缓存）" class="headerlink" title="ARP（有缓存）"></a>ARP（有缓存）</h3><p>根据IP地址查询MAC地址的，主机A想找主机B的IP对应的MAC地址，就要先<strong>在同一数据链路下进行广播</strong>发送一个ARP请求包，包内<strong>包含了主机B的IP地址</strong>。</p>
<p>RARP就是通过MAC获取IP，一般在无法通过DHCP获取IP的情况下应用到。</p>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>1）DHCP客户端也就是没有IP地址的客户端<strong>发送DHCP发现报文</strong>（DHCP DISCOVER），在数据链路中以<strong>广播</strong>形式发送；</p>
<p>2）DHCP服务器收到后向客户端响应（还是广播），发送的是<strong>DHCP提供报文</strong>（DHCP OFFER），报文包括：可租约的IP地址，子网掩码，默认网关，DNS服务器以及<strong>IP地址租用期</strong>。</p>
<p>3）客户端可能收到多个DHCP发来的报文，选一个并向该服务器发送<strong>DHCP请求报文</strong>（DHCP REQUEST）</p>
<p>4）服务器发送DHCP响应报文（<strong>DHCP ACK</strong>），应答所要求的参数。</p>
<p>5）如果<strong>IP快到期</strong>了，客户端继续向服务器发送DHCP请求报文来申请。</p>
<p>DHCP交互中，<strong>全程都是UDP广播通信</strong>，为了解决不在同一个局域网的通信，出现了<strong>DHCP中继代理</strong>，相当于以前政府直接交涉，现在交给小区居委会代理，居委会负责找政府要IP。（链路广播，中继单播）</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/37.jpg" alt=" DHCP 中继代理" style="zoom:50%;" />

<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>把私有IP转换为公有IP，如果不加点什么这个好像没啥用，所以有了NAPT</p>
<p>NAPT就是<strong>将私有IP转换为IP地址＋端口号</strong>，这正是利用了网络传输需要使用传输层协议的特点。</p>
<p>每次转换都是在NAPT路由器上生成一张转换表，TCP首次握手发出SYN包的时候就<strong>生成了这个表</strong>，关闭连接时候FIN包发送的时候<strong>表就删掉了</strong>。</p>
<p>NAT&#x2F;NAPT依赖自己的转换表，带来的以下不足：</p>
<p>1）外部无法与NAT内部服务器建立连接（不懂）</p>
<p>2）转换表的生成和转换操作有性能开销</p>
<p>3）NAT路由器一旦重启，所有TCP连接都要重置</p>
<p>如何解决：</p>
<p>1）改用IPv6。</p>
<p>2）NAT穿透技术：就是客户端<strong>主动从NAT设备获取共有IP地址</strong>，然后<strong>自己建立端口映射条目</strong>，不用NAT来建立了。</p>
<h2 id="ICMP（Internet-Control-Message-Protocol）"><a href="#ICMP（Internet-Control-Message-Protocol）" class="headerlink" title="ICMP（Internet Control Message Protocol）"></a>ICMP（Internet Control Message Protocol）</h2><p>用来确认IP包是否成功发送到目标地址，报告IP被遗弃的原因，报告改善网络设置等。包括两类（橘色和黄色），如下：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/41.jpg" alt="常见的 ICMP 类型" style="zoom:33%;" />

<h3 id="IGMP（不懂）"><a href="#IGMP（不懂）" class="headerlink" title="IGMP（不懂）"></a>IGMP（不懂）</h3><p>组播地址不是IP地址，一般用于UDP协议</p>
<h2 id="TCP三次握手与四次挥手"><a href="#TCP三次握手与四次挥手" class="headerlink" title="TCP三次握手与四次挥手"></a>TCP三次握手与四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第三次握手<strong>可以携带数据</strong>，前两次握手不可携带数据。</p>
<p><u>三次握手意义</u>：阻止重复历史连接的初始化（<strong>主要意义</strong>），同步双方初始序列号，避免资源浪费。</p>
<p>每次<u>初始化序列号不一样的意义</u>：很大程度避免<strong>历史报文被下一个相同四元组的连接接收</strong>。</p>
<p>MTU和MSS的区别如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzIzLmpwZw?x-oss-process=image/format,png" alt="MTU 与 MSS"></p>
<p>为什么TCP的整个报文（头部+数据）不交给IP分片？</p>
<p>因为IP分片丢失，整个IP报文的<strong>所有分片都需要重传</strong>（IP层无响应，无超时重传机制）。</p>
<p>而TCP以MSS为单位分片后，某个TCP分片丢失，也是<strong>以MSS为单位重发</strong>的，重传效率大大增加。</p>
<p><u>第一次握手丢失</u>：<strong>超时重传</strong>（默认逐次等1s, 2s, 4s, 16s, 32s），32s后仍没回应，不传了，直接断开TCP连接</p>
<p><u>第二次握手丢失</u>：客户端没收到ACK，触发超时重传，<strong>重传SYN报文</strong>；服务端没收到客户端的ACK（第三次握手），触发超时重传，<strong>重传SYN-ACK报文</strong>。</p>
<p><u>第三次握手丢失</u>：服务端<strong>重传SYN-ACK报文</strong>。</p>
<p>Linux半连接队列（SYN队列）和全连接队列（Accept队列）：</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzI2LmpwZw?x-oss-process=image/format,png" alt="正常流程" style="zoom:50%;" />

<h3 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h3><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzMwLmpwZw?x-oss-process=image/format,png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom:50%;" />

<p><u>第一次挥手丢失</u>：客户端重传FIN报文，超过一定次数，直接进入close状态；</p>
<p><u>第二次挥手丢失</u>：因为<strong>ACK报文不会重传</strong>，所以还是客户端重传FIN报文，直到超过最大重传次数；</p>
<p><u>第三次挥手丢失</u>：服务端重发FIN报文，与客户端机制一样；</p>
<p><u>第四次挥手丢失</u>：服务端重发FIN报文。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" data-id="cl34efpty00001cv6d0asee9e" data-title="计算机网络笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/05/13/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          我的项目
        
      </div>
    </a>
  
  
    <a href="/2022/05/13/%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E8%A7%A3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">操作字符串题解</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/">二叉树题解</a>
          </li>
        
          <li>
            <a href="/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/">Java基础知识点</a>
          </li>
        
          <li>
            <a href="/2022/05/14/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E9%A2%98%E8%A7%A3/">栈与队列题解</a>
          </li>
        
          <li>
            <a href="/2022/05/13/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/">我的项目</a>
          </li>
        
          <li>
            <a href="/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/">计算机网络笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>