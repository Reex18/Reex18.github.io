<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>计算机网络笔记 | Reex</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="路由器相关知识 MAC头部的作用就是将包传送到路由器，其中的接收方MAC地址，就是路由器端口的MAC地址。所以，当包到达了路由器，MAC头部任务就完成了，MAC头部即被丢弃。 在网络包的传输过程中，源IP和目标IP始终不变，而为了两两设备在以太网中传输，必须实时变化MAC地址。 在发送数据包的时候，如果目标主机不是本地局域网内的主机，那MAC地址填入的是路由器地址，通过路由器的层层转发，一直转发到">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络笔记">
<meta property="og:url" content="http://example.com/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Reex">
<meta property="og:description" content="路由器相关知识 MAC头部的作用就是将包传送到路由器，其中的接收方MAC地址，就是路由器端口的MAC地址。所以，当包到达了路由器，MAC头部任务就完成了，MAC头部即被丢弃。 在网络包的传输过程中，源IP和目标IP始终不变，而为了两两设备在以太网中传输，必须实时变化MAC地址。 在发送数据包的时候，如果目标主机不是本地局域网内的主机，那MAC地址填入的是路由器地址，通过路由器的层层转发，一直转发到">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/18.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/30.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/37.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/41.jpg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzYuanBn?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEyLmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEzLmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzIzLmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzI2LmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzMwLmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/8.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/11.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/19.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/24.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/25.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/27.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/28.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="article:published_time" content="2022-05-13T06:38:33.000Z">
<meta property="article:modified_time" content="2022-06-11T02:51:08.848Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png">
  
    <link rel="alternate" href="/atom.xml" title="Reex" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Reex</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-计算机网络笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-05-13T06:38:33.000Z" itemprop="datePublished">2022-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      计算机网络笔记
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="路由器相关知识"><a href="#路由器相关知识" class="headerlink" title="路由器相关知识"></a>路由器相关知识</h2><ol>
<li>MAC头部的作用就是<strong>将包传送到路由器</strong>，其中的接收方MAC地址，就是路由器端口的MAC地址。所以，当包到达了路由器，MAC头部任务就完成了，<strong>MAC头部即被丢弃</strong>。</li>
<li>在网络包的传输过程中，<strong>源IP和目标IP始终不变</strong>，而为了两两设备在以太网中传输，必须<strong>实时变化MAC地址</strong>。</li>
<li>在发送数据包的时候，<strong>如果目标主机不是本地局域网内的主机，那MAC地址填入的是路由器地址</strong>，通过路由器的层层转发，<strong>一直转发到目标主机的路由器</strong>，发现IP地址是自己局域网内的主机，就会通过ARP请求<strong>获取目标主机的MAC地址</strong>，进而转发到这个服务器主机。</li>
</ol>
<h2 id="GET和POST区别？"><a href="#GET和POST区别？" class="headerlink" title="GET和POST区别？"></a>GET和POST区别？</h2><p>GET请求的参数一般<strong>写在URL中</strong>，URL规定<strong>只能支持ASCII</strong>，虽然HTTP协议并没有限制URL长度，但是<strong>浏览器自身会对URL长度有限制</strong>。</p>
<p>POST请求的参数一般<strong>放在请求报文（body）中</strong>，body参数<strong>没有格式限制</strong>，只要浏览器和服务器都可接受就行，而且body参数的<strong>长度没有限制</strong>。</p>
<h2 id="HTTPS和HTTP"><a href="#HTTPS和HTTP" class="headerlink" title="HTTPS和HTTP"></a>HTTPS和HTTP</h2><p>前者就是在HTTP的基础上，在TCP和HTTP之间添加了一层SSL&#x2F;TLS安全协议，使得报文能够加密传输。</p>
<p>所以HTTPS不仅要进行TCP的三次握手，还要接着进行SSL&#x2F;TLS握手判断，才可以加密传输报文。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png" alt="HTTP 与 HTTPS 网络层"  />

<h2 id="HTTP对应OSI模型哪几层？"><a href="#HTTP对应OSI模型哪几层？" class="headerlink" title="HTTP对应OSI模型哪几层？"></a>HTTP对应OSI模型哪几层？</h2><p>用来管理通信连接的<strong>会话层</strong>，转换数据格式的<strong>表示层</strong>，与对端主机交互的<strong>应用层</strong>。</p>
<h2 id="应用层各大常见协议"><a href="#应用层各大常见协议" class="headerlink" title="应用层各大常见协议"></a>应用层各大常见协议</h2><h3 id="1-TELNET：远程登陆协议"><a href="#1-TELNET：远程登陆协议" class="headerlink" title="1. TELNET：远程登陆协议"></a>1. TELNET：远程登陆协议</h3><p>建立在TCP协议之上，通过一个终端登录到其他远端的服务器。<strong>最大缺点：明文传输</strong>，所以有了SSH</p>
<h3 id="2-SSH（Secure-Shell）：安全的网络传输协议"><a href="#2-SSH（Secure-Shell）：安全的网络传输协议" class="headerlink" title="2. SSH（Secure Shell）：安全的网络传输协议"></a>2. SSH（Secure Shell）：安全的网络传输协议</h3><p>有效防止远程管理过程中的信息泄露，加密传输，也是建立在TCP协议之上的。</p>
<h3 id="3-FTP：文件传输协议"><a href="#3-FTP：文件传输协议" class="headerlink" title="3. FTP：文件传输协议"></a>3. FTP：文件传输协议</h3><p>FTP是在两个“相连”的计算机之间进行文件传输的协议</p>
<p>最大特点：<strong>两条TCP连接</strong>，一条用于<strong>传送控制信息</strong>，比如：登录验证，发送文件的名称，发送方式部署等；另一条用于<strong>专门传输数据</strong>。</p>
<h3 id="4-SMTP（Simple-Mail-Transfer-Protocol）：简单邮件传输-发送-协议"><a href="#4-SMTP（Simple-Mail-Transfer-Protocol）：简单邮件传输-发送-协议" class="headerlink" title="4. SMTP（Simple Mail Transfer Protocol）：简单邮件传输(发送)协议"></a>4. SMTP（Simple Mail Transfer Protocol）：简单邮件传输(发送)协议</h3><p><strong>用来发送</strong>邮件的协议，<strong>只支持发送端主机行为</strong>，所以不会根据接收端的请求发送，而是根据发送端请求进行发送。</p>
<p>虽然建立在TCP协议上保证了传输的可靠性，但内容不能保证可靠，因为没有身份验证功能。所以现在规定“POP before SMTP”或者“SMTP认证”。</p>
<p>以前的邮件发送需要两端都要保持插电，很不友好，现在是<strong>一端发给服务器A，A发给服务器B，另一端从B接收</strong>。</p>
<h3 id="5-POP（Post-Office-Protocol）：邮局协议"><a href="#5-POP（Post-Office-Protocol）：邮局协议" class="headerlink" title="5. POP（Post Office Protocol）：邮局协议"></a>5. POP（Post Office Protocol）：邮局协议</h3><p><strong>用来接收</strong>邮件的协议，前面发送端的邮件通过SMTP<strong>发送给一直插电的POP服务器</strong>，接收端再根据POP从POP服务器把邮件“拿过来”。</p>
<p>注意：POP就有<strong>用户验证</strong>喽！</p>
<h3 id="6-IMAP（Internet-Message-Access-Protocol）：交互邮件访问协议"><a href="#6-IMAP（Internet-Message-Access-Protocol）：交互邮件访问协议" class="headerlink" title="6. IMAP（Internet Message Access Protocol）：交互邮件访问协议"></a>6. IMAP（Internet Message Access Protocol）：交互邮件访问协议</h3><p>与POP区别就是，POP是客户端管理邮件，而IMAP是<strong>服务器管理邮件</strong>。</p>
<p>这带来了极大的方便：比如我电脑已读某个邮件，那么手机也显示我读了，因为我是<strong>在一致的服务器处理</strong>了MIME信息。所以可以<strong>实现多终端同步的效果</strong>。</p>
<h2 id="电子邮箱发送过程？"><a href="#电子邮箱发送过程？" class="headerlink" title="电子邮箱发送过程？"></a>电子邮箱发送过程？</h2><p>比如一个163邮箱向一个QQ邮箱发邮件：</p>
<p>1）通过SMTP，163邮箱将邮件发给163邮箱服务器</p>
<p>2）163服务器发给QQ服务器</p>
<p>3）QQ服务器通知该QQ邮箱来取邮件，要通过POP&#x2F;IMAP取</p>
<h2 id="如何判断邮箱真正存在？"><a href="#如何判断邮箱真正存在？" class="headerlink" title="如何判断邮箱真正存在？"></a>如何判断邮箱真正存在？</h2><p>1）通过邮箱域名查找到对应的SMTP服务器地址（你家在哪？）</p>
<p>2）尝试与该服务器建立连接（找到你家）</p>
<p>3）服务器尝试向该邮箱发送邮件（你家给你打电话）</p>
<p>4）根据该邮箱返回结果判断真假（听听是自己儿子声音不）</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>首先，<strong>IP是面向无连接的</strong>，它尽管去传输，面向连接要交给它的上层TCP。</p>
<p>一开始分为ABCDE五类，都具有两个部分：网络号和主机号。其中D类用于多播（广播无法穿透路由，所以有了多播），E还没用</p>
<p>缺点：ABC所包含的主机数相差太大，不符合实际应用。</p>
<h3 id="无类别域间路由CIDR-Classless-Inter-Domain-Routing"><a href="#无类别域间路由CIDR-Classless-Inter-Domain-Routing" class="headerlink" title="无类别域间路由CIDR(Classless Inter-Domain Routing)"></a>无类别域间路由CIDR(Classless Inter-Domain Routing)</h3><p>所以有了无分类地址的CIDR：灵活分配网络号和主机号（32拆成两大部分）。这里有子网掩码的概念，<strong>掩码的意思是掩盖掉主机号。将子网掩码和IP地址按位计算AND，就可以得到网络号</strong>。</p>
<p>分离网络号和主机号的目的就是：同一个网络就<strong>直接本地传输</strong>了，不同网络我们再去通过路由向外传输。</p>
<p>下面是子网划分的示意图（<u>还没搞懂它的意义</u>）：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/18.jpg" alt="img"></p>
<h3 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h3><p>其实就是主机向另一个主机传输，如果需要跨网，就要通过路由器来路由。</p>
<p>注意：<strong>环回地址</strong>是特殊的IP地址，为127.0.0.1。localhost和它意义一样，使用这俩时，<strong>数据包不会流向网络</strong>。</p>
<h3 id="IP分片与重组"><a href="#IP分片与重组" class="headerlink" title="IP分片与重组"></a>IP分片与重组</h3><p>因为IP传输过程中，数据包要通过数据链路传输，所以要根据数据链路的最大传输单元MTU来对IP分片。</p>
<p>需要注意的时：<strong>IP在路由器上不会重组，只会在目标主机才重组</strong>。</p>
<h3 id="IPv6与IPv4"><a href="#IPv6与IPv4" class="headerlink" title="IPv6与IPv4"></a>IPv6与IPv4</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/30.jpg" alt=" IPv6 中的单播通信" style="zoom:50%;" />

<p>6比4多加了个<strong>链路本地单播地址</strong>，用于不走路由器的本数据链路传播。其他的像v6的<strong>唯一本地地址</strong>相当于v4的私有IP，v6的<strong>全局单播地址</strong>相当于v4的共有IP。</p>
<h4 id="IPv6相比IPv4的首部改进："><a href="#IPv6相比IPv4的首部改进：" class="headerlink" title="IPv6相比IPv4的首部改进："></a>IPv6相比IPv4的首部改进：</h4><p>1）<strong>取消首部校验和字段</strong>：因为数据链路层和传输层都要校验，所以v6直接取消了IP校验</p>
<p>2）<strong>取消分片&#x2F;重新组装相关字段</strong>：中间路由器不准分片和重组了</p>
<p>3）<strong>取消选项字段</strong></p>
<h2 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>解析域名的</p>
<h3 id="ARP（有缓存）"><a href="#ARP（有缓存）" class="headerlink" title="ARP（有缓存）"></a>ARP（有缓存）</h3><p>根据IP地址查询MAC地址的，主机A想找主机B的IP对应的MAC地址，就要先<strong>在同一数据链路下进行广播</strong>发送一个ARP请求包，包内<strong>包含了主机B的IP地址</strong>。</p>
<p>RARP就是通过MAC获取IP，一般在无法通过DHCP获取IP的情况下应用到。</p>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>1）DHCP客户端也就是没有IP地址的客户端<strong>发送DHCP发现报文</strong>（DHCP DISCOVER），在数据链路中以<strong>广播</strong>形式发送；</p>
<p>2）DHCP服务器收到后向客户端响应（还是广播），发送的是<strong>DHCP提供报文</strong>（DHCP OFFER），报文包括：可租约的IP地址，子网掩码，默认网关，DNS服务器以及<strong>IP地址租用期</strong>。</p>
<p>3）客户端可能收到多个DHCP发来的报文，选一个并向该服务器发送<strong>DHCP请求报文</strong>（DHCP REQUEST）</p>
<p>4）服务器发送DHCP响应报文（<strong>DHCP ACK</strong>），应答所要求的参数。</p>
<p>5）如果<strong>IP快到期</strong>了，客户端继续向服务器发送DHCP请求报文来申请。</p>
<p>DHCP交互中，<strong>全程都是UDP广播通信</strong>，为了解决不在同一个局域网的通信，出现了<strong>DHCP中继代理</strong>，相当于以前政府直接交涉，现在交给小区居委会代理，居委会负责找政府要IP。（链路广播，中继单播）</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/37.jpg" alt=" DHCP 中继代理" style="zoom:50%;" />

<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>把私有IP转换为公有IP，如果不加点什么这个好像没啥用，所以有了NAPT</p>
<p>NAPT就是<strong>将私有IP转换为IP地址＋端口号</strong>，这正是利用了网络传输需要使用传输层协议的特点。</p>
<p>每次转换都是在NAPT路由器上生成一张转换表，TCP首次握手发出SYN包的时候就<strong>生成了这个表</strong>，关闭连接时候FIN包发送的时候<strong>表就删掉了</strong>。</p>
<p>NAT&#x2F;NAPT依赖自己的转换表，带来的以下不足：</p>
<p>1）外部无法与NAT内部服务器建立连接（不懂）</p>
<p>2）转换表的生成和转换操作有性能开销</p>
<p>3）NAT路由器一旦重启，所有TCP连接都要重置</p>
<p>如何解决：</p>
<p>1）改用IPv6。</p>
<p>2）NAT穿透技术：就是客户端<strong>主动从NAT设备获取共有IP地址</strong>，然后<strong>自己建立端口映射条目</strong>，不用NAT来建立了。</p>
<h2 id="ICMP（Internet-Control-Message-Protocol）"><a href="#ICMP（Internet-Control-Message-Protocol）" class="headerlink" title="ICMP（Internet Control Message Protocol）"></a>ICMP（Internet Control Message Protocol）</h2><p>用来确认IP包是否成功发送到目标地址，报告IP被遗弃的原因，报告改善网络设置等。包括两类（橘色和黄色），如下：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/41.jpg" alt="常见的 ICMP 类型" style="zoom:33%;" />

<h3 id="IGMP（不懂）"><a href="#IGMP（不懂）" class="headerlink" title="IGMP（不懂）"></a>IGMP（不懂）</h3><p>组播地址不是IP地址，一般用于UDP协议</p>
<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzYuanBn?x-oss-process=image/format,png" alt="TCP 头格式" style="zoom: 40%;" />

<p>TCP四元组（源地址、源端口、目标地址、目标端口）可以<strong>唯一确定一个连接</strong>。</p>
<p>最大的<strong>TCP连接数</strong> &#x3D; 客户端**<u>IP数</u>** × 客户端<u><strong>端口数</strong></u>。实际远没有这么多，连接数还受<strong>文件描述符和内存</strong>的制约。</p>
<h3 id="为什么UDP头部没有首部长度字段，而TCP头部有？"><a href="#为什么UDP头部没有首部长度字段，而TCP头部有？" class="headerlink" title="为什么UDP头部没有首部长度字段，而TCP头部有？"></a>为什么UDP头部没有首部长度字段，而TCP头部有？</h3><p>因为TCP头部存在<strong>可变长的选项字段</strong>，而UDP头部长度始终不变。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEyLmpwZw?x-oss-process=image/format,png" alt="UDP 头部格式" style="zoom:50%;" />

<h3 id="为什么TCP头部没有包长度字段，而UDP头部有？"><a href="#为什么TCP头部没有包长度字段，而UDP头部有？" class="headerlink" title="为什么TCP头部没有包长度字段，而UDP头部有？"></a>为什么TCP头部没有包长度字段，而UDP头部有？</h3><p>UDP头部虽然只有四部分，但它<strong>比TCP多一个包长度</strong>（头部+数据的总长度），<strong>TCP的包长可由IP层获知</strong>。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEzLmpwZw?x-oss-process=image/format,png" alt="img" style="zoom:50%;" />

<h3 id="TCP和UDP各自的应用场景？"><a href="#TCP和UDP各自的应用场景？" class="headerlink" title="TCP和UDP各自的应用场景？"></a>TCP和UDP各自的应用场景？</h3><p>TCP可靠，所以多应用于FTP文件传输，HTTP&#x2F;HTTPS</p>
<p>UDP可以随时发送，高效。所以多应用于包较少的通信，如DNS、SNMP(Simple Network Management Protocol)等；视频，音频等；广播通信</p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>第三次握手<strong>可以携带数据</strong>，前两次握手不可携带数据。</p>
<p><u>三次握手意义</u>：阻止重复历史连接的初始化（<strong>主要意义</strong>），同步双方初始序列号，避免资源浪费。</p>
<p>每次<u>初始化序列号不一样的意义</u>：很大程度避免<strong>历史报文被下一个相同四元组的连接接收</strong>。</p>
<p>TCP头部字段的<strong>序列号</strong>和TCP建立连接的<strong>初始序列号都不是无限递增</strong>的，会发生<strong>回绕为初始值</strong>的情况，所以无法通过序列号来<strong>判断新老数据</strong>。</p>
<p>MTU和MSS的区别如下：</p>
<p>MTU(Maximum Transmission Unit)</p>
<p>MSS(Maximum Segment size)</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzIzLmpwZw?x-oss-process=image/format,png" alt="MTU 与 MSS"></p>
<h4 id="为什么TCP的整个报文（头部-数据）不交给IP分片？"><a href="#为什么TCP的整个报文（头部-数据）不交给IP分片？" class="headerlink" title="为什么TCP的整个报文（头部+数据）不交给IP分片？"></a>为什么TCP的整个报文（头部+数据）不交给IP分片？</h4><p>因为IP分片丢失，整个IP报文的<strong>所有分片都需要重传</strong>（IP层无响应，无超时重传机制）。</p>
<p>而TCP以MSS为单位分片后，某个TCP分片丢失，也是<strong>以MSS为单位重发</strong>的，重传效率大大增加。</p>
<h4 id="三次握手分别丢失的情况"><a href="#三次握手分别丢失的情况" class="headerlink" title="三次握手分别丢失的情况"></a>三次握手分别丢失的情况</h4><p><u>第一次握手丢失</u>：<strong>超时重传</strong>（默认逐次等1s, 2s, 4s, 16s, 32s），32s后仍没回应，不传了，直接断开TCP连接</p>
<p><u>第二次握手丢失</u>：客户端没收到ACK，触发超时重传，<strong>重传SYN报文</strong>；服务端没收到客户端的ACK（第三次握手），触发超时重传，<strong>重传SYN-ACK报文</strong>。</p>
<p><u>第三次握手丢失</u>：服务端<strong>重传SYN-ACK报文</strong>。</p>
<p>Linux半连接队列（SYN队列）和全连接队列（Accept队列）：</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzI2LmpwZw?x-oss-process=image/format,png" alt="正常流程" style="zoom:50%;" />

<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzMwLmpwZw?x-oss-process=image/format,png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom:50%;" />

<p><strong>主动关闭连接的一端</strong>才有TIME_WAIT状态。</p>
<h4 id="四次挥手分别丢失的情况"><a href="#四次挥手分别丢失的情况" class="headerlink" title="四次挥手分别丢失的情况"></a>四次挥手分别丢失的情况</h4><p><u>第一次挥手丢失</u>：客户端重传FIN报文，超过一定次数，直接进入close状态；</p>
<p><u>第二次挥手丢失</u>：因为<strong>ACK报文不会重传</strong>，所以还是客户端重传FIN报文，直到超过最大重传次数；</p>
<p><u>第三次挥手丢失</u>：<strong>服务端</strong>重发FIN报文，与客户端机制一样；</p>
<p><u>第四次挥手丢失</u>：<strong>服务端</strong>重发FIN报文。</p>
<h4 id="为什么TIME-WAIT等待时间是2MSL？"><a href="#为什么TIME-WAIT等待时间是2MSL？" class="headerlink" title="为什么TIME_WAIT等待时间是2MSL？"></a>为什么TIME_WAIT等待时间是2MSL？</h4><p>MSL（Maximum Segment Lifetime）报文最大生存时间，单位是时间，超时即丢弃。因为TCP基于IP协议，IP头部有TTL字段，是IP数据包可经过的最大路由数。TTL一般是64，Linux的MSL默认为30s，意味着<strong>Linux认为报文经过64个路由器的时间不超过30s</strong>。</p>
<p>其实2MSL时长是<strong>至少允许报文丢失一次</strong>。比如ACK在一个MSL内丢失，被动方重发的FIN会在第二个MSL内到达，TIME_WAIT就可以应对。如果一次ACK或一次FIN走不了一个MSL，那就很可能可以允许丢失两次、三次……所以2MSL时长至少允许一次报文丢失。</p>
<h4 id="为什么需要TIME-WAIT状态？"><a href="#为什么需要TIME-WAIT状态？" class="headerlink" title="为什么需要TIME_WAIT状态？"></a>为什么需要TIME_WAIT状态？</h4><p>①防止<strong>历史连接中的数据</strong>，被后面相同四元组的连接错误的接收；</p>
<p>②保证<strong>被动关闭连接的一方</strong>，能被正确的关闭。</p>
<h4 id="TIME-WAIT过多的危害？"><a href="#TIME-WAIT过多的危害？" class="headerlink" title="TIME_WAIT过多的危害？"></a>TIME_WAIT过多的危害？</h4><p>①客户端（发起连接方）<strong>端口资源</strong>被过多地占用；</p>
<p>②服务端（被动连接方）受<strong>系统资源</strong>限制。</p>
<h4 id="建立连接后，客户端突然出故障怎么办？"><a href="#建立连接后，客户端突然出故障怎么办？" class="headerlink" title="建立连接后，客户端突然出故障怎么办？"></a>建立连接后，客户端突然出故障怎么办？</h4><p>TCP存在保活机制，一段时间内没有任何连接活动，就每隔一个时间间隔发送一个探测报文。</p>
<h4 id="建立连接后，服务端突然出故障怎么办？"><a href="#建立连接后，服务端突然出故障怎么办？" class="headerlink" title="建立连接后，服务端突然出故障怎么办？"></a>建立连接后，服务端突然出故障怎么办？</h4><p>服务端发送FIN报文，与客户端进行四次挥手。</p>
<h2 id="TCP重传机制、滑动窗口、流量控制、拥塞控制"><a href="#TCP重传机制、滑动窗口、流量控制、拥塞控制" class="headerlink" title="TCP重传机制、滑动窗口、流量控制、拥塞控制"></a>TCP重传机制、滑动窗口、流量控制、拥塞控制</h2><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>RTT（Round-Trip Time往返时延）就是数据发送时刻到接收到确认时刻的差值，是动态变化的。</p>
<p>RTO（Retransmission Timeout超时重传时间），RTO要略大于RTT</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/8.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="RTO 应略大于 RTT" style="zoom: 67%;" />

<p>每当遇到一次超时重传，TCP都会将下一次超时重传时间间隔<strong>设为先前值的两倍</strong>。</p>
<h4 id="Linux如何计算RTO？"><a href="#Linux如何计算RTO？" class="headerlink" title="Linux如何计算RTO？"></a>Linux如何计算RTO？</h4><p>1）采样RTT时间，作<strong>加权平均</strong>，这个值不断变化</p>
<p>2）采样RTT<strong>波动范围</strong></p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>这种机制是<strong>数据驱动</strong>，而不是时间驱动。如下图，没收到就会<strong>一直传没收到2的ACK</strong>，连续收到<strong>3个</strong>就重传。</p>
<p>但是这种机制的弊端是：不知道重传2还是重传2、3、4、5，发送端不知道连续的3个ACK是谁传回来的。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传机制" style="zoom: 67%;" />

<h3 id="SACK方法（Selectice-ACK选择性确认）"><a href="#SACK方法（Selectice-ACK选择性确认）" class="headerlink" title="SACK方法（Selectice ACK选择性确认）"></a>SACK方法（Selectice ACK选择性确认）</h3><p>这种方式需要TCP头部的选项字段加一个SACK，它可以将缓存的地图发给发送方，这样发送方就知道哪些被收到了，哪些没被收到。然后就可以只重传丢失的数据了。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/11.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="选择性确认" style="zoom: 40%;" />

<p>Duplicate SACK（D-SACK）主要**使用了SACK来告诉[发送方]**有哪些数据被重复接收了。</p>
<p>D-SACK优点：</p>
<p>1）可以让[发送方]知道是<strong>包丢了</strong>还是对面的应答<strong>ACK丢了</strong>；</p>
<p>2）可以知道[发送方]的包是不是<strong>被网络延时</strong>了；</p>
<p>3）可以知道[发送方]的包是不是被<strong>网络复制</strong>了。（不懂）</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><u>窗口大小</u>：<strong>无需等待ACK</strong>而可以<strong>连续发送数据</strong>的最大值。</p>
<p><u>累计确认&#x2F;累计应答</u>：如下图：ACK 600没到<strong>但是ACK 700到了</strong>，也能说明前面的数据都收到了。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="用滑动窗口方式并行处理" style="zoom:50%;" />

<h3 id="窗口大小由哪一方决定？"><a href="#窗口大小由哪一方决定？" class="headerlink" title="窗口大小由哪一方决定？"></a>窗口大小由哪一方决定？</h3><p>窗口大小对应着TCP的<strong>Window</strong>字段。该字段是**[接收端]告诉[发送端]**自己还有多少缓冲区可以接收数据。</p>
<p>所以<strong>由[接收方]的窗口大小决定</strong>。</p>
<h3 id="发送方的滑动窗口"><a href="#发送方的滑动窗口" class="headerlink" title="发送方的滑动窗口"></a>发送方的滑动窗口</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/19.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="SND.WND、SND.UN、SND.NXT" style="zoom:45%;" />

<p>SND.WND：发送窗口的大小（<strong>接收方指定</strong>）</p>
<p>SND.UNA：<strong>绝对指针</strong>，指向<u>已发送但未收到ACK</u>的第一个字节的序列号</p>
<p>SND.NXT：<strong>绝对指针</strong>，指向<u>未发送但可发送范围</u>的第一个字节的序列号</p>
<p>指向<u>未发送且超出范围</u>（#4）的第一个字节的序列号是个<strong>相对指针</strong>。</p>
<p><strong>可用窗口大小</strong>由图可知是计算得来的。</p>
<h3 id="接收方的滑动窗口"><a href="#接收方的滑动窗口" class="headerlink" title="接收方的滑动窗口"></a>接收方的滑动窗口</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="接收窗口" style="zoom:45%;" />

<p>RCV.WND：接收窗口大小（通告<strong>给发送方的</strong>）</p>
<p>RCV.NXT：<strong>绝对指针</strong>，指向期望从发送方发来的下一个字节的序列号（#3的第一个字节）。</p>
<p>还有一个<strong>相对指针</strong>指向#4的第一个字节，是RCV.NXT+RCV.WND控制的。</p>
<p>因为接收方告诉发送方窗口大小有一定的<strong>时延</strong>，所以<strong>接收窗口约等于发送窗口</strong>。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="操作系统缓冲区与滑动窗口的关系"><a href="#操作系统缓冲区与滑动窗口的关系" class="headerlink" title="操作系统缓冲区与滑动窗口的关系"></a>操作系统缓冲区与滑动窗口的关系</h3><p>实际上，发送窗口和接收窗口中存放的字节数，都放在了操作系统缓冲区中。而应用进程就负责读取这一部分内容。</p>
<p>1）情况1</p>
<p>有的时候，应用进程非常忙碌，<strong>没有时间读取缓存区的内容</strong>，这样就会导致发送方发送来的一部分数据没办法及时被接收方的应用进程读取，滑动窗口的<strong>可用窗口越来越小，接收窗口也越来越小</strong>。（就像你吃饱了，另一个人还不停向你扔包子，虽然你告诉他一次最多仍5个，但是你现在肚子一点都装不下，所以就先放篮子里，放篮子里的早晚也要吃的，所以篮子有多少包子，你就要让你的接收窗口减少多少个包子，直到我们篮子里装了5个包子，那么就认为对方不能再扔了。）</p>
<p>所以从上边我们可以知道：缓冲区存了多少未读的数据，那么接收窗口缩小多少。接收窗口始终随缓冲区动态变化，就像消息队列一样，所以<strong>缓冲区未读数据M+接收窗口当前值N&#x3D;初始接收窗口的大小T</strong></p>
<p>上述情况就是：<strong>M一直增大，N一直减小，所以发送窗口逐渐减小</strong>。</p>
<p>2）情况2</p>
<p>有的时候，应用资源非常繁忙，操作系统会主动减少接收缓存（这就相当于操作系统自己给<strong>自己放了几个拿不走的包子——M永久性增大</strong>），这就直接导致我们现在窗口也要减少。但是窗口减少<strong>需要通知给发送方，这就需要一定的时间</strong>，在这时间内，很有可能有很大的包传过来，那么就会<strong>导致丢包</strong>（因为接收方的缓存收不下了）。</p>
<p>导致丢包的原因是：M增大的<strong>同时</strong>，N减小，但N传给发送方<strong>需要时间</strong>，这个时候发送方传来的包，接收方很可能接不住。</p>
<p>解决的方式就是：N<strong>先减小</strong>，过段时间（为了让N减小的消息通知给发送方）再让M增大（放入几个拿不走的包子）。</p>
<h3 id="窗口关闭（风险与解决）"><a href="#窗口关闭（风险与解决）" class="headerlink" title="窗口关闭（风险与解决）"></a>窗口关闭（风险与解决）</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/24.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口关闭潜在的危险" style="zoom:40%;" />

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/25.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口探测" style="zoom:35%;" />

<p>其实就是收到零窗口通知的一端会默认启用计时器，<strong>到点了就发送探测报文</strong>。</p>
<h3 id="糊涂窗口综合征（小接收与小发送问题）"><a href="#糊涂窗口综合征（小接收与小发送问题）" class="headerlink" title="糊涂窗口综合征（小接收与小发送问题）"></a>糊涂窗口综合征（小接收与小发送问题）</h3><p>有的时候，接收方通知给发送方的窗口大小越来越小，这就会带来一个问题，<strong>数据量很小的话，不值得传输一次</strong>，可以攒一攒，或者说等一等接收方接收一部分数据再传。（一个一个仍包子比较亏，等我一口能吃仨了，你一口气仍仨过来）</p>
<p>解决该问题有两种思路，一种是让接收方不通告小窗口给发送方；另一种是让发送方避免发送小数据。</p>
<h4 id="接收方不通告小窗口"><a href="#接收方不通告小窗口" class="headerlink" title="接收方不通告小窗口"></a>接收方不通告小窗口</h4><p>当 <strong>Window &lt; Math.min（MSS与缓存的一半）时</strong>，接收方就会向发送方<strong>通告Window为0</strong>。直到Window大于那俩值的时候，再通知Window值。</p>
<h4 id="发送方不发送小数据"><a href="#发送方不发送小数据" class="headerlink" title="发送方不发送小数据"></a>发送方不发送小数据</h4><p>Nagle算法，思路是延时处理。满足以下两条件之一才可以发送数据：</p>
<p>1）Window &gt;&#x3D; MSS 或 数据大小 &gt;&#x3D; MSS</p>
<p>2）收到之前发送数据的ACK回包</p>
<p>对于需要小数据包交互的场景如telnet或ssh，需要关闭Nagle算法。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>TCP不能一直按照流量控制传输，有的时候<strong>网络拥堵，就要减少传输量</strong>。</p>
<p><strong>发送窗口swnd</strong> &#x3D; min(拥塞窗口cwnd,接收窗口rwnd)</p>
<p>而拥塞窗口cwnd在网络中<strong>没有拥塞的时候，就会增大</strong>，出现拥塞，就会减少。</p>
<p><u>如何知道拥塞？</u>发送方没在规定时间收到ACK，也就是<strong>发生了超时重传</strong>，认为网络出现拥塞。</p>
<h3 id="拥塞控制的控制算法"><a href="#拥塞控制的控制算法" class="headerlink" title="拥塞控制的控制算法"></a>拥塞控制的控制算法</h3><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>慢启动算法规则：发送方每收到一个ACK，拥塞窗口cwnd就+1。（<strong>指数级增长</strong>）</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/27.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="慢启动算法" style="zoom: 40%;" />

<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>cwnd<strong>超过慢启动门限ssthresh</strong>就会进入拥塞避免算法。</p>
<p>规则：每收到一个ACK，cwnd增加1&#x2F;cwnd。（<strong>线性增长</strong>）</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/28.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="拥塞避免" style="zoom:40%;" />

<h4 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h4><p>上面两种都是cwnd逐渐增加，一旦网络拥塞，也就是拥塞发生，就会触发重传机制。</p>
<p><u><strong>超时重传</strong></u>：门限ssthresh设为cwnd&#x2F;2;cwnd置为1（<strong>急刹车并重新慢启动，一般不可取</strong>）</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="拥塞发送 —— 超时重传" style="zoom:30%;" />

<p><u><strong>快速重传</strong></u>：cwnd减半，门限ssthresh&#x3D;cwnd，然后<strong>进入快速恢复算法</strong>。</p>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>与<strong>快速重传</strong>一起“食用”。</p>
<p>规则：</p>
<ul>
<li>cwnd &#x3D; ssthresh + 3（3是指收到3个数据包）</li>
<li>重传丢失的数据包，收到一个重复ACK，cwnd就+1（线性增长）</li>
<li>一旦收到新数据ACK，就令cwnd &#x3D; ssthresh，说明恢复过程结束，<strong>再次进入拥塞避免状态</strong>（线性增长）</li>
</ul>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传和快速恢复" style="zoom:40%;" />

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" data-id="cl34efpty00001cv6d0asee9e" data-title="计算机网络笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/05/13/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          我的项目
        
      </div>
    </a>
  
  
    <a href="/2022/05/13/%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E8%A7%A3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">操作字符串题解</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/02/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E9%A2%98%E8%A7%A3/">股票问题题解</a>
          </li>
        
          <li>
            <a href="/2022/07/01/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">十大排序算法</a>
          </li>
        
          <li>
            <a href="/2022/06/26/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Linux学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/06/24/%E9%93%BE%E8%A1%A8%E9%A2%98%E8%A7%A3/">链表题解</a>
          </li>
        
          <li>
            <a href="/2022/06/20/acm%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/">acm输入输出练习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>