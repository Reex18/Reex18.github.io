<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Java基础知识点 | Reex</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="集合框架  不熟的知识点？Deque和Queue的区别；LinkedList的poll和pop；优先队列；Hash其他算法 LinkedList和ArrayDeque的区别？L可存储null，A不可存储null。 Collection接口中声明的方法向Collection接口实现类的对象中add, remove元素时，要求元素所在类要重写equals()方法。 123coll.add(new Pe">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础知识点">
<meta property="og:url" content="http://example.com/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="Reex">
<meta property="og:description" content="集合框架  不熟的知识点？Deque和Queue的区别；LinkedList的poll和pop；优先队列；Hash其他算法 LinkedList和ArrayDeque的区别？L可存储null，A不可存储null。 Collection接口中声明的方法向Collection接口实现类的对象中add, remove元素时，要求元素所在类要重写equals()方法。 123coll.add(new Pe">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://javaguide.cn/assets/java-collection-hierarchy.1727461b.png">
<meta property="article:published_time" content="2022-05-15T09:03:41.000Z">
<meta property="article:modified_time" content="2022-07-16T06:28:45.056Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://javaguide.cn/assets/java-collection-hierarchy.1727461b.png">
  
    <link rel="alternate" href="/atom.xml" title="Reex" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Reex</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java基础知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2022-05-15T09:03:41.000Z" itemprop="datePublished">2022-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Java基础知识点
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><img src="https://javaguide.cn/assets/java-collection-hierarchy.1727461b.png" alt="img"  />

<h1 id="不熟的知识点？"><a href="#不熟的知识点？" class="headerlink" title="不熟的知识点？"></a>不熟的知识点？</h1><p>Deque和Queue的区别；LinkedList的poll和pop；优先队列；Hash其他算法</p>
<h2 id="LinkedList和ArrayDeque的区别？"><a href="#LinkedList和ArrayDeque的区别？" class="headerlink" title="LinkedList和ArrayDeque的区别？"></a>LinkedList和ArrayDeque的区别？</h2><p>L可存储null，A不可存储null。</p>
<h2 id="Collection接口中声明的方法"><a href="#Collection接口中声明的方法" class="headerlink" title="Collection接口中声明的方法"></a>Collection接口中声明的方法</h2><p>向Collection接口实现类的对象中add, remove元素时，要求元素所在类要重写equals()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小王&quot;</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">//没有重写equals就是两个不同地址值的元素，则输出false，因为contains会默认调用被添加元素的equals()，不重写的话就是调==，比较地址值</span></span><br><span class="line">System.out.print(coll.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小王&quot;</span>, <span class="number">2</span>)));</span><br></pre></td></tr></table></figure>

<h2 id="为什么要使用集合？"><a href="#为什么要使用集合？" class="headerlink" title="为什么要使用集合？"></a>为什么要使用集合？</h2><p>数组一旦声明了，长度就不可变；</p>
<p>数组存储数据类型单一，而且有序且可重复的，特点也单一；</p>
<p>集合提高了数据存储的灵活性，不仅可以不同<strong>类型</strong>、不同<strong>数量</strong>，还可以<strong>控制元素重复</strong>，并且保存具有<strong>映射关系</strong>的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  数组转换为类型一致的集合</span></span><br><span class="line">  <span class="type">int</span> [] arr1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">  <span class="comment">//  注意：这里直接传入int [] 的数组，返回的List的泛型参数为 int [],而不是Integer</span></span><br><span class="line">  List&lt;<span class="type">int</span>[]&gt; list1 = Arrays.asList(arr1);</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer [] arr2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//  传入的参数类型为 Integer时，返回泛型参数就是Integer</span></span><br><span class="line">List&lt;Integer&gt; list2 = Arrays.asList(arr2);</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList和LinkedList区别与联系？"><a href="#ArrayList和LinkedList区别与联系？" class="headerlink" title="ArrayList和LinkedList区别与联系？"></a>ArrayList和LinkedList区别与联系？</h2><p>A和L都实现了List接口，他们都是<strong>线程不安全的</strong>；</p>
<p>A底层使用的是<u>Object[]数组</u>，L底层使用的是<u>双向链表</u>；</p>
<p>A在数组中的某个位置<strong>删除，插入</strong>元素都需要让整个数组跟着移动，L虽然不会移动，但是需要先移动到那个位置才能进行插入或删除操作，所以<strong>两者复杂度都较高</strong>，L只有头和尾插入或删除时，时间复杂度时o(1)。</p>
<p><strong>A支持快速随机访问</strong>，因为数组下标。而L不行。</p>
<p>A占内存主要是因为<strong>尾部需要预留空间</strong>，L空间花费更多体现在每个结点要记录的内容。</p>
<p>A好，用A，<strong>能用L的地方都能用A</strong>。</p>
<h2 id="ArrayList源码分析-尚硅谷527集"><a href="#ArrayList源码分析-尚硅谷527集" class="headerlink" title="ArrayList源码分析(尚硅谷527集)"></a>ArrayList源码分析(尚硅谷527集)</h2><p>jdk1.7默认初始化数组长度为10（饿汉式），jdk1.8默认初始化数组长度为0，添加元素才执行扩容，长度为10（懒汉式）；</p>
<p>两者扩容都是在<strong>原数组长度基础上扩容1.5倍</strong>，如果扩容后还不够，就将长度扩容为需要的长度，长度如果超过限定的数组长度最大值，就设为Integer.MAX_VALUE，还不够就<strong>报溢出异常</strong></p>
<h2 id="transient关键字没讲？"><a href="#transient关键字没讲？" class="headerlink" title="transient关键字没讲？"></a>transient关键字没讲？</h2><h2 id="如何将ArrayList集合内的元素去重？"><a href="#如何将ArrayList集合内的元素去重？" class="headerlink" title="如何将ArrayList集合内的元素去重？"></a>如何将ArrayList集合内的元素去重？</h2><p>如果集合内元素均为<strong>基本数据类型或字符串等</strong>，那么直接用HashSet对象执行addAll()方法，再将其转换为集合即可。</p>
<p>如果集合内的元素有<strong>自定义类的对象</strong>，那么该自定义不仅要重写equals()，还**必须重写hashcode()**。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">......</span><br><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">set.addAll(list);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(set);</span><br></pre></td></tr></table></figure>

<h2 id="HashSet易错题？"><a href="#HashSet易错题？" class="headerlink" title="HashSet易错题？"></a>HashSet易错题？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    <span class="comment">//这里没问题，set有2个元素</span></span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);</span><br><span class="line">    <span class="comment">//易错1：当p1的AA被CC替换后，调用remove()删除p1的时候，首先要根据1001和CC计算hashcode，这个值有很小的几率与原p1所在位置一样，所以很可能set中还是2个元素，只不过p1的AA变成了CC</span></span><br><span class="line">    p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">    set.remove(p1);</span><br><span class="line">    <span class="comment">//易错2：1001,CC的hashcode与p1和p2都不冲突，所以可以添加，set含有3个元素</span></span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line">    <span class="comment">//易错3：1001,AA的hashcode和p1一样，但是与p1的值（equals()结果为false）不一样，所以以链表的形式存储在p1的后边，set含4个元素</span></span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="comparable和comparator区别？"><a href="#comparable和comparator区别？" class="headerlink" title="comparable和comparator区别？"></a>comparable和comparator区别？</h2><p>comparable接口是java.lang包下的，接口有comareTo(Object obj)方法</p>
<p>comparator接口时java.util工具包下的，接口中有compare(Object obj1, Object obj2)方法</p>
<h2 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h2><p>JDK 1.7之前，底层是<strong>数组+链表</strong>的形式存储数据的。每次存储都对数据执行扰动函数，得到hash值，如果哈希碰撞，就equals比较，若相等则覆盖，如<strong>不等则拉链法</strong>，即用链表存储。</p>
<p>JDK 1.8之后，底层是<strong>数组+链表+红黑树</strong>。还是用扰动函数，但是<strong>扰动函数有所更新</strong>，减少了哈希碰撞几率，但是如果碰撞还是equals比较，若相等则覆盖，若不等则拉链法，当链表长度大于阈值（默认8），则检查当前数组长度是否大于64，<strong>小于64则扩容数组</strong>（这里需要rehash），大于64则将超过阈值的链表<strong>转化为红黑树</strong>。</p>
<h2 id="HashMap长度为什么是2的幂次方？"><a href="#HashMap长度为什么是2的幂次方？" class="headerlink" title="HashMap长度为什么是2的幂次方？"></a>HashMap长度为什么是2的幂次方？</h2><p><strong>这个还没搞懂</strong></p>
<h2 id="ConcurrentHashMap和Hashtable的区别？"><a href="#ConcurrentHashMap和Hashtable的区别？" class="headerlink" title="ConcurrentHashMap和Hashtable的区别？"></a>ConcurrentHashMap和Hashtable的区别？</h2><p>先说Hashtable，<strong>全表锁</strong>，效率很低</p>
<p>对于<strong>JDK 1.7</strong>的cchashmap，用segment即<strong>分段锁</strong>，只要多个线程没有哈希碰撞到同一个段就没事。</p>
<p><strong>JDK 1.8</strong>以后的cchashmap，<strong>只锁当前的链表或者红黑树的首节点</strong>，只要hash冲突不到数组的同一个节点上，就没事。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="cl39jz0gd00001cv61jgv7ohf" data-title="Java基础知识点" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          二叉树题解
        
      </div>
    </a>
  
  
    <a href="/2022/05/14/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E9%A2%98%E8%A7%A3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">栈与队列题解</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/2022/07/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80%E5%8F%8A%E8%83%8C%E5%8C%85%E9%A2%98%E8%A7%A3/">动态规划基础及背包题解</a>
          </li>
        
          <li>
            <a href="/2022/07/06/SQL%E9%A2%98%E8%A7%A3/">SQL题解</a>
          </li>
        
          <li>
            <a href="/2022/07/02/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E9%A2%98%E8%A7%A3/">股票问题题解</a>
          </li>
        
          <li>
            <a href="/2022/07/01/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">十大排序算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>