<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>回溯系列题解 | Reex</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="组合问题leetcode 77.组合题目：给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 12345678910111213141516171819class Solution &amp;#123;    List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();    Li">
<meta property="og:type" content="article">
<meta property="og:title" content="回溯系列题解">
<meta property="og:url" content="http://example.com/2022/05/30/%E5%9B%9E%E6%BA%AF%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/index.html">
<meta property="og:site_name" content="Reex">
<meta property="og:description" content="组合问题leetcode 77.组合题目：给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 12345678910111213141516171819class Solution &amp;#123;    List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();    Li">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020102916424043.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201123200304469.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201124201406192.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201124201431571.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202011171912586.png">
<meta property="article:published_time" content="2022-05-30T04:52:55.000Z">
<meta property="article:modified_time" content="2022-08-30T06:03:38.602Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/2020102916424043.png">
  
    <link rel="alternate" href="/atom.xml" title="Reex" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Reex</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-回溯系列题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/30/%E5%9B%9E%E6%BA%AF%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-05-30T04:52:55.000Z" itemprop="datePublished">2022-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      回溯系列题解
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h1><h2 id="leetcode-77-组合"><a href="#leetcode-77-组合" class="headerlink" title="leetcode 77.组合"></a>leetcode 77.组合</h2><p><u><strong>题目</strong>：给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</u></p>
<p><u>你可以按 <strong>任何顺序</strong> 返回答案。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backTracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= n - (k - path.size()) + <span class="number">1</span>;i++) &#123;<span class="comment">//剪枝</span></span><br><span class="line">            path.add(i);</span><br><span class="line">            backTracking(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-216-组合总和-III"><a href="#leetcode-216-组合总和-III" class="headerlink" title="leetcode 216.组合总和 III"></a>leetcode 216.组合总和 III</h2><p><u><strong>题目</strong>：找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</u></p>
<p><u>只使用数字1到9</u><br><u>每个数字 最多使用一次</u><br><u>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backTracking(n, k, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> k, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//这里必须要k的数量和sum的值同时满足才可以将path加入res</span></span><br><span class="line">        <span class="keyword">if</span>(k == path.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span> &amp;&amp; sum + i &lt;= target;i++) &#123;<span class="comment">//剪枝</span></span><br><span class="line">            path.add(i);</span><br><span class="line">            sum += i;<span class="comment">//因为sum要在for循环中使用多次，所以必须要对sum回溯</span></span><br><span class="line">            backTracking(target, k, i + <span class="number">1</span>, sum);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-39-组合总和"><a href="#leetcode-39-组合总和" class="headerlink" title="leetcode 39.组合总和"></a>leetcode 39.组合总和</h2><p><u><strong>题目</strong>：给你一个<strong>无重复元素</strong>的整数数组candidates和一个目标整数target，找出candidates中可以使数字和为目标数target 的所有不同组合，并以列表形式返回。你可以按任意顺序返回这些组合。</u></p>
<p><u>candidates中的同一个<strong>数字可以无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</u></p>
<p><u>对于给定的输入，保证和为 target 的不同组合数少于150个。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//排序一定不能忘</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target;i++) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backTracking(candidates, target, i, sum);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环里的剪枝操作：sum &lt;&#x3D; target为什么不可以写成sum + candidates[i] &lt;&#x3D; target，其实是因为我<strong>忘记排序了</strong>，如果没有排序，就很可能导致很小的数在最后，<strong>剪枝后永远考虑不到</strong>，所以一定要排序之后才可以剪枝。</p>
<h2 id="leetcode-40-组合总和-II"><a href="#leetcode-40-组合总和-II" class="headerlink" title="leetcode 40.组合总和 II"></a>leetcode 40.组合总和 II</h2><p><u><strong>题目</strong>：给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</u></p>
<p><u>candidates 中的每个数字在每个组合中只能使用 一次 。</u></p>
<p><u>注意：解集不能包含重复的组合。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target;i++) &#123;</span><br><span class="line">            <span class="comment">//同层跳过重复元素</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backTracking(candidates, target, i + <span class="number">1</span>, sum);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<strong>同一层不能添加相同元素</strong>，所以在for循环里现有一个判断，判断当前层，前后两个元素是否相同，不相同再继续回溯。</p>
<h2 id="☆leetcode-17-电话号码的字母组合"><a href="#☆leetcode-17-电话号码的字母组合" class="headerlink" title="☆leetcode 17.电话号码的字母组合"></a>☆leetcode 17.电话号码的字母组合</h2><p><u><strong>题目</strong>：给定一个仅包含数字 **2-9 **的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</u></p>
<p><u>给出数字到字母的映射如下（与电话按键相同）。注意1不对应任何字母。</u></p>
<img src="https://img-blog.csdnimg.cn/2020102916424043.png" alt="17.电话号码的字母组合" style="zoom:40%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="comment">//用String数组将电话号码对应的字符串存储起来</span></span><br><span class="line">        String[] numString = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//判空</span></span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        backTracking(digits, numString, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯前创建一个全局变量sb，用于操作字符串的增删</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String digits, String[] numString, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果指针index与digits长度一致，说明遍历完成</span></span><br><span class="line">        <span class="keyword">if</span>(index == digits.length()) &#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出digits中当前指针index位置的字符所对应的数组元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> numString[digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; str.length();i++) &#123;</span><br><span class="line">            sb.append(str.charAt(i));</span><br><span class="line">            backTracking(digits, numString, index + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>先把每个按键对应的字符串存储到String数组中，每个**<u>下标对应按键的数字</u>**；</li>
<li>然后记得在回溯之前，定义一个<strong>操作字符串增删的全局变量</strong>sb；</li>
<li>回溯过程中，始终有一个指针<strong>index<u>用于指向本次回溯需要取</u>digits的第几个按键</strong>，找到该按键在字符串数组中<strong>对应的字符串</strong>，然后进入for循环依次遍历并回溯这组字符串。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201123200304469.png" alt="17. 电话号码的字母组合"></p>
<h1 id="切割问题"><a href="#切割问题" class="headerlink" title="切割问题"></a>切割问题</h1><h2 id="leetcode-131-分割回文串"><a href="#leetcode-131-分割回文串" class="headerlink" title="leetcode 131.分割回文串"></a>leetcode 131.分割回文串</h2><p><u><strong>题目</strong>：给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</u></p>
<p><u><strong>回文串</strong> 是正着读和反着读都一样的字符串。</u></p>
<p><u>输入：s &#x3D; “aab”</u><br><u>输出：[[“a”,”a”,”b”],[“aa”,”b”]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backTracking(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String s, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(index == s.length()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="comment">//在模板的基础上，多了一个判断条件，如果是回文串再添加到path，否则直接进入下一次循环</span></span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s, index, i)) &#123;<span class="comment">//左闭右闭</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(index, i + <span class="number">1</span>);<span class="comment">//左闭右开</span></span><br><span class="line">                path.add(str);</span><br><span class="line">                backTracking(s, i + <span class="number">1</span>);</span><br><span class="line">            	path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = right;i &lt; j;i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="☆leetcode-93-复原IP地址"><a href="#☆leetcode-93-复原IP地址" class="headerlink" title="☆leetcode 93.复原IP地址"></a>☆leetcode 93.复原IP地址</h2><p><u><strong>题目</strong>：有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且<strong>不能含有前导 0）</strong>，整数之间用 ‘.’ 分隔。</u></p>
<p><u>例如：”0.1.2.201” 和 “192.168.1.1” 是 <strong>有效</strong> IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#57;&#x32;&#46;&#49;&#54;&#x38;&#x40;&#49;&#46;&#49;">&#x31;&#57;&#x32;&#46;&#49;&#54;&#x38;&#x40;&#49;&#46;&#49;</a>“ 是 <strong>无效</strong> IP 地址。</u><br><u>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 <strong>不能</strong> 重新排序或删除 s 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; <span class="number">12</span>) <span class="keyword">return</span> res;<span class="comment">//简单的剪枝</span></span><br><span class="line">        backTracking(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String s, <span class="type">int</span> index, <span class="type">int</span> pointCount)</span> &#123;</span><br><span class="line">        <span class="comment">//逗点为3个就不用继续循环了，直接判断最后剩下的字符串符不符合条件</span></span><br><span class="line">        <span class="keyword">if</span>(pointCount == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s, index, s.length() - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//这个位置为什么可以直接添加s，可能因为s是形参，每次添加的s之间互不干扰</span></span><br><span class="line">                res.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s, index, i)) &#123;</span><br><span class="line">                <span class="comment">//注意要从0开始加</span></span><br><span class="line">                s = s.substring(<span class="number">0</span>, i + <span class="number">1</span>) + <span class="string">&quot;.&quot;</span> + s.substring(i + <span class="number">1</span>);</span><br><span class="line">                pointCount++;</span><br><span class="line">                backTracking(s, i + <span class="number">2</span>, pointCount);</span><br><span class="line">                pointCount--;</span><br><span class="line">                <span class="comment">//这里删除逗点的方式是拼接逗点左右两边的字符串，而把逗点跳过去</span></span><br><span class="line">                s = s.substring(<span class="number">0</span>, i + <span class="number">1</span>) + s.substring(i + <span class="number">2</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//--------------------下面一行代码更容易理解回溯的原理-----------------------</span></span><br><span class="line">                <span class="comment">//backTracking(s.substring(0, i + 1) + &quot;.&quot; + s.substring(i + 1), i + 2, pointCount + 1);</span></span><br><span class="line">                <span class="comment">//--------------------上面一行代码更容易理解回溯的原理-----------------------</span></span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//一旦IP不合法，就没必要继续向下走了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是不是含有前导0</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(start) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i &lt;= end;i++) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h1><h2 id="leetcode-78-子集"><a href="#leetcode-78-子集" class="headerlink" title="leetcode 78.子集"></a>leetcode 78.子集</h2><p><u><strong>题目</strong>：给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</u></p>
<p><u>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</u></p>
<p><u>输入：nums &#x3D; [1,2,3]</u><br><u>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</u></p>
<p><u><strong>提示：</strong></u></p>
<ul>
<li><u><code>1 &lt;= nums.length &lt;= 10</code></u></li>
<li><u><code>-10 &lt;= nums[i] &lt;= 10</code></u></li>
<li><u><code>nums</code> 中的所有元素 <strong>互不相同</u></strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backTracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; nums.length;i++) &#123;<span class="comment">//广度遍历</span></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums, i + <span class="number">1</span>);<span class="comment">//深度遍历</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-90-子集-II（与组合总和-II-一起食用）"><a href="#leetcode-90-子集-II（与组合总和-II-一起食用）" class="headerlink" title="leetcode 90.子集 II（与组合总和 II 一起食用）"></a>leetcode 90.子集 II（与组合总和 II 一起食用）</h2><p><u><strong>题目</strong>：给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</u></p>
<p><u>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//必须要排序，便于后面去重操作</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="comment">//同层去重，前提是数组排过序了</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="☆leetcode-491-递增子序列"><a href="#☆leetcode-491-递增子序列" class="headerlink" title="☆leetcode 491.递增子序列"></a>☆leetcode 491.递增子序列</h2><p><u><strong>题目</strong>：给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 任意顺序 返回答案。</u></p>
<p><u>数组中可能含有重复元素，如出现<strong>两个整数相等</strong>，也可以视作递增序列的一种特殊情况。</u></p>
<p><u>输入：nums &#x3D; [4,6,7,7]</u><br><u>输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backTracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//一旦path中装了多于1个元素，就可以放进res中了，但是一定不要return！！！</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次树层遍历的开始，定义一个有着map功能的数组used，用于记录同层出现的数字</span></span><br><span class="line">        <span class="type">int</span>[] used = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">201</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="comment">//不满足递增或者nums[i]已经存在过都要进入下一次循环</span></span><br><span class="line">            <span class="keyword">if</span>(!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - <span class="number">1</span>) || used[nums[i] + <span class="number">100</span>] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//不要忘了记录当前的nums[i]</span></span><br><span class="line">            used[nums[i] + <span class="number">100</span>] = <span class="number">1</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="comment">//这里很容易把user[nums[i] + 100] = 0，不可以的原因是used是针对本循环的，而不是回溯的全局变量，所以不要让used归零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用HashSet存储同层的值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backTracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - <span class="number">1</span>) || set.contains(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            backTracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h1><h2 id="leetcode-46-全排列（与491递增子序列一起食用）"><a href="#leetcode-46-全排列（与491递增子序列一起食用）" class="headerlink" title="leetcode 46.全排列（与491递增子序列一起食用）"></a>leetcode 46.全排列（与491递增子序列一起食用）</h2><p><u><strong>题目</strong>：给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</u></p>
<p><u>输入：nums &#x3D; [1,2,3]</u><br><u>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backTracking(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//排列问题只有在path的长度和nums长度相等时才可以存入res，其实就是存入叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排列问题不需要指针，每一个位置都要考虑，所以i = 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="comment">//一旦之前标记过了，就说明path.contains(nums[i])，也可以用这个来判断</span></span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums);</span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="comment">//不仅要从path里删除元素，也要让数组中该位置元素的标记归零</span></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" alt="46.全排列" style="zoom: 33%;" />

<h4 id="1-为什么全排列的回溯过程中要让used-i-数组归位，而上一题491递增子序列不需要归位？"><a href="#1-为什么全排列的回溯过程中要让used-i-数组归位，而上一题491递增子序列不需要归位？" class="headerlink" title="1.为什么全排列的回溯过程中要让used[i]数组归位，而上一题491递增子序列不需要归位？"></a>1.为什么全排列的回溯过程中要让used[i]数组归位，而上一题491递增子序列不需要归位？</h4><p>因为全排列的used数组是全局变量，每次backTracking递归过程就是一次深度遍历，而used数组的目的就是让下一层的树枝for循环的时候，避免上面树枝中添加的元素，所以used的目的是**<u>树枝去重</u>**作用的。</p>
<p>而对于递增子序列，我们的used并不是全局变量，而是每层树枝在广度遍历之前创建的一个**<u>树层去重</u><strong>的数组，如果nums取值范围非常大，我们还要用HashMap来替代数组，因为这道题只有201个不同数值，所以可以用</strong>数组模拟HashMap去重**。所以<u><em>树层遍历的used数组不应该因为回溯深度遍历而被回溯（因为没有used数组参与深度遍历）</em></u>。</p>
<h4 id="2-为什么全排列需要used数组，而组合不需要？"><a href="#2-为什么全排列需要used数组，而组合不需要？" class="headerlink" title="2.为什么全排列需要used数组，而组合不需要？"></a>2.为什么全排列需要used数组，而组合不需要？</h4><p>因为全排列的[1,2,3]和[3,2,1]是两个不一样的结果，组合则是一样的结果。所以组合和子集问题我们都有一个指针，在每层树枝广度遍历的时候通过<strong>backTracking的形参中指针的传递</strong>就避免了重复元素。</p>
<p>而全排列则不可以有指针，每一层树枝广度遍历的时候，必须要<strong>从0到nums.length每一个元素都要遍历</strong>，而为了避免上面树层已经添加过某些元素，在本层不可以添加了，就要一个负责<strong>深度遍历去重的数组used</strong>。</p>
<h2 id="leetcode-47-全排列-II"><a href="#leetcode-47-全排列-II" class="headerlink" title="leetcode 47.全排列 II"></a>leetcode 47.全排列 II</h2><p><u><strong>题目</strong>：给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</u></p>
<p><u>输入：nums &#x3D; [1,1,2]</u><br><u>输出：[[1,1,2], [1,2,1], [2,1,1]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTracking(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;           </span><br><span class="line">            <span class="comment">//这里是重点，树层去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//树枝去重</span></span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                backTracking(nums);</span><br><span class="line">                path.removeLast();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题因为是含有重复元素的数组，所以我们去重一般选择的是<strong>同层去重</strong>，前提就是<strong>对nums数组先进行排序</strong>，这在组合题目中就练习过。</p>
<p>结合上面的全排列，我们发现used数组是为了深度遍历而创建的，那么怎么利用他来进行树层去重呢，首先因为nums排序了，所以每层遍历的时候，都要比较当前元素和前一个元素（如果有的话）是否相等。我们还得证明前一个元素在<strong>同父节点的前一个子节点</strong>已经取过了，我们知道上一个子节点取完会<strong>回溯到父节点</strong>，然后走到本节点，相应的used[i - 1]也会置为false，所以如果used[i - 1] &#x3D;&#x3D; false，说明上一个同父的子节点已经取过了，又因为这两个相邻元素相等，我们这个子节点就没必要继续取了。按照这个思路，当两个相邻元素相等，但used[i - 1] &#x3D; true的时候，就说明前面子节点没添加（其实就是<strong>前面没有子节点，本节点是当前层的第一个</strong>），也就是左下角那种情况。</p>
<p>重点！！！这里used[i - 1] &#x3D; true其实上面说法是错的，当nums[i - 1]在前面一树层中被添加之后，<strong>如果没进行回溯（used[i - 1] 还是 true）</strong>，那么当前nums[i] &#x3D;&#x3D; nums[i - 1]也不影响path继续添加nums[i]，这是因为，<strong>used[i - 1] &#x3D;&#x3D; true意味着nums[i - 1]与nums[i]在不同层树枝</strong>，自然互不影响；但是如果used[i - 1] &#x3D;&#x3D; false，说明nums[i]是回溯过来的，即nums[i - 1]和nums[i]在同一树层，自然需要去重考虑。</p>
<img src="https://img-blog.csdnimg.cn/20201124201406192.png" alt="47.全排列II2" style="zoom:35%;" />

<p>如果我们把判断条件中的used[i - 1] &#x3D;&#x3D; false改为true其实也可以，这就是一种<strong>树枝去重</strong>的方式，要注意和全排列中used[i] &#x3D;&#x3D; true区分开，本题既要判断used[i - 1] &#x3D;&#x3D; true又要判断used[i] &#x3D;&#x3D; true，整个流程如下图所示。可以看到出现了很多冗余的判断，直到最后的右下角，才得到了答案。原因是：我们始终判断的是<strong>前一个元素有没有在整个树枝中出现</strong>，如果<u>先添加最后一个元素</u>，那么前面的元素就可以依次添加进来了。</p>
<img src="https://img-blog.csdnimg.cn/20201124201431571.png" alt="47.全排列II3" style="zoom: 33%;" />

<h1 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h1><h2 id="leetcode-51-N皇后"><a href="#leetcode-51-N皇后" class="headerlink" title="leetcode 51.N皇后"></a>leetcode 51.N皇后</h2><p><u><strong>题目</strong>：按照国际象棋的规则，皇后可以攻击与之处在<strong>同一行</strong>或<strong>同一列</strong>或<strong>同一斜线上</strong>的棋子。</u></p>
<p><u>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</u></p>
<p><u>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</u></p>
<p><u>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] chessboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="comment">//先把数组的每一个位置填上&#x27;.&#x27;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c : chessboard) &#123;</span><br><span class="line">            Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(n, <span class="number">0</span>, chessboard);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, <span class="type">char</span>[][] chessboard)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n) &#123;</span><br><span class="line">            res.add(arrayToList(chessboard));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;col &lt; n;col++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(n, row, col, chessboard)) &#123;</span><br><span class="line">                chessboard[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                backTracking(n, row + <span class="number">1</span>, chessboard);</span><br><span class="line">                chessboard[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数组转换为集合</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">arrayToList</span><span class="params">(<span class="type">char</span>[][] chessboard)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c : chessboard) &#123;</span><br><span class="line">            list.add(String.copyValueOf(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前行和列能不能添加Q</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span>[][] chessboard)</span> &#123;</span><br><span class="line">        <span class="comment">//当前列每一行是否都没有Q</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; row;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//45°有没有Q</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>;i--,j--) &#123;</span><br><span class="line">            <span class="comment">//这里写错了两次，是i,j不是row,col</span></span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//135°有没有Q</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; j &lt;= n - <span class="number">1</span>;i--,j++) &#123;</span><br><span class="line">            <span class="comment">//这里写错了两次，是i,j不是row,col</span></span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-37-解数独"><a href="#leetcode-37-解数独" class="headerlink" title="leetcode 37.解数独"></a>leetcode 37.解数独</h2><p><u><strong>题目</strong>：编写一个程序，通过填充空格来解决数独问题。</u></p>
<p><u>数独的解法需 遵循如下规则：</u></p>
<p><u>数字 1-9 在每一行只能出现一次。</u><br><u>数字 1-9 在每一列只能出现一次。</u><br><u>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</u><br><u>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</u></p>
<p><img src="https://img-blog.csdnimg.cn/202011171912586.png" alt="解数独"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        backTracking(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; board.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>;k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(isValid(k, i, j, board)) &#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        <span class="keyword">if</span>(backTracking(board)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//一旦9个数字都填不进去，就跳出循环，肯定数独是无解的了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="comment">//检查当前列的每一行有没有k</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查当前行的每一列有没有k</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">9</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][j] == k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//九宫格内检查有没有k</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startRow</span> <span class="operator">=</span> (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startRow;i &lt; startRow + <span class="number">3</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> startCol;j &lt; startCol + <span class="number">3</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>全排列问题，[1,2]和[2,1]不一样，也就是深度遍历的时候，每层都要<strong>从nums的头遍历到nums的尾</strong>，但必须要记录这一树枝上添加到path的元素，所以一定要用<strong>全局变量数组used</strong>，通过<strong>回溯过程</strong>将used归零，可以有效区分<strong>每个树枝</strong>不含重复元素。记住！每个根节点下面的子节点，都是走的根节点的backTracking()，所以子节点拥有的used<strong>一致的部分</strong>是根节点及其上面的节点，子节点与子节点之间的used互不影响。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/30/%E5%9B%9E%E6%BA%AF%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/" data-id="cl3sliw020000wkv65w08c6t5" data-title="回溯系列题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Redis知识点
        
      </div>
    </a>
  
  
    <a href="/2022/05/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">操作系统笔记</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/2022/07/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80%E5%8F%8A%E8%83%8C%E5%8C%85%E9%A2%98%E8%A7%A3/">动态规划基础及背包题解</a>
          </li>
        
          <li>
            <a href="/2022/07/06/SQL%E9%A2%98%E8%A7%A3/">SQL题解</a>
          </li>
        
          <li>
            <a href="/2022/07/02/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E9%A2%98%E8%A7%A3/">股票问题题解</a>
          </li>
        
          <li>
            <a href="/2022/07/01/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">十大排序算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>