<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Redis知识点 | Reex</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Redis数据结构缓存数据的处理流程及优势高性能：一个业务要请求数据库中的数据，先从缓存中查询，如果没有再去库里边查询。从库中查询数据是读取硬盘的操作，效率比较低。我们可以将访问频率比较高的数据放入缓存中，达到高性能的目的。 高并发：MySQL的QPS大概在1w左右（4核8g），但是Redis缓存后很容易达到10w+，单机少一些，Redis集群更高。（QPS：Query Per Second，服务">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis知识点">
<meta property="og:url" content="http://example.com/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="Reex">
<meta property="og:description" content="Redis数据结构缓存数据的处理流程及优势高性能：一个业务要请求数据库中的数据，先从缓存中查询，如果没有再去库里边查询。从库中查询数据是读取硬盘的操作，效率比较低。我们可以将访问频率比较高的数据放入缓存中，达到高性能的目的。 高并发：MySQL的QPS大概在1w左右（4核8g），但是Redis缓存后很容易达到10w+，单机少一些，Redis集群更高。（QPS：Query Per Second，服务">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/376128646c75a893ad47914858fa2131.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/516738c4058cdf9109e40a7812ef4239.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/cadf797496816eb343a19c2451437f1e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ab0b44f557f8b5bc7acb3a53d43ebfcb.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/85f597f7851b90d6c78bb0d8e39690fc.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/cabce0ce7e320bc9d9b5bde947b6811b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/6f0ab40396b7fc2c15e6f4487d3a0ad7.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/28afd536c57a46447ddab0a2062abe84.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/98987d9417b2bab43087f45fc959d32a.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/5a1f2a90b5f3821c19bea3b7a5f27fa1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/d4cfac545377b54dd035c775603b4936.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202105270918298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ebd620db8a1af66fbeb8f4d4ef6adc68.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/f67379b60d151262753fec3b817b8617.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/717343a0da7a1b05edab1d1cdf8f28e5.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/061e2c04e0ebca3425dd75dd035b6b7b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/2b7231b6aabb9a9a2e2390ab3a280b2d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ea4f7e86baf2435af3999e5cd38b6a26.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/03eacec67cc58ff8d5819d0872ddd41e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4d850bfe8d712d3d67ff13e59b919452.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/e081b470870daeb763062bb873a4477e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/2db4831516b9a8b79f833cf0593c1f12.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/5e9e65a4a59b3688fa37cadbd87bb5ac.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/775865f6bd894dfba8d373ee54d79af1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/13e4361407ba46979e802eaa654dcf67.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a6286053c6884cf58bf397d01674fe80.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/fdd5f695bb3643258662886f9fba0aab.png">
<meta property="article:published_time" content="2022-06-02T05:43:35.000Z">
<meta property="article:modified_time" content="2022-06-10T13:27:48.782Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/img_convert/376128646c75a893ad47914858fa2131.png">
  
    <link rel="alternate" href="/atom.xml" title="Reex" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Reex</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Redis知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2022-06-02T05:43:35.000Z" itemprop="datePublished">2022-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Redis知识点
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><h2 id="缓存数据的处理流程及优势"><a href="#缓存数据的处理流程及优势" class="headerlink" title="缓存数据的处理流程及优势"></a>缓存数据的处理流程及优势</h2><p><u>高性能</u>：一个业务要请求数据库中的数据，<u>先从缓存中查询，如果没有再去库里边查询</u>。从库中查询数据是读取硬盘的操作，效率比较低。我们可以将<strong>访问频率比较高</strong>的数据放入缓存中，达到高性能的目的。</p>
<p><u>高并发</u>：MySQL的QPS大概在<strong>1w</strong>左右（4核8g），但是Redis缓存后很容易达到10w+，单机少一些，Redis<strong>集群更高</strong>。（QPS：Query Per Second，服务器每秒可以执行的查询次数）</p>
<h2 id="SDS（Simple-Dynamic-String）简单动态字符串"><a href="#SDS（Simple-Dynamic-String）简单动态字符串" class="headerlink" title="SDS（Simple Dynamic String）简单动态字符串"></a>SDS（Simple Dynamic String）简单动态字符串</h2><h3 id="C语言字符串的弊端："><a href="#C语言字符串的弊端：" class="headerlink" title="C语言字符串的弊端："></a>C语言字符串的弊端：</h3><img src="https://img-blog.csdnimg.cn/img_convert/376128646c75a893ad47914858fa2131.png" alt="img" style="zoom: 67%;" />

<ul>
<li>获取字符串长度，必须要从头到尾遍历到\0才可以，所以<strong>复杂度是o(n)</strong></li>
<li>字符串里不能存\0，所以是<strong>二进制不安全</strong>的</li>
<li>字符串操作时有<strong>缓存区溢出</strong>的风险</li>
</ul>
<h3 id="SDS结构设计"><a href="#SDS结构设计" class="headerlink" title="SDS结构设计"></a>SDS结构设计</h3><img src="https://img-blog.csdnimg.cn/img_convert/516738c4058cdf9109e40a7812ef4239.png" alt="img" style="zoom: 67%;" />

<p>len：SDS直接记录了字符串的长度，所以<strong>复杂度降为o(1)</strong></p>
<p>alloc：记录了<strong>分配</strong>给字符数组的空间长度，在修改字符串的时候，首先<strong>计算alloc - len</strong>够不够用，不够的话<strong>自动扩展</strong>空间长度，所以<strong>无缓存区溢出的风险</strong></p>
<p>flags：记录了五种类型的sds</p>
<p>buf[]：不仅可以保存字符串，也可以<strong>保存任意格式的二进制数据</strong></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><img src="https://img-blog.csdnimg.cn/img_convert/cadf797496816eb343a19c2451437f1e.png" alt="img" style="zoom:50%;" />

<ul>
<li>每个节点都有pre和next指针，而且这两个指针都可以指向NULL，所以链表是<strong>无环链表</strong></li>
<li>list结构存储了表头指针head和表尾指针tail，所以<strong>获得头尾节点</strong>的复杂度是o(1)</li>
<li>和SDS一样，list结构也存储了长度len，所以<strong>查询链表长度</strong>的复杂度也是o(1)</li>
<li>链表节点可以<strong>保存各种不同类型</strong>的值</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>内存不连续</strong>，无法很好利用CPU缓存（与数组相比）</li>
<li>保存每个节点都需要分配一个链表节点结构头，<strong>内存开销大</strong></li>
</ul>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p><strong>Redis3.0</strong>的产物，为了设计一个<strong>内存紧凑型</strong>的数据结构，节省内存开销，创造了压缩列表</p>
<img src="https://img-blog.csdnimg.cn/img_convert/ab0b44f557f8b5bc7acb3a53d43ebfcb.png" alt="img" style="zoom: 67%;" />

<p>表头前三个字段分别记录了[整个压缩列表<strong>占用的内存字节数</strong>]，[尾部节点举例起始地址的字节数（<strong>尾部偏移量</strong>）]，[包含的<strong>节点数量</strong>]。最后的[zlend]相当于\0，代表<strong>结束点</strong>。</p>
<p>通过这三个字段可以容易的查到表头和表尾（复杂度为o(1)），但是查找其他元素就是o(n)</p>
<p>**<u>缺点明显</u>**：</p>
<ul>
<li>不能保存过多元素，会导致查询效率降低</li>
<li>新增或修改某个元素，内存空间需要重新分配，很可能导致<strong>连锁更新</strong>（多米诺效应）</li>
</ul>
<p>**<u>使用场景</u>**：</p>
<p><strong>节点数量足够小</strong>，即使发生连锁更新，代价也很小。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>与JDK1.8之前的哈希表很相似，都是数组+链表的数据结构，数组里每一个元素就是一个<strong>哈希桶</strong>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/85f597f7851b90d6c78bb0d8e39690fc.png" alt="img" style="zoom: 67%;" />

<p>当负载因子 &gt;&#x3D; 1的时候，Redis<u>没有执行RDB快照或者没有进行AOF重写</u>的时候，就会进行rehash操作；</p>
<p>当负载因子 &gt;&#x3D; 5的时候，哈希冲突会非常严重，<strong>强制rehash</strong></p>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>分三步：</p>
<ul>
<li>给表2分配空间，一般<strong>比表1大2倍</strong></li>
<li>将表1的<strong>数据迁移</strong>到表2</li>
<li>把表1表2<strong>身份互换</strong>，在表2新创建一个空白的哈希表，用于下次rehash</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/cabce0ce7e320bc9d9b5bde947b6811b.png" alt="img" style="zoom:50%;" />

<h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>上面问题就处在数据迁移过程中会引发<strong>大量数据拷贝</strong>，导致<strong>请求阻塞</strong>，所以采用渐进式rehash。</p>
<p>将一次拷贝<strong>分成多次进行</strong>，而且进行的时机是：对哈希表元素<strong>进行CRUD的时候</strong>，顺便将表1中索引位置上的所有key-value<strong>顺序迁移到表2</strong>，随着请求增多，渐进式完成了迁移操作。</p>
<p>如果渐进式rehash期间，新增一个key-value，只会保存在哈希表2中，而<strong>哈希表1只减不增</strong>。</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="AOF持久化-Append-Only-File"><a href="#AOF持久化-Append-Only-File" class="headerlink" title="AOF持久化(Append Only File)"></a>AOF持久化(Append Only File)</h2><p>AOF就是<strong>保存写操作命令到日志</strong>中，<u>不保存读操作</u>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/6f0ab40396b7fc2c15e6f4487d3a0ad7.png" alt="img" style="zoom: 67%;" />



<h3 id="写在前，日志在后优势与风险"><a href="#写在前，日志在后优势与风险" class="headerlink" title="写在前，日志在后优势与风险"></a>写在前，日志在后优势与风险</h3><p>注意执行写命令和写AOF日志是一个进程中的两个任务，所以要分先后，<u>先执行写命令，后写日志的原因</u>是：</p>
<ul>
<li><strong>避免额外的检查开销</strong>，避免写操作的语法等有问题，所以先执行写操作，没问题了再写日志</li>
<li><strong>不会阻塞当前写</strong>操作命令</li>
</ul>
<p><u>先执行写命令，后写日志潜在风险</u>：</p>
<ul>
<li>写操作执行完，还没来得及写日志或者日志没来得及写入硬盘，服务器就宕机了，会导致<strong>数据丢失</strong></li>
<li>虽然不阻塞当前写操作，但是会<strong>阻塞下一个命令操作</strong></li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/28afd536c57a46447ddab0a2062abe84.png" alt="img" style="zoom:50%;" />

<p>上面说的风险其实就是AOF传入硬盘的时机问题。这里注意，AOF还没有存入硬盘，真正将AOF写入硬盘有三个策略。</p>
<h3 id="三种写回策略-与MySQL相似）"><a href="#三种写回策略-与MySQL相似）" class="headerlink" title="三种写回策略(与MySQL相似）"></a>三种写回策略(与MySQL相似）</h3><p>写操作-&gt;AOF-&gt;硬盘具体步骤</p>
<ol>
<li><p>实际上，执行完写操作后，先把写操作的命令追加到<strong>server.aof_buf缓冲区</strong>中</p>
</li>
<li><p>通过<strong>write()系统调用</strong>，将缓冲区的数据写入AOF文件，此时数据被拷贝到了<strong>内核缓冲区page cache</strong></p>
</li>
<li><p>接着就<strong>等待内核</strong>将page cache中的数据写入硬盘</p>
<img src="https://img-blog.csdnimg.cn/img_convert/4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png" alt="img" style="zoom:50%;" /></li>
</ol>
<p>redis.conf配置文件中的appendfsync配置项可以设置3种参数：</p>
<p><strong><u>Always</u><strong>：每次写操作和AOF日志写回硬盘是</strong>同步</strong>进行的，<u>写一个存一个</u>。</p>
<p><strong><u>Everysec</u><strong>：写操作执行完，先把命令</strong>写入内核缓冲区</strong>，每隔1秒写回一次硬盘，<u>每隔1秒存一个</u>。</p>
<p><strong><u>No</u><strong>：写操作执行完，先把命令</strong>写入内核缓冲区</strong>，写回时机完全转交给<u>操作系统控制</u></p>
<p>不同业务需要使用不同的参数，Always追求<u>高可靠</u>，Everysec追求<u>折中</u>，No追求<u>高性能</u></p>
<img src="https://img-blog.csdnimg.cn/img_convert/98987d9417b2bab43087f45fc959d32a.png" alt="img" style="zoom: 67%;" />

<h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>为了避免AOF越写越大，提供AOF重写机制，<strong>每个键值对只保留一条命令</strong>，用于<u>压缩</u>AOF的大小。</p>
<p>这一点与MySQL不一样，每个键值的<strong>历史记录</strong>对Redis来说没有意义，所以只保留<strong>最近的一次写操作</strong>。所以具体的方式是：根据每个键值的最新状态，用一条命令记录这个键值对。</p>
<p>重写的方式是：重写的过程要与原始AOF<strong>隔离</strong>，写完后<strong>覆盖</strong>原始AOF文件，这样<strong>不会</strong>对原始AOF文件<strong>造成污染</strong>。</p>
<h3 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h3><p>为了不影响主进程写AOF机制，重写AOF过程由<strong>后台子进程<em>bgrewriteaof</em></strong>来完成，好处是：</p>
<ul>
<li>AOF重写期间，<strong>不影响主进程</strong>，避免阻塞</li>
<li>子进程带有主进程的<strong>数据副本</strong>。<u>不使用线程</u>是因为：线程间操作共享内存必须<strong>加锁</strong>-&gt;性能降低；<u>使用子进程</u>是因为：父子进程共享内存是<strong>只读</strong>的，所以当有一方操作了共享内存，就发生[<strong>写时复制</strong>]，这样父子进程各自有了<strong>独立</strong>的数据副本，不需加锁。</li>
</ul>
<h4 id="数据副本的来由"><a href="#数据副本的来由" class="headerlink" title="数据副本的来由"></a>数据副本的来由</h4><p>主进程通过<strong>fork系统调用</strong>生成子进程时，OS会把主进程的<strong>页表</strong>复制给子进程，这样父子进程的虚拟内存指向了<strong>同一块物理内存</strong>（只读）</p>
<img src="https://img-blog.csdnimg.cn/img_convert/5a1f2a90b5f3821c19bea3b7a5f27fa1.png" alt="img" style="zoom:50%;" />

<h4 id="写时复制-Copy-On-Write"><a href="#写时复制-Copy-On-Write" class="headerlink" title="写时复制(Copy On Write)"></a>写时复制(Copy On Write)</h4><p>当父进程对这块内存发起写操作时，CPU会发起<strong>缺页中断</strong>（违反权限导致），OS会在[<strong>缺页异常处理函数</strong>]进行物理内存的复制（注意<strong>只是被执行写操作的这部分内存</strong>），然后重新设置内存映射关系，将父子进程的<strong>这部分内存</strong>读写权限设置为<strong>可读写</strong>，最后才对内存进行写操作，这个过程称为<u>写时复制</u>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/d4cfac545377b54dd035c775603b4936.png" alt="img" style="zoom:50%;" />

<p>其实写时复制就是为了防止fork创建子进程的时候，<strong>物理内存复制时间过长</strong>，页表要比物理内存小的多，所以<strong>尽可能减少</strong>了<u>子进程创建时对父进程的阻塞</u>。</p>
<p>三个阶段会<u>阻塞父进程</u>：</p>
<ul>
<li>创建子进程复制的<strong>页表</strong>如果特别大，肯定阻塞时间长</li>
<li>写时复制的时候，<strong>被主进程修改的内存</strong>越大，阻塞越长</li>
<li>后面要写的执行<strong>信号处理函数</strong></li>
</ul>
<p>写时复制带来的问题其实就是父子进程的<strong>时间差</strong>问题：子进程重写了一个key-value，主进程又修改了这对键值对，这次父子进程的<strong>内存数据不一致</strong>了怎么办？</p>
<h4 id="时间差导致数据不一致问题"><a href="#时间差导致数据不一致问题" class="headerlink" title="时间差导致数据不一致问题"></a>时间差导致数据不一致问题</h4><p>在<strong>创建子进程之后</strong>，Redis开始使用其专门设置的**[<u>AOF重写缓冲区</u>]<strong>，当主进程进行</strong>写操作后**，不仅将命令写入AOF缓冲区中，还写入了AOF缓冲区。</p>
<img src="https://img-blog.csdnimg.cn/202105270918298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:45%;" />

<p>为了解决时间差问题，最后在AOF重写完成时必须还要阻塞一下，以便<strong>让子进程追上父进程</strong>：</p>
<p>当子进程<strong>完成AOF重写工作后</strong>（扫描数据库所有数据。逐一把内存数据的键值对转换成一条命令，写入重写日志），向主进程发送信号（异步）。</p>
<p>主进程<strong>调用信号处理函数</strong>，将AOF重写缓冲区的所有内容追加到新的AOF中，然后让新的AOF文件改名，覆盖旧的AOF文件。调用函数的时候一定要<strong>阻塞主进程</strong>，否则时间差还会存在。</p>
<h2 id="RDB快照-Redis-Database"><a href="#RDB快照-Redis-Database" class="headerlink" title="RDB快照(Redis Database)"></a>RDB快照(Redis Database)</h2><p>如果说AOF相当于MySQL中的binlog，那么redolog就是Redis中的RDB快照了，两种技术存了不同的日志信息：</p>
<p>AOF：日志内容是<strong>操作命令</strong></p>
<p>RDB：日志内容是<strong>二进制数据</strong></p>
<p>这就带来了二者<u>恢复数据上的差异性</u>：Redis恢复数据的时候，直接<strong>将RDB读入内存即可</strong>；而AOF读入内存后，需要<strong>逐条执行操作命令</strong>才可以恢复。</p>
<h3 id="生成RDB快照的命令"><a href="#生成RDB快照的命令" class="headerlink" title="生成RDB快照的命令"></a>生成RDB快照的命令</h3><p>save和bgsave，save是<strong>直接在主线程中生成RDB文件</strong>，如果写入时间太长，会<strong>阻塞</strong>主线程；bgsave则是创建子进程，<strong>避免了阻塞</strong>问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>虽然是save，但实际执行的是bgsave，表明在多少秒内，对数据库<strong>至少</strong>进行了多少次<strong>修改</strong>。<strong>满足任意一个</strong>就会执行bgsave。</p>
<p>注意：RDB快照是**<u>全量快照</u><strong>，也就是每次快照都把</strong>内存中所有数据**存入硬盘中。</p>
<h3 id="写时复制-Copy-On-Write-1"><a href="#写时复制-Copy-On-Write-1" class="headerlink" title="写时复制(Copy On Write)"></a>写时复制(Copy On Write)</h3><p>与AOF一样，RDB快照也采用[<strong>写时复制技术</strong>]，即当父进程对共享内存执行写操作的时候，CPU先发生缺页中断，然后被执行写操作的内存则被OS复制一份，然后父进程就可以对这部分内存进行写操作了。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/ebd620db8a1af66fbeb8f4d4ef6adc68.png" alt="图片" style="zoom:50%;" />

<h3 id="混合持久化（AOF-RDB）"><a href="#混合持久化（AOF-RDB）" class="headerlink" title="混合持久化（AOF+RDB）"></a>混合持久化（AOF+RDB）</h3><p>RDB快照刚执行完，肯定会有一部分写操作还会执行，那么在下次快照执行之前，这一部分写操作会导致父子进程的<strong>数据不一致</strong>。解决的方法就是<strong>混合使用AOF日志和内存快照</strong>（混合持久化）。<u>开启方式</u>就是将下面的参数设为yes。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<p><strong>Redis 4.0</strong>提出的混合持久化，具体工作<strong>只发生</strong>在<u>AOF日志的重写过程</u>：</p>
<ul>
<li>首先fork出来的子进程先把共享内存中的数据<strong>以RDB方式</strong>写入AOF中</li>
<li>然后重写缓冲区中的<strong>增量命令以AOF方式</strong>写入AOF文件中</li>
<li>写入完成，通知主进程将这个混合持久化的AOF文件<strong>替换旧</strong>的AOF文件</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/f67379b60d151262753fec3b817b8617.png" alt="图片" style="zoom:50%;" />

<p>这样，AOF文件<u>前半部分</u>是RDB格式的<strong>全量数据</strong>，<u>后半部分</u>是AOF格式的<strong>增量数据</strong></p>
<p>好处是：重启Redis加载数据的时候，<strong>加载速度很快</strong>（RDB直接加载到内存即可），加载完了再加载AOF内容，保证<strong>数据尽可能少的丢失</strong>。</p>
<h1 id="缓存雪崩、击穿、穿透"><a href="#缓存雪崩、击穿、穿透" class="headerlink" title="缓存雪崩、击穿、穿透"></a>缓存雪崩、击穿、穿透</h1><p>雪崩和击穿都是缓存中的数据没法提供给用户了，用户只好去数据库中找了，一旦这个请求是<strong>大批量的</strong>，那么就会造成雪崩。如果数据批量不大，但是数据<strong>热度特别高</strong>，那么就是击穿，注意不是穿透，因为库上有数据。</p>
<p>而穿透则是<strong>缓存找不到，数据库也找不到</strong>，相当于一个攻击层层穿透两个库，最后给<strong>打透了</strong>。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>大批量数据访问缓存访不到，只能去库中找，有两个原因：</p>
<ul>
<li>大量数据同时过期</li>
<li>Redis故障宕机</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/717343a0da7a1b05edab1d1cdf8f28e5.png" alt="图片" style="zoom: 45%;" />

<h3 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h3><p>对于大量数据过期可以采用以下几种办法应对：</p>
<p>1）**<u>均匀设置过期时间</u><strong>：可以在设置过期时间的时候，</strong>加上一个随机数**，保证不会发生同时过期的现象。</p>
<p>2）**<u>互斥锁</u><strong>：如果发现缓存中数据没有了，那肯定得去库里面找到然后重新构建缓存，这个时候可以加个互斥锁，保证</strong>同一时间只有一个请求<strong>在构建缓存，当然锁要</strong>设置超时时间**，防止意外出现导致阻塞。</p>
<p>3）**<u>双key策略</u><strong>：即设置主key和备key，主key设置过期时间，而</strong>备key不设置<strong>，这样主key找不到了就去读备key的value。不过，更新缓存的时候要</strong>同时更新**主备key的value。</p>
<p>4）<u><strong>后台更新缓存</strong></u>：<strong>不设置有效期</strong>，业务线程也不负责更新缓存。更新的工作交给<strong>后台线程定时更新</strong>。</p>
<p>不过，缓存并不是永久有效，系统内存紧张还是会淘汰一部分数据。解决的方式有二：</p>
<p>①后台线程不仅定时更新缓存，也<strong>定时检测缓存的有效性</strong>。不过总会在两个检测<strong>间隔内</strong>出现被淘汰但还没更新的</p>
<p>②当业务线程发现数据失效后，通过<strong>消息队列</strong>发送消息<strong>通知后台线程</strong>更新缓存，用户体验较好</p>
<p>所以虽说业务线不负责更新，还是<strong>间接的</strong>利用了业务线来完成缓存的更新</p>
<p>对于<u>刚上线的业务</u>，我们有必要先进行<strong>缓存预热</strong>，即把一些数据提前存入缓存中。</p>
<h3 id="Redis故障宕机"><a href="#Redis故障宕机" class="headerlink" title="Redis故障宕机"></a>Redis故障宕机</h3><p>Redis故障宕机引起的雪崩问题采用以下两种办法应对：</p>
<p>1）<u><strong>服务熔断或请求限流机制</strong></u>：服务熔断就是<strong>暂停业务访问缓存</strong>，直接返回错误。直到缓存恢复正常，再进行访问；这种方式保证了数据库的正常运行，但是极大的阻塞了业务进行，所以可以启用请求限流，让<strong>少部分请求发送到数据库</strong>中。</p>
<p>2）**<u>构建Redis缓存高可靠集群</u><strong>：通过</strong>主从节点**的方式构建可靠集群，当主节点宕机，直接切换为从节点。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>就是<strong>热点数据过期</strong>了，数据库很容易被这个<strong>高并发量</strong>冲垮。</p>
<p>可以认为击穿是雪崩的<strong>子集</strong></p>
<p>应对方案有如下两种：</p>
<ul>
<li>**<u>互斥锁</u>**：保证同一时间只有一个业务线程更新缓存</li>
<li><strong><u>不给热点数据设置过期时间</u><strong>：后台异步更新缓存，或者过期前，</strong>提前通知</strong>后台线程更新缓存和重设过期时间</li>
</ul>
<p>要知道，*<u>不设过期时间不代表缓存一直存在</u>*，很可能因为系统内存紧张而被淘汰，所以还是要做好反馈机制。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存和数据库<strong>都没有请求的数据</strong>，导致数据库压力骤增。</p>
<p>一般<strong>业务误操作</strong>，也就是缓存和数据库的这部分数据被误删除了导致穿透现象；还有就是<strong>黑客恶意攻击</strong>，即故意访问大量不存在的数据业务。</p>
<p>应对方案有三（<em>宗旨：避免访问数据库</em>）：</p>
<p>1）<u><strong>非法请求限制</strong></u>：在API入口处判断请求参数<strong>是否合理</strong>，是否含有<strong>非法值</strong>，字段<strong>是否存在</strong>，判断出是非法请求就直接返回错误。</p>
<p>2）**<u>缓存控制或默认值</u><strong>：可以专门</strong>针对出现缓存穿透的数据<strong>，在缓存中</strong>设置**一个空值或者默认值，这样可以避免访问数据库。</p>
<p>3）**<u>布隆过滤器</u><strong>快速判断：在</strong>数据库写入数据时<strong>，使用布隆过滤器进行标记，一旦请求在缓存中找不到数据，</strong>先来到布隆过滤器**这里进行数据的存在性判断，避免了访问数据库。</p>
<p>布隆过滤器基于<strong>哈希函数</strong>查找，存在<strong>哈希碰撞</strong>的可能性，所以布隆过滤器说数据存在，数据<strong>不一定存在</strong>，但是说数据不存在，就<strong>一定不存在</strong>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/061e2c04e0ebca3425dd75dd035b6b7b.png" alt="图片" style="zoom:60%;" />

<h1 id="主从复制的实现"><a href="#主从复制的实现" class="headerlink" title="主从复制的实现"></a>主从复制的实现</h1><p>如果数据只存在一台服务器上，一旦服务器宕机或故障，会导致严重的业务中断甚至数据丢失。所以为了避免<strong>单点故障</strong>，就需要将服务器的数据保存在多台服务器上，这也是<strong>避免缓存雪崩（服务器宕机）</strong>的一种方式。</p>
<p>这就带来了一个重要的问题——数据一致性如何保证？Redis给出的是<strong>主从复制模式</strong>，主从服务器遵从<strong>读写分离</strong></p>
<p>如下图所示，主服务器可以<strong>读写</strong>，而从服务器一般是<strong>只读</strong>，一旦主服务器发生<strong>写操作</strong>，就把该操作<strong>同步</strong>给从服务器。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/2b7231b6aabb9a9a2e2390ab3a280b2d.png" alt="图片" style="zoom:50%;" />

<h2 id="第一次同步"><a href="#第一次同步" class="headerlink" title="第一次同步"></a>第一次同步</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 服务器 B 执行这条命令</span><br><span class="line">replicaof &lt;服务器 A 的 IP 地址&gt; &lt;服务器 A 的 Redis 端口号&gt;</span><br></pre></td></tr></table></figure>

<p>在服务器B上执行该命令，B就会变成A的<strong>从服务器</strong>，然后开始与A进行<strong>第一次同步</strong></p>
<p><u>第一次同步</u>有如下三阶段：</p>
<img src="https://img-blog.csdnimg.cn/img_convert/ea4f7e86baf2435af3999e5cd38b6a26.png" alt="图片" style="zoom: 50%;" />

<p>一、<u><strong>建立链接</strong>，协商同步</u>：</p>
<p><u>1.1-1.2</u>：可以从图中看出来，执行完replicaof命令后，从服务器就<strong>发送psync命令</strong>，表示自己要进行数据同步。</p>
<p>psync包含<strong>主服务器</strong>的<strong>runID</strong>（随机ID且唯一，但第一次不知道主服务器的runID，所以<strong>设为？</strong>）和复制进度<strong>offset</strong>（第一次是-1）。</p>
<p><u>1.3-1.4</u>：主服务器收到psync会回应<strong>FULLRESYNC</strong>，包含了主服务器的runID和主服务器的<strong>复制进度offset</strong>，从服务器<strong>保存记录</strong>这俩信息。此命令目的是<strong>全量复制</strong>，即把所有数据赋值给从服务器。</p>
<p>二、<u>主向从<strong>同步数据</strong></u>：</p>
<p><u>2.1-2.3</u>：主服务器执行bgsave生成RDB文件，然后发给从服务器；</p>
<p><u>2.4</u>：从服务器收到RDB文件后，<strong>先清空自己的数据再载入RDB</strong>；</p>
<p>上述操作中，主服务器生成RDB<strong>不会很大程度阻塞主线程</strong>的进行(因为是子进程<strong>复制页表</strong>)，但是在<strong>生成、发送、载入RDB</strong>的三个阶段，主服务器都有新的写操作执行的可能性，为了保证数据一致性，就要把这三个时间段的写操作命令写入到<strong>replication buffer缓冲区</strong>中。</p>
<p>三、<u>主向从发送新的<strong>写操作</strong>命令</u></p>
<p><u>3.1-3.2</u>：从服务器加载完RDB之后，主服务器将<strong>replication buffer</strong>中的写操作命令<strong>发送</strong>给从服务器，然后从服务器<strong>执行</strong>这些操作。</p>
<p>至此，第一次同步结束~</p>
<h2 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h2><p>为了<strong>避免</strong>频繁的TCP连接和断开带来<strong>性能开销</strong>，第一次同步后维持长连接，持续<strong>传播写操作</strong>，保证数据的一致性。</p>
<p>即<strong>基于长连接的命令传播</strong>。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/03eacec67cc58ff8d5819d0872ddd41e.png" alt="图片" style="zoom:50%;" />

<h2 id="分摊服务器压力"><a href="#分摊服务器压力" class="headerlink" title="分摊服务器压力"></a>分摊服务器压力</h2><p>一个从服务器还好，如果是一个服务器集群，那么在主服务器<strong>创建</strong>RDB的时候，务必会<strong>复制大量页表</strong>，从而对主线程造成<strong>阻塞</strong>；而在<strong>传播</strong>RDB的时候又会<strong>占用主服务器的网络带宽</strong>。</p>
<p>如何解决这个压力集中的问题？</p>
<p>在某个从服务器上执行如下的命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;目标服务器的IP&gt; 6379</span><br></pre></td></tr></table></figure>

<p>如果目标服务器也是<strong>从服务器</strong>，那么<strong>目标服务器</strong>就是当前服务器的“<strong>经理</strong>”。那么它就有向下传播写操作的能力了。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/4d850bfe8d712d3d67ff13e59b919452.png" alt="图片" style="zoom: 45%;" />

<h2 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h2><p>主从服务器在第一次同步之后虽然保持长连接，但是网络连接还是有可能中断，一旦<strong>网络中断</strong>，客户端在从服务器中读到的就是<strong>旧数据</strong>了。</p>
<p>网络断开后再恢复，如何*<u>保证主从服务器的一致性</u>*呢？</p>
<p>Redis 2.8之前，一直采用<strong>全量复制</strong>，开销非常大。</p>
<p><strong>Redis 2.8开始</strong>，主服务器只会把网络断开期间的<strong>相差</strong>的这一部分写操作传播给从服务器，即<strong>增量复制</strong>。</p>
<ul>
<li>再次建立连接后，还是和第一次同步一样，传一个psync，但是这次的<strong>offset不是-1</strong>了，而是断开时自己的<strong>复制偏移量</strong></li>
<li>主服务器收到psync命令后，响应<strong>CONTINUE命令</strong>来告诉从服务器接下来采用增量复制</li>
<li>然后主把这部分<strong>增量传给</strong>从服务器</li>
</ul>
<img src="https://img-blog.csdnimg.cn/img_convert/e081b470870daeb763062bb873a4477e.png" alt="图片" style="zoom:50%;" />

<p>主服务器如何获知<u><em>这部分增量</em></u>的？</p>
<p>主服务器在命令传播的时候，不仅把写操作传播给从服务器，也同时将写命令<strong>写入repl_backlog_buffer</strong>这个环形缓冲区，环形意味着<strong>超过容量即覆盖</strong>。</p>
<p>当从服务器断开重连的时候，向主服务器发送的<strong>fsync</strong>命令包含了其<strong>复制偏移量slave_repl_offset</strong>，主服务器根据自己的<strong>master_repl_offset</strong>与其差值，来决定执行增量同步还是全量同步：</p>
<p>如果<strong>差值小于</strong>一个扇形存储区域，那么就说明数据还在扇形缓冲区，然后就把扇形区的这部分增量数据<strong>写入到replication buffer</strong>，也就是第一次同步时专门负责传播增量数据的缓冲区，然后进行命令传播，即<strong>增量复制</strong>。</p>
<p>如果大于一个扇形区域，就会发生<strong>覆盖</strong>，那么就只能进行<strong>全量复制</strong>了。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/2db4831516b9a8b79f833cf0593c1f12.png" alt="图片" style="zoom:60%;" />

<p>所以一般扇形区域会设置的<strong>尽量大</strong>一些，就是为了<strong>避免全量复制</strong>这种抵消操作。</p>
<p>估算公式如下：</p>
<p>second是服务器<strong>断开后重连</strong>的平均时间</p>
<p>write_size_per_second是主服务器平均每秒产生的<strong>写命令</strong>的数据<strong>大小</strong></p>
<img src="https://img-blog.csdnimg.cn/img_convert/5e9e65a4a59b3688fa37cadbd87bb5ac.png" alt="图片" style="zoom: 90%;" />

<h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><h2 id="哨兵机制存在的意义"><a href="#哨兵机制存在的意义" class="headerlink" title="哨兵机制存在的意义"></a>哨兵机制存在的意义</h2><p>前面虽然说主服务器挂了，客户端还可以去读从服务器，但是<strong>写操作</strong>始终是主服务器向其他从服务器传播的，所以一旦主服务器挂了，还必须尽快<strong>设置新的主服务器</strong>，这就会涉及<strong>大量的工作</strong>，包括：从其它从节点选一个当主节点，通知并更新其他从节点新的主服务器IP。</p>
<p><strong>Redis 2.8</strong>开始提供了哨兵机制，目的就是<strong>实现主从节点故障转移</strong>，监控主节点是否<strong>存活</strong>，一旦主挂了，就<strong>选取</strong>新的主节点，并<strong>通知</strong>其他从节点和客户端新主节点的相关信息。</p>
<h2 id="哨兵工作机制"><a href="#哨兵工作机制" class="headerlink" title="哨兵工作机制"></a>哨兵工作机制</h2><img src="https://img-blog.csdnimg.cn/775865f6bd894dfba8d373ee54d79af1.png" alt="哨兵的职责" style="zoom: 50%;" />

<h3 id="判断主节点故障"><a href="#判断主节点故障" class="headerlink" title="判断主节点故障"></a>判断主节点故障</h3><p>哨兵会<strong>周期性</strong>地给主从节点发送<strong>PING</strong>命令，根据是否收到回应来判断是否正常运行。</p>
<p>由于一个哨兵判断有偶然性，很可能是系统压力大或网络拥塞造成未收到回应。为了减少误判，用多个节点部署成<u><em><strong>哨兵集群</strong></em></u>（最少<strong>三台</strong>机器），一旦有一个哨兵判断主节点<strong>主观下线</strong>了，就开始”参考“其他哨兵的“观点”，相当于投票机制。</p>
<p>在哨兵配置文件中有一个<strong>quorum配置项</strong>（一般设置为哨兵个数的1&#x2F;2 + 1），如果投票数超过这个值，主节点就会被标记为<strong>客观下线</strong>。</p>
<img src="https://img-blog.csdnimg.cn/13e4361407ba46979e802eaa654dcf67.png" alt="img" style="zoom:45%;" />

<h3 id="选新的主节点"><a href="#选新的主节点" class="headerlink" title="选新的主节点"></a>选新的主节点</h3><p>选择新的主节点，必然要在从节点中选择，一定不能随机选，因为有些从节点可能网络连接不太好，选了它相当于选择了”残疾人”，所以要<strong>避开连接状态不好</strong>的节点。</p>
<p>Redis中有一个down-after-milliseconds * 10的配置项，意为主从节点<strong>断后重连</strong>的最大超时时间，如果在<strong>这个时间内</strong>没连上，那就认为主从节点断连了，如果次数超过10次，说明这个<strong>从节点网络状况</strong>不好。</p>
<p>过滤掉离线的和网络不好的节点后，开始三轮考察：</p>
<p>第一轮：先选<strong>优先级最高</strong>的从服务器作为主服务器。配置项slava-priority可以设置</p>
<p>第二轮：选<strong>复制进度最靠前</strong>的从节点。比较谁的slave_repl_offset最接近master_repl_offset</p>
<p>第三轮：前面都一样，就<strong>选ID小的</strong>从节点</p>
<p><u>总结</u>：<em>先过滤离线的和网络不好的，然后进行三轮考察</em>，每一轮考察中，如果有胜出的节点，直接作为新主节点。</p>
<h3 id="哨兵竞争主从故障转移"><a href="#哨兵竞争主从故障转移" class="headerlink" title="哨兵竞争主从故障转移"></a>哨兵竞争主从故障转移</h3><p>选定了哪个从节点作为接下来的主节点之后，就要决定哪个哨兵节点<strong>负责故障转移</strong>这项工作。</p>
<p>首先要确定<strong>候选者</strong>：只有判断主节点是<strong>客观下线</strong>的哨兵才可以成为候选者。</p>
<p>候选者如何成为leader？通过所有节点（包括自己）投票选举。所有节点只可以投给候选者赞成票，而且<strong>机会只有一次</strong>，这就意味着候选者可以投给自己（<strong>其实候选者都投给自己，然后向其他哨兵发起投票请求</strong>）。</p>
<p>当候选者满足以下两个条件就可以成为leader：</p>
<ul>
<li>拿到<strong>一半以上</strong>数量（<strong>所有</strong>哨兵数量的一半 + 1）的赞成票；</li>
<li>拿到的票数要 <strong>&gt;&#x3D;</strong> 哨兵配置文件中的<strong>quorum</strong>值</li>
</ul>
<p><u><em>问</em></u>：假如当前Redis 1主4从，5个哨兵，挂了2个，quorum设为3，判断主节点宕机能否判断其“<strong>客观下线</strong>”？主从能否<strong>自动切换</strong>？</p>
<p><u><em>答</em></u>：还有3个哨兵，全部投“主观下线”，就<strong>可以判断“客观下线”</strong>了。对于主从故障转移，就要判断投票数能不能超过半数（<strong>5&#x2F;2 + 1 &#x3D; 3</strong>），能。再判断能不能超过quorum &#x3D; 3，前面判断过了，也能。所以<strong>可以自动切换</strong>。</p>
<p><u><em>问</em></u>：还是5个哨兵，挂了3，quorum设为2呢？</p>
<p>挂了3还有两个可以投票，而quorum正好改为2，所以<strong>可以判断“客观下线”</strong>。而（5&#x2F;2 + 1 &#x3D; 3），但是哨兵只有俩，赞成票数无法超过半数，所以<strong>无法自动切换</strong></p>
<p><u><em>问</em>：</u>：还是5个哨兵，还是挂了3，但是quorum设为3？</p>
<p>*<u>答</u>*：这个时候两票已经超不过quorum了，所以<strong>既无法判读“客观下线”，又无法自动切换</strong>。</p>
<p>这里面我们故意把quorum随意调整了，就是为了证明<strong>quorum</strong>不是随便设置的，其最好设置为<strong>哨兵个数 &#x2F; 2 + 1</strong>，同时保证<strong>哨兵数量为奇数</strong>。</p>
<h3 id="通知客户端新的主节点信息"><a href="#通知客户端新的主节点信息" class="headerlink" title="通知客户端新的主节点信息"></a>通知客户端新的主节点信息</h3><p>主从切换之后，新的主节点迫切需要被客户端知道，否则客户端都不知道该找谁进行写操作。</p>
<p>Redis采用<strong>发布者&#x2F;订阅者机制</strong>来实现信息的通知的。每个哨兵节点提供发布者&#x2F;订阅者机制，客户端可以<strong>从哨兵订阅消息</strong>。</p>
<p>假如客户端<strong>订阅了主从切换的事件</strong>，当哨兵选好了新的主节点，就会<strong>发布</strong>新主节点的<strong>IP和端口信息</strong>，客户端就<strong>收到</strong>了这个信息，就自然可以与新主节点通信了。</p>
<h2 id="哨兵集群如何组成的"><a href="#哨兵集群如何组成的" class="headerlink" title="哨兵集群如何组成的"></a>哨兵集群如何组成的</h2><p>其实搭建哨兵并配置信息的时候，只需要设置<strong>主节点</strong>名字、IP和端口号以及quorum值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; </span><br></pre></td></tr></table></figure>

<p>既没有填其他<strong>哨兵节点</strong>信息，也没有填其他的<strong>从节点</strong>信息。</p>
<p>其实哨兵节点之间是通过<u><em><strong>Redis的发布者&#x2F;订阅者机制</strong></em></u>来<strong>相互发现</strong>的。</p>
<p>主节点上有一个订阅频道，名为_sentinel_:hello，比如下图的A把自己的IP和端口发到这个频道上，B、C订阅了这个频道，B、C就可以获取A的位置，进而形成哨兵集群。</p>
<img src="https://img-blog.csdnimg.cn/a6286053c6884cf58bf397d01674fe80.png" alt="img" style="zoom: 40%;" />

<p>那么哨兵又是<strong>如何监控</strong>从节点的呢？</p>
<p>哨兵会向主节点发送INFO命令来获取从节点的信息，主节点就返回从节点列表。然后哨兵根据这个列表的信息，与每个从节点建立连接。</p>
<img src="https://img-blog.csdnimg.cn/fdd5f695bb3643258662886f9fba0aab.png" alt="img" style="zoom:40%;" />

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="cl3yfz0zx0000b8v6elnn24sa" data-title="Redis知识点" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/06/04/%E8%B4%AA%E5%BF%83%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          贪心系列题解
        
      </div>
    </a>
  
  
    <a href="/2022/05/30/%E5%9B%9E%E6%BA%AF%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">回溯系列题解</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/20/acm%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/">acm输入输出练习</a>
          </li>
        
          <li>
            <a href="/2022/06/04/%E8%B4%AA%E5%BF%83%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/">贪心系列题解</a>
          </li>
        
          <li>
            <a href="/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/">Redis知识点</a>
          </li>
        
          <li>
            <a href="/2022/05/30/%E5%9B%9E%E6%BA%AF%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/">回溯系列题解</a>
          </li>
        
          <li>
            <a href="/2022/05/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/">操作系统笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>