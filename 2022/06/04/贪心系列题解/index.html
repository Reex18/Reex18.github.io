<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>贪心系列题解 | Reex</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="leetcode 455.分发饼干题目：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，">
<meta property="og:type" content="article">
<meta property="og:title" content="贪心系列题解">
<meta property="og:url" content="http://example.com/2022/06/04/%E8%B4%AA%E5%BF%83%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/index.html">
<meta property="og:site_name" content="Reex">
<meta property="og:description" content="leetcode 455.分发饼干题目：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201201232338693.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201201232445286.png">
<meta property="article:published_time" content="2022-06-04T03:14:58.000Z">
<meta property="article:modified_time" content="2022-06-08T13:08:45.904Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20201201232338693.png">
  
    <link rel="alternate" href="/atom.xml" title="Reex" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Reex</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-贪心系列题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/04/%E8%B4%AA%E5%BF%83%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-06-04T03:14:58.000Z" itemprop="datePublished">2022-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      贪心系列题解
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="leetcode-455-分发饼干"><a href="#leetcode-455-分发饼干" class="headerlink" title="leetcode 455.分发饼干"></a>leetcode 455.分发饼干</h2><p><u><strong>题目</strong>：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</u></p>
<p><u>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</u></p>
<p><u>输入: g &#x3D; [1,2,3], s &#x3D; [1,1]</u><br><u>输出: 1</u><br><u>输入: g &#x3D; [1,2], s &#x3D; [1,2,3]</u><br><u>输出: 2</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小饼干先喂饱小胃口，饼干从小到大遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length &amp;&amp; start &lt; g.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= g[start]) &#123;</span><br><span class="line">                start++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大饼干先喂饱大胃口，胃口从大到小遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> g.length - <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; start &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start] &gt;= g[i]) &#123;</span><br><span class="line">                start--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们肯定先想到的是两层for循环，实际上有一层for循环可以随着count的增加而变化，那么是小饼干还是胃口呢？对于<u>小胃口优先吃饱</u>的思路，如果饼干喂不饱胃口最小的人，肯定要<strong>逐一寻找更大的饼干</strong>，所以一直增大的指针是饼干的数组，而胃口数组的指针必须<strong>喂饱一个再向后走</strong>一个。</p>
<p>对于大胃口优先吃饱的思路，我们知道，最大的胃口一般都满足不了，所以这个时候我们要<strong>逐一去减小胃口</strong>，直到找到能满足最大饼干的<strong>最大胃口的位置</strong>，所以饼干的指针要等到<strong>能喂饱人了再向前走</strong>。</p>
<h2 id="leetcode-376-摆动序列"><a href="#leetcode-376-摆动序列" class="headerlink" title="leetcode 376.摆动序列"></a>leetcode 376.摆动序列</h2><p><u><strong>题目</strong>：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</u></p>
<p><u>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</u></p>
<p><u>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</u><br><u>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</u></p>
<p><u>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//假设最左边还有一个nums[0]，构造一个假的preDiff初始化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//随时用来记录当前节点与前一个节点的差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从第二个数开始算起，所以默认第一个元素一定算进来</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从第二个元素开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="comment">//每次都与前一个元素计算差值</span></span><br><span class="line">            curDiff = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//preDiff == 0的情况只出现在第一次</span></span><br><span class="line">            <span class="keyword">if</span>((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                preDiff = curDiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题就是每次遍历到一个元素，都与前一个做差值，然后比较一下本次差值和上一次差值是不是符号相反，如果相反就累加一个数，如果相同就继续下次循环。</p>
<p>但是第一个元素没有与之做差的元素，所以就<strong>假装最前面还有一个nums[0]<strong>，这样，第一个差值我们就默认为0，所以判断条件里边写的是</strong>preDiff大于等于或小于等于0</strong>。其实这个等号只是最开始的preDiff会等于0，后面随着每次preDiff &#x3D; curDiff，preDiff没有机会再等于0了。</p>
<h2 id="leetcode-53-最大子序和"><a href="#leetcode-53-最大子序和" class="headerlink" title="leetcode 53.最大子序和"></a>leetcode 53.最大子序和</h2><p><u><strong>题目</strong>：给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</u></p>
<p><u><strong>子数组</strong> 是数组中的一个连续部分。</u></p>
<p><u>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</u><br><u>输出：6</u><br><u>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//注意res的初始化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>, res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            pre = Math.max(x, pre + x);</span><br><span class="line">            res = Math.max(pre, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里res很容易初始化为0，如果nums数组中只有{-1}，那么res &#x3D; 0是错的，所以既然res一定是记录nums中一个或几个数字之和，而且nums中含有负数，就让res初始化为nums[0]即可。</p>
<h2 id="leetcode-122-买卖股票的最佳时机-II"><a href="#leetcode-122-买卖股票的最佳时机-II" class="headerlink" title="leetcode 122.买卖股票的最佳时机 II"></a>leetcode 122.买卖股票的最佳时机 II</h2><p><u><strong>题目</strong>：给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</u></p>
<p><u>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</u></p>
<p><u>返回 你能获得的 最大 利润 。</u></p>
<p><u>输入：prices &#x3D; [7,1,5,3,6,4]</u><br><u>输出：7</u><br><u>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 总利润为 4 + 3 &#x3D; 7 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心法，有一点利润就算数：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                sum += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态规划：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//第一天持有股票时的最大利润</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//第一天不持有股票时的最大利润</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>贪心法其实就是<strong>累计利润</strong>的思路</p>
<h2 id="leetcode-55-跳跃游戏"><a href="#leetcode-55-跳跃游戏" class="headerlink" title="leetcode 55.跳跃游戏"></a>leetcode 55.跳跃游戏</h2><p><u><strong>题目</strong>：给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</u></p>
<p><u>数组中的每个元素代表你在该位置可以跳跃的<strong>最大长度</strong>。</u></p>
<p><u>判断你是否能够到达最后一个下标。</u></p>
<p><u>输入：nums &#x3D; [2,3,1,1,4]</u><br><u>输出：true</u><br><u>输入：nums &#x3D; [3,2,1,0,4]</u><br><u>输出：false</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误解法1：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            cover = Math.max(cover, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cover &gt;= nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误解法2：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= cover;i++) &#123;</span><br><span class="line">            cover = Math.max(cover, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cover &gt;= nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确的贪心解法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= cover;i++) &#123;</span><br><span class="line">            cover = Math.max(cover, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(cover &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实本题只要始终记录当前节点能覆盖到的最大范围即可。</p>
<p>但是<u>错误解法1</u>就是犯了每个节点<strong>不停地</strong>算最大cover的错误，我们要知道，<strong>不是每个节点都能遍历到的</strong>，比如[3,2,1,0,4]中的0就永远走不到，那就谈不上计算最后4位置的覆盖范围了。</p>
<p>错误解法2将nums.length范围缩小到<strong>一直变化的cover</strong>了，但是还是有很大问题，比如某个节点的<strong>覆盖范围非常大</strong>，那么接下来i就需要遍历非常大的长度才可以，但是nums可能根本没有这么大长度。</p>
<p>所以<strong>每次</strong>得到当前最大覆盖范围的时候，都要判断<strong>当前的覆盖范围能不能走到最后一个位置</strong>，如果可以的话，就直接返回true了。</p>
<h2 id="☆leetcode-45-跳跃游戏-II"><a href="#☆leetcode-45-跳跃游戏-II" class="headerlink" title="☆leetcode 45.跳跃游戏 II"></a>☆leetcode 45.跳跃游戏 II</h2><p><u><strong>题目</strong>：给你一个非负整数数组 nums ，你<strong>最初</strong>位于数组的<strong>第一个位置</strong>。</u></p>
<p><u>数组中的每个元素代表你在该位置可以跳跃的<strong>最大长度</strong>。</u></p>
<p><u>你的目标是使用<strong>最少的跳跃次数</strong>到达数组的最后一个位置。</u></p>
<p><u>假设你<strong>总是可以</strong>到达数组的最后一个位置</u></p>
<p><u>输入: nums &#x3D; [2,3,1,1,4]</u><br><u>输出: 2</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curRange</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//当前的最大覆盖的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextRange</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//下一步最大覆盖的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录当前走的最大步数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++) &#123;<span class="comment">//注意这里时走到nums.length - 2的位置</span></span><br><span class="line">            nextRange = Math.max(nextRange, nums[i] + i);<span class="comment">//随时下一步最大的覆盖的下标</span></span><br><span class="line">            <span class="keyword">if</span>(i == curRange) &#123;<span class="comment">//一旦当前下标与当前最大覆盖的下标重合</span></span><br><span class="line">                curRange = nextRange;<span class="comment">//更新当前最大覆盖下标为下一个最大覆盖的下标</span></span><br><span class="line">                res++;<span class="comment">//最大步数+1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的贪心策略比较难懂：从一开始先记录第一个最大覆盖范围curRange，然后每次遍历当前节点都记录下一步的最大覆盖范围下标nextRange，这个值是一直变化的，<strong>目的是</strong>等到下标i走到与当前最大覆盖范围下标重合的时候，<strong>更新curRange</strong>。</p>
<p>所以每次只有在当前下标i与当前最大覆盖范围的下标curRange重合的时候，才算一次步数，即ans++。而且只有在这个时候，才更新curRange。</p>
<p>最后的重点就是：<strong>i最后一步是走到nums.length - 2的位置</strong>，下图给出了很明显的解释。如果走到nums.length - 2了，但<strong>没有与curRange重合</strong>，说明当前的覆盖范围已经<strong>足够走到</strong>最后一位了，即nums.length - 1的位置，没有必要再增加步数了；如果<strong>与curRange重合</strong>了，说民当前还<strong>需要再走一步</strong>才可以到达nums.length - 1的位置，所以正好<strong>最后一次循环</strong>还需要进行**ans++**。</p>
<p><img src="https://img-blog.csdnimg.cn/20201201232338693.png" alt="45.跳跃游戏II1" style="zoom: 50%;" /><img src="https://img-blog.csdnimg.cn/20201201232445286.png" alt="45.跳跃游戏II2" style="zoom: 50%;" /></p>
<h2 id="leetcode-1005-K次取反后最大化的数组和"><a href="#leetcode-1005-K次取反后最大化的数组和" class="headerlink" title="leetcode 1005.K次取反后最大化的数组和"></a>leetcode 1005.K次取反后最大化的数组和</h2><p><u><strong>题目</strong>：给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</u></p>
<p><u>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。</u><br><u>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</u></p>
<p><u>以这种方式修改数组后，返回数组 可能的最大和 。</u></p>
<p><u>输入：nums &#x3D; [4,2,3], k &#x3D; 1</u><br><u>输出：5</u><br><u>解释：选择下标 1 ，nums 变为 [4,-2,3] 。</u><br><u>输入：nums &#x3D; [3,-1,0,2], k &#x3D; 3</u><br><u>输出：6</u><br><u>解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] *= -<span class="number">1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为有些负数变成正数之后，比原来的正数还要小，所以一旦k为奇数，还需要对他们进行转为负数的操作</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">1</span>) nums[<span class="number">0</span>] *= -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题就是先对数组排序，然后将数组中的负数全部转换为正数，一旦跳出循环，有三种可能：<u>一种可能就是k还不等于0且数组中也没有负数了</u>，那么就要看<strong>k是不是奇数</strong>，如果是奇数，还需要对数组中最小的非负数进行转为负数的操作，但是这个时候，我们<strong>不知道谁是最小的非负数</strong>，所以还需要对数组再进行排列。<u>另一种可能是k为0，数组中还有负数</u>，那没办法，这些负数因为比较小，被转换为正数的优先级也小，轮不到他们被转换为正数，直接求和即可。</p>
<p>最后一种可能就是<u>k等于0了，而数组中的元素已经没有负数</u>了，这种情况最好了，把k都用了，负数也全部转换成正数了，直接求和即可。</p>
<h2 id="leetcode-134-加油站"><a href="#leetcode-134-加油站" class="headerlink" title="leetcode 134.加油站"></a>leetcode 134.加油站</h2><p><u><strong>题目</strong>：在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</u></p>
<p><u>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</u></p>
<p><u>给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</u></p>
<p><u>输入: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]</u><br><u>输出: 3</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录一段区域差值的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录从0到尾的整个区域的差值最大和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录当前合理的出发点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; gas.length;i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//一旦当前差值的和 &lt; 0，就置零，并将索引向后移动一位</span></span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">                index = (i + <span class="number">1</span>) % gas.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//总的差值总和小于零，说明没有合适的出发点</span></span><br><span class="line">        <span class="keyword">if</span>(totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的思路就是：每次从0位置开始累加当前（加油-耗油的差值），一旦这个差值小于0，说明<strong>这一段区间都不能作为出发点</strong>，所以要从<strong>下一个位置</strong>开始出发，并将刚刚<strong>累加的差值归零</strong>。不要忘了定义一个totalSum用来记录整个过程中的差值累计，如果这个累计最后是负的，说明<strong>加油的量还没有耗油的量多</strong>，又因为出发点车没有油，所以totalSum&lt;0必然没有可靠的出发点。</p>
<h2 id="leetcode-135-分发糖果"><a href="#leetcode-135-分发糖果" class="headerlink" title="leetcode 135.分发糖果"></a>leetcode 135.分发糖果</h2><p><u><strong>题目</strong>：n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</u></p>
<p><u>你需要按照以下要求，给这些孩子分发糖果：</u></p>
<p><u>每个孩子至少分配到 1 个糖果。</u><br><u>相邻两个孩子评分更高的孩子会获得更多的糖果。</u><br><u>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</u></p>
<p><u>输入：ratings &#x3D; [1,0,2]</u><br><u>输出：5 (2、1、2)</u></p>
<p><u>输入：ratings &#x3D; [1,2,2]</u><br><u>输出：4 (1、2、1)</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] candy = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        candy[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; ratings.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//本次循环，只保证右边比左边评分高时，右边比左边多一个糖果</span></span><br><span class="line">                candy[i] = candy[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//初始化</span></span><br><span class="line">                candy[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//本次循环，保证左边比右边评分高时，当前糖果既比左边多，也比右边多</span></span><br><span class="line">                candy[i] = Math.max(candy[i], candy[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : candy) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的思路就是先从左到右遍历，比较后面的比前面评分高的学生，只保证<u>右边比左边评分高时</u>，<strong>右边比左边多一个糖果</strong>，记住，一定要初始化（右边评分等于或小于左边评分时，要给1颗糖果）。第二次遍历就是从右向左遍历，保证<u>左边比右边评分高时</u>，当前糖果<strong>既比左边多，也比右边多</strong>。</p>
<h2 id="leetcode-860-柠檬水找零"><a href="#leetcode-860-柠檬水找零" class="headerlink" title="leetcode 860.柠檬水找零"></a>leetcode 860.柠檬水找零</h2><p><u><strong>题目</strong>：在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</u></p>
<p><u>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</u></p>
<p><u>注意，一开始你手头没有任何零钱。</u></p>
<p><u>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</u></p>
<p><u>输入：bills &#x3D; [5,5,5,10,20]</u><br><u>输出：true</u></p>
<p><u>输入：bills &#x3D; [5,5,10,10,20]</u><br><u>输出：false</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">five</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ten</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; bills.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bills[i] == <span class="number">5</span>) &#123;</span><br><span class="line">                five++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(five == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                five--;</span><br><span class="line">                ten++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(five &gt; <span class="number">0</span> &amp;&amp; ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个题就是看碰到谁给出相应的对策，碰到5，就five++；碰到10，就five–，ten++，当然要<strong>判断five够不够减</strong>的；碰到20，就先看看<strong>ten和five够不够</strong>，够就各减一个，不够就看看<strong>five够不够3个</strong>，都不够就return false。</p>
<h2 id="☆leetcode-406-根据身高重建队列"><a href="#☆leetcode-406-根据身高重建队列" class="headerlink" title="☆leetcode 406.根据身高重建队列"></a>☆leetcode 406.根据身高重建队列</h2><p><u><strong>题目</strong>：假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</u></p>
<p><u>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</u></p>
<p><u>输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</u><br><u>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        <span class="comment">//根据身高从大到小排序，身高相等的，按照数组第二个元素从小到大排序</span></span><br><span class="line">        Arrays.sort(people, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//以数组的第二元素为下标，按照数组的顺序，即按照身高从大到小一次插入队列中</span></span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] p : people) &#123;</span><br><span class="line">            queue.add(p[<span class="number">1</span>], p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将队列返回成数组形式</span></span><br><span class="line">        <span class="keyword">return</span> queue.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下面的排列方式就明白了：</p>
<p><strong>排序完</strong>的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]</p>
<ul>
<li>插入[7,0]：[[7,0]]</li>
<li>插入[7,1]：[[7,0],[7,1]]</li>
<li>插入[6,1]：[[7,0],[6,1],[7,1]]</li>
<li>插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]</li>
<li>插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]</li>
<li>插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li>
</ul>
<h2 id="☆leetcode-452-用最少数量的箭引爆气球"><a href="#☆leetcode-452-用最少数量的箭引爆气球" class="headerlink" title="☆leetcode 452.用最少数量的箭引爆气球"></a>☆leetcode 452.用最少数量的箭引爆气球</h2><p><u><strong>题目</strong>：有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</u></p>
<p><u>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  <strong>xstart ≤ x ≤ xend</strong>，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</u></p>
<p><u>给你一个数组 points ，返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数 。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="comment">//按照每个区间的左边界由小到大排列，因为测试用例中有边界值，所以不能用a[0] - b[0]</span></span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">//因为从第二个区间开始与前面的区间比较，所以从一只箭开始计数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; points.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//说明当前区间与前面记录的最小右边界没有重合，所以必须要增加一支箭</span></span><br><span class="line">                <span class="comment">//注意这里的最小右边界就默认是当前区间的右边界了</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明当前区间与前面记录的最小右边界有重合，继续保持当前最小的右边界</span></span><br><span class="line">                points[i][<span class="number">1</span>] = Math.min(points[i - <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先让数组按照每个区间的左边界从小到大排序，这样就可以保证后面的区间左边界一定不比前面的区间左边界小，这样我们只需要比较右边界就可以了。依次向后遍历，如果后面的区间的左边界比前面记录的最小右边界大，也就是<strong>没有重合</strong>，那么自然就需要<strong>增加</strong>一只箭；如果左边界比前面的最小右边界小或相等，也就是<strong>有重合部分</strong>，那么就要记录当前的最小右边界，因为当前区间有可能<strong>包含</strong>在前一个区间内，也就是不仅左边界比最小右边界小，而且<strong>右边界也比最小右边界小</strong>，这样的话，我们必须缩小右边界到<strong>满足所有不增加箭的区间</strong>。</p>
<h2 id="leetcode-435-无重叠区间"><a href="#leetcode-435-无重叠区间" class="headerlink" title="leetcode 435.无重叠区间"></a>leetcode 435.无重叠区间</h2><p><u><strong>题目</strong>：给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</u></p>
<p><u>输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]</u><br><u>输出: 1</u><br><u>解释: 移除 [1,3] 后，剩下的区间没有重叠。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="comment">//改动1，其实不改动也可以，即按左边界由小到大也可以</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">1</span>],b[<span class="number">1</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++) &#123;</span><br><span class="line">            <span class="comment">//改动2</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= intervals[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                intervals[i][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>], intervals[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//改动3</span></span><br><span class="line">        <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题和前面的452题非常像，因为射箭击穿某些重合区间，几只箭就证明有几个不重合的区间，只不过本题[1,2]和[2,3]不算重叠区间，所以在<strong>改动2的if</strong>判断位置<strong>加上了等号</strong>。</p>
<p>其次我们是要获得<strong>移除</strong>区间的<strong>最小数量</strong>，所以最后<strong>改动3</strong>的位置，也就是最后需要返回区间总个数-最大非重叠区间</p>
<p>那么问题是怎么才可以获得最多的非重叠区间呢，本题解给的思路是将每个区间的***<u>右边界从小到大</u><em><strong>排列，这样每个区间给右边的区间留下的空间是最大的，</strong>最大程度避免重叠</em>*，从而获得最大非重叠区间。</p>
<p>其实不改动也可以，即<strong>按左边界由小到大</strong>也可以。</p>
<h2 id="leetcode-56-合并区间"><a href="#leetcode-56-合并区间" class="headerlink" title="leetcode 56.合并区间"></a>leetcode 56.合并区间</h2><p><u><strong>题目</strong>：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</u></p>
<p><u>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</u><br><u>输出：[[1,6],[8,10],[15,18]]</u><br><u>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        res.add(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++) &#123;</span><br><span class="line">            <span class="comment">//当前的区间左边界小于前面的区间右边界</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= res.getLast()[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> res.getLast()[<span class="number">0</span>];<span class="comment">//因为左边界从小到大排列，所以start肯定取前面的</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.max(intervals[i][<span class="number">1</span>], res.getLast()[<span class="number">1</span>]);<span class="comment">//右边界不确定谁大，需要比一下</span></span><br><span class="line">                res.removeLast();<span class="comment">//记得删除当前最后一个区间</span></span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;);<span class="comment">//用start,end构建新区间</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//区间没重合，说明可以把当前的区间添加进去</span></span><br><span class="line">                res.add(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意res的长度是size()</span></span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的思路是：先将每个区间按照左区间由小到大排列，构造一个链表用于把合适的区间添加进来，先把第一个区间加进来，然后判断第二个区间的左区间和第一个区间的右区间是不是<strong>有重合的地方</strong>，如果重合，那就取两个区间的<strong>最小左区间和最大右区间</strong>，不要忘记<strong>删除前面</strong>的区间，然后将新构造的<strong>更大的区间</strong>添加进去。</p>
<p>如果<strong>没有重合</strong>的地方，就直接将该区间添加进去即可。</p>
<p>后面的区间以此类推，最后将链表转换为数组的形式，要注意LinkedList链表的长度是**size()**，不要写成length()。</p>
<h2 id="leetcode-738-单调递增的数字"><a href="#leetcode-738-单调递增的数字" class="headerlink" title="leetcode 738.单调递增的数字"></a>leetcode 738.单调递增的数字</h2><p><u><strong>题目</strong>：当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。</u></p>
<p><u>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。</u></p>
<p><u>输入: n &#x3D; 10</u><br><u>输出: 9</u></p>
<p><u>输入: n &#x3D; 1234</u><br><u>输出: 1234</u></p>
<p><u>输入: n &#x3D; 332</u><br><u>输出: 299</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//先将数字转换为字符数组，便于遍历</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="comment">//定义一个start指针，记录需要改为9的起始点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> ch.length;</span><br><span class="line">        <span class="comment">//从后向前遍历，因为修改的是前面的字符，如果从前向后遍历会出现问题</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ch.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="comment">//凡是前一个元素比后面大的，就将该元素-1，并将后面的元素置为9</span></span><br><span class="line">            <span class="keyword">if</span>(ch[i] &gt; ch[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                ch[i]--;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将指针及其后面的元素全部置为9</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i &lt; ch.length;i++) &#123;</span><br><span class="line">            ch[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//字符数组-&gt;字符串-&gt;数字</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(String.valueOf(ch));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先把数字转换为方便遍历的字符数组，具体贪心的思路就是：每相邻的字符进行比较，前面比后面大则不满足递增规律，所以要让<strong>当前ch[i]–<strong>，同时让后面的元素</strong>ch[i + 1]置为9</strong>，这一点很关键。</p>
<p>但是如果从前向后遍历，就会造成后面的元素<strong>在自减后又比前面的元素小</strong>了，所以为了避免这种情况，我们<strong>从后向前遍历</strong>。但是不一定要让ch[i + 1]全部置为9，也许前面的元素<strong>自减之后，就满足递增了</strong>。所以要定义一个指针start，<strong>随时记录</strong>目前需要置为9的位置，直到最后数组遍历完成。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/04/%E8%B4%AA%E5%BF%83%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/" data-id="cl3zgzig90000v8v6bzm0gp9d" data-title="贪心系列题解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Redis知识点</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/04/%E8%B4%AA%E5%BF%83%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/">贪心系列题解</a>
          </li>
        
          <li>
            <a href="/2022/06/02/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/">Redis知识点</a>
          </li>
        
          <li>
            <a href="/2022/05/30/%E5%9B%9E%E6%BA%AF%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/">回溯系列题解</a>
          </li>
        
          <li>
            <a href="/2022/05/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/">操作系统笔记</a>
          </li>
        
          <li>
            <a href="/2022/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/">二叉树题解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>